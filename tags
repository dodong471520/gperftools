!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.8	//
$	Makefile	/^	$(AWK) 'BEGIN { files["."] = ""; dirs["."] = 1 } \\$/;"	f	signature:(AWK)
$	Makefile	/^  $(AWK) 'BEGIN { files["."] = "" } { files[$$2] = files[$$2] " " $$1; \\$/;"	f	signature:(AWK)
$	Makefile.in	/^	$(AWK) 'BEGIN { files["."] = ""; dirs["."] = 1 } \\$/;"	f	signature:(AWK)
$	Makefile.in	/^  $(AWK) 'BEGIN { files["."] = "" } { files[$$2] = files[$$2] " " $$1; \\$/;"	f	signature:(AWK)
$	benchmark/unwind_bench-getcontext_light.o	/^/;"	v
$	config.guess	/^if test $# != 0; then$/;"	v
$	config.guess	920;"	d	file:
$	config.guess	921;"	d	file:
$	config.log	/^configure:17772: $? = 0$/;"	v
$	install-sh	/^    --help) echo "$usage"; exit $?;;$/;"	v
$	low_level_alloc_unittest	/^/;"	v
$	m4/libtool.m4	/^        eval '\\''$striplib \\$dldir\/$dlname'\\'' || exit \\$?;$/;"	v
$	m4/libtool.m4	/^configured by $[0], generated by m4_PACKAGE_STRING.$/;"	v
$	src/base/.libs/thread_lister.o	/^ELF/;"	v
$	src/base/thread_lister.o	/^ELF/;"	v
$	src/libtcmalloc_internal_la-malloc_extension.o	/^/;"	v
$	tags	/^lt_cv_sys_global_symbol_to_c_name_address	config.status	\/^lt_cv_sys_global_symbol_to_c_name_address='sed -n -e '\\\\''s\\\/^: \\\\([^ ]*\\\\) $\\\/  {\\\\"\\\\1\\\\", (void *) 0},\\\/p'\\\\'' -e '\\\\''s\\\/^[ABCDGIRSTW]* \\\\([^ ]*\\\\) \\\\([^ ]*\\\\)$\\\/  {"\\\\2", (void *) \\\\&\\\\2},\\\/p'\\\\'''$\/;"	v$/;"	v
$	tags	/^yes	m4\/libtool.m4	\/^  yes,cygwin* | yes,mingw* | yes,pw32* | yes,cegcc*)$\/;"	v$/;"	v
$$file	Makefile	/^	  dist_files=`for file in $$list; do echo $$file; done | \\$/;"	v
$$files	Makefile	/^	echo " ( cd '$(DESTDIR)$(bindir)' && rm -f" $$files ")"; \\$/;"	v
$$files	Makefile.in	/^	echo " ( cd '$(DESTDIR)$(bindir)' && rm -f" $$files ")"; \\$/;"	v
$$list	Makefile	/^	@list='$(noinst_LTLIBRARIES)'; for p in $$list; do \\$/;"	v
$$list	Makefile	/^	echo " rm -f" $$list; \\$/;"	v
$$list	Makefile	/^	for p in $$list; do \\$/;"	v
$$list	Makefile	/^	for p in $$list; do echo "$$p $$p"; done | \\$/;"	v
$$list	Makefile	/^  for p in $$list; do echo "$$p $$p"; done | \\$/;"	v
$$list	Makefile.in	/^	@list='$(noinst_LTLIBRARIES)'; for p in $$list; do \\$/;"	v
$$list	Makefile.in	/^	echo " rm -f" $$list; \\$/;"	v
$$list	Makefile.in	/^	for p in $$list; do \\$/;"	v
$$list	Makefile.in	/^	for p in $$list; do echo "$$p $$p"; done | \\$/;"	v
$$list	Makefile.in	/^  for p in $$list; do echo "$$p $$p"; done | \\$/;"	v
$2	m4/libtool.m4	/^      x$lt_dlneed_uscore) $2 ;;$/;"	v
$3	m4/libtool.m4	/^      x$lt_dlunknown|x*) $3 ;;$/;"	v
$CENSUSPROFILE_PAGE	src/pprof	/^my $CENSUSPROFILE_PAGE = "\/pprof\/censusprofile(?:\\\\?.*)?"; # must support cgi-param$/;"	v
$CONTENTION_PAGE	src/pprof	/^my $CONTENTION_PAGE = "\/pprof\/contention";$/;"	v
$FILTEREDPROFILE_PAGE	src/pprof	/^my $FILTEREDPROFILE_PAGE = "\/pprof\/filteredprofile(?:\\\\?.*)?";$/;"	v
$HEAP_PAGE	src/pprof	/^my $HEAP_PAGE = "\/pprof\/heap";$/;"	v
$PPROF_VERSION	src/pprof	/^my $PPROF_VERSION = "2.0";$/;"	v
$PROFILES	src/pprof	/^my $PROFILES = "($HEAP_PAGE|$PROFILE_PAGE|$PMUPROFILE_PAGE|" .$/;"	v
$PROFILE_PAGE	src/pprof	/^my $PROFILE_PAGE = "\/pprof\/profile";   # must support cgi-param "?seconds=#"$/;"	v
$PROGRAM_NAME_PAGE	src/pprof	/^my $PROGRAM_NAME_PAGE = "\/pprof\/cmdline";$/;"	v
$UNKNOWN_BINARY	src/pprof	/^my $UNKNOWN_BINARY = "(unknown)";$/;"	v
$WALL_PAGE	src/pprof	/^my $WALL_PAGE = "\/pprof\/wall(?:\\\\?.*)?";  # accepts options like namefilter$/;"	v
$acx_pthread_flags	m4/acx_pthread.m4	/^for flag in $acx_pthread_flags; do$/;"	v
$address_length	src/pprof	/^my $address_length = 16;$/;"	v
$dev_null	src/pprof	/^my $dev_null = "\/dev\/null";$/;"	v
$sep_address	src/pprof	/^my $sep_address = undef;$/;"	v
$sep_symbol	src/pprof	/^my $sep_symbol = '_fini';$/;"	v
$timestamp	config.guess	/^This script, last modified $timestamp, has failed to recognize$/;"	v
$timestamp	tags	/^script	config.guess	\/^This script, last modified $timestamp, has failed to recognize$\/;"	v$/;"	v
$touch_files	missing	/^    touch $touch_files$/;"	v
$var	m4/libtool.m4	/^      eval "lt_\\$var=\\\\\\\\\\\\"\\\\\\$\\$var\\\\\\\\\\\\""$/;"	v
$var	tags	/^$var	m4\/libtool.m4	\/^      eval "lt_\\\\$var=\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\$\\\\$var\\\\\\\\\\\\\\\\\\\\\\\\""$\/;"	v$/;"	v
A	src/tests/heap-checker_unittest.cc	/^  virtual void A() = 0;$/;"	p	class:InterfaceA	file:	access:public	signature:()
A	src/tests/heap-checker_unittest.cc	/^  virtual void A() { }$/;"	f	class:ClassMltD1	access:public	signature:()
A	src/tests/heap-checker_unittest.cc	/^  virtual void A() { }$/;"	f	class:ClassMltD2	access:public	signature:()
A	src/tests/malloc_hook_test-testutil.o	/^/;"	v
A	src/tests/markidle_unittest-testutil.o	/^/;"	v
A	src/tests/markidle_unittest-testutil.o	/^/;"	v
A	src/tests/memalign_debug_unittest-testutil.o	/^/;"	v
A	src/tests/memalign_debug_unittest-testutil.o	/^/;"	v
A	src/tests/memalign_unittest-testutil.o	/^/;"	v
A	src/tests/memalign_unittest-testutil.o	/^/;"	v
A	src/tests/profiler3_unittest-testutil.o	/^/;"	v
A	src/tests/profiler4_unittest-testutil.o	/^/;"	v
A	src/tests/tcm_min_asserts_unittest-testutil.o	/^/;"	v
A	src/tests/tcmalloc_and_profiler_unittest-testutil.o	/^/;"	v
A	src/tests/tcmalloc_and_profiler_unittest-testutil.o	/^/;"	v
A	src/tests/tcmalloc_both_unittest-testutil.o	/^/;"	v
A	src/tests/tcmalloc_both_unittest-testutil.o	/^/;"	v
A	src/tests/tcmalloc_debug_unittest-testutil.o	/^/;"	v
A	src/tests/tcmalloc_debug_unittest-testutil.o	/^/;"	v
A	src/tests/tcmalloc_minimal_debug_unittest-testutil.o	/^/;"	v
A	src/tests/tcmalloc_minimal_debug_unittest-testutil.o	/^/;"	v
A	src/tests/tcmalloc_minimal_unittest-testutil.o	/^/;"	v
A	src/tests/tcmalloc_minimal_unittest-testutil.o	/^/;"	v
A	src/tests/tcmalloc_unittest-testutil.o	/^/;"	v
A	src/tests/tcmalloc_unittest-testutil.o	/^/;"	v
A	src/tests/thread_dealloc_unittest-testutil.o	/^/;"	v
A	src/tests/thread_dealloc_unittest-testutil.o	/^/;"	v
ACMRandom	src/tests/tcmalloc_unittest.cc	/^    explicit ACMRandom(int32 seed) { seed_ = seed; }$/;"	f	class:testing::TesterThread::ACMRandom	access:public	signature:(int32 seed)
ACMRandom	src/tests/tcmalloc_unittest.cc	/^  class ACMRandom {$/;"	c	class:testing::TesterThread	file:	access:private
ACQUIRED_AFTER	src/base/thread_annotations.h	84;"	d
ACQUIRED_BEFORE	src/base/thread_annotations.h	86;"	d
ACQUIRED_BEFORE	src/profile-handler.cc	/^  SpinLock control_lock_ ACQUIRED_BEFORE(signal_lock_);$/;"	p	class:ProfileHandler	file:	access:private	signature:(signal_lock_)
AC_CHECK_LIB	m4/libtool.m4	/^    AC_CHECK_LIB([dl], [dlopen],$/;"	p	file:	signature:([dl], [dlopen], [lt_cv_dlopen=Ó lt_cv_dlopen_libs=Ó],[ lt_cv_dlopen=Ó lt_cv_dlopen_libs= lt_cv_dlopen_self=yes ])
AC_DEFINE	configure.ac	/^       AC_DEFINE(TCMALLOC_ALIGN_8BYTES, 1,$/;"	p	file:	signature:(TCMALLOC_ALIGN_8BYTES, 1, [Define 8 bytes of allocation alignment for tcmalloc])
AC_MSG_CHECKING	m4/acx_pthread.m4	/^                AC_MSG_CHECKING([whether pthreads work without any flags])$/;"	p	file:	signature:([whether pthreads work without any flags])
ADCDF	src/tests/sampler_test.cc	/^void ADCDF() {$/;"	f	signature:()
ADDR_IN_ATTRIBUTE_SECTION	src/malloc_hook.cc	579;"	d	file:
ADDR_IN_ATTRIBUTE_SECTION	src/malloc_hook.cc	595;"	d	file:
ADJUST_ADDRESS_RANGE_FROM_RA	src/tests/stacktrace_unittest.cc	77;"	d	file:
ADJUST_ADDRESS_RANGE_FROM_RA	src/tests/stacktrace_unittest.cc	96;"	d	file:
ADTestTest	src/tests/sampler_test.cc	/^void ADTestTest(int n) {$/;"	f	signature:(int n)
AF	src/tcmalloc.cc	1758;"	d	file:
AF	src/tcmalloc.cc	1768;"	d	file:
ALIAS	src/libc_override_gcc_and_weak.h	/^                                              ALIAS(tc_delete_nothrow);$/;"	p	signature:(tc_delete_nothrow)
ALIAS	src/libc_override_gcc_and_weak.h	/^                                              ALIAS(tc_deletearray_nothrow);$/;"	p	signature:(tc_deletearray_nothrow)
ALIAS	src/libc_override_gcc_and_weak.h	/^                                              ALIAS(tc_new_nothrow);$/;"	p	signature:(tc_new_nothrow)
ALIAS	src/libc_override_gcc_and_weak.h	/^                                              ALIAS(tc_newarray_nothrow);$/;"	p	signature:(tc_newarray_nothrow)
ALIAS	src/libc_override_gcc_and_weak.h	/^         ALIAS(tc_malloc_size);$/;"	p	signature:(tc_malloc_size)
ALIAS	src/libc_override_gcc_and_weak.h	/^      ALIAS(tc_posix_memalign);$/;"	p	signature:(tc_posix_memalign)
ALIAS	src/libc_override_gcc_and_weak.h	/^    ALIAS(tc_delete_aligned);$/;"	p	signature:(tc_delete_aligned)
ALIAS	src/libc_override_gcc_and_weak.h	/^    ALIAS(tc_delete_aligned_nothrow);$/;"	p	signature:(tc_delete_aligned_nothrow)
ALIAS	src/libc_override_gcc_and_weak.h	/^    ALIAS(tc_delete_sized);$/;"	p	signature:(tc_delete_sized)
ALIAS	src/libc_override_gcc_and_weak.h	/^    ALIAS(tc_delete_sized_aligned);$/;"	p	signature:(tc_delete_sized_aligned)
ALIAS	src/libc_override_gcc_and_weak.h	/^    ALIAS(tc_deletearray_aligned);$/;"	p	signature:(tc_deletearray_aligned)
ALIAS	src/libc_override_gcc_and_weak.h	/^    ALIAS(tc_deletearray_aligned_nothrow);$/;"	p	signature:(tc_deletearray_aligned_nothrow)
ALIAS	src/libc_override_gcc_and_weak.h	/^    ALIAS(tc_deletearray_sized);$/;"	p	signature:(tc_deletearray_sized)
ALIAS	src/libc_override_gcc_and_weak.h	/^    ALIAS(tc_deletearray_sized_aligned);$/;"	p	signature:(tc_deletearray_sized_aligned)
ALIAS	src/libc_override_gcc_and_weak.h	/^    ALIAS(tc_new_aligned_nothrow);$/;"	p	signature:(tc_new_aligned_nothrow)
ALIAS	src/libc_override_gcc_and_weak.h	/^    ALIAS(tc_newarray_aligned_nothrow);$/;"	p	signature:(tc_newarray_aligned_nothrow)
ALIAS	src/libc_override_gcc_and_weak.h	/^  ALIAS(tc_delete);$/;"	p	signature:(tc_delete)
ALIAS	src/libc_override_gcc_and_weak.h	/^  ALIAS(tc_deletearray);$/;"	p	signature:(tc_deletearray)
ALIAS	src/libc_override_gcc_and_weak.h	/^  int mallopt(int cmd, int value) __THROW         ALIAS(tc_mallopt);$/;"	p	signature:(tc_mallopt)
ALIAS	src/libc_override_gcc_and_weak.h	/^  size_t malloc_size(void* p) __THROW             ALIAS(tc_malloc_size);$/;"	p	signature:(tc_malloc_size)
ALIAS	src/libc_override_gcc_and_weak.h	/^  size_t malloc_usable_size(void* p) __THROW      ALIAS(tc_malloc_size);$/;"	p	signature:(tc_malloc_size)
ALIAS	src/libc_override_gcc_and_weak.h	/^  struct mallinfo mallinfo(void) __THROW          ALIAS(tc_mallinfo);$/;"	p	signature:(tc_mallinfo)
ALIAS	src/libc_override_gcc_and_weak.h	/^  void cfree(void* ptr) __THROW                   ALIAS(tc_cfree);$/;"	p	signature:(tc_cfree)
ALIAS	src/libc_override_gcc_and_weak.h	/^  void free(void* ptr) __THROW                    ALIAS(tc_free);$/;"	p	signature:(tc_free)
ALIAS	src/libc_override_gcc_and_weak.h	/^  void malloc_stats(void) __THROW                 ALIAS(tc_malloc_stats);$/;"	p	signature:(tc_malloc_stats)
ALIAS	src/libc_override_gcc_and_weak.h	/^  void* aligned_alloc(size_t align, size_t s) __THROW ALIAS(tc_memalign);$/;"	p	signature:(tc_memalign)
ALIAS	src/libc_override_gcc_and_weak.h	/^  void* calloc(size_t n, size_t size) __THROW     ALIAS(tc_calloc);$/;"	p	signature:(tc_calloc)
ALIAS	src/libc_override_gcc_and_weak.h	/^  void* malloc(size_t size) __THROW               ALIAS(tc_malloc);$/;"	p	signature:(tc_malloc)
ALIAS	src/libc_override_gcc_and_weak.h	/^  void* memalign(size_t align, size_t s) __THROW  ALIAS(tc_memalign);$/;"	p	signature:(tc_memalign)
ALIAS	src/libc_override_gcc_and_weak.h	/^  void* pvalloc(size_t size) __THROW              ALIAS(tc_pvalloc);$/;"	p	signature:(tc_pvalloc)
ALIAS	src/libc_override_gcc_and_weak.h	/^  void* realloc(void* ptr, size_t size) __THROW   ALIAS(tc_realloc);$/;"	p	signature:(tc_realloc)
ALIAS	src/libc_override_gcc_and_weak.h	/^  void* valloc(size_t size) __THROW               ALIAS(tc_valloc);$/;"	p	signature:(tc_valloc)
ALIAS	src/libc_override_gcc_and_weak.h	/^void operator delete(void* p) CPP_NOTHROW     ALIAS(tc_delete);$/;"	p	signature:(tc_delete)
ALIAS	src/libc_override_gcc_and_weak.h	/^void operator delete[](void* p) CPP_NOTHROW   ALIAS(tc_deletearray);$/;"	p	signature:(tc_deletearray)
ALIAS	src/libc_override_gcc_and_weak.h	/^void* operator new(size_t size) CPP_BADALLOC  ALIAS(tc_new);$/;"	p	signature:(tc_new)
ALIAS	src/libc_override_gcc_and_weak.h	/^void* operator new[](size_t size) CPP_BADALLOC ALIAS(tc_newarray);$/;"	p	signature:(tc_newarray)
ALIAS	src/libc_override_gcc_and_weak.h	238;"	d
ALIAS	src/libc_override_gcc_and_weak.h	58;"	d
ALIAS	src/libc_override_glibc.h	73;"	d
ALIAS	src/libc_override_glibc.h	85;"	d
ALLOC	src/tests/tcmalloc_unittest.cc	/^  enum Type { ALLOC, FREE, UPDATE, PASS };$/;"	e	enum:testing::TesterThread::Type	file:
ALLOC_COUNT	src/addressmap-inl.h	/^  static const int ALLOC_COUNT = 64;$/;"	m	class:AddressMap	access:private
ALPHA_CPU_TYPE	config.guess	/^	ALPHA_CPU_TYPE=`\/usr\/sbin\/psrinfo -v | sed -n -e 's\/^  The alpha \\(.*\\) processor.*$\/\\1\/p' | head -n 1`$/;"	v
ALT_STACKSIZE	src/base/linuxthreads.cc	246;"	d	file:
AM_A	src/windows/mini_disassembler_types.h	/^  AM_A = 0x00010000,    \/\/ A addressing type$/;"	e	enum:sidestep::AddressingMethod
AM_C	src/windows/mini_disassembler_types.h	/^  AM_C = 0x00020000,    \/\/ C addressing type$/;"	e	enum:sidestep::AddressingMethod
AM_D	src/windows/mini_disassembler_types.h	/^  AM_D = 0x00030000,    \/\/ D addressing type$/;"	e	enum:sidestep::AddressingMethod
AM_E	src/windows/mini_disassembler_types.h	/^  AM_E = 0x00040000,    \/\/ E addressing type$/;"	e	enum:sidestep::AddressingMethod
AM_F	src/windows/mini_disassembler_types.h	/^  AM_F = 0x00050000,    \/\/ F addressing type$/;"	e	enum:sidestep::AddressingMethod
AM_G	src/windows/mini_disassembler_types.h	/^  AM_G = 0x00060000,    \/\/ G addressing type$/;"	e	enum:sidestep::AddressingMethod
AM_I	src/windows/mini_disassembler_types.h	/^  AM_I = 0x00070000,    \/\/ I addressing type$/;"	e	enum:sidestep::AddressingMethod
AM_IMPLICIT	src/windows/mini_disassembler_types.h	/^  AM_IMPLICIT = 0x00150000,  \/\/ An implicit, fixed value is used$/;"	e	enum:sidestep::AddressingMethod
AM_J	src/windows/mini_disassembler_types.h	/^  AM_J = 0x00080000,    \/\/ J addressing type$/;"	e	enum:sidestep::AddressingMethod
AM_M	src/windows/mini_disassembler_types.h	/^  AM_M = 0x00090000,    \/\/ M addressing type$/;"	e	enum:sidestep::AddressingMethod
AM_MASK	src/windows/mini_disassembler_types.h	/^  AM_MASK = 0x00FF0000,  \/\/ Mask for the rest of the values in this enumeration$/;"	e	enum:sidestep::AddressingMethod
AM_NOT_USED	src/windows/mini_disassembler_types.h	/^  AM_NOT_USED = 0,        \/\/ This operand is not used for this instruction$/;"	e	enum:sidestep::AddressingMethod
AM_O	src/windows/mini_disassembler_types.h	/^  AM_O = 0x000A0000,    \/\/ O addressing type$/;"	e	enum:sidestep::AddressingMethod
AM_P	src/windows/mini_disassembler_types.h	/^  AM_P = 0x000B0000,    \/\/ P addressing type$/;"	e	enum:sidestep::AddressingMethod
AM_Q	src/windows/mini_disassembler_types.h	/^  AM_Q = 0x000C0000,    \/\/ Q addressing type$/;"	e	enum:sidestep::AddressingMethod
AM_R	src/windows/mini_disassembler_types.h	/^  AM_R = 0x000D0000,    \/\/ R addressing type$/;"	e	enum:sidestep::AddressingMethod
AM_REGISTER	src/windows/mini_disassembler_types.h	/^  AM_REGISTER = 0x00140000,  \/\/ Specific register is always used as this op$/;"	e	enum:sidestep::AddressingMethod
AM_S	src/windows/mini_disassembler_types.h	/^  AM_S = 0x000E0000,    \/\/ S addressing type$/;"	e	enum:sidestep::AddressingMethod
AM_T	src/windows/mini_disassembler_types.h	/^  AM_T = 0x000F0000,    \/\/ T addressing type$/;"	e	enum:sidestep::AddressingMethod
AM_V	src/windows/mini_disassembler_types.h	/^  AM_V = 0x00100000,    \/\/ V addressing type$/;"	e	enum:sidestep::AddressingMethod
AM_W	src/windows/mini_disassembler_types.h	/^  AM_W = 0x00110000,    \/\/ W addressing type$/;"	e	enum:sidestep::AddressingMethod
AM_X	src/windows/mini_disassembler_types.h	/^  AM_X = 0x00120000,    \/\/ X addressing type$/;"	e	enum:sidestep::AddressingMethod
AM_Y	src/windows/mini_disassembler_types.h	/^  AM_Y = 0x00130000,    \/\/ Y addressing type$/;"	e	enum:sidestep::AddressingMethod
ANNOTALYSIS_IGNORE_READS_BEGIN	src/base/dynamic_annotations.h	381;"	d
ANNOTALYSIS_IGNORE_READS_BEGIN	src/base/dynamic_annotations.h	400;"	d
ANNOTALYSIS_IGNORE_READS_BEGIN	src/base/dynamic_annotations.h	401;"	d
ANNOTALYSIS_IGNORE_READS_END	src/base/dynamic_annotations.h	382;"	d
ANNOTALYSIS_IGNORE_READS_END	src/base/dynamic_annotations.h	402;"	d
ANNOTALYSIS_IGNORE_READS_END	src/base/dynamic_annotations.h	403;"	d
ANNOTALYSIS_IGNORE_WRITES_BEGIN	src/base/dynamic_annotations.h	383;"	d
ANNOTALYSIS_IGNORE_WRITES_BEGIN	src/base/dynamic_annotations.h	404;"	d
ANNOTALYSIS_IGNORE_WRITES_BEGIN	src/base/dynamic_annotations.h	405;"	d
ANNOTALYSIS_IGNORE_WRITES_END	src/base/dynamic_annotations.h	384;"	d
ANNOTALYSIS_IGNORE_WRITES_END	src/base/dynamic_annotations.h	406;"	d
ANNOTALYSIS_IGNORE_WRITES_END	src/base/dynamic_annotations.h	407;"	d
ANNOTALYSIS_ONLY	src/base/dynamic_annotations.h	391;"	d
ANNOTALYSIS_ONLY	src/base/dynamic_annotations.h	576;"	d
ANNOTALYSIS_SEMICOLON_OR_EMPTY_BODY	src/base/dynamic_annotations.h	380;"	d
ANNOTALYSIS_SEMICOLON_OR_EMPTY_BODY	src/base/dynamic_annotations.h	394;"	d
ANNOTALYSIS_SEMICOLON_OR_EMPTY_BODY	src/base/dynamic_annotations.h	395;"	d
ANNOTALYSIS_SEMICOLON_OR_EMPTY_BODY	src/base/dynamic_annotations.h	625;"	d
ANNOTALYSIS_STATIC_INLINE	src/base/dynamic_annotations.h	379;"	d
ANNOTALYSIS_STATIC_INLINE	src/base/dynamic_annotations.h	392;"	d
ANNOTALYSIS_STATIC_INLINE	src/base/dynamic_annotations.h	393;"	d
ANNOTALYSIS_STATIC_INLINE	src/base/dynamic_annotations.h	624;"	d
ANNOTALYSIS_UNPROTECTED_READ	src/base/dynamic_annotations.h	385;"	d
ANNOTALYSIS_UNPROTECTED_READ	src/base/dynamic_annotations.h	408;"	d
ANNOTALYSIS_UNPROTECTED_READ	src/base/dynamic_annotations.h	409;"	d
ANNOTATE_BARRIER_DESTROY	src/base/dynamic_annotations.h	309;"	d
ANNOTATE_BARRIER_DESTROY	src/base/dynamic_annotations.h	339;"	d
ANNOTATE_BARRIER_INIT	src/base/dynamic_annotations.h	296;"	d
ANNOTATE_BARRIER_INIT	src/base/dynamic_annotations.h	336;"	d
ANNOTATE_BARRIER_WAIT_AFTER	src/base/dynamic_annotations.h	305;"	d
ANNOTATE_BARRIER_WAIT_AFTER	src/base/dynamic_annotations.h	338;"	d
ANNOTATE_BARRIER_WAIT_BEFORE	src/base/dynamic_annotations.h	301;"	d
ANNOTATE_BARRIER_WAIT_BEFORE	src/base/dynamic_annotations.h	337;"	d
ANNOTATE_BENIGN_RACE	src/base/dynamic_annotations.h	206;"	d
ANNOTATE_BENIGN_RACE	src/base/dynamic_annotations.h	355;"	d
ANNOTATE_BENIGN_RACE_SIZED	src/base/dynamic_annotations.h	212;"	d
ANNOTATE_BENIGN_RACE_SIZED	src/base/dynamic_annotations.h	356;"	d
ANNOTATE_BENIGN_RACE_STATIC	src/base/dynamic_annotations.h	545;"	d
ANNOTATE_BENIGN_RACE_STATIC	src/base/dynamic_annotations.h	560;"	d
ANNOTATE_CONDVAR_LOCK_WAIT	src/base/dynamic_annotations.h	106;"	d
ANNOTATE_CONDVAR_LOCK_WAIT	src/base/dynamic_annotations.h	340;"	d
ANNOTATE_CONDVAR_SIGNAL	src/base/dynamic_annotations.h	116;"	d
ANNOTATE_CONDVAR_SIGNAL	src/base/dynamic_annotations.h	342;"	d
ANNOTATE_CONDVAR_SIGNAL_ALL	src/base/dynamic_annotations.h	120;"	d
ANNOTATE_CONDVAR_SIGNAL_ALL	src/base/dynamic_annotations.h	343;"	d
ANNOTATE_CONDVAR_WAIT	src/base/dynamic_annotations.h	111;"	d
ANNOTATE_CONDVAR_WAIT	src/base/dynamic_annotations.h	341;"	d
ANNOTATE_ENABLE_RACE_DETECTION	src/base/dynamic_annotations.h	252;"	d
ANNOTATE_ENABLE_RACE_DETECTION	src/base/dynamic_annotations.h	367;"	d
ANNOTATE_EXPECT_RACE	src/base/dynamic_annotations.h	317;"	d
ANNOTATE_EXPECT_RACE	src/base/dynamic_annotations.h	354;"	d
ANNOTATE_FLUSH_STATE	src/base/dynamic_annotations.h	326;"	d
ANNOTATE_FLUSH_STATE	src/base/dynamic_annotations.h	369;"	d
ANNOTATE_HAPPENS_AFTER	src/base/dynamic_annotations.h	125;"	d
ANNOTATE_HAPPENS_AFTER	src/base/dynamic_annotations.h	345;"	d
ANNOTATE_HAPPENS_BEFORE	src/base/dynamic_annotations.h	124;"	d
ANNOTATE_HAPPENS_BEFORE	src/base/dynamic_annotations.h	344;"	d
ANNOTATE_IGNORE_READS_AND_WRITES_BEGIN	src/base/dynamic_annotations.h	236;"	d
ANNOTATE_IGNORE_READS_AND_WRITES_BEGIN	src/base/dynamic_annotations.h	365;"	d
ANNOTATE_IGNORE_READS_AND_WRITES_BEGIN	src/base/dynamic_annotations.h	595;"	d
ANNOTATE_IGNORE_READS_AND_WRITES_BEGIN	src/base/dynamic_annotations.h	596;"	d
ANNOTATE_IGNORE_READS_AND_WRITES_END	src/base/dynamic_annotations.h	243;"	d
ANNOTATE_IGNORE_READS_AND_WRITES_END	src/base/dynamic_annotations.h	366;"	d
ANNOTATE_IGNORE_READS_AND_WRITES_END	src/base/dynamic_annotations.h	602;"	d
ANNOTATE_IGNORE_READS_AND_WRITES_END	src/base/dynamic_annotations.h	603;"	d
ANNOTATE_IGNORE_READS_BEGIN	src/base/dynamic_annotations.h	220;"	d
ANNOTATE_IGNORE_READS_BEGIN	src/base/dynamic_annotations.h	361;"	d
ANNOTATE_IGNORE_READS_BEGIN	src/base/dynamic_annotations.h	579;"	d
ANNOTATE_IGNORE_READS_BEGIN	src/base/dynamic_annotations.h	580;"	d
ANNOTATE_IGNORE_READS_END	src/base/dynamic_annotations.h	224;"	d
ANNOTATE_IGNORE_READS_END	src/base/dynamic_annotations.h	362;"	d
ANNOTATE_IGNORE_READS_END	src/base/dynamic_annotations.h	583;"	d
ANNOTATE_IGNORE_READS_END	src/base/dynamic_annotations.h	584;"	d
ANNOTATE_IGNORE_WRITES_BEGIN	src/base/dynamic_annotations.h	228;"	d
ANNOTATE_IGNORE_WRITES_BEGIN	src/base/dynamic_annotations.h	363;"	d
ANNOTATE_IGNORE_WRITES_BEGIN	src/base/dynamic_annotations.h	587;"	d
ANNOTATE_IGNORE_WRITES_BEGIN	src/base/dynamic_annotations.h	588;"	d
ANNOTATE_IGNORE_WRITES_END	src/base/dynamic_annotations.h	232;"	d
ANNOTATE_IGNORE_WRITES_END	src/base/dynamic_annotations.h	364;"	d
ANNOTATE_IGNORE_WRITES_END	src/base/dynamic_annotations.h	591;"	d
ANNOTATE_IGNORE_WRITES_END	src/base/dynamic_annotations.h	592;"	d
ANNOTATE_MUTEX_IS_USED_AS_CONDVAR	src/base/dynamic_annotations.h	159;"	d
ANNOTATE_MUTEX_IS_USED_AS_CONDVAR	src/base/dynamic_annotations.h	358;"	d
ANNOTATE_NEW_MEMORY	src/base/dynamic_annotations.h	170;"	d
ANNOTATE_NEW_MEMORY	src/base/dynamic_annotations.h	353;"	d
ANNOTATE_NO_OP	src/base/dynamic_annotations.h	321;"	d
ANNOTATE_NO_OP	src/base/dynamic_annotations.h	368;"	d
ANNOTATE_PCQ_CREATE	src/base/dynamic_annotations.h	181;"	d
ANNOTATE_PCQ_CREATE	src/base/dynamic_annotations.h	349;"	d
ANNOTATE_PCQ_DESTROY	src/base/dynamic_annotations.h	185;"	d
ANNOTATE_PCQ_DESTROY	src/base/dynamic_annotations.h	350;"	d
ANNOTATE_PCQ_GET	src/base/dynamic_annotations.h	194;"	d
ANNOTATE_PCQ_GET	src/base/dynamic_annotations.h	352;"	d
ANNOTATE_PCQ_PUT	src/base/dynamic_annotations.h	190;"	d
ANNOTATE_PCQ_PUT	src/base/dynamic_annotations.h	351;"	d
ANNOTATE_PUBLISH_MEMORY_RANGE	src/base/dynamic_annotations.h	134;"	d
ANNOTATE_PUBLISH_MEMORY_RANGE	src/base/dynamic_annotations.h	346;"	d
ANNOTATE_PURE_HAPPENS_BEFORE_MUTEX	src/base/dynamic_annotations.h	155;"	d
ANNOTATE_PURE_HAPPENS_BEFORE_MUTEX	src/base/dynamic_annotations.h	357;"	d
ANNOTATE_RWLOCK_ACQUIRED	src/base/dynamic_annotations.h	281;"	d
ANNOTATE_RWLOCK_ACQUIRED	src/base/dynamic_annotations.h	334;"	d
ANNOTATE_RWLOCK_CREATE	src/base/dynamic_annotations.h	272;"	d
ANNOTATE_RWLOCK_CREATE	src/base/dynamic_annotations.h	332;"	d
ANNOTATE_RWLOCK_DESTROY	src/base/dynamic_annotations.h	276;"	d
ANNOTATE_RWLOCK_DESTROY	src/base/dynamic_annotations.h	333;"	d
ANNOTATE_RWLOCK_RELEASED	src/base/dynamic_annotations.h	285;"	d
ANNOTATE_RWLOCK_RELEASED	src/base/dynamic_annotations.h	335;"	d
ANNOTATE_SWAP_MEMORY_RANGE	src/base/dynamic_annotations.h	142;"	d
ANNOTATE_SWAP_MEMORY_RANGE	src/base/dynamic_annotations.h	348;"	d
ANNOTATE_THREAD_NAME	src/base/dynamic_annotations.h	263;"	d
ANNOTATE_THREAD_NAME	src/base/dynamic_annotations.h	360;"	d
ANNOTATE_TRACE_MEMORY	src/base/dynamic_annotations.h	259;"	d
ANNOTATE_TRACE_MEMORY	src/base/dynamic_annotations.h	359;"	d
ANNOTATE_UNPROTECTED_READ	src/base/dynamic_annotations.h	559;"	d
ANNOTATE_UNPROTECTED_READ	src/base/dynamic_annotations.h	610;"	d
ANNOTATE_UNPUBLISH_MEMORY_RANGE	src/base/dynamic_annotations.h	138;"	d
ANNOTATE_UNPUBLISH_MEMORY_RANGE	src/base/dynamic_annotations.h	347;"	d
ANY	src/windows/shortproc.asm	/^; DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY$/;"	v
ARMV2	src/base/arm_instruction_set_select.h	81;"	d
ARMV3	src/base/arm_instruction_set_select.h	76;"	d
ARMV4	src/base/arm_instruction_set_select.h	70;"	d
ARMV5	src/base/arm_instruction_set_select.h	64;"	d
ARMV6	src/base/arm_instruction_set_select.h	56;"	d
ARMV7	src/base/arm_instruction_set_select.h	46;"	d
ARMV8	src/base/arm_instruction_set_select.h	39;"	d
ARM_INSTRUCTION_SET_SELECT_H_	src/base/arm_instruction_set_select.h	36;"	d
ARRAYSIZE	src/tests/stack_trace_table_test.cc	16;"	d	file:
ARRAYSIZE	src/tests/stack_trace_table_test.cc	17;"	d	file:
ASM_INT3	src/windows/preamble_patcher.cc	47;"	d	file:
ASM_INT3	src/windows/preamble_patcher_with_stub.cc	44;"	d	file:
ASM_JCC32REL_0	src/windows/preamble_patcher.cc	51;"	d	file:
ASM_JCC32REL_1_MASK	src/windows/preamble_patcher.cc	52;"	d	file:
ASM_JMP	src/windows/preamble_patcher.cc	57;"	d	file:
ASM_JMP	src/windows/preamble_patcher_with_stub.cc	49;"	d	file:
ASM_JMP32ABS_0	src/windows/preamble_patcher.cc	48;"	d	file:
ASM_JMP32ABS_1	src/windows/preamble_patcher.cc	49;"	d	file:
ASM_JMP32REL	src/windows/preamble_patcher.cc	46;"	d	file:
ASM_JMP32REL	src/windows/preamble_patcher_with_stub.cc	43;"	d	file:
ASM_JMP8REL	src/windows/preamble_patcher.cc	50;"	d	file:
ASM_JMP_RAX	src/windows/preamble_patcher.cc	58;"	d	file:
ASM_JMP_RAX	src/windows/preamble_patcher_with_stub.cc	50;"	d	file:
ASM_MOVRAX_IMM	src/windows/preamble_patcher.cc	56;"	d	file:
ASM_MOVRAX_IMM	src/windows/preamble_patcher_with_stub.cc	47;"	d	file:
ASM_NOP	src/windows/preamble_patcher.cc	53;"	d	file:
ASM_NOP	src/windows/preamble_patcher_with_stub.cc	45;"	d	file:
ASM_PUSH	src/windows/preamble_patcher_with_stub.cc	51;"	d	file:
ASM_RET	src/windows/preamble_patcher_with_stub.cc	52;"	d	file:
ASM_REXW	src/windows/preamble_patcher.cc	55;"	d	file:
ASM_REXW	src/windows/preamble_patcher_with_stub.cc	48;"	d	file:
ASSERT	src/internal_logging.h	120;"	d
ASSERT_EQ	src/base/logging.h	157;"	d
ASSERT_FALSE	src/base/logging.h	168;"	d
ASSERT_GE	src/base/logging.h	161;"	d
ASSERT_GT	src/base/logging.h	162;"	d
ASSERT_LE	src/base/logging.h	159;"	d
ASSERT_LT	src/base/logging.h	160;"	d
ASSERT_NE	src/base/logging.h	158;"	d
ASSERT_STREQ	src/base/logging.h	169;"	d
ASSERT_TRUE	src/base/logging.h	167;"	d
ATOMICOPS_COMPILER_BARRIER	src/base/atomicops-internals-x86.h	389;"	d
ATOMICOPS_COMPILER_BARRIER	src/base/atomicops-internals-x86.h	64;"	d
ATTRIBUTE_ALWAYS_INLINE	src/base/basictypes.h	413;"	d
ATTRIBUTE_ALWAYS_INLINE	src/base/basictypes.h	415;"	d
ATTRIBUTE_ALWAYS_INLINE	src/base/basictypes.h	417;"	d
ATTRIBUTE_HIDDEN	src/base/basictypes.h	407;"	d
ATTRIBUTE_HIDDEN	src/base/basictypes.h	409;"	d
ATTRIBUTE_NOINLINE	src/base/basictypes.h	252;"	d
ATTRIBUTE_NOINLINE	src/base/basictypes.h	255;"	d
ATTRIBUTE_NOINSTRUMENT	src/stacktrace_instrument-inl.h	63;"	d
ATTRIBUTE_SECTION	src/base/basictypes.h	284;"	d
ATTRIBUTE_SECTION	src/base/basictypes.h	303;"	d
ATTRIBUTE_SECTION	src/base/basictypes.h	362;"	d
ATTRIBUTE_SECTION	src/base/low_level_alloc.h	/^    ATTRIBUTE_SECTION(malloc_hook);$/;"	p	class:LowLevelAlloc	access:public	signature:(malloc_hook)
ATTRIBUTE_SECTION	src/base/low_level_alloc.h	/^  static void Free(void *s) ATTRIBUTE_SECTION(malloc_hook);$/;"	p	class:LowLevelAlloc	access:public	signature:(malloc_hook)
ATTRIBUTE_SECTION	src/malloc_hook_mmap_freebsd.h	/^    ATTRIBUTE_SECTION(malloc_hook);$/;"	p	signature:(malloc_hook)
ATTRIBUTE_SECTION	src/malloc_hook_mmap_linux.h	/^    ATTRIBUTE_SECTION(malloc_hook);$/;"	p	signature:(malloc_hook)
ATTRIBUTE_SECTION	src/tcmalloc.cc	/^      ATTRIBUTE_SECTION(google_malloc);$/;"	p	file:	signature:(google_malloc)
ATTRIBUTE_SECTION_START	src/base/basictypes.h	298;"	d
ATTRIBUTE_SECTION_START	src/base/basictypes.h	357;"	d
ATTRIBUTE_SECTION_START	src/base/basictypes.h	366;"	d
ATTRIBUTE_SECTION_STOP	src/base/basictypes.h	299;"	d
ATTRIBUTE_SECTION_STOP	src/base/basictypes.h	358;"	d
ATTRIBUTE_SECTION_STOP	src/base/basictypes.h	367;"	d
ATTRIBUTE_UNUSED	src/base/basictypes.h	198;"	d
ATTRIBUTE_UNUSED	src/base/basictypes.h	200;"	d
ATTRIBUTE_VISIBILITY_HIDDEN	src/base/basictypes.h	259;"	d
ATTRIBUTE_VISIBILITY_HIDDEN	src/base/basictypes.h	261;"	d
ATTRIBUTE_WEAK	src/base/atomicops-internals-arm-generic.h	/^LinuxKernelCmpxchgFunc pLinuxKernelCmpxchg ATTRIBUTE_WEAK =$/;"	m	namespace:base::subtle
ATTRIBUTE_WEAK	src/base/atomicops-internals-arm-generic.h	/^LinuxKernelMemoryBarrierFunc pLinuxKernelMemoryBarrier ATTRIBUTE_WEAK =$/;"	m	namespace:base::subtle
ATTRIBUTE_WEAK	src/base/basictypes.h	251;"	d
ATTRIBUTE_WEAK	src/base/basictypes.h	254;"	d
ATTRIBUTE_WEAK	src/maybe_threads.cc	/^      __THROW ATTRIBUTE_WEAK;$/;"	v
ATTRIBUTE_WEAK	src/maybe_threads.cc	/^    __THROW ATTRIBUTE_WEAK;$/;"	v
ATTR_INITIAL_EXEC	src/base/basictypes.h	204;"	d
ATTR_INITIAL_EXEC	src/base/basictypes.h	206;"	d
ATTR_INITIAL_EXEC	src/stacktrace_libunwind-inl.h	/^static __thread int recursive ATTR_INITIAL_EXEC;$/;"	v
ATTR_INITIAL_EXEC	src/thread_cache.h	/^    CACHELINE_ALIGNED ATTR_INITIAL_EXEC;$/;"	m	class:tcmalloc::ThreadCache	access:private
AT_FDCWD	src/base/linux_syscall_support.h	562;"	d
AT_REMOVEDIR	src/base/linux_syscall_support.h	568;"	d
AT_SYMLINK_NOFOLLOW	src/base/linux_syscall_support.h	565;"	d
AT_SYSINFO_EHDR	src/base/vdso_support.cc	54;"	d	file:
AcquirePassedObjects	src/tests/tcmalloc_unittest.cc	/^  void AcquirePassedObjects() {$/;"	f	class:testing::TesterThread	access:public	signature:()
Acquire_AtomicExchange	src/base/atomicops-internals-arm-generic.h	/^inline Atomic32 Acquire_AtomicExchange(volatile Atomic32* ptr,$/;"	f	namespace:base::subtle	signature:(volatile Atomic32* ptr, Atomic32 new_value)
Acquire_AtomicExchange	src/base/atomicops-internals-arm-generic.h	/^inline Atomic64 Acquire_AtomicExchange(volatile Atomic64* ptr,$/;"	f	namespace:base::subtle	signature:(volatile Atomic64* ptr, Atomic64 new_value)
Acquire_AtomicExchange	src/base/atomicops-internals-arm-v6plus.h	/^inline Atomic32 Acquire_AtomicExchange(volatile Atomic32* ptr,$/;"	f	namespace:base::subtle	signature:(volatile Atomic32* ptr, Atomic32 new_value)
Acquire_AtomicExchange	src/base/atomicops-internals-arm-v6plus.h	/^inline Atomic64 Acquire_AtomicExchange(volatile Atomic64* ptr,$/;"	f	namespace:base::subtle	signature:(volatile Atomic64* ptr, Atomic64 new_value)
Acquire_AtomicExchange	src/base/atomicops-internals-gcc.h	/^inline Atomic32 Acquire_AtomicExchange(volatile Atomic32* ptr,$/;"	f	namespace:base::subtle	signature:(volatile Atomic32* ptr, Atomic32 new_value)
Acquire_AtomicExchange	src/base/atomicops-internals-gcc.h	/^inline Atomic64 Acquire_AtomicExchange(volatile Atomic64* ptr,$/;"	f	namespace:base::subtle	signature:(volatile Atomic64* ptr, Atomic64 new_value)
Acquire_AtomicExchange	src/base/atomicops-internals-linuxppc.h	/^inline Atomic32 Acquire_AtomicExchange(volatile Atomic32 *ptr,$/;"	f	namespace:base::subtle	signature:(volatile Atomic32 *ptr, Atomic32 new_value)
Acquire_AtomicExchange	src/base/atomicops-internals-linuxppc.h	/^inline Atomic64 Acquire_AtomicExchange(volatile Atomic64 *ptr,$/;"	f	namespace:base::subtle	signature:(volatile Atomic64 *ptr, Atomic64 new_value)
Acquire_AtomicExchange	src/base/atomicops-internals-macosx.h	/^inline Atomic32 Acquire_AtomicExchange(volatile Atomic32 *ptr,$/;"	f	namespace:base::subtle	signature:(volatile Atomic32 *ptr, Atomic32 new_value)
Acquire_AtomicExchange	src/base/atomicops-internals-macosx.h	/^inline Atomic64 Acquire_AtomicExchange(volatile Atomic64 *ptr,$/;"	f	namespace:base::subtle	signature:(volatile Atomic64 *ptr, Atomic64 new_value)
Acquire_AtomicExchange	src/base/atomicops-internals-mips.h	/^inline Atomic32 Acquire_AtomicExchange(volatile Atomic32* ptr,$/;"	f	namespace:base::subtle	signature:(volatile Atomic32* ptr, Atomic32 new_value)
Acquire_AtomicExchange	src/base/atomicops-internals-mips.h	/^inline Atomic64 Acquire_AtomicExchange(volatile Atomic64* ptr,$/;"	f	namespace:base::subtle	signature:(volatile Atomic64* ptr, Atomic64 new_value)
Acquire_AtomicExchange	src/base/atomicops-internals-windows.h	/^inline Atomic32 Acquire_AtomicExchange(volatile Atomic32* ptr,$/;"	f	namespace:base::subtle	signature:(volatile Atomic32* ptr, Atomic32 new_value)
Acquire_AtomicExchange	src/base/atomicops-internals-windows.h	/^inline Atomic64 Acquire_AtomicExchange(volatile Atomic64* ptr,$/;"	f	namespace:base::subtle	signature:(volatile Atomic64* ptr, Atomic64 new_value)
Acquire_AtomicExchange	src/base/atomicops-internals-x86.h	/^inline Atomic32 Acquire_AtomicExchange(volatile Atomic32* ptr,$/;"	f	namespace:base::subtle	signature:(volatile Atomic32* ptr, Atomic32 new_value)
Acquire_AtomicExchange	src/base/atomicops-internals-x86.h	/^inline Atomic64 Acquire_AtomicExchange(volatile Atomic64* ptr,$/;"	f	namespace:base::subtle	signature:(volatile Atomic64* ptr, Atomic64 new_val)
Acquire_AtomicExchange	src/base/atomicops-internals-x86.h	/^inline Atomic64 Acquire_AtomicExchange(volatile Atomic64* ptr,$/;"	f	namespace:base::subtle	signature:(volatile Atomic64* ptr, Atomic64 new_value)
Acquire_AtomicExchange	src/base/atomicops.h	/^inline AtomicWord Acquire_AtomicExchange(volatile AtomicWord* ptr,$/;"	f	namespace:base::subtle	signature:(volatile AtomicWord* ptr, AtomicWord new_value)
Acquire_CompareAndSwap	src/base/atomicops-internals-arm-generic.h	/^inline Atomic32 Acquire_CompareAndSwap(volatile Atomic32* ptr,$/;"	f	namespace:base::subtle	signature:(volatile Atomic32* ptr, Atomic32 old_value, Atomic32 new_value)
Acquire_CompareAndSwap	src/base/atomicops-internals-arm-generic.h	/^inline Atomic64 Acquire_CompareAndSwap(volatile Atomic64* ptr,$/;"	f	namespace:base::subtle	signature:(volatile Atomic64* ptr, Atomic64 old_value, Atomic64 new_value)
Acquire_CompareAndSwap	src/base/atomicops-internals-arm-v6plus.h	/^inline Atomic32 Acquire_CompareAndSwap(volatile Atomic32* ptr,$/;"	f	namespace:base::subtle	signature:(volatile Atomic32* ptr, Atomic32 old_value, Atomic32 new_value)
Acquire_CompareAndSwap	src/base/atomicops-internals-arm-v6plus.h	/^inline Atomic64 Acquire_CompareAndSwap(volatile Atomic64* ptr,$/;"	f	namespace:base::subtle	signature:(volatile Atomic64* ptr, Atomic64 old_value, Atomic64 new_value)
Acquire_CompareAndSwap	src/base/atomicops-internals-gcc.h	/^inline Atomic32 Acquire_CompareAndSwap(volatile Atomic32* ptr,$/;"	f	namespace:base::subtle	signature:(volatile Atomic32* ptr, Atomic32 old_value, Atomic32 new_value)
Acquire_CompareAndSwap	src/base/atomicops-internals-gcc.h	/^inline Atomic64 Acquire_CompareAndSwap(volatile Atomic64* ptr,$/;"	f	namespace:base::subtle	signature:(volatile Atomic64* ptr, Atomic64 old_value, Atomic64 new_value)
Acquire_CompareAndSwap	src/base/atomicops-internals-linuxppc.h	/^inline Atomic32 Acquire_CompareAndSwap(volatile Atomic32 *ptr,$/;"	f	namespace:base::subtle	signature:(volatile Atomic32 *ptr, Atomic32 old_value, Atomic32 new_value)
Acquire_CompareAndSwap	src/base/atomicops-internals-linuxppc.h	/^inline Atomic64 Acquire_CompareAndSwap(volatile Atomic64 *ptr,$/;"	f	namespace:base::subtle	signature:(volatile Atomic64 *ptr, Atomic64 old_value, Atomic64 new_value)
Acquire_CompareAndSwap	src/base/atomicops-internals-macosx.h	/^inline Atomic32 Acquire_CompareAndSwap(volatile Atomic32 *ptr,$/;"	f	namespace:base::subtle	signature:(volatile Atomic32 *ptr, Atomic32 old_value, Atomic32 new_value)
Acquire_CompareAndSwap	src/base/atomicops-internals-macosx.h	/^inline Atomic64 Acquire_CompareAndSwap(volatile Atomic64 *ptr,$/;"	f	namespace:base::subtle	signature:(volatile Atomic64 *ptr, Atomic64 old_value, Atomic64 new_value)
Acquire_CompareAndSwap	src/base/atomicops-internals-mips.h	/^inline Atomic32 Acquire_CompareAndSwap(volatile Atomic32* ptr,$/;"	f	namespace:base::subtle	signature:(volatile Atomic32* ptr, Atomic32 old_value, Atomic32 new_value)
Acquire_CompareAndSwap	src/base/atomicops-internals-mips.h	/^inline Atomic64 Acquire_CompareAndSwap(volatile Atomic64* ptr,$/;"	f	namespace:base::subtle	signature:(volatile Atomic64* ptr, Atomic64 old_value, Atomic64 new_value)
Acquire_CompareAndSwap	src/base/atomicops-internals-windows.h	/^inline Atomic32 Acquire_CompareAndSwap(volatile Atomic32* ptr,$/;"	f	namespace:base::subtle	signature:(volatile Atomic32* ptr, Atomic32 old_value, Atomic32 new_value)
Acquire_CompareAndSwap	src/base/atomicops-internals-windows.h	/^inline Atomic64 Acquire_CompareAndSwap(volatile Atomic64* ptr,$/;"	f	namespace:base::subtle	signature:(volatile Atomic64* ptr, Atomic64 old_value, Atomic64 new_value)
Acquire_CompareAndSwap	src/base/atomicops-internals-x86.h	/^inline Atomic32 Acquire_CompareAndSwap(volatile Atomic32* ptr,$/;"	f	namespace:base::subtle	signature:(volatile Atomic32* ptr, Atomic32 old_value, Atomic32 new_value)
Acquire_CompareAndSwap	src/base/atomicops-internals-x86.h	/^inline Atomic64 Acquire_CompareAndSwap(volatile Atomic64* ptr,$/;"	f	namespace:base::subtle	signature:(volatile Atomic64* ptr, Atomic64 old_value, Atomic64 new_value)
Acquire_CompareAndSwap	src/base/atomicops.h	/^inline Atomic32 Acquire_CompareAndSwap(volatile Atomic32* ptr,$/;"	f	signature:(volatile Atomic32* ptr, Atomic32 old_value, Atomic32 new_value)
Acquire_CompareAndSwap	src/base/atomicops.h	/^inline AtomicWord Acquire_CompareAndSwap(volatile AtomicWord* ptr,$/;"	f	namespace:base::subtle	signature:(volatile AtomicWord* ptr, AtomicWord old_value, AtomicWord new_value)
Acquire_CompareAndSwap	src/base/atomicops.h	/^inline AtomicWord Acquire_CompareAndSwap(volatile AtomicWord* ptr,$/;"	f	signature:(volatile AtomicWord* ptr, AtomicWord old_value, AtomicWord new_value)
Acquire_CompareAndSwap	src/base/atomicops.h	/^inline base::subtle::Atomic64 Acquire_CompareAndSwap($/;"	f	signature:( volatile base::subtle::Atomic64* ptr, base::subtle::Atomic64 old_value, base::subtle::Atomic64 new_value)
Acquire_Load	src/base/atomicops-internals-arm-generic.h	/^inline Atomic32 Acquire_Load(volatile const Atomic32* ptr) {$/;"	f	namespace:base::subtle	signature:(volatile const Atomic32* ptr)
Acquire_Load	src/base/atomicops-internals-arm-generic.h	/^inline Atomic64 Acquire_Load(volatile const Atomic64* ptr) {$/;"	f	namespace:base::subtle	signature:(volatile const Atomic64* ptr)
Acquire_Load	src/base/atomicops-internals-arm-v6plus.h	/^inline Atomic32 Acquire_Load(volatile const Atomic32* ptr) {$/;"	f	namespace:base::subtle	signature:(volatile const Atomic32* ptr)
Acquire_Load	src/base/atomicops-internals-arm-v6plus.h	/^inline Atomic64 Acquire_Load(volatile const Atomic64* ptr) {$/;"	f	namespace:base::subtle	signature:(volatile const Atomic64* ptr)
Acquire_Load	src/base/atomicops-internals-gcc.h	/^inline Atomic32 Acquire_Load(volatile const Atomic32* ptr) {$/;"	f	namespace:base::subtle	signature:(volatile const Atomic32* ptr)
Acquire_Load	src/base/atomicops-internals-gcc.h	/^inline Atomic64 Acquire_Load(volatile const Atomic64* ptr) {$/;"	f	namespace:base::subtle	signature:(volatile const Atomic64* ptr)
Acquire_Load	src/base/atomicops-internals-linuxppc.h	/^inline Atomic32 Acquire_Load(volatile const Atomic32 *ptr) {$/;"	f	namespace:base::subtle	signature:(volatile const Atomic32 *ptr)
Acquire_Load	src/base/atomicops-internals-linuxppc.h	/^inline Atomic64 Acquire_Load(volatile const Atomic64 *ptr) {$/;"	f	namespace:base::subtle	signature:(volatile const Atomic64 *ptr)
Acquire_Load	src/base/atomicops-internals-macosx.h	/^inline Atomic32 Acquire_Load(volatile const Atomic32 *ptr) {$/;"	f	namespace:base::subtle	signature:(volatile const Atomic32 *ptr)
Acquire_Load	src/base/atomicops-internals-macosx.h	/^inline Atomic64 Acquire_Load(volatile const Atomic64 *ptr) {$/;"	f	namespace:base::subtle	signature:(volatile const Atomic64 *ptr)
Acquire_Load	src/base/atomicops-internals-mips.h	/^inline Atomic32 Acquire_Load(volatile const Atomic32* ptr)$/;"	f	namespace:base::subtle	signature:(volatile const Atomic32* ptr)
Acquire_Load	src/base/atomicops-internals-mips.h	/^inline Atomic64 Acquire_Load(volatile const Atomic64* ptr)$/;"	f	namespace:base::subtle	signature:(volatile const Atomic64* ptr)
Acquire_Load	src/base/atomicops-internals-windows.h	/^inline Atomic32 Acquire_Load(volatile const Atomic32* ptr) {$/;"	f	namespace:base::subtle	signature:(volatile const Atomic32* ptr)
Acquire_Load	src/base/atomicops-internals-windows.h	/^inline Atomic64 Acquire_Load(volatile const Atomic64* ptr) {$/;"	f	namespace:base::subtle	signature:(volatile const Atomic64* ptr)
Acquire_Load	src/base/atomicops-internals-x86.h	/^inline Atomic32 Acquire_Load(volatile const Atomic32* ptr) {$/;"	f	namespace:base::subtle	signature:(volatile const Atomic32* ptr)
Acquire_Load	src/base/atomicops-internals-x86.h	/^inline Atomic64 Acquire_Load(volatile const Atomic64* ptr) {$/;"	f	namespace:base::subtle	signature:(volatile const Atomic64* ptr)
Acquire_Load	src/base/atomicops.h	/^inline Atomic32 Acquire_Load(volatile const Atomic32* ptr) {$/;"	f	signature:(volatile const Atomic32* ptr)
Acquire_Load	src/base/atomicops.h	/^inline AtomicWord Acquire_Load(volatile const AtomicWord* ptr) {$/;"	f	namespace:base::subtle	signature:(volatile const AtomicWord* ptr)
Acquire_Load	src/base/atomicops.h	/^inline AtomicWord Acquire_Load(volatile const AtomicWord* ptr) {$/;"	f	signature:(volatile const AtomicWord* ptr)
Acquire_Load	src/base/atomicops.h	/^inline base::subtle::Atomic64 Acquire_Load($/;"	f	signature:( volatile const base::subtle::Atomic64* ptr)
Acquire_Store	src/base/atomicops-internals-arm-generic.h	/^inline void Acquire_Store(volatile Atomic32* ptr, Atomic32 value) {$/;"	f	namespace:base::subtle	signature:(volatile Atomic32* ptr, Atomic32 value)
Acquire_Store	src/base/atomicops-internals-arm-generic.h	/^inline void Acquire_Store(volatile Atomic64* ptr, Atomic64 value) {$/;"	f	namespace:base::subtle	signature:(volatile Atomic64* ptr, Atomic64 value)
Acquire_Store	src/base/atomicops-internals-arm-v6plus.h	/^inline void Acquire_Store(volatile Atomic32* ptr, Atomic32 value) {$/;"	f	namespace:base::subtle	signature:(volatile Atomic32* ptr, Atomic32 value)
Acquire_Store	src/base/atomicops-internals-arm-v6plus.h	/^inline void Acquire_Store(volatile Atomic64* ptr, Atomic64 value) {$/;"	f	namespace:base::subtle	signature:(volatile Atomic64* ptr, Atomic64 value)
Acquire_Store	src/base/atomicops-internals-gcc.h	/^inline void Acquire_Store(volatile Atomic32* ptr, Atomic32 value) {$/;"	f	namespace:base::subtle	signature:(volatile Atomic32* ptr, Atomic32 value)
Acquire_Store	src/base/atomicops-internals-gcc.h	/^inline void Acquire_Store(volatile Atomic64* ptr, Atomic64 value) {$/;"	f	namespace:base::subtle	signature:(volatile Atomic64* ptr, Atomic64 value)
Acquire_Store	src/base/atomicops-internals-linuxppc.h	/^inline void Acquire_Store(volatile Atomic32 *ptr, Atomic32 value) {$/;"	f	namespace:base::subtle	signature:(volatile Atomic32 *ptr, Atomic32 value)
Acquire_Store	src/base/atomicops-internals-linuxppc.h	/^inline void Acquire_Store(volatile Atomic64 *ptr, Atomic64 value) {$/;"	f	namespace:base::subtle	signature:(volatile Atomic64 *ptr, Atomic64 value)
Acquire_Store	src/base/atomicops-internals-macosx.h	/^inline void Acquire_Store(volatile Atomic32 *ptr, Atomic32 value) {$/;"	f	namespace:base::subtle	signature:(volatile Atomic32 *ptr, Atomic32 value)
Acquire_Store	src/base/atomicops-internals-macosx.h	/^inline void Acquire_Store(volatile Atomic64 *ptr, Atomic64 value) {$/;"	f	namespace:base::subtle	signature:(volatile Atomic64 *ptr, Atomic64 value)
Acquire_Store	src/base/atomicops-internals-mips.h	/^inline void Acquire_Store(volatile Atomic32* ptr, Atomic32 value)$/;"	f	namespace:base::subtle	signature:(volatile Atomic32* ptr, Atomic32 value)
Acquire_Store	src/base/atomicops-internals-mips.h	/^inline void Acquire_Store(volatile Atomic64* ptr, Atomic64 value)$/;"	f	namespace:base::subtle	signature:(volatile Atomic64* ptr, Atomic64 value)
Acquire_Store	src/base/atomicops-internals-windows.h	/^inline void Acquire_Store(volatile Atomic32* ptr, Atomic32 value) {$/;"	f	namespace:base::subtle	signature:(volatile Atomic32* ptr, Atomic32 value)
Acquire_Store	src/base/atomicops-internals-windows.h	/^inline void Acquire_Store(volatile Atomic64* ptr, Atomic64 value) {$/;"	f	namespace:base::subtle	signature:(volatile Atomic64* ptr, Atomic64 value)
Acquire_Store	src/base/atomicops-internals-x86.h	/^inline void Acquire_Store(volatile Atomic32* ptr, Atomic32 value) {$/;"	f	namespace:base::subtle	signature:(volatile Atomic32* ptr, Atomic32 value)
Acquire_Store	src/base/atomicops-internals-x86.h	/^inline void Acquire_Store(volatile Atomic64* ptr, Atomic64 value) {$/;"	f	namespace:base::subtle	signature:(volatile Atomic64* ptr, Atomic64 value)
Acquire_Store	src/base/atomicops.h	/^inline void Acquire_Store($/;"	f	signature:( volatile base::subtle::Atomic64* ptr, base::subtle::Atomic64 value)
Acquire_Store	src/base/atomicops.h	/^inline void Acquire_Store(volatile Atomic32* ptr, Atomic32 value) {$/;"	f	signature:(volatile Atomic32* ptr, Atomic32 value)
Acquire_Store	src/base/atomicops.h	/^inline void Acquire_Store(volatile AtomicWord* ptr, AtomicWord value) {$/;"	f	namespace:base::subtle	signature:(volatile AtomicWord* ptr, AtomicWord value)
Acquire_Store	src/base/atomicops.h	/^inline void Acquire_Store(volatile AtomicWord* ptr, AtomicWord value) {$/;"	f	signature:(volatile AtomicWord* ptr, AtomicWord value)
Add	src/heap-profile-table.h	/^  inline void Add(const void* ptr, const AllocValue& v) {$/;"	f	class:HeapProfileTable::Snapshot	access:private	signature:(const void* ptr, const AllocValue& v)
Add	src/internal_logging.cc	/^  bool Add(const LogItem& item);$/;"	p	class:tcmalloc::Logger	file:	access:public	signature:(const LogItem& item)
Add	src/internal_logging.cc	/^bool Logger::Add(const LogItem& item) {$/;"	f	class:tcmalloc::Logger	signature:(const LogItem& item)
Add	src/malloc_hook-inl.h	/^  bool Add(T value);$/;"	p	struct:base::internal::HookList	access:public	signature:(T value)
Add	src/malloc_hook.cc	/^bool HookList<T>::Add(T value_as_t) {$/;"	f	class:base::internal::HookList	signature:(T value_as_t)
Add	src/profiledata.cc	/^void ProfileData::Add(int depth, const void* const* stack) {$/;"	f	class:ProfileData	signature:(int depth, const void* const* stack)
Add	src/profiledata.h	/^  void Add(int depth, const void* const* stack);$/;"	p	class:ProfileData	access:public	signature:(int depth, const void* const* stack)
Add	src/symbolize.cc	/^void SymbolTable::Add(const void* addr) {$/;"	f	class:SymbolTable	signature:(const void* addr)
Add	src/symbolize.h	/^  void Add(const void* addr);$/;"	p	class:SymbolTable	access:public	signature:(const void* addr)
AddDeleteHook	src/gperftools/malloc_hook.h	/^  inline static bool AddDeleteHook(DeleteHook hook) {$/;"	f	class:MallocHook	access:public	signature:(DeleteHook hook)
AddIfNonLive	src/heap-profile-table.cc	/^void HeapProfileTable::AddIfNonLive(const void* ptr, AllocValue* v,$/;"	f	class:HeapProfileTable	signature:(const void* ptr, AllocValue* v, AddNonLiveArgs* arg)
AddIfNonLive	src/heap-profile-table.h	/^  static void AddIfNonLive(const void* ptr, AllocValue* v,$/;"	p	class:HeapProfileTable	access:private	signature:(const void* ptr, AllocValue* v, AddNonLiveArgs* arg)
AddMmapHook	src/gperftools/malloc_hook.h	/^  inline static bool AddMmapHook(MmapHook hook) {$/;"	f	class:MallocHook	access:public	signature:(MmapHook hook)
AddMremapHook	src/gperftools/malloc_hook.h	/^  inline static bool AddMremapHook(MremapHook hook) {$/;"	f	class:MallocHook	access:public	signature:(MremapHook hook)
AddMunmapHook	src/gperftools/malloc_hook.h	/^  inline static bool AddMunmapHook(MunmapHook hook) {$/;"	f	class:MallocHook	access:public	signature:(MunmapHook hook)
AddNewHook	src/gperftools/malloc_hook.h	/^  inline static bool AddNewHook(NewHook hook) {$/;"	f	class:MallocHook	access:public	signature:(NewHook hook)
AddNonLiveArgs	src/heap-profile-table.h	/^  struct AddNonLiveArgs {$/;"	s	class:HeapProfileTable	access:private
AddNum	src/internal_logging.cc	/^  bool AddNum(uint64_t num, int base);  \/\/ base must be 10 or 16.$/;"	p	class:tcmalloc::Logger	file:	access:public	signature:(uint64_t num, int base)
AddNum	src/internal_logging.cc	/^bool Logger::AddNum(uint64_t num, int base) {$/;"	f	class:tcmalloc::Logger	signature:(uint64_t num, int base)
AddPreMmapHook	src/gperftools/malloc_hook.h	/^  inline static bool AddPreMmapHook(PreMmapHook hook) {$/;"	f	class:MallocHook	access:public	signature:(PreMmapHook hook)
AddPreSbrkHook	src/gperftools/malloc_hook.h	/^  inline static bool AddPreSbrkHook(PreSbrkHook hook) {$/;"	f	class:MallocHook	access:public	signature:(PreSbrkHook hook)
AddSbrkHook	src/gperftools/malloc_hook.h	/^  inline static bool AddSbrkHook(SbrkHook hook) {$/;"	f	class:MallocHook	access:public	signature:(SbrkHook hook)
AddStr	src/internal_logging.cc	/^  bool AddStr(const char* str, int n);$/;"	p	class:tcmalloc::Logger	file:	access:public	signature:(const char* str, int n)
AddStr	src/internal_logging.cc	/^bool Logger::AddStr(const char* str, int n) {$/;"	f	class:tcmalloc::Logger	signature:(const char* str, int n)
AddToFreelist	src/base/low_level_alloc.cc	/^static void AddToFreelist(void *v, LowLevelAlloc::Arena *arena) {$/;"	f	file:	signature:(void *v, LowLevelAlloc::Arena *arena)
AddToSnapshot	src/heap-profile-table.cc	/^void HeapProfileTable::AddToSnapshot(const void* ptr, AllocValue* v,$/;"	f	class:HeapProfileTable	signature:(const void* ptr, AllocValue* v, Snapshot* snapshot)
AddToSnapshot	src/heap-profile-table.h	/^  static void AddToSnapshot(const void* ptr, AllocValue* v, Snapshot* s);$/;"	p	class:HeapProfileTable	access:private	signature:(const void* ptr, AllocValue* v, Snapshot* s)
AddTrace	src/stack_trace_table.cc	/^void StackTraceTable::AddTrace(const StackTrace& t) {$/;"	f	class:tcmalloc::StackTraceTable	signature:(const StackTrace& t)
AddTrace	src/stack_trace_table.h	/^  void AddTrace(const StackTrace& t);$/;"	p	class:tcmalloc::StackTraceTable	access:public	signature:(const StackTrace& t)
AddTrace	src/tests/stack_trace_table_test.cc	/^static void AddTrace(tcmalloc::StackTraceTable* table,$/;"	f	file:	signature:(tcmalloc::StackTraceTable* table, const tcmalloc::StackTrace& t)
AddType	src/tests/tcmalloc_unittest.cc	/^  void AddType(int type, int weight, const char* name);$/;"	p	class:testing::TestHarness	file:	access:public	signature:(int type, int weight, const char* name)
AddType	src/tests/tcmalloc_unittest.cc	/^void TestHarness::AddType(int type, int weight, const char* name) {$/;"	f	class:testing::TestHarness	signature:(int type, int weight, const char* name)
AddressMap	src/addressmap-inl.h	/^  AddressMap(Allocator alloc, DeAllocator dealloc);$/;"	p	class:AddressMap	access:public	signature:(Allocator alloc, DeAllocator dealloc)
AddressMap	src/addressmap-inl.h	/^AddressMap<Value>::AddressMap(Allocator alloc, DeAllocator dealloc)$/;"	f	class:AddressMap	signature:(Allocator alloc, DeAllocator dealloc)
AddressMap	src/addressmap-inl.h	/^class AddressMap {$/;"	c
AddressMap::ALLOC_COUNT	src/addressmap-inl.h	/^  static const int ALLOC_COUNT = 64;$/;"	m	class:AddressMap	access:private
AddressMap::AddressMap	src/addressmap-inl.h	/^  AddressMap(Allocator alloc, DeAllocator dealloc);$/;"	p	class:AddressMap	access:public	signature:(Allocator alloc, DeAllocator dealloc)
AddressMap::AddressMap	src/addressmap-inl.h	/^AddressMap<Value>::AddressMap(Allocator alloc, DeAllocator dealloc)$/;"	f	class:AddressMap	signature:(Allocator alloc, DeAllocator dealloc)
AddressMap::Allocator	src/addressmap-inl.h	/^  typedef void* (*Allocator)(size_t size);$/;"	t	class:AddressMap	access:public
AddressMap::BlockID	src/addressmap-inl.h	/^  static int BlockID(Number address) {$/;"	f	class:AddressMap	access:private	signature:(Number address)
AddressMap::Cluster	src/addressmap-inl.h	/^  struct Cluster {$/;"	s	class:AddressMap	access:private
AddressMap::Cluster::blocks	src/addressmap-inl.h	/^    Entry*   blocks[kClusterBlocks];    \/\/ Per-block linked-lists$/;"	m	struct:AddressMap::Cluster	access:public
AddressMap::Cluster::id	src/addressmap-inl.h	/^    Number   id;                        \/\/ Cluster ID$/;"	m	struct:AddressMap::Cluster	access:public
AddressMap::Cluster::next	src/addressmap-inl.h	/^    Cluster* next;                      \/\/ Next cluster in hash table chain$/;"	m	struct:AddressMap::Cluster	access:public
AddressMap::DeAllocator	src/addressmap-inl.h	/^  typedef void  (*DeAllocator)(void* ptr);$/;"	t	class:AddressMap	access:public
AddressMap::Entry	src/addressmap-inl.h	/^  struct Entry {$/;"	s	class:AddressMap	access:private
AddressMap::Entry::key	src/addressmap-inl.h	/^    Key    key;$/;"	m	struct:AddressMap::Entry	access:public
AddressMap::Entry::next	src/addressmap-inl.h	/^    Entry* next;$/;"	m	struct:AddressMap::Entry	access:public
AddressMap::Entry::value	src/addressmap-inl.h	/^    Value  value;$/;"	m	struct:AddressMap::Entry	access:public
AddressMap::Find	src/addressmap-inl.h	/^  inline const Value* Find(Key key) const;$/;"	p	class:AddressMap	access:public	signature:(Key key) const
AddressMap::Find	src/addressmap-inl.h	/^inline const Value* AddressMap<Value>::Find(Key key) const {$/;"	f	class:AddressMap	signature:(Key key) const
AddressMap::FindAndRemove	src/addressmap-inl.h	/^  bool FindAndRemove(Key key, Value* removed_value);$/;"	p	class:AddressMap	access:public	signature:(Key key, Value* removed_value)
AddressMap::FindAndRemove	src/addressmap-inl.h	/^bool AddressMap<Value>::FindAndRemove(Key key, Value* removed_value) {$/;"	f	class:AddressMap	signature:(Key key, Value* removed_value)
AddressMap::FindCluster	src/addressmap-inl.h	/^  Cluster* FindCluster(Number address, bool create) {$/;"	f	class:AddressMap	access:private	signature:(Number address, bool create)
AddressMap::FindInside	src/addressmap-inl.h	/^  const Value* FindInside(ValueSizeFunc size_func, size_t max_size,$/;"	p	class:AddressMap	access:public	signature:(ValueSizeFunc size_func, size_t max_size, Key key, Key* res_key)
AddressMap::FindInside	src/addressmap-inl.h	/^const Value* AddressMap<Value>::FindInside(ValueSizeFunc size_func,$/;"	f	class:AddressMap	signature:(ValueSizeFunc size_func, size_t max_size, Key key, Key* res_key)
AddressMap::FindMutable	src/addressmap-inl.h	/^  inline Value* FindMutable(Key key);$/;"	p	class:AddressMap	access:public	signature:(Key key)
AddressMap::FindMutable	src/addressmap-inl.h	/^inline Value* AddressMap<Value>::FindMutable(Key key) {$/;"	f	class:AddressMap	signature:(Key key)
AddressMap::HashInt	src/addressmap-inl.h	/^  static int HashInt(Number x) {$/;"	f	class:AddressMap	access:private	signature:(Number x)
AddressMap::Insert	src/addressmap-inl.h	/^  void Insert(Key key, Value value);$/;"	p	class:AddressMap	access:public	signature:(Key key, Value value)
AddressMap::Insert	src/addressmap-inl.h	/^void AddressMap<Value>::Insert(Key key, Value value) {$/;"	f	class:AddressMap	signature:(Key key, Value value)
AddressMap::Iterate	src/addressmap-inl.h	/^  inline void Iterate(void (*callback)(Key, Value*, Type), Type arg) const;$/;"	p	class:AddressMap	access:public	signature:(void (*callback)(Key, Value*, Type), Type arg) const
AddressMap::Iterate	src/addressmap-inl.h	/^inline void AddressMap<Value>::Iterate(void (*callback)(Key, Value*, Type),$/;"	f	class:AddressMap	signature:(void (*callback)(Key, Value*, Type), Type arg) const
AddressMap::Key	src/addressmap-inl.h	/^  typedef const void* Key;$/;"	t	class:AddressMap	access:public
AddressMap::New	src/addressmap-inl.h	/^  template <class T> T* New(int num) {$/;"	f	class:AddressMap	access:private	signature:(int num)
AddressMap::Number	src/addressmap-inl.h	/^  typedef uintptr_t Number;$/;"	t	class:AddressMap	access:private
AddressMap::Object	src/addressmap-inl.h	/^  struct Object {$/;"	s	class:AddressMap	access:private
AddressMap::Object::next	src/addressmap-inl.h	/^    Object* next;$/;"	m	struct:AddressMap::Object	access:public
AddressMap::ValueSizeFunc	src/addressmap-inl.h	/^  typedef size_t (*ValueSizeFunc)(const Value& v);$/;"	t	class:AddressMap	access:public
AddressMap::alloc_	src/addressmap-inl.h	/^  Allocator     alloc_;                 \/\/ The allocator$/;"	m	class:AddressMap	access:private
AddressMap::allocated_	src/addressmap-inl.h	/^  Object*       allocated_;             \/\/ List of allocated objects$/;"	m	class:AddressMap	access:private
AddressMap::dealloc_	src/addressmap-inl.h	/^  DeAllocator   dealloc_;               \/\/ The deallocator$/;"	m	class:AddressMap	access:private
AddressMap::free_	src/addressmap-inl.h	/^  Entry*        free_;                   \/\/ Free list of unused Entry objects$/;"	m	class:AddressMap	access:private
AddressMap::hashtable_	src/addressmap-inl.h	/^  Cluster**     hashtable_;              \/\/ The hash-table$/;"	m	class:AddressMap	access:private
AddressMap::kBlockBits	src/addressmap-inl.h	/^  static const int kBlockBits = 7;$/;"	m	class:AddressMap	access:private
AddressMap::kBlockSize	src/addressmap-inl.h	/^  static const int kBlockSize = 1 << kBlockBits;$/;"	m	class:AddressMap	access:private
AddressMap::kClusterBits	src/addressmap-inl.h	/^  static const int kClusterBits = 13;$/;"	m	class:AddressMap	access:private
AddressMap::kClusterBlocks	src/addressmap-inl.h	/^  static const int kClusterBlocks = 1 << kClusterBits;$/;"	m	class:AddressMap	access:private
AddressMap::kClusterSize	src/addressmap-inl.h	/^  static const Number kClusterSize = 1 << (kBlockBits + kClusterBits);$/;"	m	class:AddressMap	access:private
AddressMap::kHashBits	src/addressmap-inl.h	/^  static const int kHashBits = 12;$/;"	m	class:AddressMap	access:private
AddressMap::kHashMultiplier	src/addressmap-inl.h	/^  static const uint32_t kHashMultiplier = 2654435769u;$/;"	m	class:AddressMap	access:private
AddressMap::kHashSize	src/addressmap-inl.h	/^  static const int kHashSize = 1 << 12;$/;"	m	class:AddressMap	access:private
AddressMap::~AddressMap	src/addressmap-inl.h	/^  ~AddressMap();$/;"	p	class:AddressMap	access:public	signature:()
AddressMap::~AddressMap	src/addressmap-inl.h	/^AddressMap<Value>::~AddressMap() {$/;"	f	class:AddressMap	signature:()
AddressRange	src/tests/stacktrace_unittest.cc	/^struct AddressRange {$/;"	s	namespace:__anon52	file:
AddressingMethod	src/windows/mini_disassembler_types.h	/^enum AddressingMethod {$/;"	g	namespace:sidestep
AggressiveDecommitChanger	src/tests/tcmalloc_unittest.cc	/^  AggressiveDecommitChanger(size_t new_value) {$/;"	f	class:testing::AggressiveDecommitChanger	access:public	signature:(size_t new_value)
AggressiveDecommitChanger	src/tests/tcmalloc_unittest.cc	/^class AggressiveDecommitChanger {$/;"	c	namespace:testing	file:
AlignmentForSize	src/common.cc	/^int AlignmentForSize(size_t size) {$/;"	f	namespace:tcmalloc	signature:(size_t size)
AlignmentForSize	src/common.h	/^int AlignmentForSize(size_t size);$/;"	p	namespace:tcmalloc	signature:(size_t size)
Alloc	src/base/low_level_alloc.cc	/^void *LowLevelAlloc::Alloc(size_t request) {$/;"	f	class:LowLevelAlloc	signature:(size_t request)
Alloc	src/gperftools/malloc_extension.h	/^  virtual void* Alloc(size_t size, size_t *actual_size, size_t alignment) = 0;$/;"	p	class:SysAllocator	access:public	signature:(size_t size, size_t *actual_size, size_t alignment)
Alloc	src/memfs_malloc.cc	/^  void* Alloc(size_t size, size_t *actual_size, size_t alignment);$/;"	p	class:HugetlbSysAllocator	file:	access:public	signature:(size_t size, size_t *actual_size, size_t alignment)
Alloc	src/memfs_malloc.cc	/^void* HugetlbSysAllocator::Alloc(size_t size, size_t *actual_size,$/;"	f	class:HugetlbSysAllocator	signature:(size_t size, size_t *actual_size, size_t alignment)
Alloc	src/system-alloc.cc	/^  void* Alloc(size_t size, size_t *actual_size, size_t alignment);$/;"	p	class:DefaultSysAllocator	file:	access:public	signature:(size_t size, size_t *actual_size, size_t alignment)
Alloc	src/system-alloc.cc	/^  void* Alloc(size_t size, size_t *actual_size, size_t alignment);$/;"	p	class:DevMemSysAllocator	file:	access:public	signature:(size_t size, size_t *actual_size, size_t alignment)
Alloc	src/system-alloc.cc	/^  void* Alloc(size_t size, size_t *actual_size, size_t alignment);$/;"	p	class:MmapSysAllocator	file:	access:public	signature:(size_t size, size_t *actual_size, size_t alignment)
Alloc	src/system-alloc.cc	/^  void* Alloc(size_t size, size_t *actual_size, size_t alignment);$/;"	p	class:SbrkSysAllocator	file:	access:public	signature:(size_t size, size_t *actual_size, size_t alignment)
Alloc	src/system-alloc.cc	/^void* DefaultSysAllocator::Alloc(size_t size, size_t *actual_size,$/;"	f	class:DefaultSysAllocator	signature:(size_t size, size_t *actual_size, size_t alignment)
Alloc	src/system-alloc.cc	/^void* DevMemSysAllocator::Alloc(size_t size, size_t *actual_size,$/;"	f	class:DevMemSysAllocator	signature:(size_t size, size_t *actual_size, size_t alignment)
Alloc	src/system-alloc.cc	/^void* MmapSysAllocator::Alloc(size_t size, size_t *actual_size,$/;"	f	class:MmapSysAllocator	signature:(size_t size, size_t *actual_size, size_t alignment)
Alloc	src/system-alloc.cc	/^void* SbrkSysAllocator::Alloc(size_t size, size_t *actual_size,$/;"	f	class:SbrkSysAllocator	signature:(size_t size, size_t *actual_size, size_t alignment)
Alloc	src/tests/system-alloc_unittest.cc	/^  void* Alloc(size_t size, size_t *actual_size, size_t alignment) {$/;"	f	class:ArraySysAllocator	access:public	signature:(size_t size, size_t *actual_size, size_t alignment)
Alloc	src/tests/tcmalloc_unittest.cc	/^  void* Alloc(size_t size, size_t* actual_size, size_t alignment) {$/;"	f	struct:OOMAbleSysAlloc	access:public	signature:(size_t size, size_t* actual_size, size_t alignment)
Alloc	src/windows/system-alloc.cc	/^  void* Alloc(size_t size, size_t *actual_size, size_t alignment);$/;"	p	class:VirtualSysAllocator	file:	access:public	signature:(size_t size, size_t *actual_size, size_t alignment)
Alloc	src/windows/system-alloc.cc	/^void* VirtualSysAllocator::Alloc(size_t size, size_t *actual_size,$/;"	f	class:VirtualSysAllocator	signature:(size_t size, size_t *actual_size, size_t alignment)
AllocContextInfo	src/heap-profile-table.h	/^  struct AllocContextInfo : public Stats {$/;"	s	class:HeapProfileTable	inherits:Stats	access:public
AllocContextIterator	src/heap-profile-table.h	/^  typedef void (*AllocContextIterator)(const AllocContextInfo& info);$/;"	t	class:HeapProfileTable	access:public
AllocHidden	src/tests/heap-checker_unittest.cc	/^static void* AllocHidden(size_t size) {$/;"	f	file:	signature:(size_t size)
AllocHook	src/tests/low_level_alloc_unittest.cc	/^static void AllocHook(const void *p, size_t size) {$/;"	f	file:	signature:(const void *p, size_t size)
AllocInfo	src/heap-profile-table.h	/^  struct AllocInfo {$/;"	s	class:HeapProfileTable	access:public
AllocInternal	src/memfs_malloc.cc	/^  void* AllocInternal(size_t size, size_t *actual_size, size_t alignment);$/;"	p	class:HugetlbSysAllocator	file:	access:private	signature:(size_t size, size_t *actual_size, size_t alignment)
AllocInternal	src/memfs_malloc.cc	/^void* HugetlbSysAllocator::AllocInternal(size_t size, size_t* actual_size,$/;"	f	class:HugetlbSysAllocator	signature:(size_t size, size_t* actual_size, size_t alignment)
AllocIterator	src/heap-profile-table.h	/^  typedef void (*AllocIterator)(const void* ptr, const AllocInfo& info);$/;"	t	class:HeapProfileTable	access:public
AllocLarge	src/page_heap.cc	/^Span* PageHeap::AllocLarge(Length n) {$/;"	f	class:tcmalloc::PageHeap	signature:(Length n)
AllocLarge	src/page_heap.h	/^  Span* AllocLarge(Length n);$/;"	p	class:tcmalloc::PageHeap	access:private	signature:(Length n)
AllocList	src/base/low_level_alloc.cc	/^  struct AllocList {$/;"	s	namespace:low_level_alloc_internal	file:
AllocMap	src/debugallocation.cc	/^  typedef AddressMap<int> AllocMap;$/;"	t	class:MallocBlock	file:	access:private
AllocName	src/debugallocation.cc	/^  static const char* AllocName(int type) {$/;"	f	class:MallocBlock	file:	access:private	signature:(int type)
AllocObject	src/heap-checker.cc	/^  AllocObject(const void* p, size_t s, ObjectPlacement l)$/;"	f	struct:AllocObject	access:public	signature:(const void* p, size_t s, ObjectPlacement l)
AllocObject	src/heap-checker.cc	/^struct AllocObject {$/;"	s	file:
AllocObject::AllocObject	src/heap-checker.cc	/^  AllocObject(const void* p, size_t s, ObjectPlacement l)$/;"	f	struct:AllocObject	access:public	signature:(const void* p, size_t s, ObjectPlacement l)
AllocObject::place	src/heap-checker.cc	/^  ObjectPlacement place;  \/\/ where ptr points to$/;"	m	struct:AllocObject	file:	access:public
AllocObject::ptr	src/heap-checker.cc	/^  const void* ptr;        \/\/ the object$/;"	m	struct:AllocObject	file:	access:public
AllocObject::size	src/heap-checker.cc	/^  uintptr_t size;         \/\/ its size$/;"	m	struct:AllocObject	file:	access:public
AllocPageNear	src/windows/preamble_patcher.cc	/^void* PreamblePatcher::AllocPageNear(void* target) {$/;"	f	class:sidestep::PreamblePatcher	signature:(void* target)
AllocPageNear	src/windows/preamble_patcher.h	/^  static void* AllocPageNear(void* target);$/;"	p	class:sidestep::PreamblePatcher	access:private	signature:(void* target)
AllocPreambleBlockNear	src/windows/preamble_patcher.cc	/^unsigned char* PreamblePatcher::AllocPreambleBlockNear(void* target) {$/;"	f	class:sidestep::PreamblePatcher	signature:(void* target)
AllocPreambleBlockNear	src/windows/preamble_patcher.h	/^  static unsigned char* AllocPreambleBlockNear(void* target);$/;"	p	class:sidestep::PreamblePatcher	access:public	signature:(void* target)
AllocStuff	src/tests/thread_dealloc_unittest.cc	/^static void AllocStuff() {$/;"	f	file:	signature:()
AllocValue	src/heap-profile-table.h	/^  struct AllocValue {$/;"	s	class:HeapProfileTable	access:private
AllocValueSize	src/heap-profile-table.h	/^  static size_t AllocValueSize(const AllocValue& v) { return v.bytes; }$/;"	f	class:HeapProfileTable	access:private	signature:(const AllocValue& v)
AllocWithArena	src/base/low_level_alloc.cc	/^void *LowLevelAlloc::AllocWithArena(size_t request, Arena *arena) {$/;"	f	class:LowLevelAlloc	signature:(size_t request, Arena *arena)
Allocate	src/debugallocation.cc	/^  static MallocBlock* Allocate(size_t size, int type) {$/;"	f	class:MallocBlock	access:public	signature:(size_t size, int type)
Allocate	src/heap-checker.cc	/^  static void* Allocate(size_t n) {$/;"	f	class:HeapLeakChecker::Allocator	access:public	signature:(size_t n)
Allocate	src/memory_region_map.h	/^    static void *Allocate(size_t n) {$/;"	f	struct:MemoryRegionMap::MyAllocator	access:public	signature:(size_t n)
Allocate	src/tests/heap-profiler_unittest.cc	/^static ATTRIBUTE_NOINLINE void Allocate(int start, int end, int size) {$/;"	f	file:	signature:(int start, int end, int size)
Allocate	src/thread_cache.h	/^  void* Allocate(size_t size, uint32 cl, void *(*oom_handler)(size_t size));$/;"	p	class:tcmalloc::ThreadCache	access:public	signature:(size_t size, uint32 cl, void *(*oom_handler)(size_t size))
Allocate	src/thread_cache.h	/^inline ATTRIBUTE_ALWAYS_INLINE void* ThreadCache::Allocate($/;"	f	class:tcmalloc::ThreadCache	signature:( size_t size, uint32 cl, void *(*oom_handler)(size_t size))
Allocate2	src/tests/heap-profiler_unittest.cc	/^static ATTRIBUTE_NOINLINE void Allocate2(int start, int end, int size) {$/;"	f	file:	signature:(int start, int end, int size)
AllocateAllocate	src/tests/sampling_test.cc	/^extern "C" void* AllocateAllocate() {$/;"	f	signature:()
AllocateObject	src/tests/tcmalloc_unittest.cc	/^  void AllocateObject() {$/;"	f	class:testing::TesterThread	access:public	signature:()
AllocationMap	src/heap-profile-table.h	/^  typedef AddressMap<AllocValue> AllocationMap;$/;"	t	class:HeapProfileTable	access:private
Allocator	src/addressmap-inl.h	/^  typedef void* (*Allocator)(size_t size);$/;"	t	class:AddressMap	access:public
Allocator	src/heap-checker.cc	/^class HeapLeakChecker::Allocator {$/;"	c	class:HeapLeakChecker	file:
Allocator	src/heap-profile-table.h	/^  typedef void* (*Allocator)(size_t size);$/;"	t	class:HeapProfileTable	access:public
AllocatorState	src/tests/tcmalloc_unittest.cc	/^  explicit AllocatorState(int seed) : TestHarness(seed), memalign_fraction_(0) {$/;"	f	class:testing::AllocatorState	access:public	signature:(int seed)
AllocatorState	src/tests/tcmalloc_unittest.cc	/^class AllocatorState : public TestHarness {$/;"	c	namespace:testing	file:	inherits:TestHarness
AndersonDarlingErrFix	src/tests/sampler_test.cc	/^double AndersonDarlingErrFix(int n, double x) {$/;"	f	signature:(int n, double x)
AndersonDarlingInf	src/tests/sampler_test.cc	/^double AndersonDarlingInf(double z) {$/;"	f	signature:(double z)
AndersonDarlingPValue	src/tests/sampler_test.cc	/^double AndersonDarlingPValue(int n, double z) {$/;"	f	signature:(int n, double z)
AndersonDarlingStatistic	src/tests/sampler_test.cc	/^double AndersonDarlingStatistic(int n, double* random_sample) {$/;"	f	signature:(int n, double* random_sample)
AndersonDarlingTest	src/tests/sampler_test.cc	/^double AndersonDarlingTest(int n, double* random_sample) {$/;"	f	signature:(int n, double* random_sample)
AnnotateBarrierDestroy	src/base/dynamic_annotations.c	/^void AnnotateBarrierDestroy(const char *file, int line,$/;"	f	signature:(const char *file, int line, const volatile void *barrier)
AnnotateBarrierDestroy	src/base/dynamic_annotations.h	/^void AnnotateBarrierDestroy(const char *file, int line,$/;"	p	signature:(const char *file, int line, const volatile void *barrier)
AnnotateBarrierInit	src/base/dynamic_annotations.c	/^void AnnotateBarrierInit(const char *file, int line,$/;"	f	signature:(const char *file, int line, const volatile void *barrier, long count, long reinitialization_allowed)
AnnotateBarrierInit	src/base/dynamic_annotations.h	/^void AnnotateBarrierInit(const char *file, int line,$/;"	p	signature:(const char *file, int line, const volatile void *barrier, long count, long reinitialization_allowed)
AnnotateBarrierWaitAfter	src/base/dynamic_annotations.c	/^void AnnotateBarrierWaitAfter(const char *file, int line,$/;"	f	signature:(const char *file, int line, const volatile void *barrier)
AnnotateBarrierWaitAfter	src/base/dynamic_annotations.h	/^void AnnotateBarrierWaitAfter(const char *file, int line,$/;"	p	signature:(const char *file, int line, const volatile void *barrier)
AnnotateBarrierWaitBefore	src/base/dynamic_annotations.c	/^void AnnotateBarrierWaitBefore(const char *file, int line,$/;"	f	signature:(const char *file, int line, const volatile void *barrier)
AnnotateBarrierWaitBefore	src/base/dynamic_annotations.h	/^void AnnotateBarrierWaitBefore(const char *file, int line,$/;"	p	signature:(const char *file, int line, const volatile void *barrier)
AnnotateBenignRace	src/base/dynamic_annotations.c	/^void AnnotateBenignRace(const char *file, int line,$/;"	f	signature:(const char *file, int line, const volatile void *mem, const char *description)
AnnotateBenignRace	src/base/dynamic_annotations.h	/^void AnnotateBenignRace(const char *file, int line,$/;"	p	signature:(const char *file, int line, const volatile void *address, const char *description)
AnnotateBenignRaceSized	src/base/dynamic_annotations.c	/^void AnnotateBenignRaceSized(const char *file, int line,$/;"	f	signature:(const char *file, int line, const volatile void *mem, long size, const char *description)
AnnotateBenignRaceSized	src/base/dynamic_annotations.h	/^void AnnotateBenignRaceSized(const char *file, int line,$/;"	p	signature:(const char *file, int line, const volatile void *address, long size, const char *description)
AnnotateCondVarSignal	src/base/dynamic_annotations.c	/^void AnnotateCondVarSignal(const char *file, int line,$/;"	f	signature:(const char *file, int line, const volatile void *cv)
AnnotateCondVarSignal	src/base/dynamic_annotations.h	/^void AnnotateCondVarSignal(const char *file, int line,$/;"	p	signature:(const char *file, int line, const volatile void *cv)
AnnotateCondVarSignalAll	src/base/dynamic_annotations.c	/^void AnnotateCondVarSignalAll(const char *file, int line,$/;"	f	signature:(const char *file, int line, const volatile void *cv)
AnnotateCondVarSignalAll	src/base/dynamic_annotations.h	/^void AnnotateCondVarSignalAll(const char *file, int line,$/;"	p	signature:(const char *file, int line, const volatile void *cv)
AnnotateCondVarWait	src/base/dynamic_annotations.c	/^void AnnotateCondVarWait(const char *file, int line,$/;"	f	signature:(const char *file, int line, const volatile void *cv, const volatile void *lock)
AnnotateCondVarWait	src/base/dynamic_annotations.h	/^void AnnotateCondVarWait(const char *file, int line,$/;"	p	signature:(const char *file, int line, const volatile void *cv, const volatile void *lock)
AnnotateEnableRaceDetection	src/base/dynamic_annotations.c	/^void AnnotateEnableRaceDetection(const char *file, int line, int enable){}$/;"	f	signature:(const char *file, int line, int enable)
AnnotateEnableRaceDetection	src/base/dynamic_annotations.h	/^void AnnotateEnableRaceDetection(const char *file, int line, int enable);$/;"	p	signature:(const char *file, int line, int enable)
AnnotateExpectRace	src/base/dynamic_annotations.c	/^void AnnotateExpectRace(const char *file, int line,$/;"	f	signature:(const char *file, int line, const volatile void *mem, const char *description)
AnnotateExpectRace	src/base/dynamic_annotations.h	/^void AnnotateExpectRace(const char *file, int line,$/;"	p	signature:(const char *file, int line, const volatile void *address, const char *description)
AnnotateFlushState	src/base/dynamic_annotations.c	/^void AnnotateFlushState(const char *file, int line){}$/;"	f	signature:(const char *file, int line)
AnnotateFlushState	src/base/dynamic_annotations.h	/^void AnnotateFlushState(const char *file, int line);$/;"	p	signature:(const char *file, int line)
AnnotateIgnoreReadsBegin	src/base/dynamic_annotations.c	/^void AnnotateIgnoreReadsBegin(const char *file, int line){}$/;"	f	signature:(const char *file, int line)
AnnotateIgnoreReadsEnd	src/base/dynamic_annotations.c	/^void AnnotateIgnoreReadsEnd(const char *file, int line){}$/;"	f	signature:(const char *file, int line)
AnnotateIgnoreWritesBegin	src/base/dynamic_annotations.c	/^void AnnotateIgnoreWritesBegin(const char *file, int line){}$/;"	f	signature:(const char *file, int line)
AnnotateIgnoreWritesEnd	src/base/dynamic_annotations.c	/^void AnnotateIgnoreWritesEnd(const char *file, int line){}$/;"	f	signature:(const char *file, int line)
AnnotateMutexIsUsedAsCondVar	src/base/dynamic_annotations.c	/^void AnnotateMutexIsUsedAsCondVar(const char *file, int line,$/;"	f	signature:(const char *file, int line, const volatile void *mu)
AnnotateMutexIsUsedAsCondVar	src/base/dynamic_annotations.h	/^void AnnotateMutexIsUsedAsCondVar(const char *file, int line,$/;"	p	signature:(const char *file, int line, const volatile void *mu)
AnnotateNewMemory	src/base/dynamic_annotations.c	/^void AnnotateNewMemory(const char *file, int line,$/;"	f	signature:(const char *file, int line, const volatile void *mem, long size)
AnnotateNewMemory	src/base/dynamic_annotations.h	/^void AnnotateNewMemory(const char *file, int line,$/;"	p	signature:(const char *file, int line, const volatile void *address, long size)
AnnotateNoOp	src/base/dynamic_annotations.c	/^void AnnotateNoOp(const char *file, int line,$/;"	f	signature:(const char *file, int line, const volatile void *arg)
AnnotateNoOp	src/base/dynamic_annotations.h	/^void AnnotateNoOp(const char *file, int line,$/;"	p	signature:(const char *file, int line, const volatile void *arg)
AnnotatePCQCreate	src/base/dynamic_annotations.c	/^void AnnotatePCQCreate(const char *file, int line,$/;"	f	signature:(const char *file, int line, const volatile void *pcq)
AnnotatePCQCreate	src/base/dynamic_annotations.h	/^void AnnotatePCQCreate(const char *file, int line,$/;"	p	signature:(const char *file, int line, const volatile void *pcq)
AnnotatePCQDestroy	src/base/dynamic_annotations.c	/^void AnnotatePCQDestroy(const char *file, int line,$/;"	f	signature:(const char *file, int line, const volatile void *pcq)
AnnotatePCQDestroy	src/base/dynamic_annotations.h	/^void AnnotatePCQDestroy(const char *file, int line,$/;"	p	signature:(const char *file, int line, const volatile void *pcq)
AnnotatePCQGet	src/base/dynamic_annotations.c	/^void AnnotatePCQGet(const char *file, int line,$/;"	f	signature:(const char *file, int line, const volatile void *pcq)
AnnotatePCQGet	src/base/dynamic_annotations.h	/^void AnnotatePCQGet(const char *file, int line,$/;"	p	signature:(const char *file, int line, const volatile void *pcq)
AnnotatePCQPut	src/base/dynamic_annotations.c	/^void AnnotatePCQPut(const char *file, int line,$/;"	f	signature:(const char *file, int line, const volatile void *pcq)
AnnotatePCQPut	src/base/dynamic_annotations.h	/^void AnnotatePCQPut(const char *file, int line,$/;"	p	signature:(const char *file, int line, const volatile void *pcq)
AnnotatePublishMemoryRange	src/base/dynamic_annotations.c	/^void AnnotatePublishMemoryRange(const char *file, int line,$/;"	f	signature:(const char *file, int line, const volatile void *address, long size)
AnnotatePublishMemoryRange	src/base/dynamic_annotations.h	/^void AnnotatePublishMemoryRange(const char *file, int line,$/;"	p	signature:(const char *file, int line, const volatile void *address, long size)
AnnotateRWLockAcquired	src/base/dynamic_annotations.c	/^void AnnotateRWLockAcquired(const char *file, int line,$/;"	f	signature:(const char *file, int line, const volatile void *lock, long is_w)
AnnotateRWLockAcquired	src/base/dynamic_annotations.h	/^void AnnotateRWLockAcquired(const char *file, int line,$/;"	p	signature:(const char *file, int line, const volatile void *lock, long is_w)
AnnotateRWLockCreate	src/base/dynamic_annotations.c	/^void AnnotateRWLockCreate(const char *file, int line,$/;"	f	signature:(const char *file, int line, const volatile void *lock)
AnnotateRWLockCreate	src/base/dynamic_annotations.h	/^void AnnotateRWLockCreate(const char *file, int line,$/;"	p	signature:(const char *file, int line, const volatile void *lock)
AnnotateRWLockDestroy	src/base/dynamic_annotations.c	/^void AnnotateRWLockDestroy(const char *file, int line,$/;"	f	signature:(const char *file, int line, const volatile void *lock)
AnnotateRWLockDestroy	src/base/dynamic_annotations.h	/^void AnnotateRWLockDestroy(const char *file, int line,$/;"	p	signature:(const char *file, int line, const volatile void *lock)
AnnotateRWLockReleased	src/base/dynamic_annotations.c	/^void AnnotateRWLockReleased(const char *file, int line,$/;"	f	signature:(const char *file, int line, const volatile void *lock, long is_w)
AnnotateRWLockReleased	src/base/dynamic_annotations.h	/^void AnnotateRWLockReleased(const char *file, int line,$/;"	p	signature:(const char *file, int line, const volatile void *lock, long is_w)
AnnotateThreadName	src/base/dynamic_annotations.c	/^void AnnotateThreadName(const char *file, int line,$/;"	f	signature:(const char *file, int line, const char *name)
AnnotateThreadName	src/base/dynamic_annotations.h	/^void AnnotateThreadName(const char *file, int line,$/;"	p	signature:(const char *file, int line, const char *name)
AnnotateTraceMemory	src/base/dynamic_annotations.c	/^void AnnotateTraceMemory(const char *file, int line,$/;"	f	signature:(const char *file, int line, const volatile void *arg)
AnnotateTraceMemory	src/base/dynamic_annotations.h	/^void AnnotateTraceMemory(const char *file, int line,$/;"	p	signature:(const char *file, int line, const volatile void *arg)
AnnotateUnpublishMemoryRange	src/base/dynamic_annotations.c	/^void AnnotateUnpublishMemoryRange(const char *file, int line,$/;"	f	signature:(const char *file, int line, const volatile void *address, long size)
AnnotateUnpublishMemoryRange	src/base/dynamic_annotations.h	/^void AnnotateUnpublishMemoryRange(const char *file, int line,$/;"	p	signature:(const char *file, int line, const volatile void *address, long size)
Arena	src/base/low_level_alloc.cc	/^  Arena() : mu(SpinLock::LINKER_INITIALIZED) {} \/\/ does nothing; for static init$/;"	f	struct:LowLevelAlloc::Arena	access:public	signature:()
Arena	src/base/low_level_alloc.cc	/^  explicit Arena(int) : pagesize(0) {}  \/\/ set pagesize to zero explicitly$/;"	f	struct:LowLevelAlloc::Arena	access:public	signature:(int)
Arena	src/base/low_level_alloc.cc	/^struct LowLevelAlloc::Arena {$/;"	s	class:LowLevelAlloc	file:
ArenaInit	src/base/low_level_alloc.cc	/^static void ArenaInit(LowLevelAlloc::Arena *arena) {$/;"	f	file:	signature:(LowLevelAlloc::Arena *arena)
ArenaLock	src/base/low_level_alloc.cc	/^  class SCOPED_LOCKABLE ArenaLock {$/;"	c	namespace:__anon39	file:
Array	src/tests/heap-checker_unittest.cc	/^  Array() {$/;"	f	struct:Array	access:public	signature:()
Array	src/tests/heap-checker_unittest.cc	/^  Array(const Array& x) {$/;"	f	struct:Array	access:public	signature:(const Array& x)
Array	src/tests/heap-checker_unittest.cc	/^struct Array {$/;"	s	file:
Array::Array	src/tests/heap-checker_unittest.cc	/^  Array() {$/;"	f	struct:Array	access:public	signature:()
Array::Array	src/tests/heap-checker_unittest.cc	/^  Array(const Array& x) {$/;"	f	struct:Array	access:public	signature:(const Array& x)
Array::append	src/tests/heap-checker_unittest.cc	/^  void append(const Array& x) {$/;"	f	struct:Array	access:public	signature:(const Array& x)
Array::operator =	src/tests/heap-checker_unittest.cc	/^  void operator=(const Array& x) {$/;"	f	struct:Array	access:public	signature:(const Array& x)
Array::ptr	src/tests/heap-checker_unittest.cc	/^  T* ptr;$/;"	m	struct:Array	file:	access:private
Array::size	src/tests/heap-checker_unittest.cc	/^  size_t size;$/;"	m	struct:Array	file:	access:private
Array::~Array	src/tests/heap-checker_unittest.cc	/^  ~Array() { delete [] ptr; }$/;"	f	struct:Array	access:public	signature:()
ArraySysAllocator	src/tests/system-alloc_unittest.cc	/^  ArraySysAllocator() : SysAllocator() {$/;"	f	class:ArraySysAllocator	access:public	signature:()
ArraySysAllocator	src/tests/system-alloc_unittest.cc	/^class ArraySysAllocator : public SysAllocator {$/;"	c	file:	inherits:SysAllocator
ArraySysAllocator::Alloc	src/tests/system-alloc_unittest.cc	/^  void* Alloc(size_t size, size_t *actual_size, size_t alignment) {$/;"	f	class:ArraySysAllocator	access:public	signature:(size_t size, size_t *actual_size, size_t alignment)
ArraySysAllocator::ArraySysAllocator	src/tests/system-alloc_unittest.cc	/^  ArraySysAllocator() : SysAllocator() {$/;"	f	class:ArraySysAllocator	access:public	signature:()
ArraySysAllocator::DumpStats	src/tests/system-alloc_unittest.cc	/^  void DumpStats() {$/;"	f	class:ArraySysAllocator	access:public	signature:()
ArraySysAllocator::array_	src/tests/system-alloc_unittest.cc	/^  char array_[kArraySize];$/;"	m	class:ArraySysAllocator	file:	access:private
ArraySysAllocator::invoked_	src/tests/system-alloc_unittest.cc	/^  bool invoked_;$/;"	m	class:ArraySysAllocator	file:	access:public
ArraySysAllocator::kArraySize	src/tests/system-alloc_unittest.cc	/^  static const int kArraySize = 8 * 1024 * 1024;$/;"	m	class:ArraySysAllocator	file:	access:private
ArraySysAllocator::kArraySize	src/tests/system-alloc_unittest.cc	/^const int ArraySysAllocator::kArraySize;$/;"	m	class:ArraySysAllocator	file:
ArraySysAllocator::ptr_	src/tests/system-alloc_unittest.cc	/^  int ptr_;$/;"	m	class:ArraySysAllocator	file:	access:private
AsInt	src/heap-checker.cc	/^inline static uintptr_t AsInt(const void* ptr) {$/;"	f	file:	signature:(const void* ptr)
AsPtr	src/heap-checker.cc	/^inline static const void* AsPtr(T addr) {$/;"	f	file:	signature:(T addr)
AssertIsConsistent	src/memory_region_map.h	/^    void AssertIsConsistent() const {$/;"	f	struct:MemoryRegionMap::Region	access:private	signature:() const
AssignAttributeStartEnd	src/base/basictypes.h	/^  AssignAttributeStartEnd(const char* name, char** pstart, char** pend) {$/;"	f	class:AssignAttributeStartEnd	access:public	signature:(const char* name, char** pstart, char** pend)
AssignAttributeStartEnd	src/base/basictypes.h	/^class AssignAttributeStartEnd {$/;"	c
AssignAttributeStartEnd::AssignAttributeStartEnd	src/base/basictypes.h	/^  AssignAttributeStartEnd(const char* name, char** pstart, char** pend) {$/;"	f	class:AssignAttributeStartEnd	access:public	signature:(const char* name, char** pstart, char** pend)
Atomic32	src/base/atomicops-internals-arm-generic.h	/^typedef int32_t Atomic32;$/;"	t
Atomic32	src/base/atomicops-internals-arm-v6plus.h	/^typedef int32_t Atomic32;$/;"	t
Atomic32	src/base/atomicops-internals-gcc.h	/^typedef int32_t Atomic32;$/;"	t
Atomic32	src/base/atomicops-internals-linuxppc.h	/^typedef int32_t Atomic32;$/;"	t
Atomic32	src/base/atomicops-internals-macosx.h	/^typedef int32_t Atomic32;$/;"	t
Atomic32	src/base/atomicops-internals-mips.h	/^typedef int32_t Atomic32;$/;"	t
Atomic32	src/base/atomicops-internals-windows.h	/^typedef int32 Atomic32;$/;"	t
Atomic32	src/base/atomicops-internals-x86.h	/^typedef int32_t Atomic32;$/;"	t
Atomic64	src/base/atomicops-internals-arm-generic.h	/^typedef int64_t Atomic64;$/;"	t	namespace:base::subtle
Atomic64	src/base/atomicops-internals-arm-v6plus.h	/^typedef int64_t Atomic64;$/;"	t	namespace:base::subtle
Atomic64	src/base/atomicops-internals-gcc.h	/^typedef int64_t Atomic64;$/;"	t	namespace:base::subtle
Atomic64	src/base/atomicops-internals-linuxppc.h	/^typedef int64_t Atomic64;$/;"	t	namespace:base::subtle
Atomic64	src/base/atomicops-internals-macosx.h	/^typedef int64_t Atomic64;$/;"	t	namespace:base::subtle
Atomic64	src/base/atomicops-internals-mips.h	/^typedef int64_t Atomic64;$/;"	t	namespace:base::subtle
Atomic64	src/base/atomicops-internals-windows.h	/^typedef int64 Atomic64;$/;"	t	namespace:base::subtle
Atomic64	src/base/atomicops-internals-x86.h	/^typedef int64_t Atomic64;$/;"	t	namespace:base::subtle
AtomicOps_Internalx86CPUFeatures	src/base/atomicops-internals-x86.cc	/^struct AtomicOps_x86CPUFeatureStruct AtomicOps_Internalx86CPUFeatures = {$/;"	v	typeref:struct:AtomicOps_x86CPUFeatureStruct
AtomicOps_Internalx86CPUFeaturesInit	src/base/atomicops-internals-x86.cc	/^static void AtomicOps_Internalx86CPUFeaturesInit() {$/;"	f	file:	signature:()
AtomicOps_x86CPUFeatureStruct	src/base/atomicops-internals-x86.h	/^struct AtomicOps_x86CPUFeatureStruct {$/;"	s
AtomicOps_x86CPUFeatureStruct::has_cmpxchg16b	src/base/atomicops-internals-x86.h	/^  bool has_cmpxchg16b;      \/\/ Processor supports cmpxchg16b instruction.$/;"	m	struct:AtomicOps_x86CPUFeatureStruct	access:public
AtomicOps_x86CPUFeatureStruct::has_sse2	src/base/atomicops-internals-x86.h	/^  bool has_sse2;            \/\/ Processor has SSE2.$/;"	m	struct:AtomicOps_x86CPUFeatureStruct	access:public
AtomicWord	src/base/atomicops.h	/^typedef intptr_t AtomicWord;$/;"	t
AtomicWordCastType	src/base/atomicops-internals-macosx.h	46;"	d
AtomicWordCastType	src/base/atomicops-internals-macosx.h	48;"	d
AutoHookIncrementNumber	src/windows/preamble_patcher_test.cc	/^int __declspec(noinline) AutoHookIncrementNumber(int i) {$/;"	f	namespace:__anon12	signature:(int i)
AutoTestingHook	src/windows/auto_testing_hook.h	/^typedef const AutoTestingHookBase& AutoTestingHook;$/;"	t	namespace:sidestep
AutoTestingHookBase	src/windows/auto_testing_hook.h	/^class AutoTestingHookBase {$/;"	c	namespace:sidestep
AutoTestingHookHolder	src/windows/auto_testing_hook.h	/^  AutoTestingHookHolder() {}  \/\/ disallow$/;"	f	class:sidestep::AutoTestingHookHolder	access:private	signature:()
AutoTestingHookHolder	src/windows/auto_testing_hook.h	/^  explicit AutoTestingHookHolder(AutoTestingHookBase* hook) : hook_(hook) {}$/;"	f	class:sidestep::AutoTestingHookHolder	access:public	signature:(AutoTestingHookBase* hook)
AutoTestingHookHolder	src/windows/auto_testing_hook.h	/^class AutoTestingHookHolder {$/;"	c	namespace:sidestep
AutoTestingHookImpl	src/windows/auto_testing_hook.h	/^  AutoTestingHookImpl(T target_function, T replacement_function, bool do_it)$/;"	f	class:sidestep::AutoTestingHookImpl	access:private	signature:(T target_function, T replacement_function, bool do_it)
AutoTestingHookImpl	src/windows/auto_testing_hook.h	/^class AutoTestingHookImpl : public AutoTestingHookBase {$/;"	c	namespace:sidestep	inherits:AutoTestingHookBase
AutoTestingHookInContainerTest	src/windows/preamble_patcher_test.cc	/^bool AutoTestingHookInContainerTest() {$/;"	f	namespace:sidestep	signature:()
AutoTestingHookTest	src/windows/preamble_patcher_test.cc	/^bool AutoTestingHookTest() {$/;"	f	namespace:sidestep	signature:()
B	src/.libs/libtcmalloc_and_profiler_la-profile-handler.o	/^ELF/;"	v
B	src/.libs/libtcmalloc_internal_la-internal_logging.o	/^/;"	v
B	src/.libs/profile-handler.o	/^ELF/;"	v
B	src/tests/heap-checker_unittest.cc	/^  virtual void B() = 0;$/;"	p	class:InterfaceB	file:	access:public	signature:()
B	src/tests/heap-checker_unittest.cc	/^  virtual void B() { }$/;"	f	class:ClassMltD1	access:public	signature:()
B	src/tests/heap-checker_unittest.cc	/^  virtual void B() { }$/;"	f	class:ClassMltD2	access:public	signature:()
B	src/tests/malloc_hook_test-testutil.o	/^:;/;"	v
B	src/tests/markidle_unittest-testutil.o	/^:;/;"	v
B	src/tests/memalign_debug_unittest-testutil.o	/^:;/;"	v
B	src/tests/memalign_unittest-testutil.o	/^:;/;"	v
B	src/tests/profiler3_unittest-testutil.o	/^:;/;"	v
B	src/tests/profiler4_unittest-testutil.o	/^:;/;"	v
B	src/tests/tcm_min_asserts_unittest-testutil.o	/^:;/;"	v
B	src/tests/tcmalloc_and_profiler_unittest-testutil.o	/^:;/;"	v
B	src/tests/tcmalloc_both_unittest-testutil.o	/^:;/;"	v
B	src/tests/tcmalloc_debug_unittest-testutil.o	/^:;/;"	v
B	src/tests/tcmalloc_minimal_debug_unittest-testutil.o	/^:;/;"	v
B	src/tests/tcmalloc_minimal_unittest-testutil.o	/^:;/;"	v
B	src/tests/tcmalloc_unittest-testutil.o	/^:;/;"	v
B	src/tests/thread_dealloc_unittest-testutil.o	/^:;/;"	v
BACKTRACE_STEPS	src/tests/stacktrace_unittest.cc	/^const int BACKTRACE_STEPS = 6;$/;"	m	namespace:__anon52	file:
BACK_TRACE	src/stacktrace_instrument-inl.h	/^}BACK_TRACE;$/;"	t	typeref:struct:__anon30
BASE_ADDRESSMAP_INL_H_	src/addressmap-inl.h	82;"	d
BASE_ATOMICOPS_HAS_LDREXD_AND_STREXD	src/base/atomicops-internals-arm-v6plus.h	50;"	d
BASE_ATOMICOPS_INTERNALS_ARM_GENERIC_H_	src/base/atomicops-internals-arm-generic.h	39;"	d
BASE_ATOMICOPS_INTERNALS_ARM_V6PLUS_H_	src/base/atomicops-internals-arm-v6plus.h	40;"	d
BASE_ATOMICOPS_INTERNALS_GCC_GENERIC_H_	src/base/atomicops-internals-gcc.h	39;"	d
BASE_ATOMICOPS_INTERNALS_LINUXPPC_H_	src/base/atomicops-internals-linuxppc.h	39;"	d
BASE_ATOMICOPS_INTERNALS_MACOSX_H_	src/base/atomicops-internals-macosx.h	37;"	d
BASE_ATOMICOPS_INTERNALS_MIPS_H_	src/base/atomicops-internals-mips.h	40;"	d
BASE_ATOMICOPS_INTERNALS_WINDOWS_H_	src/base/atomicops-internals-windows.h	40;"	d
BASE_ATOMICOPS_INTERNALS_X86_H_	src/base/atomicops-internals-x86.h	40;"	d
BASE_COMMANDLINEFLAGS_H_	src/base/commandlineflags.h	50;"	d
BASE_DYNAMIC_ANNOTATIONS_H_	src/base/dynamic_annotations.h	58;"	d
BASE_ELF_MEM_IMAGE_H_	src/base/elf_mem_image.h	37;"	d
BASE_GETPC_H_	src/getpc.h	45;"	d
BASE_HAS_ATOMIC64	src/base/atomicops-internals-arm-v6plus.h	168;"	d
BASE_HAS_ATOMIC64	src/base/atomicops-internals-linuxppc.h	44;"	d
BASE_HAS_ATOMIC64	src/base/atomicops-internals-macosx.h	52;"	d
BASE_HAS_ATOMIC64	src/base/atomicops-internals-mips.h	43;"	d
BASE_HAS_ATOMIC64	src/base/atomicops-internals-windows.h	49;"	d
BASE_HAS_ATOMIC64	src/base/atomicops-internals-x86.h	44;"	d
BASE_HEAP_CHECKER_H_	src/gperftools/heap-checker.h	53;"	d
BASE_HEAP_PROFILER_H_	src/gperftools/heap-profiler.h	52;"	d
BASE_HEAP_PROFILE_TABLE_H_	src/heap-profile-table.h	37;"	d
BASE_MALLOC_EXTENSION_H_	src/gperftools/malloc_extension.h	43;"	d
BASE_MEMORY_REGION_MAP_H_	src/memory_region_map.h	36;"	d
BASE_PROFILEDATA_H_	src/profiledata.h	42;"	d
BASE_PROFILER_H_	src/gperftools/profiler.h	61;"	d
BASE_PROFILE_HANDLER_H_	src/profile-handler.h	49;"	d
BASE_RAW_PRINTER_H_	src/raw_printer.h	44;"	d
BASE_SPINLOCK_H_	src/base/spinlock.h	40;"	d
BASE_SPINLOCK_INTERNAL_H_	src/base/spinlock_internal.h	37;"	d
BASE_STACKTRACE_ARM_INL_H_	src/stacktrace_arm-inl.h	37;"	d
BASE_STACKTRACE_GENERIC_INL_H_	src/stacktrace_generic-inl.h	40;"	d
BASE_STACKTRACE_INSTRUMENT_INL_H_	src/stacktrace_instrument-inl.h	46;"	d
BASE_STACKTRACE_LIBGCC_INL_H_	src/stacktrace_libgcc-inl.h	38;"	d
BASE_STACKTRACE_LIBINWIND_INL_H_	src/stacktrace_libunwind-inl.h	37;"	d
BASE_STACKTRACE_POWERPC_INL_H_	src/stacktrace_powerpc-darwin-inl.h	38;"	d
BASE_STACKTRACE_POWERPC_INL_H_	src/stacktrace_powerpc-inl.h	41;"	d
BASE_STACKTRACE_POWERPC_INL_H_	src/stacktrace_powerpc-linux-inl.h	41;"	d
BASE_STACKTRACE_UNW_CONTEXT_IS_UCONTEXT	src/stacktrace_libunwind-inl.h	64;"	d
BASE_STACKTRACE_WIN32_INL_H_	src/stacktrace_win32-inl.h	54;"	d
BASE_STACKTRACE_X86_INL_H_	src/stacktrace_x86-inl.h	37;"	d
BASE_STL_ALLOCATOR_H_	src/base/stl_allocator.h	37;"	d
BASE_THREAD_ANNOTATIONS_H_	src/base/thread_annotations.h	46;"	d
BASE_VDSO_SUPPORT_H_	src/base/vdso_support.h	56;"	d
BIN_SH	binary_trees_shared	/^BIN_SH=xpg4; export BIN_SH # for Tru64$/;"	v
BIN_SH	current_allocated_bytes_test	/^BIN_SH=xpg4; export BIN_SH # for Tru64$/;"	v
BIN_SH	debugallocation_test	/^BIN_SH=xpg4; export BIN_SH # for Tru64$/;"	v
BIN_SH	frag_unittest	/^BIN_SH=xpg4; export BIN_SH # for Tru64$/;"	v
BIN_SH	heap-checker_debug_unittest	/^BIN_SH=xpg4; export BIN_SH # for Tru64$/;"	v
BIN_SH	heap-checker_unittest	/^BIN_SH=xpg4; export BIN_SH # for Tru64$/;"	v
BIN_SH	heap-profiler_debug_unittest	/^BIN_SH=xpg4; export BIN_SH # for Tru64$/;"	v
BIN_SH	heap-profiler_unittest	/^BIN_SH=xpg4; export BIN_SH # for Tru64$/;"	v
BIN_SH	libtool	/^BIN_SH=xpg4; export BIN_SH # for Tru64$/;"	v
BIN_SH	ltmain.sh	/^BIN_SH=xpg4; export BIN_SH # for Tru64$/;"	v
BIN_SH	malloc_bench_shared	/^BIN_SH=xpg4; export BIN_SH # for Tru64$/;"	v
BIN_SH	malloc_bench_shared_full	/^BIN_SH=xpg4; export BIN_SH # for Tru64$/;"	v
BIN_SH	malloc_extension_c_test	/^BIN_SH=xpg4; export BIN_SH # for Tru64$/;"	v
BIN_SH	malloc_extension_debug_test	/^BIN_SH=xpg4; export BIN_SH # for Tru64$/;"	v
BIN_SH	malloc_extension_test	/^BIN_SH=xpg4; export BIN_SH # for Tru64$/;"	v
BIN_SH	malloc_hook_test	/^BIN_SH=xpg4; export BIN_SH # for Tru64$/;"	v
BIN_SH	markidle_unittest	/^BIN_SH=xpg4; export BIN_SH # for Tru64$/;"	v
BIN_SH	memalign_debug_unittest	/^BIN_SH=xpg4; export BIN_SH # for Tru64$/;"	v
BIN_SH	memalign_unittest	/^BIN_SH=xpg4; export BIN_SH # for Tru64$/;"	v
BIN_SH	packed_cache_test	/^BIN_SH=xpg4; export BIN_SH # for Tru64$/;"	v
BIN_SH	page_heap_test	/^BIN_SH=xpg4; export BIN_SH # for Tru64$/;"	v
BIN_SH	pagemap_unittest	/^BIN_SH=xpg4; export BIN_SH # for Tru64$/;"	v
BIN_SH	profile_handler_unittest	/^BIN_SH=xpg4; export BIN_SH # for Tru64$/;"	v
BIN_SH	profiledata_unittest	/^BIN_SH=xpg4; export BIN_SH # for Tru64$/;"	v
BIN_SH	profiler1_unittest	/^BIN_SH=xpg4; export BIN_SH # for Tru64$/;"	v
BIN_SH	profiler2_unittest	/^BIN_SH=xpg4; export BIN_SH # for Tru64$/;"	v
BIN_SH	profiler3_unittest	/^BIN_SH=xpg4; export BIN_SH # for Tru64$/;"	v
BIN_SH	profiler4_unittest	/^BIN_SH=xpg4; export BIN_SH # for Tru64$/;"	v
BIN_SH	raw_printer_test	/^BIN_SH=xpg4; export BIN_SH # for Tru64$/;"	v
BIN_SH	realloc_debug_unittest	/^BIN_SH=xpg4; export BIN_SH # for Tru64$/;"	v
BIN_SH	realloc_unittest	/^BIN_SH=xpg4; export BIN_SH # for Tru64$/;"	v
BIN_SH	sampler_debug_test	/^BIN_SH=xpg4; export BIN_SH # for Tru64$/;"	v
BIN_SH	sampler_test	/^BIN_SH=xpg4; export BIN_SH # for Tru64$/;"	v
BIN_SH	sampling_debug_test	/^BIN_SH=xpg4; export BIN_SH # for Tru64$/;"	v
BIN_SH	sampling_test	/^BIN_SH=xpg4; export BIN_SH # for Tru64$/;"	v
BIN_SH	simple_compat_test	/^BIN_SH=xpg4; export BIN_SH # for Tru64$/;"	v
BIN_SH	stack_trace_table_test	/^BIN_SH=xpg4; export BIN_SH # for Tru64$/;"	v
BIN_SH	system_alloc_unittest	/^BIN_SH=xpg4; export BIN_SH # for Tru64$/;"	v
BIN_SH	tcmalloc_and_profiler_unittest	/^BIN_SH=xpg4; export BIN_SH # for Tru64$/;"	v
BIN_SH	tcmalloc_both_unittest	/^BIN_SH=xpg4; export BIN_SH # for Tru64$/;"	v
BIN_SH	tcmalloc_debug_unittest	/^BIN_SH=xpg4; export BIN_SH # for Tru64$/;"	v
BIN_SH	tcmalloc_large_heap_fragmentation_unittest	/^BIN_SH=xpg4; export BIN_SH # for Tru64$/;"	v
BIN_SH	tcmalloc_large_unittest	/^BIN_SH=xpg4; export BIN_SH # for Tru64$/;"	v
BIN_SH	tcmalloc_minimal_debug_unittest	/^BIN_SH=xpg4; export BIN_SH # for Tru64$/;"	v
BIN_SH	tcmalloc_minimal_large_heap_fragmentation_unittest	/^BIN_SH=xpg4; export BIN_SH # for Tru64$/;"	v
BIN_SH	tcmalloc_minimal_large_unittest	/^BIN_SH=xpg4; export BIN_SH # for Tru64$/;"	v
BIN_SH	tcmalloc_minimal_unittest	/^BIN_SH=xpg4; export BIN_SH # for Tru64$/;"	v
BIN_SH	tcmalloc_unittest	/^BIN_SH=xpg4; export BIN_SH # for Tru64$/;"	v
BIN_SH	thread_dealloc_unittest	/^BIN_SH=xpg4; export BIN_SH # for Tru64$/;"	v
BIN_SH	unwind_bench	/^BIN_SH=xpg4; export BIN_SH # for Tru64$/;"	v
BP	src/base/elfcore.h	70;"	d
BP	src/base/elfcore.h	94;"	d
Be	config.guess	/^    BeBox:BeOS:*:*)	# BeOS running on hardware made by Be, PPC only.$/;"	v
BecomeIdle	src/thread_cache.cc	/^void ThreadCache::BecomeIdle() {$/;"	f	class:tcmalloc::ThreadCache	signature:()
BecomeIdle	src/thread_cache.h	/^  static void         BecomeIdle();$/;"	p	class:tcmalloc::ThreadCache	access:public	signature:()
BecomeTemporarilyIdle	src/thread_cache.cc	/^void ThreadCache::BecomeTemporarilyIdle() {$/;"	f	class:tcmalloc::ThreadCache	signature:()
BecomeTemporarilyIdle	src/thread_cache.h	/^  static void         BecomeTemporarilyIdle();$/;"	p	class:tcmalloc::ThreadCache	access:public	signature:()
BeforeConstructorsLocked	src/gperftools/heap-checker.h	/^  static void BeforeConstructorsLocked();$/;"	p	class:HeapLeakChecker	access:private	signature:()
BeforeConstructorsLocked	src/heap-checker.cc	/^void HeapLeakChecker::BeforeConstructorsLocked() {$/;"	f	class:HeapLeakChecker	signature:()
BeginRegionLocked	src/memory_region_map.cc	/^MemoryRegionMap::RegionIterator MemoryRegionMap::BeginRegionLocked() {$/;"	f	class:MemoryRegionMap	signature:()
BeginRegionLocked	src/memory_region_map.h	/^  static RegionIterator BeginRegionLocked();$/;"	p	class:MemoryRegionMap	access:public	signature:()
BlockDesc	src/tests/low_level_alloc_unittest.cc	/^struct BlockDesc {$/;"	s	file:
BlockDesc::fill	src/tests/low_level_alloc_unittest.cc	/^  int fill;       \/\/ filled with data starting with this$/;"	m	struct:BlockDesc	file:	access:public
BlockDesc::len	src/tests/low_level_alloc_unittest.cc	/^  int len;        \/\/ number of bytes$/;"	m	struct:BlockDesc	file:	access:public
BlockDesc::ptr	src/tests/low_level_alloc_unittest.cc	/^  char *ptr;      \/\/ pointer to memory$/;"	m	struct:BlockDesc	file:	access:public
BlockID	src/addressmap-inl.h	/^  static int BlockID(Number address) {$/;"	f	class:AddressMap	access:private	signature:(Number address)
BriefNoLeaks	src/gperftools/heap-checker.h	/^  bool BriefNoLeaks()  { return NoLeaks(); }$/;"	f	class:HeapLeakChecker	access:public	signature:()
BriefSameHeap	src/gperftools/heap-checker.h	/^  bool BriefSameHeap() { return NoLeaks(); }$/;"	f	class:HeapLeakChecker	access:public	signature:()
Bucket	src/heap-profile-table.h	/^  typedef HeapProfileBucket Bucket;$/;"	t	class:HeapProfileTable	access:private
Bucket	src/profiledata.h	/^  struct Bucket {$/;"	s	class:ProfileData	access:private
Bucket	src/stack_trace_table.h	/^  struct Bucket {$/;"	s	class:tcmalloc::StackTraceTable	access:public
Buffer	src/base/sysinfo.h	/^  struct Buffer {$/;"	s	class:ProcMapsIterator	access:public
BufferArgs	src/heap-profile-table.h	/^    BufferArgs(char* buf_arg, int buflen_arg, int bufsize_arg)$/;"	f	struct:HeapProfileTable::BufferArgs	access:public	signature:(char* buf_arg, int buflen_arg, int bufsize_arg)
BufferArgs	src/heap-profile-table.h	/^  struct BufferArgs {$/;"	s	class:HeapProfileTable	access:private
BusyThread	src/tests/profile-handler_unittest.cc	/^  BusyThread() : stop_work_(false) {$/;"	f	class:__anon56::BusyThread	access:public	signature:()
BusyThread	src/tests/profile-handler_unittest.cc	/^class BusyThread : public Thread {$/;"	c	namespace:__anon56	file:	inherits:Thread
ByAllocatedSpace	src/heap-profile-table.cc	/^static bool ByAllocatedSpace(HeapProfileTable::Stats* a,$/;"	f	file:	signature:(HeapProfileTable::Stats* a, HeapProfileTable::Stats* b)
ByteSizeForClass	src/common.h	/^  inline int32 ATTRIBUTE_ALWAYS_INLINE ByteSizeForClass(uint32 cl) {$/;"	f	class:tcmalloc::SizeMap	access:public	signature:(uint32 cl)
BytesLeaked	src/gperftools/heap-checker.h	/^  ssize_t BytesLeaked() const;$/;"	p	class:HeapLeakChecker	access:public	signature:() const
BytesLeaked	src/heap-checker.cc	/^ssize_t HeapLeakChecker::BytesLeaked() const {$/;"	f	class:HeapLeakChecker	signature:() const
C	src/.libs/libtcmalloc_minimal_internal_la-internal_logging.o	/^/;"	v
C	src/tests/heap-checker_unittest.cc	/^  virtual void C() = 0;$/;"	p	class:InterfaceC	file:	access:public	signature:()
C	src/tests/heap-checker_unittest.cc	/^  virtual void C() { }$/;"	f	class:ClassMltD1	access:public	signature:()
C$	src/.libs/libtcmalloc_and_profiler_la-profile-handler.o	/^/;"	v
C$	src/.libs/profile-handler.o	/^/;"	v
CACHELINE_ALIGNED	src/base/basictypes.h	/^} CACHELINE_ALIGNED;$/;"	v	typeref:union:MemoryAligner
CACHELINE_ALIGNED	src/base/basictypes.h	373;"	d
CACHELINE_ALIGNED	src/base/basictypes.h	375;"	d
CACHELINE_ALIGNED	src/base/basictypes.h	377;"	d
CACHELINE_ALIGNED	src/base/basictypes.h	380;"	d
CACHELINE_ALIGNED	src/base/basictypes.h	382;"	d
CACHELINE_ALIGNED	src/base/basictypes.h	385;"	d
CACHELINE_ALIGNED	src/base/basictypes.h	390;"	d
CACHELINE_ALIGNED	src/thread_cache.cc	/^    ATTR_INITIAL_EXEC CACHELINE_ALIGNED;$/;"	m	namespace:tcmalloc	file:
CACHELINE_ALIGNED	src/thread_cache.h	/^} CACHELINE_ALIGNED;$/;"	m	namespace:tcmalloc	typeref:class:tcmalloc::ThreadCache
CACHELINE_ALIGNED_FN	src/base/basictypes.h	394;"	d
CACHELINE_ALIGNED_FN	src/base/basictypes.h	396;"	d
CALLBACK_COMPLETED	src/heap-checker.cc	/^  CALLBACK_COMPLETED,$/;"	e	enum:__anon4	file:
CALLBACK_NOT_STARTED	src/heap-checker.cc	/^  CALLBACK_NOT_STARTED,$/;"	e	enum:__anon4	file:
CALLBACK_STARTED	src/heap-checker.cc	/^  CALLBACK_STARTED,$/;"	e	enum:__anon4	file:
CALL_FN_W_10W	src/third_party/valgrind.h	1322;"	d
CALL_FN_W_10W	src/third_party/valgrind.h	1765;"	d
CALL_FN_W_10W	src/third_party/valgrind.h	2271;"	d
CALL_FN_W_10W	src/third_party/valgrind.h	2826;"	d
CALL_FN_W_10W	src/third_party/valgrind.h	3387;"	d
CALL_FN_W_10W	src/third_party/valgrind.h	888;"	d
CALL_FN_W_11W	src/third_party/valgrind.h	1362;"	d
CALL_FN_W_11W	src/third_party/valgrind.h	1811;"	d
CALL_FN_W_11W	src/third_party/valgrind.h	2323;"	d
CALL_FN_W_11W	src/third_party/valgrind.h	2880;"	d
CALL_FN_W_11W	src/third_party/valgrind.h	3441;"	d
CALL_FN_W_11W	src/third_party/valgrind.h	926;"	d
CALL_FN_W_12W	src/third_party/valgrind.h	1404;"	d
CALL_FN_W_12W	src/third_party/valgrind.h	1861;"	d
CALL_FN_W_12W	src/third_party/valgrind.h	2379;"	d
CALL_FN_W_12W	src/third_party/valgrind.h	2938;"	d
CALL_FN_W_12W	src/third_party/valgrind.h	3499;"	d
CALL_FN_W_12W	src/third_party/valgrind.h	967;"	d
CALL_FN_W_5W	src/third_party/valgrind.h	1156;"	d
CALL_FN_W_5W	src/third_party/valgrind.h	1597;"	d
CALL_FN_W_5W	src/third_party/valgrind.h	2073;"	d
CALL_FN_W_5W	src/third_party/valgrind.h	2618;"	d
CALL_FN_W_5W	src/third_party/valgrind.h	3179;"	d
CALL_FN_W_5W	src/third_party/valgrind.h	730;"	d
CALL_FN_W_6W	src/third_party/valgrind.h	1184;"	d
CALL_FN_W_6W	src/third_party/valgrind.h	1625;"	d
CALL_FN_W_6W	src/third_party/valgrind.h	2107;"	d
CALL_FN_W_6W	src/third_party/valgrind.h	2654;"	d
CALL_FN_W_6W	src/third_party/valgrind.h	3215;"	d
CALL_FN_W_6W	src/third_party/valgrind.h	757;"	d
CALL_FN_W_7W	src/third_party/valgrind.h	1214;"	d
CALL_FN_W_7W	src/third_party/valgrind.h	1655;"	d
CALL_FN_W_7W	src/third_party/valgrind.h	2143;"	d
CALL_FN_W_7W	src/third_party/valgrind.h	2692;"	d
CALL_FN_W_7W	src/third_party/valgrind.h	3253;"	d
CALL_FN_W_7W	src/third_party/valgrind.h	786;"	d
CALL_FN_W_8W	src/third_party/valgrind.h	1248;"	d
CALL_FN_W_8W	src/third_party/valgrind.h	1688;"	d
CALL_FN_W_8W	src/third_party/valgrind.h	2182;"	d
CALL_FN_W_8W	src/third_party/valgrind.h	2733;"	d
CALL_FN_W_8W	src/third_party/valgrind.h	3294;"	d
CALL_FN_W_8W	src/third_party/valgrind.h	818;"	d
CALL_FN_W_9W	src/third_party/valgrind.h	1284;"	d
CALL_FN_W_9W	src/third_party/valgrind.h	1723;"	d
CALL_FN_W_9W	src/third_party/valgrind.h	2223;"	d
CALL_FN_W_9W	src/third_party/valgrind.h	2776;"	d
CALL_FN_W_9W	src/third_party/valgrind.h	3337;"	d
CALL_FN_W_9W	src/third_party/valgrind.h	852;"	d
CALL_FN_W_W	src/third_party/valgrind.h	1064;"	d
CALL_FN_W_W	src/third_party/valgrind.h	1505;"	d
CALL_FN_W_W	src/third_party/valgrind.h	1957;"	d
CALL_FN_W_W	src/third_party/valgrind.h	2494;"	d
CALL_FN_W_W	src/third_party/valgrind.h	3055;"	d
CALL_FN_W_W	src/third_party/valgrind.h	642;"	d
CALL_FN_W_WW	src/third_party/valgrind.h	1084;"	d
CALL_FN_W_WW	src/third_party/valgrind.h	1525;"	d
CALL_FN_W_WW	src/third_party/valgrind.h	1983;"	d
CALL_FN_W_WW	src/third_party/valgrind.h	2522;"	d
CALL_FN_W_WW	src/third_party/valgrind.h	3083;"	d
CALL_FN_W_WW	src/third_party/valgrind.h	661;"	d
CALL_FN_W_WWW	src/third_party/valgrind.h	1106;"	d
CALL_FN_W_WWW	src/third_party/valgrind.h	1547;"	d
CALL_FN_W_WWW	src/third_party/valgrind.h	2011;"	d
CALL_FN_W_WWW	src/third_party/valgrind.h	2552;"	d
CALL_FN_W_WWW	src/third_party/valgrind.h	3113;"	d
CALL_FN_W_WWW	src/third_party/valgrind.h	682;"	d
CALL_FN_W_WWWW	src/third_party/valgrind.h	1130;"	d
CALL_FN_W_WWWW	src/third_party/valgrind.h	1571;"	d
CALL_FN_W_WWWW	src/third_party/valgrind.h	2041;"	d
CALL_FN_W_WWWW	src/third_party/valgrind.h	2584;"	d
CALL_FN_W_WWWW	src/third_party/valgrind.h	3145;"	d
CALL_FN_W_WWWW	src/third_party/valgrind.h	705;"	d
CALL_FN_W_v	src/third_party/valgrind.h	1046;"	d
CALL_FN_W_v	src/third_party/valgrind.h	1487;"	d
CALL_FN_W_v	src/third_party/valgrind.h	1933;"	d
CALL_FN_W_v	src/third_party/valgrind.h	2468;"	d
CALL_FN_W_v	src/third_party/valgrind.h	3029;"	d
CALL_FN_W_v	src/third_party/valgrind.h	626;"	d
CALL_FN_v_W	src/third_party/valgrind.h	603;"	d
CALL_FN_v_WW	src/third_party/valgrind.h	607;"	d
CALL_FN_v_WWW	src/third_party/valgrind.h	611;"	d
CALL_FN_v_v	src/third_party/valgrind.h	599;"	d
CANT_OPEN_PROC_MAPS	src/gperftools/heap-checker.h	/^    CANT_OPEN_PROC_MAPS,$/;"	e	enum:HeapLeakChecker::ProcMapsResult
CC_FOR_BUILD	config.guess	/^	     CC_FOR_BUILD="$c"; break ;$/;"	v
CC_FOR_BUILD	config.guess	/^	  CC_FOR_BUILD=no_compiler_found ;$/;"	v
CEEE_TESTING_SIDESTEP_AUTO_TESTING_HOOK_H_	src/windows/auto_testing_hook.h	33;"	d
CFI_ADJUST_CFA_OFFSET	src/base/linux_syscall_support.h	1045;"	d
CFI_ADJUST_CFA_OFFSET	src/base/linux_syscall_support.h	1048;"	d
CFLAGS	configure.ac	/^CFLAGS='-g3 -O0'$/;"	v
CFLAGS	m4/libtool.m4	/^    CFLAGS="$SAVE_CFLAGS"$/;"	v
CHECK	src/base/logging.h	84;"	d
CHECK_CONDITION	src/internal_logging.h	109;"	d
CHECK_CONDITION	src/internal_logging.h	110;"	d
CHECK_EQ	src/base/logging.h	143;"	d
CHECK_ERR	src/base/logging.h	172;"	d
CHECK_GE	src/base/logging.h	147;"	d
CHECK_GT	src/base/logging.h	148;"	d
CHECK_LE	src/base/logging.h	145;"	d
CHECK_LT	src/base/logging.h	146;"	d
CHECK_NE	src/base/logging.h	144;"	d
CHECK_OP	src/base/logging.h	135;"	d
CLANG_VERSION	src/base/atomicops.h	105;"	d
CLONE_STACK_SIZE	src/base/linuxthreads.cc	103;"	d	file:
CLONE_STACK_SIZE	src/base/linuxthreads.cc	105;"	d	file:
CLONE_UNTRACED	src/base/linuxthreads.cc	56;"	d	file:
COLLECT_NAMES	m4/libtool.m4	/^    COLLECT_NAMES=$/;"	v
COLLECT_NAMES	m4/libtool.m4	/^  COLLECT_NAMES=$/;"	v
COMPILE_ASSERT	src/base/basictypes.h	209;"	d
CONTRACT	COPYING	/^THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT$/;"	v
CONTRACT	packages/deb/copyright	/^THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT$/;"	v
CONTRACT	src/windows/shortproc.asm	/^; THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT$/;"	v
CONTRIBUTORS	src/windows/shortproc.asm	/^; THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS$/;"	v
CPP_BADALLOC	src/libc_override.h	63;"	d
CPP_BADALLOC	src/libc_override.h	66;"	d
CPP_NOTHROW	src/libc_override.h	62;"	d
CPP_NOTHROW	src/libc_override.h	65;"	d
CPU	config.guess	919;"	d	file:
CPUPROFILE	README	/^There are other environment variables, besides CPUPROFILE, you can set$/;"	v
CPUPROFILE	docs/cpuprofile.html	/^       <pre>% env CPUPROFILE=chrome.prof CPUPROFILESIGNAL=12 \/bin\/chrome &<\/pre>$/;"	v
CPUPROFILE	docs/cpuprofile.html	/^       <pre>% env CPUPROFILE=ls.prof \/bin\/ls<\/pre>$/;"	v
C_SHIM	src/malloc_extension.cc	354;"	d	file:
C_TRY_EVAL	m4/libtool.m4	/^  if AC_TRY_EVAL(ac_compile); then$/;"	p	file:	signature:(ac_compile)
C_TRY_EVAL	tags	/^C_TRY_EVAL	m4\/libtool.m4	\/^  if AC_TRY_EVAL(ac_compile); then$\/;"	p	file:	signature:(ac_compile)$/;"	p	file:	signature:(ac_compile)
CallNearRelativeFunction	src/windows/preamble_patcher_test.cc	/^extern "C" int CallNearRelativeFunction(int);$/;"	p	namespace:__anon12	file:	signature:(int)
CallUnrollInfo	src/getpc.h	/^struct CallUnrollInfo {$/;"	s
CallUnrollInfo::ins	src/getpc.h	/^  unsigned char ins[16];$/;"	m	struct:CallUnrollInfo	access:public
CallUnrollInfo::ins_size	src/getpc.h	/^  int ins_size;$/;"	m	struct:CallUnrollInfo	access:public
CallUnrollInfo::pc_offset	src/getpc.h	/^  int pc_offset;$/;"	m	struct:CallUnrollInfo	access:public
CallUnrollInfo::return_sp_offset	src/getpc.h	/^  int return_sp_offset;$/;"	m	struct:CallUnrollInfo	access:public
Callback0	src/tests/heap-checker_unittest.cc	/^  inline Callback0(FunctionSignature f) : f_(f) {}$/;"	f	class:Callback0	access:public	signature:(FunctionSignature f)
Callback0	src/tests/heap-checker_unittest.cc	/^class Callback0 : public Closure {$/;"	c	file:	inherits:Closure
Callback0::Callback0	src/tests/heap-checker_unittest.cc	/^  inline Callback0(FunctionSignature f) : f_(f) {}$/;"	f	class:Callback0	access:public	signature:(FunctionSignature f)
Callback0::FunctionSignature	src/tests/heap-checker_unittest.cc	/^  typedef void (*FunctionSignature)();$/;"	t	class:Callback0	file:	access:public
Callback0::Run	src/tests/heap-checker_unittest.cc	/^  virtual void Run() { (*f_)(); delete this; }$/;"	f	class:Callback0	access:public	signature:()
Callback0::f_	src/tests/heap-checker_unittest.cc	/^  FunctionSignature f_;$/;"	m	class:Callback0	file:	access:private
Callback1	src/tests/heap-checker_unittest.cc	/^  inline Callback1<P1>(FunctionSignature f, P1 p1) : f_(f), p1_(p1) {}$/;"	f	class:Callback1	access:public	signature:(FunctionSignature f, P1 p1)
Callback1	src/tests/heap-checker_unittest.cc	/^template <class P1> class Callback1 : public Closure {$/;"	c	file:	inherits:Closure
Callback1::Callback1	src/tests/heap-checker_unittest.cc	/^  inline Callback1<P1>(FunctionSignature f, P1 p1) : f_(f), p1_(p1) {}$/;"	f	class:Callback1	access:public	signature:(FunctionSignature f, P1 p1)
Callback1::FunctionSignature	src/tests/heap-checker_unittest.cc	/^  typedef void (*FunctionSignature)(P1);$/;"	t	class:Callback1	file:	access:public
Callback1::Run	src/tests/heap-checker_unittest.cc	/^  virtual void Run() { (*f_)(p1_); delete this; }$/;"	f	class:Callback1	access:public	signature:()
Callback1::f_	src/tests/heap-checker_unittest.cc	/^  FunctionSignature f_;$/;"	m	class:Callback1	file:	access:private
Callback1::p1_	src/tests/heap-checker_unittest.cc	/^  P1 p1_;$/;"	m	class:Callback1	file:	access:private
Callback2	src/tests/heap-checker_unittest.cc	/^  inline Callback2<P1,P2>(FunctionSignature f, P1 p1, P2 p2) : f_(f), p1_(p1), p2_(p2) {}$/;"	f	class:Callback2	access:public	signature:(FunctionSignature f, P1 p1, P2 p2)
Callback2	src/tests/heap-checker_unittest.cc	/^template <class P1, class P2> class Callback2 : public Closure {$/;"	c	file:	inherits:Closure
Callback2::Callback2	src/tests/heap-checker_unittest.cc	/^  inline Callback2<P1,P2>(FunctionSignature f, P1 p1, P2 p2) : f_(f), p1_(p1), p2_(p2) {}$/;"	f	class:Callback2	access:public	signature:(FunctionSignature f, P1 p1, P2 p2)
Callback2::FunctionSignature	src/tests/heap-checker_unittest.cc	/^  typedef void (*FunctionSignature)(P1,P2);$/;"	t	class:Callback2	file:	access:public
Callback2::Run	src/tests/heap-checker_unittest.cc	/^  virtual void Run() { (*f_)(p1_, p2_); delete this; }$/;"	f	class:Callback2	access:public	signature:()
Callback2::f_	src/tests/heap-checker_unittest.cc	/^  FunctionSignature f_;$/;"	m	class:Callback2	file:	access:private
Callback2::p1_	src/tests/heap-checker_unittest.cc	/^  P1 p1_;$/;"	m	class:Callback2	file:	access:private
Callback2::p2_	src/tests/heap-checker_unittest.cc	/^  P2 p2_;$/;"	m	class:Callback2	file:	access:private
CallbackIterator	src/profile-handler.cc	/^  typedef CallbackList::iterator CallbackIterator;$/;"	t	class:ProfileHandler	file:	access:private
CallbackList	src/profile-handler.cc	/^  typedef list<ProfileHandlerToken*> CallbackList;$/;"	t	class:ProfileHandler	file:	access:private
CancelGlobalCheck	src/gperftools/heap-checker.h	/^  static void CancelGlobalCheck();$/;"	p	class:HeapLeakChecker	access:public	signature:()
CancelGlobalCheck	src/heap-checker.cc	/^void HeapLeakChecker::CancelGlobalCheck() {$/;"	f	class:HeapLeakChecker	signature:()
Carve	src/page_heap.cc	/^Span* PageHeap::Carve(Span* span, Length n) {$/;"	f	class:tcmalloc::PageHeap	signature:(Span* span, Length n)
Carve	src/page_heap.h	/^  Span* Carve(Span* span, Length n);$/;"	p	class:tcmalloc::PageHeap	access:private	signature:(Span* span, Length n)
CentralCacheLockAll	src/libc_override_osx.h	/^  void CentralCacheLockAll();$/;"	p	namespace:tcmalloc	signature:()
CentralCacheLockAll	src/static_vars.cc	/^void CentralCacheLockAll()$/;"	f	namespace:tcmalloc	signature:()
CentralCacheUnlockAll	src/libc_override_osx.h	/^  void CentralCacheUnlockAll();$/;"	p	namespace:tcmalloc	signature:()
CentralCacheUnlockAll	src/static_vars.cc	/^void CentralCacheUnlockAll()$/;"	f	namespace:tcmalloc	signature:()
CentralFreeList	src/central_freelist.h	/^  CentralFreeList() : lock_(base::LINKER_INITIALIZED) { }$/;"	f	class:tcmalloc::CentralFreeList	access:public	signature:()
CentralFreeList	src/central_freelist.h	/^class CentralFreeList {$/;"	c	namespace:tcmalloc
CentralFreeListPadded	src/central_freelist.h	/^class CentralFreeListPadded : public CentralFreeListPaddedTo<$/;"	c	namespace:tcmalloc	inherits:CentralFreeListPaddedTo
CentralFreeListPaddedTo	src/central_freelist.h	/^class CentralFreeListPaddedTo : public CentralFreeList {$/;"	c	namespace:tcmalloc	inherits:CentralFreeList
CentralFreeListPaddedTo	src/central_freelist.h	/^class CentralFreeListPaddedTo<0> : public CentralFreeList {$/;"	c	namespace:tcmalloc	inherits:CentralFreeList
Check	src/debugallocation.cc	/^  void Check(int type) const {$/;"	f	class:MallocBlock	access:public	signature:(int type) const
Check	src/page_heap.cc	/^bool PageHeap::Check() {$/;"	f	class:tcmalloc::PageHeap	signature:()
Check	src/page_heap.h	/^  bool Check();$/;"	p	class:tcmalloc::PageHeap	access:public	signature:()
Check	src/tests/profiledata_unittest.cc	/^  string Check(const ProfileDataSlot* slots, int num_slots) {$/;"	f	class:__anon53::ProfileDataChecker	access:public	signature:(const ProfileDataSlot* slots, int num_slots)
CheckAddressBits	src/system-alloc.cc	/^template <> bool CheckAddressBits<8 * sizeof(void*)>(uintptr_t ptr) {$/;"	f	namespace:__anon32	signature:(uintptr_t ptr)
CheckAddressBits	src/system-alloc.cc	/^template <int ADDRESS_BITS> bool CheckAddressBits(uintptr_t ptr) {$/;"	f	namespace:__anon32	signature:(uintptr_t ptr)
CheckAlignment	src/tests/memalign_unittest.cc	/^static void CheckAlignment(void* p, int align) {$/;"	f	file:	signature:(void* p, int align)
CheckAndClear	src/debugallocation.cc	/^  size_t CheckAndClear(int type, size_t given_size) {$/;"	f	class:MallocBlock	file:	access:private	signature:(int type, size_t given_size)
CheckAndHandlePreMerge	src/page_heap.cc	/^Span* PageHeap::CheckAndHandlePreMerge(Span* span, Span* other) {$/;"	f	class:tcmalloc::PageHeap	signature:(Span* span, Span* other)
CheckAndHandlePreMerge	src/page_heap.h	/^  Span* CheckAndHandlePreMerge(Span *span, Span *other);$/;"	p	class:tcmalloc::PageHeap	access:private	signature:(Span *span, Span *other)
CheckBlockDesc	src/tests/low_level_alloc_unittest.cc	/^static void CheckBlockDesc(const BlockDesc &d) {$/;"	f	file:	signature:(const BlockDesc &d)
CheckCachedSizeClass	src/tcmalloc.cc	/^static inline bool CheckCachedSizeClass(void *ptr) {$/;"	f	file:	signature:(void *ptr)
CheckCallback	src/debugallocation.cc	/^  static void CheckCallback(const void* ptr, int* type, int dummy) {$/;"	f	class:MallocBlock	file:	access:private	signature:(const void* ptr, int* type, int dummy)
CheckContents	src/tests/tcmalloc_unittest.cc	/^  void CheckContents(const Object& object) {$/;"	f	class:testing::TesterThread	access:public	signature:(const Object& object)
CheckEverything	src/debugallocation.cc	/^  static bool CheckEverything() {$/;"	f	class:MallocBlock	access:public	signature:()
CheckExpensive	src/page_heap.cc	/^bool PageHeap::CheckExpensive() {$/;"	f	class:tcmalloc::PageHeap	signature:()
CheckExpensive	src/page_heap.h	/^  bool CheckExpensive();$/;"	p	class:tcmalloc::PageHeap	access:public	signature:()
CheckForCorruptedBuffer	src/debugallocation.cc	/^  static void CheckForCorruptedBuffer(const MallocBlockQueueEntry& queue_entry,$/;"	f	class:MallocBlock	access:public	signature:(const MallocBlockQueueEntry& queue_entry, size_t buffer_idx, const unsigned char* buffer, size_t size_of_buffer)
CheckForDanglingWrites	src/debugallocation.cc	/^  static void CheckForDanglingWrites(const MallocBlockQueueEntry& queue_entry) {$/;"	f	class:MallocBlock	access:public	signature:(const MallocBlockQueueEntry& queue_entry)
CheckInHookCaller	src/malloc_hook.cc	/^static inline void CheckInHookCaller() {$/;"	f	file:	signature:()
CheckList	src/page_heap.cc	/^bool PageHeap::CheckList(Span* list, Length min_pages, Length max_pages,$/;"	f	class:tcmalloc::PageHeap	signature:(Span* list, Length min_pages, Length max_pages, int freelist)
CheckList	src/page_heap.h	/^  bool CheckList(Span* list, Length min_pages, Length max_pages,$/;"	p	class:tcmalloc::PageHeap	access:public	signature:(Span* list, Length min_pages, Length max_pages, int freelist)
CheckLocked	src/debugallocation.cc	/^  void CheckLocked(int type) const {$/;"	f	class:MallocBlock	file:	access:private	signature:(int type) const
CheckMean	src/tests/sampler_test.cc	/^bool CheckMean(size_t mean, int num_samples) {$/;"	f	signature:(size_t mean, int num_samples)
CheckRangeCallback	src/tests/tcmalloc_unittest.cc	/^static void CheckRangeCallback(void* ptr, base::MallocRange::Type type,$/;"	f	namespace:testing::__anon59	signature:(void* ptr, base::MallocRange::Type type, size_t min_size)
CheckRetAddrIsInFunction	src/tests/stacktrace_unittest.cc	/^void CheckRetAddrIsInFunction(void *ret_addr, const AddressRange &range)$/;"	f	namespace:__anon52	signature:(void *ret_addr, const AddressRange &range)
CheckStackTrace	src/tests/stacktrace_unittest.cc	/^void ATTRIBUTE_NOINLINE CheckStackTrace(int i) {$/;"	f	namespace:__anon52	signature:(int i)
CheckStackTrace	src/tests/stacktrace_unittest.cc	/^void ATTRIBUTE_NOINLINE CheckStackTrace(int);$/;"	p	namespace:__anon52	file:	signature:(int)
CheckStackTrace1	src/tests/stacktrace_unittest.cc	/^void ATTRIBUTE_NOINLINE CheckStackTrace1(int i) {$/;"	f	namespace:__anon52	signature:(int i)
CheckStackTrace2	src/tests/stacktrace_unittest.cc	/^void ATTRIBUTE_NOINLINE CheckStackTrace2(int i) {$/;"	f	namespace:__anon52	signature:(int i)
CheckStackTrace3	src/tests/stacktrace_unittest.cc	/^void ATTRIBUTE_NOINLINE CheckStackTrace3(int i) {$/;"	f	namespace:__anon52	signature:(int i)
CheckStackTrace4	src/tests/stacktrace_unittest.cc	/^void ATTRIBUTE_NOINLINE CheckStackTrace4(int i) {$/;"	f	namespace:__anon52	signature:(int i)
CheckStackTraceLeaf	src/tests/stacktrace_unittest.cc	/^void ATTRIBUTE_NOINLINE CheckStackTraceLeaf(void) {$/;"	f	namespace:__anon52	signature:(void)
CheckStats	src/tests/page_heap_test.cc	/^static void CheckStats(const tcmalloc::PageHeap* ph,$/;"	f	namespace:__anon55	signature:(const tcmalloc::PageHeap* ph, uint64_t system_pages, uint64_t free_pages, uint64_t unmapped_pages)
CheckTracesAndReset	src/tests/stack_trace_table_test.cc	/^static void CheckTracesAndReset(tcmalloc::StackTraceTable* table,$/;"	f	file:	signature:(tcmalloc::StackTraceTable* table, const uintptr_t* expected, int len)
CheckType	src/tests/heap-checker_unittest.cc	/^enum CheckType { SAME_HEAP, NO_LEAKS };$/;"	g	file:
CheckWithSkips	src/tests/profiledata_unittest.cc	/^  string CheckWithSkips(const ProfileDataSlot* slots, int num_slots,$/;"	p	class:__anon53::ProfileDataChecker	file:	access:public	signature:(const ProfileDataSlot* slots, int num_slots, const int* skips, int num_skips)
CheckWithSkips	src/tests/profiledata_unittest.cc	/^string ProfileDataChecker::CheckWithSkips(const ProfileDataSlot* slots,$/;"	f	class:__anon53::ProfileDataChecker	signature:(const ProfileDataSlot* slots, int num_slots, const int* skips, int num_skips)
CheckedMallocResult	src/tcmalloc.cc	/^static inline ATTRIBUTE_ALWAYS_INLINE void* CheckedMallocResult(void *result) {$/;"	f	file:	signature:(void *result)
ClassA	src/tests/heap-checker_unittest.cc	/^  explicit ClassA(int a) : ptr(NULL) { }$/;"	f	class:ClassA	access:public	signature:(int a)
ClassA	src/tests/heap-checker_unittest.cc	/^class ClassA {$/;"	c	file:
ClassA::ClassA	src/tests/heap-checker_unittest.cc	/^  explicit ClassA(int a) : ptr(NULL) { }$/;"	f	class:ClassA	access:public	signature:(int a)
ClassA::ptr	src/tests/heap-checker_unittest.cc	/^  mutable char* ptr;$/;"	m	class:ClassA	file:	access:public
ClassB	src/tests/heap-checker_unittest.cc	/^  ClassB() { }$/;"	f	class:ClassB	access:public	signature:()
ClassB	src/tests/heap-checker_unittest.cc	/^class ClassB {$/;"	c	file:
ClassB2	src/tests/heap-checker_unittest.cc	/^  ClassB2() { }$/;"	f	class:ClassB2	access:public	signature:()
ClassB2	src/tests/heap-checker_unittest.cc	/^class ClassB2 {$/;"	c	file:
ClassB2::ClassB2	src/tests/heap-checker_unittest.cc	/^  ClassB2() { }$/;"	f	class:ClassB2	access:public	signature:()
ClassB2::b2	src/tests/heap-checker_unittest.cc	/^  char b2[11];$/;"	m	class:ClassB2	file:	access:public
ClassB2::f2	src/tests/heap-checker_unittest.cc	/^  virtual void f2() { }$/;"	f	class:ClassB2	access:public	signature:()
ClassB2::~ClassB2	src/tests/heap-checker_unittest.cc	/^  virtual ~ClassB2() { }$/;"	f	class:ClassB2	access:public	signature:()
ClassB::ClassB	src/tests/heap-checker_unittest.cc	/^  ClassB() { }$/;"	f	class:ClassB	access:public	signature:()
ClassB::b	src/tests/heap-checker_unittest.cc	/^  char b[7];$/;"	m	class:ClassB	file:	access:public
ClassB::f	src/tests/heap-checker_unittest.cc	/^  virtual void f() { }$/;"	f	class:ClassB	access:public	signature:()
ClassB::~ClassB	src/tests/heap-checker_unittest.cc	/^  virtual ~ClassB() { }$/;"	f	class:ClassB	access:public	signature:()
ClassD	src/tests/heap-checker_unittest.cc	/^class ClassD : public ClassD1, public ClassD2 {$/;"	c	file:	inherits:ClassD1,ClassD2
ClassD1	src/tests/heap-checker_unittest.cc	/^class ClassD1 : public ClassB {$/;"	c	file:	inherits:ClassB
ClassD1::d1	src/tests/heap-checker_unittest.cc	/^  char d1[15];$/;"	m	class:ClassD1	file:	access:private
ClassD1::f	src/tests/heap-checker_unittest.cc	/^  virtual void f() { }$/;"	f	class:ClassD1	file:	access:private	signature:()
ClassD2	src/tests/heap-checker_unittest.cc	/^class ClassD2 : public ClassB2 {$/;"	c	file:	inherits:ClassB2
ClassD2::d2	src/tests/heap-checker_unittest.cc	/^  char d2[19];$/;"	m	class:ClassD2	file:	access:private
ClassD2::f2	src/tests/heap-checker_unittest.cc	/^  virtual void f2() { }$/;"	f	class:ClassD2	file:	access:private	signature:()
ClassD::d	src/tests/heap-checker_unittest.cc	/^  char d[3];$/;"	m	class:ClassD	file:	access:private
ClassD::f	src/tests/heap-checker_unittest.cc	/^  virtual void f() { }$/;"	f	class:ClassD	file:	access:private	signature:()
ClassD::f2	src/tests/heap-checker_unittest.cc	/^  virtual void f2() { }$/;"	f	class:ClassD	file:	access:private	signature:()
ClassIndex	src/common.h	/^  static inline size_t ClassIndex(size_t s) {$/;"	f	class:tcmalloc::SizeMap	access:private	signature:(size_t s)
ClassIndexMaybe	src/common.h	/^  static inline bool ATTRIBUTE_ALWAYS_INLINE ClassIndexMaybe(size_t s,$/;"	f	class:tcmalloc::SizeMap	access:private	signature:(size_t s, uint32* idx)
ClassMltD1	src/tests/heap-checker_unittest.cc	/^class ClassMltD1 : public ClassB, public InterfaceB, public InterfaceC {$/;"	c	file:	inherits:ClassB,InterfaceB,InterfaceC
ClassMltD1::A	src/tests/heap-checker_unittest.cc	/^  virtual void A() { }$/;"	f	class:ClassMltD1	access:public	signature:()
ClassMltD1::B	src/tests/heap-checker_unittest.cc	/^  virtual void B() { }$/;"	f	class:ClassMltD1	access:public	signature:()
ClassMltD1::C	src/tests/heap-checker_unittest.cc	/^  virtual void C() { }$/;"	f	class:ClassMltD1	access:public	signature:()
ClassMltD1::d1	src/tests/heap-checker_unittest.cc	/^  char d1[11];$/;"	m	class:ClassMltD1	file:	access:public
ClassMltD1::f	src/tests/heap-checker_unittest.cc	/^  virtual void f() { }$/;"	f	class:ClassMltD1	access:public	signature:()
ClassMltD2	src/tests/heap-checker_unittest.cc	/^class ClassMltD2 : public InterfaceA, public InterfaceB, public ClassB {$/;"	c	file:	inherits:InterfaceA,InterfaceB,ClassB
ClassMltD2::A	src/tests/heap-checker_unittest.cc	/^  virtual void A() { }$/;"	f	class:ClassMltD2	access:public	signature:()
ClassMltD2::B	src/tests/heap-checker_unittest.cc	/^  virtual void B() { }$/;"	f	class:ClassMltD2	access:public	signature:()
ClassMltD2::d2	src/tests/heap-checker_unittest.cc	/^  char d2[15];$/;"	m	class:ClassMltD2	file:	access:public
ClassMltD2::f	src/tests/heap-checker_unittest.cc	/^  virtual void f() { }$/;"	f	class:ClassMltD2	access:public	signature:()
Cleanup	src/tests/sampler_test.cc	/^  void Cleanup() {}$/;"	f	class:OldSampler	access:public	signature:()
Cleanup	src/thread_cache.cc	/^void ThreadCache::Cleanup() {$/;"	f	class:tcmalloc::ThreadCache	signature:()
Cleanup	src/thread_cache.h	/^  void Cleanup();$/;"	p	class:tcmalloc::ThreadCache	access:public	signature:()
CleanupOldProfiles	src/heap-profile-table.cc	/^void HeapProfileTable::CleanupOldProfiles(const char* prefix) {$/;"	f	class:HeapProfileTable	signature:(const char* prefix)
CleanupOldProfiles	src/heap-profile-table.h	/^  static void CleanupOldProfiles(const char* prefix);$/;"	p	class:HeapProfileTable	access:public	signature:(const char* prefix)
Clear	src/packed-cache-inl.h	/^  void Clear() {$/;"	f	class:PackedCache	access:public	signature:()
Closure	src/tests/heap-checker_unittest.cc	/^class Closure {$/;"	c	file:
Closure::Run	src/tests/heap-checker_unittest.cc	/^  virtual void Run() = 0;$/;"	p	class:Closure	file:	access:public	signature:()
Closure::~Closure	src/tests/heap-checker_unittest.cc	/^  virtual ~Closure() { }$/;"	f	class:Closure	access:public	signature:()
Cluster	src/addressmap-inl.h	/^  struct Cluster {$/;"	s	class:AddressMap	access:private
Coalesce	src/base/low_level_alloc.cc	/^static void Coalesce(AllocList *a) {$/;"	f	file:	signature:(AllocList *a)
CollectOne	src/tests/profiledata_unittest.cc	/^  void CollectOne();$/;"	p	class:__anon53::ProfileDataTest	file:	access:private	signature:()
CollectTwoFlush	src/tests/profiledata_unittest.cc	/^  void CollectTwoFlush();$/;"	p	class:__anon53::ProfileDataTest	file:	access:private	signature:()
CollectTwoMatching	src/tests/profiledata_unittest.cc	/^  void CollectTwoMatching();$/;"	p	class:__anon53::ProfileDataTest	file:	access:private	signature:()
CommitSpan	src/page_heap.cc	/^void PageHeap::CommitSpan(Span* span) {$/;"	f	class:tcmalloc::PageHeap	signature:(Span* span)
CommitSpan	src/page_heap.h	/^  void CommitSpan(Span* span);$/;"	p	class:tcmalloc::PageHeap	access:private	signature:(Span* span)
CompileAssert	src/base/basictypes.h	/^struct CompileAssert {$/;"	s
ConstructFilename	src/base/sysinfo.cc	/^static void ConstructFilename(const char* spec, pid_t pid,$/;"	f	file:	signature:(const char* spec, pid_t pid, char* buf, int buf_size)
CopyFrom	src/windows/patch_functions.cc	/^  void CopyFrom(const LibcInfo& that) {$/;"	f	class:__anon13::LibcInfo	access:protected	signature:(const LibcInfo& that)
CopyStringUntilChar	src/base/sysinfo.cc	/^static char *CopyStringUntilChar($/;"	f	file:	signature:( char *text, unsigned out_len, int c, char *out)
Count	src/malloc_extension.cc	/^uintptr_t Count(void** entry) {$/;"	f	namespace:__anon21	signature:(void** entry)
CountPushInstructions	src/stacktrace_x86-inl.h	/^static int CountPushInstructions(const unsigned char *const addr) {$/;"	f	signature:(const unsigned char *const addr)
CpuProfiler	src/profiler.cc	/^  CpuProfiler();$/;"	p	class:CpuProfiler	file:	access:public	signature:()
CpuProfiler	src/profiler.cc	/^CpuProfiler::CpuProfiler()$/;"	f	class:CpuProfiler	signature:()
CpuProfiler	src/profiler.cc	/^class CpuProfiler {$/;"	c	file:
CpuProfiler::CpuProfiler	src/profiler.cc	/^  CpuProfiler();$/;"	p	class:CpuProfiler	file:	access:public	signature:()
CpuProfiler::CpuProfiler	src/profiler.cc	/^CpuProfiler::CpuProfiler()$/;"	f	class:CpuProfiler	signature:()
CpuProfiler::DisableHandler	src/profiler.cc	/^  void DisableHandler();$/;"	p	class:CpuProfiler	file:	access:private	signature:()
CpuProfiler::DisableHandler	src/profiler.cc	/^void CpuProfiler::DisableHandler() {$/;"	f	class:CpuProfiler	signature:()
CpuProfiler::EnableHandler	src/profiler.cc	/^  void EnableHandler();$/;"	p	class:CpuProfiler	file:	access:private	signature:()
CpuProfiler::EnableHandler	src/profiler.cc	/^void CpuProfiler::EnableHandler() {$/;"	f	class:CpuProfiler	signature:()
CpuProfiler::Enabled	src/profiler.cc	/^  bool Enabled();$/;"	p	class:CpuProfiler	file:	access:public	signature:()
CpuProfiler::Enabled	src/profiler.cc	/^bool CpuProfiler::Enabled() {$/;"	f	class:CpuProfiler	signature:()
CpuProfiler::FlushTable	src/profiler.cc	/^  void FlushTable();$/;"	p	class:CpuProfiler	file:	access:public	signature:()
CpuProfiler::FlushTable	src/profiler.cc	/^void CpuProfiler::FlushTable() {$/;"	f	class:CpuProfiler	signature:()
CpuProfiler::GetCurrentState	src/profiler.cc	/^  void GetCurrentState(ProfilerState* state);$/;"	p	class:CpuProfiler	file:	access:public	signature:(ProfilerState* state)
CpuProfiler::GetCurrentState	src/profiler.cc	/^void CpuProfiler::GetCurrentState(ProfilerState* state) {$/;"	f	class:CpuProfiler	signature:(ProfilerState* state)
CpuProfiler::Start	src/profiler.cc	/^  bool Start(const char* fname, const ProfilerOptions* options);$/;"	p	class:CpuProfiler	file:	access:public	signature:(const char* fname, const ProfilerOptions* options)
CpuProfiler::Start	src/profiler.cc	/^bool CpuProfiler::Start(const char* fname, const ProfilerOptions* options) {$/;"	f	class:CpuProfiler	signature:(const char* fname, const ProfilerOptions* options)
CpuProfiler::Stop	src/profiler.cc	/^  void Stop();$/;"	p	class:CpuProfiler	file:	access:public	signature:()
CpuProfiler::Stop	src/profiler.cc	/^void CpuProfiler::Stop() {$/;"	f	class:CpuProfiler	signature:()
CpuProfiler::collector_	src/profiler.cc	/^  ProfileData   collector_;$/;"	m	class:CpuProfiler	file:	access:private
CpuProfiler::filter_	src/profiler.cc	/^  int           (*filter_)(void*);$/;"	m	class:CpuProfiler	file:	access:private
CpuProfiler::filter_arg_	src/profiler.cc	/^  void*         filter_arg_;$/;"	m	class:CpuProfiler	file:	access:private
CpuProfiler::instance_	src/profiler.cc	/^  static CpuProfiler instance_;$/;"	m	class:CpuProfiler	file:	access:public
CpuProfiler::instance_	src/profiler.cc	/^CpuProfiler CpuProfiler::instance_;$/;"	m	class:CpuProfiler	file:
CpuProfiler::lock_	src/profiler.cc	/^  SpinLock      lock_;$/;"	m	class:CpuProfiler	file:	access:private
CpuProfiler::prof_handler	src/profiler.cc	/^  static void prof_handler(int sig, siginfo_t*, void* signal_ucontext,$/;"	p	class:CpuProfiler	file:	access:private	signature:(int sig, siginfo_t*, void* signal_ucontext, void* cpu_profiler)
CpuProfiler::prof_handler	src/profiler.cc	/^void CpuProfiler::prof_handler(int sig, siginfo_t*, void* signal_ucontext,$/;"	f	class:CpuProfiler	signature:(int sig, siginfo_t*, void* signal_ucontext, void* cpu_profiler)
CpuProfiler::prof_handler_token_	src/profiler.cc	/^  ProfileHandlerToken* prof_handler_token_;$/;"	m	class:CpuProfiler	file:	access:private
CpuProfiler::~CpuProfiler	src/profiler.cc	/^  ~CpuProfiler();$/;"	p	class:CpuProfiler	file:	access:public	signature:()
CpuProfiler::~CpuProfiler	src/profiler.cc	/^CpuProfiler::~CpuProfiler() {$/;"	f	class:CpuProfiler	signature:()
CpuProfilerSwitch	src/profiler.cc	/^static void CpuProfilerSwitch(int signal_number)$/;"	f	file:	signature:(int signal_number)
Create	src/gperftools/heap-checker.h	/^  void Create(const char *name, bool make_start_snapshot);$/;"	p	class:HeapLeakChecker	access:private	signature:(const char *name, bool make_start_snapshot)
Create	src/heap-checker.cc	/^void HeapLeakChecker::Create(const char *name, bool make_start_snapshot) {$/;"	f	class:HeapLeakChecker	signature:(const char *name, bool make_start_snapshot)
Create	src/memory_region_map.h	/^    void Create(const void* start, size_t size) {$/;"	f	struct:MemoryRegionMap::Region	access:private	signature:(const void* start, size_t size)
CreateCacheIfNecessary	src/thread_cache.cc	/^ThreadCache* ThreadCache::CreateCacheIfNecessary() {$/;"	f	class:tcmalloc::ThreadCache	signature:()
CreateCacheIfNecessary	src/thread_cache.h	/^  static ThreadCache* CreateCacheIfNecessary();$/;"	p	class:tcmalloc::ThreadCache	access:public	signature:()
CreateThreadTimerKey	src/profile-handler.cc	/^static void CreateThreadTimerKey(pthread_key_t *pkey) {$/;"	f	file:	signature:(pthread_key_t *pkey)
CurrentElfClass	src/base/elf_mem_image.cc	/^typedef ElfClass<__WORDSIZE> CurrentElfClass;$/;"	t	namespace:base::__anon50	file:
CurrentLine	src/base/sysinfo.h	/^  const char *CurrentLine() const { return stext_; }$/;"	f	class:ProcMapsIterator	access:public	signature:() const
CurrentlyAllocatedBytes	src/tests/debugallocation_test.cc	/^static size_t CurrentlyAllocatedBytes() {$/;"	f	file:	signature:()
Cwd	src/pprof	/^use Cwd;$/;"	v
D	benchmark/unwind_bench-getcontext_light.o	/^/;"	v
D	docs/tcmalloc-opspercpusec.vs.threads.8192.bytes.png	/^Ü[I7¿_!(P%´¶\\&"A§?ÎÂÈ/;"	v
D	src/.libs/maybe_threads.o	/^/;"	v
DCHECK_EQ	src/base/logging.h	176;"	d
DCHECK_EQ	src/base/logging.h	183;"	d
DCHECK_GE	src/base/logging.h	180;"	d
DCHECK_GE	src/base/logging.h	187;"	d
DCHECK_GT	src/base/logging.h	181;"	d
DCHECK_GT	src/base/logging.h	188;"	d
DCHECK_LE	src/base/logging.h	178;"	d
DCHECK_LE	src/base/logging.h	185;"	d
DCHECK_LT	src/base/logging.h	179;"	d
DCHECK_LT	src/base/logging.h	186;"	d
DCHECK_NE	src/base/logging.h	177;"	d
DCHECK_NE	src/base/logging.h	184;"	d
DEBUGALLOCATION_TEST	debugallocation_test.sh	/^DEBUGALLOCATION_TEST="${1:-$BINDIR\/debugallocation_test}"$/;"	v
DEBUGALLOCATION_TEST	src/tests/debugallocation_test.sh	/^DEBUGALLOCATION_TEST="${1:-$BINDIR\/debugallocation_test}"$/;"	v
DEBUG_MODE	src/base/logging.h	/^enum { DEBUG_MODE = 0 };$/;"	e	enum:__anon46
DEBUG_MODE	src/base/logging.h	/^enum { DEBUG_MODE = 1 };$/;"	e	enum:__anon47
DECLARE_ADDRESS_LABEL	src/tests/stacktrace_unittest.cc	71;"	d	file:
DECLARE_ADDRESS_LABEL	src/tests/stacktrace_unittest.cc	95;"	d	file:
DECLARE_ATTRIBUTE_SECTION_VARS	src/base/basictypes.h	289;"	d
DECLARE_ATTRIBUTE_SECTION_VARS	src/base/basictypes.h	344;"	d
DECLARE_ATTRIBUTE_SECTION_VARS	src/base/basictypes.h	363;"	d
DECLARE_VARIABLE	src/base/commandlineflags.h	58;"	d
DECLARE_bool	src/base/commandlineflags.h	72;"	d
DECLARE_double	src/base/commandlineflags.h	95;"	d
DECLARE_int32	src/base/commandlineflags.h	78;"	d
DECLARE_int64	src/base/commandlineflags.h	84;"	d
DECLARE_string	src/base/commandlineflags.h	102;"	d
DECLARE_uint64	src/base/commandlineflags.h	89;"	d
DEFINE_ATTRIBUTE_SECTION_VARS	src/base/basictypes.h	293;"	d
DEFINE_ATTRIBUTE_SECTION_VARS	src/base/basictypes.h	353;"	d
DEFINE_ATTRIBUTE_SECTION_VARS	src/base/basictypes.h	365;"	d
DEFINE_VARIABLE	src/base/commandlineflags.h	64;"	d
DEFINE_bool	src/base/commandlineflags.h	74;"	d
DEFINE_double	src/base/commandlineflags.h	97;"	d
DEFINE_int32	src/base/commandlineflags.h	80;"	d
DEFINE_int64	src/base/commandlineflags.h	86;"	d
DEFINE_string	src/base/commandlineflags.h	107;"	d
DEFINE_uint64	src/base/commandlineflags.h	91;"	d
DIRECT	src/windows/shortproc.asm	/^; OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,$/;"	v
DISABLE_LIBRARY_ALLOCS	src/gperftools/heap-checker.h	/^    DISABLE_LIBRARY_ALLOCS$/;"	e	enum:HeapLeakChecker::ProcMapsTask
DISALLOW_COPY_AND_ASSIGN	src/base/basictypes.h	135;"	d
DISALLOW_COPY_AND_ASSIGN	src/base/low_level_alloc.cc	/^    DISALLOW_COPY_AND_ASSIGN(ArenaLock);$/;"	p	class:__anon39::ArenaLock	file:	access:private	signature:(ArenaLock)
DISALLOW_COPY_AND_ASSIGN	src/base/spinlock.h	/^  DISALLOW_COPY_AND_ASSIGN(SpinLock);$/;"	p	class:SpinLock	access:private	signature:(SpinLock)
DISALLOW_COPY_AND_ASSIGN	src/base/vdso_support.h	/^  DISALLOW_COPY_AND_ASSIGN(VDSOSupport);$/;"	p	class:base::VDSOSupport	access:private	signature:(VDSOSupport)
DISALLOW_COPY_AND_ASSIGN	src/heap-profile-table.h	/^    DISALLOW_COPY_AND_ASSIGN(BufferArgs);$/;"	p	struct:HeapProfileTable::BufferArgs	access:public	signature:(BufferArgs)
DISALLOW_COPY_AND_ASSIGN	src/heap-profile-table.h	/^  DISALLOW_COPY_AND_ASSIGN(HeapProfileTable);$/;"	p	class:HeapProfileTable	access:private	signature:(HeapProfileTable)
DISALLOW_COPY_AND_ASSIGN	src/heap-profile-table.h	/^  DISALLOW_COPY_AND_ASSIGN(Snapshot);$/;"	p	class:HeapProfileTable::Snapshot	access:private	signature:(Snapshot)
DISALLOW_COPY_AND_ASSIGN	src/memory_region_map.h	/^    DISALLOW_COPY_AND_ASSIGN(LockHolder);$/;"	p	class:MemoryRegionMap::LockHolder	access:private	signature:(LockHolder)
DISALLOW_COPY_AND_ASSIGN	src/memory_region_map.h	/^  DISALLOW_COPY_AND_ASSIGN(MemoryRegionMap);$/;"	p	class:MemoryRegionMap	access:private	signature:(MemoryRegionMap)
DISALLOW_COPY_AND_ASSIGN	src/profile-handler.cc	/^  DISALLOW_COPY_AND_ASSIGN(ProfileHandler);$/;"	p	class:ProfileHandler	file:	access:private	signature:(ProfileHandler)
DISALLOW_COPY_AND_ASSIGN	src/profiledata.h	/^  DISALLOW_COPY_AND_ASSIGN(ProfileData);$/;"	p	class:ProfileData	access:private	signature:(ProfileData)
DISALLOW_COPY_AND_ASSIGN	src/raw_printer.h	/^  DISALLOW_COPY_AND_ASSIGN(RawPrinter);$/;"	p	class:base::RawPrinter	access:private	signature:(RawPrinter)
DISALLOW_EVIL_CONSTRUCTORS	src/base/basictypes.h	130;"	d
DLL_Init	src/span.cc	/^void DLL_Init(Span* list) {$/;"	f	namespace:tcmalloc	signature:(Span* list)
DLL_Init	src/span.h	/^void DLL_Init(Span* list);$/;"	p	namespace:tcmalloc	signature:(Span* list)
DLL_IsEmpty	src/span.h	/^inline bool DLL_IsEmpty(const Span* list) {$/;"	f	namespace:tcmalloc	signature:(const Span* list)
DLL_Length	src/span.cc	/^int DLL_Length(const Span* list) {$/;"	f	namespace:tcmalloc	signature:(const Span* list)
DLL_Length	src/span.h	/^int DLL_Length(const Span* list);$/;"	p	namespace:tcmalloc	signature:(const Span* list)
DLL_Prepend	src/span.cc	/^void DLL_Prepend(Span* list, Span* span) {$/;"	f	namespace:tcmalloc	signature:(Span* list, Span* span)
DLL_Prepend	src/span.h	/^void DLL_Prepend(Span* list, Span* span);$/;"	p	namespace:tcmalloc	signature:(Span* list, Span* span)
DLL_Remove	src/span.cc	/^void DLL_Remove(Span* span) {$/;"	f	namespace:tcmalloc	signature:(Span* span)
DLL_Remove	src/span.h	/^void DLL_Remove(Span* span);$/;"	p	namespace:tcmalloc	signature:(Span* span)
DOT	src/pprof	/^my @DOT = ("dot");          # leave non-absolute, since it may be in \/usr\/local$/;"	v
DO_NOT_SYMBOLIZE	src/gperftools/heap-checker.h	/^  enum ShouldSymbolize { SYMBOLIZE, DO_NOT_SYMBOLIZE };$/;"	e	enum:HeapLeakChecker::ShouldSymbolize
DTSL	src/tests/heap-checker_unittest.cc	1506;"	d	file:
DTSL	src/tests/heap-checker_unittest.cc	1519;"	d	file:
DUALCASE	binary_trees_shared	/^DUALCASE=1; export DUALCASE # for MKS sh$/;"	v
DUALCASE	current_allocated_bytes_test	/^DUALCASE=1; export DUALCASE # for MKS sh$/;"	v
DUALCASE	debugallocation_test	/^DUALCASE=1; export DUALCASE # for MKS sh$/;"	v
DUALCASE	frag_unittest	/^DUALCASE=1; export DUALCASE # for MKS sh$/;"	v
DUALCASE	heap-checker_debug_unittest	/^DUALCASE=1; export DUALCASE # for MKS sh$/;"	v
DUALCASE	heap-checker_unittest	/^DUALCASE=1; export DUALCASE # for MKS sh$/;"	v
DUALCASE	heap-profiler_debug_unittest	/^DUALCASE=1; export DUALCASE # for MKS sh$/;"	v
DUALCASE	heap-profiler_unittest	/^DUALCASE=1; export DUALCASE # for MKS sh$/;"	v
DUALCASE	libtool	/^DUALCASE=1; export DUALCASE # for MKS sh$/;"	v
DUALCASE	ltmain.sh	/^DUALCASE=1; export DUALCASE # for MKS sh$/;"	v
DUALCASE	malloc_bench_shared	/^DUALCASE=1; export DUALCASE # for MKS sh$/;"	v
DUALCASE	malloc_bench_shared_full	/^DUALCASE=1; export DUALCASE # for MKS sh$/;"	v
DUALCASE	malloc_extension_c_test	/^DUALCASE=1; export DUALCASE # for MKS sh$/;"	v
DUALCASE	malloc_extension_debug_test	/^DUALCASE=1; export DUALCASE # for MKS sh$/;"	v
DUALCASE	malloc_extension_test	/^DUALCASE=1; export DUALCASE # for MKS sh$/;"	v
DUALCASE	malloc_hook_test	/^DUALCASE=1; export DUALCASE # for MKS sh$/;"	v
DUALCASE	markidle_unittest	/^DUALCASE=1; export DUALCASE # for MKS sh$/;"	v
DUALCASE	memalign_debug_unittest	/^DUALCASE=1; export DUALCASE # for MKS sh$/;"	v
DUALCASE	memalign_unittest	/^DUALCASE=1; export DUALCASE # for MKS sh$/;"	v
DUALCASE	packed_cache_test	/^DUALCASE=1; export DUALCASE # for MKS sh$/;"	v
DUALCASE	page_heap_test	/^DUALCASE=1; export DUALCASE # for MKS sh$/;"	v
DUALCASE	pagemap_unittest	/^DUALCASE=1; export DUALCASE # for MKS sh$/;"	v
DUALCASE	profile_handler_unittest	/^DUALCASE=1; export DUALCASE # for MKS sh$/;"	v
DUALCASE	profiledata_unittest	/^DUALCASE=1; export DUALCASE # for MKS sh$/;"	v
DUALCASE	profiler1_unittest	/^DUALCASE=1; export DUALCASE # for MKS sh$/;"	v
DUALCASE	profiler2_unittest	/^DUALCASE=1; export DUALCASE # for MKS sh$/;"	v
DUALCASE	profiler3_unittest	/^DUALCASE=1; export DUALCASE # for MKS sh$/;"	v
DUALCASE	profiler4_unittest	/^DUALCASE=1; export DUALCASE # for MKS sh$/;"	v
DUALCASE	raw_printer_test	/^DUALCASE=1; export DUALCASE # for MKS sh$/;"	v
DUALCASE	realloc_debug_unittest	/^DUALCASE=1; export DUALCASE # for MKS sh$/;"	v
DUALCASE	realloc_unittest	/^DUALCASE=1; export DUALCASE # for MKS sh$/;"	v
DUALCASE	sampler_debug_test	/^DUALCASE=1; export DUALCASE # for MKS sh$/;"	v
DUALCASE	sampler_test	/^DUALCASE=1; export DUALCASE # for MKS sh$/;"	v
DUALCASE	sampling_debug_test	/^DUALCASE=1; export DUALCASE # for MKS sh$/;"	v
DUALCASE	sampling_test	/^DUALCASE=1; export DUALCASE # for MKS sh$/;"	v
DUALCASE	simple_compat_test	/^DUALCASE=1; export DUALCASE # for MKS sh$/;"	v
DUALCASE	stack_trace_table_test	/^DUALCASE=1; export DUALCASE # for MKS sh$/;"	v
DUALCASE	system_alloc_unittest	/^DUALCASE=1; export DUALCASE # for MKS sh$/;"	v
DUALCASE	tcmalloc_and_profiler_unittest	/^DUALCASE=1; export DUALCASE # for MKS sh$/;"	v
DUALCASE	tcmalloc_both_unittest	/^DUALCASE=1; export DUALCASE # for MKS sh$/;"	v
DUALCASE	tcmalloc_debug_unittest	/^DUALCASE=1; export DUALCASE # for MKS sh$/;"	v
DUALCASE	tcmalloc_large_heap_fragmentation_unittest	/^DUALCASE=1; export DUALCASE # for MKS sh$/;"	v
DUALCASE	tcmalloc_large_unittest	/^DUALCASE=1; export DUALCASE # for MKS sh$/;"	v
DUALCASE	tcmalloc_minimal_debug_unittest	/^DUALCASE=1; export DUALCASE # for MKS sh$/;"	v
DUALCASE	tcmalloc_minimal_large_heap_fragmentation_unittest	/^DUALCASE=1; export DUALCASE # for MKS sh$/;"	v
DUALCASE	tcmalloc_minimal_large_unittest	/^DUALCASE=1; export DUALCASE # for MKS sh$/;"	v
DUALCASE	tcmalloc_minimal_unittest	/^DUALCASE=1; export DUALCASE # for MKS sh$/;"	v
DUALCASE	tcmalloc_unittest	/^DUALCASE=1; export DUALCASE # for MKS sh$/;"	v
DUALCASE	thread_dealloc_unittest	/^DUALCASE=1; export DUALCASE # for MKS sh$/;"	v
DUALCASE	unwind_bench	/^DUALCASE=1; export DUALCASE # for MKS sh$/;"	v
DUMPER	src/base/elfcore.h	56;"	d
DYNAMIC_ANNOTATIONS_ENABLED	src/base/dynamic_annotations.h	61;"	d
DYNAMIC_ANNOTATIONS_EXTERNAL_IMPL	src/base/dynamic_annotations.c	59;"	d	file:
DanglingWriteChecker	src/debugallocation.cc	/^void DanglingWriteChecker() {$/;"	f	signature:()
DeAllocHidden	src/tests/heap-checker_unittest.cc	/^static void DeAllocHidden(void** ptr) {$/;"	f	file:	signature:(void** ptr)
DeAllocator	src/addressmap-inl.h	/^  typedef void  (*DeAllocator)(void* ptr);$/;"	t	class:AddressMap	access:public
DeAllocator	src/heap-profile-table.h	/^  typedef void  (*DeAllocator)(void* ptr);$/;"	t	class:HeapProfileTable	access:public
DeallocName	src/debugallocation.cc	/^  static const char* DeallocName(int type) {$/;"	f	class:MallocBlock	file:	access:private	signature:(int type)
Deallocate	src/debugallocation.cc	/^  void Deallocate(int type, size_t given_size) {$/;"	f	class:MallocBlock	access:public	signature:(int type, size_t given_size)
Deallocate	src/tests/heap-profiler_unittest.cc	/^static void Deallocate(int start, int end) {$/;"	f	file:	signature:(int start, int end)
Deallocate	src/thread_cache.h	/^  void Deallocate(void* ptr, uint32 size_class);$/;"	p	class:tcmalloc::ThreadCache	access:public	signature:(void* ptr, uint32 size_class)
Deallocate	src/thread_cache.h	/^inline ATTRIBUTE_ALWAYS_INLINE void ThreadCache::Deallocate(void* ptr, uint32 cl) {$/;"	f	class:tcmalloc::ThreadCache	signature:(void* ptr, uint32 cl)
DebugAllocate	src/debugallocation.cc	/^static inline void* DebugAllocate(size_t size, int type) {$/;"	f	file:	signature:(size_t size, int type)
DebugDeallocate	src/debugallocation.cc	/^static inline void DebugDeallocate(void* ptr, int type, size_t given_size) {$/;"	f	file:	signature:(void* ptr, int type, size_t given_size)
DebugMallocImplementation	src/debugallocation.cc	/^class DebugMallocImplementation : public TCMallocImplementation {$/;"	c	file:	inherits:TCMallocImplementation
DebugMallocImplementation::GetAllocatedSize	src/debugallocation.cc	/^  virtual size_t GetAllocatedSize(const void* p) {$/;"	f	class:DebugMallocImplementation	access:public	signature:(const void* p)
DebugMallocImplementation::GetEstimatedAllocatedSize	src/debugallocation.cc	/^  virtual size_t GetEstimatedAllocatedSize(size_t size) {$/;"	f	class:DebugMallocImplementation	access:public	signature:(size_t size)
DebugMallocImplementation::GetFreeListSizes	src/debugallocation.cc	/^  virtual void GetFreeListSizes(vector<MallocExtension::FreeListInfo>* v) {$/;"	f	class:DebugMallocImplementation	access:public	signature:(vector<MallocExtension::FreeListInfo>* v)
DebugMallocImplementation::GetNumericProperty	src/debugallocation.cc	/^  virtual bool GetNumericProperty(const char* name, size_t* value) {$/;"	f	class:DebugMallocImplementation	access:public	signature:(const char* name, size_t* value)
DebugMallocImplementation::GetOwnership	src/debugallocation.cc	/^  virtual MallocExtension::Ownership GetOwnership(const void* p) {$/;"	f	class:DebugMallocImplementation	access:public	signature:(const void* p)
DebugMallocImplementation::MallocMemoryStats	src/debugallocation.cc	/^  virtual bool MallocMemoryStats(int* blocks, size_t* total,$/;"	f	class:DebugMallocImplementation	access:public	signature:(int* blocks, size_t* total, int histogram[kMallocHistogramSize])
DebugMallocImplementation::VerifyAllMemory	src/debugallocation.cc	/^  virtual bool VerifyAllMemory() {$/;"	f	class:DebugMallocImplementation	access:public	signature:()
DebugMallocImplementation::VerifyArrayNewMemory	src/debugallocation.cc	/^  virtual bool VerifyArrayNewMemory(const void* p) {$/;"	f	class:DebugMallocImplementation	access:public	signature:(const void* p)
DebugMallocImplementation::VerifyMallocMemory	src/debugallocation.cc	/^  virtual bool VerifyMallocMemory(const void* p) {$/;"	f	class:DebugMallocImplementation	access:public	signature:(const void* p)
DebugMallocImplementation::VerifyNewMemory	src/debugallocation.cc	/^  virtual bool VerifyNewMemory(const void* p) {$/;"	f	class:DebugMallocImplementation	access:public	signature:(const void* p)
DecommitSpan	src/page_heap.cc	/^bool PageHeap::DecommitSpan(Span* span) {$/;"	f	class:tcmalloc::PageHeap	signature:(Span* span)
DecommitSpan	src/page_heap.h	/^  bool DecommitSpan(Span* span);$/;"	p	class:tcmalloc::PageHeap	access:private	signature:(Span* span)
DefaultArena	src/base/low_level_alloc.cc	/^LowLevelAlloc::Arena *LowLevelAlloc::DefaultArena() {$/;"	f	class:LowLevelAlloc	signature:()
DefaultArena	src/base/low_level_alloc.h	/^  static Arena *DefaultArena();$/;"	p	class:LowLevelAlloc	access:public	signature:()
DefaultPagesAllocator	src/base/low_level_alloc.cc	/^  class DefaultPagesAllocator : public LowLevelAlloc::PagesAllocator {$/;"	c	namespace:__anon38	file:	inherits:LowLevelAlloc::PagesAllocator
DefaultPagesAllocator::MapPages	src/base/low_level_alloc.cc	/^void *DefaultPagesAllocator::MapPages(int32 flags, size_t size) {$/;"	f	class:DefaultPagesAllocator	signature:(int32 flags, size_t size)
DefaultPagesAllocator::UnMapPages	src/base/low_level_alloc.cc	/^void DefaultPagesAllocator::UnMapPages(int32 flags, void *region, size_t size) {$/;"	f	class:DefaultPagesAllocator	signature:(int32 flags, void *region, size_t size)
DefaultSysAllocator	src/system-alloc.cc	/^  DefaultSysAllocator() : SysAllocator() {$/;"	f	class:DefaultSysAllocator	access:public	signature:()
DefaultSysAllocator	src/system-alloc.cc	/^class DefaultSysAllocator : public SysAllocator {$/;"	c	file:	inherits:SysAllocator
DefaultSysAllocator::Alloc	src/system-alloc.cc	/^  void* Alloc(size_t size, size_t *actual_size, size_t alignment);$/;"	p	class:DefaultSysAllocator	file:	access:public	signature:(size_t size, size_t *actual_size, size_t alignment)
DefaultSysAllocator::Alloc	src/system-alloc.cc	/^void* DefaultSysAllocator::Alloc(size_t size, size_t *actual_size,$/;"	f	class:DefaultSysAllocator	signature:(size_t size, size_t *actual_size, size_t alignment)
DefaultSysAllocator::DefaultSysAllocator	src/system-alloc.cc	/^  DefaultSysAllocator() : SysAllocator() {$/;"	f	class:DefaultSysAllocator	access:public	signature:()
DefaultSysAllocator::SetChildAllocator	src/system-alloc.cc	/^  void SetChildAllocator(SysAllocator* alloc, unsigned int index,$/;"	f	class:DefaultSysAllocator	access:public	signature:(SysAllocator* alloc, unsigned int index, const char* name)
DefaultSysAllocator::allocs_	src/system-alloc.cc	/^  SysAllocator* allocs_[kMaxAllocators];$/;"	m	class:DefaultSysAllocator	file:	access:private
DefaultSysAllocator::failed_	src/system-alloc.cc	/^  bool failed_[kMaxAllocators];$/;"	m	class:DefaultSysAllocator	file:	access:private
DefaultSysAllocator::kMaxAllocators	src/system-alloc.cc	/^  static const int kMaxAllocators = 2;$/;"	m	class:DefaultSysAllocator	file:	access:private
DefaultSysAllocator::names_	src/system-alloc.cc	/^  const char* names_[kMaxAllocators];$/;"	m	class:DefaultSysAllocator	file:	access:private
Delay	src/tests/profile-handler_unittest.cc	/^void Delay(int delay_ns) {$/;"	f	namespace:__anon56	signature:(int delay_ns)
Delete	src/page_heap.cc	/^void PageHeap::Delete(Span* span) {$/;"	f	class:tcmalloc::PageHeap	signature:(Span* span)
Delete	src/page_heap.h	/^  void Delete(Span* span);$/;"	p	class:tcmalloc::PageHeap	access:public	signature:(Span* span)
Delete	src/page_heap_allocator.h	/^  void Delete(T* p) {$/;"	f	class:tcmalloc::PageHeapAllocator	access:public	signature:(T* p)
DeleteAndNull	src/heap-checker.cc	/^  template<typename T> static void DeleteAndNull(T** p) {$/;"	f	class:HeapLeakChecker::Allocator	access:public	signature:(T** p)
DeleteAndNullIfNot	src/heap-checker.cc	/^  template<typename T> static void DeleteAndNullIfNot(T** p) {$/;"	f	class:HeapLeakChecker::Allocator	access:public	signature:(T** p)
DeleteArena	src/base/low_level_alloc.cc	/^bool LowLevelAlloc::DeleteArena(Arena *arena) {$/;"	f	class:LowLevelAlloc	signature:(Arena *arena)
DeleteArena	src/base/low_level_alloc.h	/^  static bool DeleteArena(Arena *arena);$/;"	p	class:LowLevelAlloc	access:public	signature:(Arena *arena)
DeleteCache	src/thread_cache.cc	/^void ThreadCache::DeleteCache(ThreadCache* heap) {$/;"	f	class:tcmalloc::ThreadCache	signature:(ThreadCache* heap)
DeleteCache	src/thread_cache.h	/^  static void DeleteCache(ThreadCache* heap);$/;"	p	class:tcmalloc::ThreadCache	access:private	signature:(ThreadCache* heap)
DeleteHeap	src/tests/tcmalloc_unittest.cc	/^  void DeleteHeap() {$/;"	f	class:testing::TesterThread	access:public	signature:()
DeleteHook	src/gperftools/malloc_hook.h	/^  typedef MallocHook_DeleteHook DeleteHook;$/;"	t	class:MallocHook	access:public
DeleteHook	src/heap-checker.cc	/^static void DeleteHook(const void* ptr) {$/;"	f	file:	signature:(const void* ptr)
DeleteHook	src/heap-profiler.cc	/^static void DeleteHook(const void* ptr);$/;"	p	file:	signature:(const void* ptr)
DeleteHook	src/heap-profiler.cc	/^void DeleteHook(const void* ptr) {$/;"	f	signature:(const void* ptr)
DeleteMatchingFiles	src/windows/port.cc	/^void DeleteMatchingFiles(const char* prefix, const char* full_glob) {$/;"	f	signature:(const char* prefix, const char* full_glob)
DeleteSpan	src/span.cc	/^void DeleteSpan(Span* span) {$/;"	f	namespace:tcmalloc	signature:(Span* span)
DeleteSpan	src/span.h	/^void DeleteSpan(Span* span);$/;"	p	namespace:tcmalloc	signature:(Span* span)
DeleteUnsignedCharArray	src/windows/preamble_patcher.cc	/^  DeleteUnsignedCharArray(unsigned char* array) : array_(array) {$/;"	f	class:sidestep::DeleteUnsignedCharArray	access:public	signature:(unsigned char* array)
DeleteUnsignedCharArray	src/windows/preamble_patcher.cc	/^class DeleteUnsignedCharArray {$/;"	c	namespace:sidestep	file:
Depth	src/malloc_extension.cc	/^uintptr_t Depth(void** entry) {$/;"	f	namespace:__anon21	signature:(void** entry)
DestrFnClosure	src/windows/port.cc	/^struct DestrFnClosure {$/;"	s	file:
DestrFnClosure::destr_fn	src/windows/port.cc	/^  void (*destr_fn)(void*);$/;"	m	struct:DestrFnClosure	file:	access:public
DestrFnClosure::key_for_destr_fn_arg	src/windows/port.cc	/^  pthread_key_t key_for_destr_fn_arg;$/;"	m	struct:DestrFnClosure	file:	access:public
DestroyThreadCache	src/thread_cache.cc	/^void ThreadCache::DestroyThreadCache(void* ptr) {$/;"	f	class:tcmalloc::ThreadCache	signature:(void* ptr)
DestroyThreadCache	src/thread_cache.h	/^  static void DestroyThreadCache(void* ptr);$/;"	p	class:tcmalloc::ThreadCache	access:private	signature:(void* ptr)
DevMemSysAllocator	src/system-alloc.cc	/^  DevMemSysAllocator() : SysAllocator() {$/;"	f	class:DevMemSysAllocator	access:public	signature:()
DevMemSysAllocator	src/system-alloc.cc	/^class DevMemSysAllocator : public SysAllocator {$/;"	c	file:	inherits:SysAllocator
DevMemSysAllocator::Alloc	src/system-alloc.cc	/^  void* Alloc(size_t size, size_t *actual_size, size_t alignment);$/;"	p	class:DevMemSysAllocator	file:	access:public	signature:(size_t size, size_t *actual_size, size_t alignment)
DevMemSysAllocator::Alloc	src/system-alloc.cc	/^void* DevMemSysAllocator::Alloc(size_t size, size_t *actual_size,$/;"	f	class:DevMemSysAllocator	signature:(size_t size, size_t *actual_size, size_t alignment)
DevMemSysAllocator::DevMemSysAllocator	src/system-alloc.cc	/^  DevMemSysAllocator() : SysAllocator() {$/;"	f	class:DevMemSysAllocator	access:public	signature:()
DirectTestSTLAlloc	src/tests/heap-checker_unittest.cc	/^static void DirectTestSTLAlloc(Alloc allocator, const char* name) {$/;"	f	file:	signature:(Alloc allocator, const char* name)
DirtyStack	src/base/linuxthreads.cc	/^static void DirtyStack(size_t amount) {$/;"	f	file:	signature:(size_t amount)
DisableChecksFromToLocked	src/gperftools/heap-checker.h	/^  static void DisableChecksFromToLocked(const void* start_address,$/;"	p	class:HeapLeakChecker	access:private	signature:(const void* start_address, const void* end_address, int max_depth)
DisableChecksFromToLocked	src/heap-checker.cc	/^void HeapLeakChecker::DisableChecksFromToLocked(const void* start_address,$/;"	f	class:HeapLeakChecker	signature:(const void* start_address, const void* end_address, int max_depth)
DisableChecksIn	src/gperftools/heap-checker.h	/^  static void DisableChecksIn(const char* pattern);$/;"	p	class:HeapLeakChecker	access:private	signature:(const char* pattern)
DisableChecksIn	src/heap-checker.cc	/^void HeapLeakChecker::DisableChecksIn(const char* pattern) {$/;"	f	class:HeapLeakChecker	signature:(const char* pattern)
DisableChecksToHereFrom	src/gperftools/heap-checker.h	/^  static void DisableChecksToHereFrom(const void* start_address);$/;"	p	class:HeapLeakChecker	access:private	signature:(const void* start_address)
DisableHandler	src/profiler.cc	/^  void DisableHandler();$/;"	p	class:CpuProfiler	file:	access:private	signature:()
DisableHandler	src/profiler.cc	/^void CpuProfiler::DisableHandler() {$/;"	f	class:CpuProfiler	signature:()
DisableLibraryAllocsLocked	src/gperftools/heap-checker.h	/^  static void DisableLibraryAllocsLocked(const char* library,$/;"	p	class:HeapLeakChecker	access:private	signature:(const char* library, uintptr_t start_address, uintptr_t end_address)
DisableLibraryAllocsLocked	src/heap-checker.cc	/^void HeapLeakChecker::DisableLibraryAllocsLocked(const char* library,$/;"	f	class:HeapLeakChecker	signature:(const char* library, uintptr_t start_address, uintptr_t end_address)
DisabledRangeMap	src/heap-checker.cc	/^           > DisabledRangeMap;$/;"	t	file:
Disabler	src/gperftools/heap-checker.h	/^    Disabler();$/;"	p	class:HeapLeakChecker::Disabler	access:public	signature:()
Disabler	src/gperftools/heap-checker.h	/^    Disabler(const Disabler&);        \/\/ disallow copy$/;"	p	class:HeapLeakChecker::Disabler	access:private	signature:(const Disabler&)
Disabler	src/gperftools/heap-checker.h	/^  class Disabler {$/;"	c	class:HeapLeakChecker	access:public
Disabler	src/heap-checker.cc	/^HeapLeakChecker::Disabler::Disabler() {$/;"	f	class:HeapLeakChecker::Disabler	signature:()
Disassemble	src/windows/mini_disassembler.cc	/^InstructionType MiniDisassembler::Disassemble($/;"	f	class:sidestep::MiniDisassembler	signature:( unsigned char* start_byte, unsigned int& instruction_bytes)
Disassemble	src/windows/mini_disassembler.h	/^  InstructionType Disassemble(unsigned char* start, unsigned int& instruction_bytes);$/;"	p	class:sidestep::MiniDisassembler	access:public	signature:(unsigned char* start, unsigned int& instruction_bytes)
DllMain	src/windows/port.cc	/^BOOL WINAPI DllMain(HINSTANCE h, DWORD dwReason, PVOID pv) {$/;"	f	signature:(HINSTANCE h, DWORD dwReason, PVOID pv)
DoAllocHidden	src/tests/heap-checker_unittest.cc	/^static void DoAllocHidden(size_t size, void** ptr) {$/;"	f	file:	signature:(size_t size, void** ptr)
DoAllocWithArena	src/base/low_level_alloc.cc	/^static void *DoAllocWithArena(size_t request, LowLevelAlloc::Arena *arena) {$/;"	f	file:	signature:(size_t request, LowLevelAlloc::Arena *arena)
DoDeAllocHidden	src/tests/heap-checker_unittest.cc	/^static void DoDeAllocHidden(void** ptr) {$/;"	f	file:	signature:(void** ptr)
DoFindRegionLocked	src/memory_region_map.cc	/^MemoryRegionMap::DoFindRegionLocked(uintptr_t addr) {$/;"	f	class:MemoryRegionMap	signature:(uintptr_t addr)
DoFindRegionLocked	src/memory_region_map.h	/^  static const Region* DoFindRegionLocked(uintptr_t addr);$/;"	p	class:MemoryRegionMap	access:private	signature:(uintptr_t addr)
DoGetHeapProfileLocked	src/heap-profiler.cc	/^static char* DoGetHeapProfileLocked(char* buf, int buflen) {$/;"	f	file:	signature:(char* buf, int buflen)
DoIgnoreObject	src/gperftools/heap-checker.h	/^  static void DoIgnoreObject(const void* ptr);$/;"	p	class:HeapLeakChecker	access:private	signature:(const void* ptr)
DoIgnoreObject	src/heap-checker.cc	/^void HeapLeakChecker::DoIgnoreObject(const void* ptr) {$/;"	f	class:HeapLeakChecker	signature:(const void* ptr)
DoInsertRegionLocked	src/memory_region_map.cc	/^inline void MemoryRegionMap::DoInsertRegionLocked(const Region& region) {$/;"	f	class:MemoryRegionMap	signature:(const Region& region)
DoInsertRegionLocked	src/memory_region_map.h	/^  inline static void DoInsertRegionLocked(const Region& region);$/;"	p	class:MemoryRegionMap	access:private	signature:(const Region& region)
DoMainHeapCheck	src/gperftools/heap-checker.h	/^  static bool DoMainHeapCheck();$/;"	p	class:HeapLeakChecker	access:private	signature:()
DoMainHeapCheck	src/heap-checker.cc	/^bool HeapLeakChecker::DoMainHeapCheck() {$/;"	f	class:HeapLeakChecker	signature:()
DoNoLeaks	src/gperftools/heap-checker.h	/^  bool DoNoLeaks(ShouldSymbolize should_symbolize);$/;"	p	class:HeapLeakChecker	access:private	signature:(ShouldSymbolize should_symbolize)
DoNoLeaks	src/heap-checker.cc	/^bool HeapLeakChecker::DoNoLeaks(ShouldSymbolize should_symbolize) {$/;"	f	class:HeapLeakChecker	signature:(ShouldSymbolize should_symbolize)
DoRun	src/tests/profile-handler_unittest.cc	/^  static void* DoRun(void* cls) {$/;"	f	class:__anon56::Thread	file:	access:private	signature:(void* cls)
DoRunHidden	src/tests/heap-checker_unittest.cc	/^static void DoRunHidden(Closure* c, int n) {$/;"	f	file:	signature:(Closure* c, int n)
DoSampledAllocation	src/tcmalloc.cc	/^static void* DoSampledAllocation(size_t size) {$/;"	f	file:	signature:(size_t size)
DoTestSTLAlloc	src/tests/heap-checker_unittest.cc	/^static void DoTestSTLAlloc() {$/;"	f	file:	signature:()
DoTestSTLAllocInverse	src/tests/heap-checker_unittest.cc	/^static void DoTestSTLAllocInverse(IntSet** setx) {$/;"	f	file:	signature:(IntSet** setx)
DoWipeStack	src/tests/heap-checker_unittest.cc	/^\/*static*\/ void DoWipeStack(int n) {$/;"	f	signature:(int n)
DoWipeStack	src/tests/heap-checker_unittest.cc	/^static void DoWipeStack(int n);  \/\/ defined below$/;"	p	file:	signature:(int n)
DumpAddressMap	src/malloc_extension.cc	/^static void DumpAddressMap(string* result) {$/;"	f	file:	signature:(string* result)
DumpArgs	src/heap-profile-table.h	/^    DumpArgs(RawFD fd_arg, Stats* profile_stats_arg)$/;"	f	struct:HeapProfileTable::DumpArgs	access:public	signature:(RawFD fd_arg, Stats* profile_stats_arg)
DumpArgs	src/heap-profile-table.h	/^  struct DumpArgs {$/;"	s	class:HeapProfileTable	access:private
DumpBucketIterator	src/heap-profile-table.cc	/^void HeapProfileTable::DumpBucketIterator(const Bucket* bucket,$/;"	f	class:HeapProfileTable	signature:(const Bucket* bucket, BufferArgs* args)
DumpBucketIterator	src/heap-profile-table.h	/^  inline static void DumpBucketIterator(const Bucket* bucket,$/;"	p	class:HeapProfileTable	access:private	signature:(const Bucket* bucket, BufferArgs* args)
DumpHeapGrowthStackTraces	src/tcmalloc.cc	/^static void** DumpHeapGrowthStackTraces() {$/;"	f	file:	signature:()
DumpNonLiveIterator	src/heap-profile-table.cc	/^void HeapProfileTable::DumpNonLiveIterator(const void* ptr, AllocValue* v,$/;"	f	class:HeapProfileTable	signature:(const void* ptr, AllocValue* v, const DumpArgs& args)
DumpNonLiveIterator	src/heap-profile-table.h	/^  inline static void DumpNonLiveIterator(const void* ptr, AllocValue* v,$/;"	p	class:HeapProfileTable	access:private	signature:(const void* ptr, AllocValue* v, const DumpArgs& args)
DumpProcSelfMaps	src/base/sysinfo.cc	/^void DumpProcSelfMaps(RawFD fd) {$/;"	f	namespace:tcmalloc	signature:(RawFD fd)
DumpProcSelfMaps	src/base/sysinfo.h	/^void DumpProcSelfMaps(RawFD fd);$/;"	p	namespace:tcmalloc	signature:(RawFD fd)
DumpProcSelfMaps	src/profiledata.cc	/^static void DumpProcSelfMaps(int fd) {$/;"	f	file:	signature:(int fd)
DumpProfileLocked	src/heap-profiler.cc	/^static void DumpProfileLocked(const char* reason) {$/;"	f	file:	signature:(const char* reason)
DumpStats	src/tcmalloc.cc	/^static void DumpStats(TCMalloc_Printer* out, int level) {$/;"	f	file:	signature:(TCMalloc_Printer* out, int level)
DumpStats	src/tests/system-alloc_unittest.cc	/^  void DumpStats() {$/;"	f	class:ArraySysAllocator	access:public	signature:()
DumpSystemAllocatorStats	src/windows/system-alloc.cc	/^void DumpSystemAllocatorStats(TCMalloc_Printer* printer) {$/;"	f	signature:(TCMalloc_Printer* printer)
E	benchmark/unwind_bench-unwind_bench.o	/^¸/;"	v
E	src/.libs/libtcmalloc_internal_la-heap-profile-table.o	/^HEøHEøHÁèH1EøEôEô;E´|ÁHEøHÁàHEøHEøHÁèH1EøHEøÁº½jºÈ÷âÐÁèEäEäiÀ¿/;"	v
E	src/.libs/libtcmalloc_internal_la-internal_logging.o	/^/;"	v
E	src/.libs/libtcmalloc_internal_la-page_heap.o	/^HEèH/;"	v
E	src/.libs/libtcmalloc_minimal_internal_la-page_heap.o	/^HEèH/;"	v
E	src/libtcmalloc_internal_la-heap-profile-table.o	/^HEøHEøHÁèH1EøEôEô;E´|ÁHEøHÁàHEøHEøHÁèH1EøHEøÁº½jºÈ÷âÐÁèEäEäiÀ¿/;"	v
E	src/libtcmalloc_internal_la-page_heap.o	/^HEèH/;"	v
E	src/libtcmalloc_internal_la-raw_printer.o	/^/;"	v
E	src/libtcmalloc_minimal_internal_la-page_heap.o	/^HEèH/;"	v
ECHO	binary_trees_shared	/^    ECHO="echo"$/;"	v
ECHO	configure	/^ECHO=${lt_ECHO-echo}$/;"	v
ECHO	current_allocated_bytes_test	/^    ECHO="echo"$/;"	v
ECHO	debugallocation_test	/^    ECHO="echo"$/;"	v
ECHO	frag_unittest	/^    ECHO="echo"$/;"	v
ECHO	heap-checker_debug_unittest	/^    ECHO="echo"$/;"	v
ECHO	heap-checker_unittest	/^    ECHO="echo"$/;"	v
ECHO	heap-profiler_debug_unittest	/^    ECHO="echo"$/;"	v
ECHO	heap-profiler_unittest	/^    ECHO="echo"$/;"	v
ECHO	malloc_bench_shared	/^    ECHO="echo"$/;"	v
ECHO	malloc_bench_shared_full	/^    ECHO="echo"$/;"	v
ECHO	malloc_extension_c_test	/^    ECHO="echo"$/;"	v
ECHO	malloc_extension_debug_test	/^    ECHO="echo"$/;"	v
ECHO	malloc_extension_test	/^    ECHO="echo"$/;"	v
ECHO	malloc_hook_test	/^    ECHO="echo"$/;"	v
ECHO	markidle_unittest	/^    ECHO="echo"$/;"	v
ECHO	memalign_debug_unittest	/^    ECHO="echo"$/;"	v
ECHO	memalign_unittest	/^    ECHO="echo"$/;"	v
ECHO	packed_cache_test	/^    ECHO="echo"$/;"	v
ECHO	page_heap_test	/^    ECHO="echo"$/;"	v
ECHO	pagemap_unittest	/^    ECHO="echo"$/;"	v
ECHO	profile_handler_unittest	/^    ECHO="echo"$/;"	v
ECHO	profiledata_unittest	/^    ECHO="echo"$/;"	v
ECHO	profiler1_unittest	/^    ECHO="echo"$/;"	v
ECHO	profiler2_unittest	/^    ECHO="echo"$/;"	v
ECHO	profiler3_unittest	/^    ECHO="echo"$/;"	v
ECHO	profiler4_unittest	/^    ECHO="echo"$/;"	v
ECHO	raw_printer_test	/^    ECHO="echo"$/;"	v
ECHO	realloc_debug_unittest	/^    ECHO="echo"$/;"	v
ECHO	realloc_unittest	/^    ECHO="echo"$/;"	v
ECHO	sampler_debug_test	/^    ECHO="echo"$/;"	v
ECHO	sampler_test	/^    ECHO="echo"$/;"	v
ECHO	sampling_debug_test	/^    ECHO="echo"$/;"	v
ECHO	sampling_test	/^    ECHO="echo"$/;"	v
ECHO	simple_compat_test	/^    ECHO="echo"$/;"	v
ECHO	stack_trace_table_test	/^    ECHO="echo"$/;"	v
ECHO	system_alloc_unittest	/^    ECHO="echo"$/;"	v
ECHO	tcmalloc_and_profiler_unittest	/^    ECHO="echo"$/;"	v
ECHO	tcmalloc_both_unittest	/^    ECHO="echo"$/;"	v
ECHO	tcmalloc_debug_unittest	/^    ECHO="echo"$/;"	v
ECHO	tcmalloc_large_heap_fragmentation_unittest	/^    ECHO="echo"$/;"	v
ECHO	tcmalloc_large_unittest	/^    ECHO="echo"$/;"	v
ECHO	tcmalloc_minimal_debug_unittest	/^    ECHO="echo"$/;"	v
ECHO	tcmalloc_minimal_large_heap_fragmentation_unittest	/^    ECHO="echo"$/;"	v
ECHO	tcmalloc_minimal_large_unittest	/^    ECHO="echo"$/;"	v
ECHO	tcmalloc_minimal_unittest	/^    ECHO="echo"$/;"	v
ECHO	tcmalloc_unittest	/^    ECHO="echo"$/;"	v
ECHO	thread_dealloc_unittest	/^    ECHO="echo"$/;"	v
ECHO	unwind_bench	/^    ECHO="echo"$/;"	v
EMERGENCY_MALLOC_H	src/emergency_malloc.h	32;"	d
ENABLE_ALIGNED_NEW_DELETE	src/config.h.in	9;"	d	file:
ENABLE_DYNAMIC_SIZED_DELETE	src/config.h.in	12;"	d	file:
ENABLE_SIZED_DELETE	src/config.h.in	15;"	d	file:
ERRNO	src/base/linuxthreads.cc	167;"	d	file:
ERROR	src/base/logging.h	/^enum LogSeverity {INFO = -1, WARNING = -2, ERROR = -3, FATAL = -4};$/;"	e	enum:LogSeverity
ERROR	src/base/logging.h	193;"	d
ERROR	src/heap-checker.cc	65;"	d	file:
EVINCE	src/pprof	/^my @EVINCE = ("evince");    # could also be xpdf or perhaps acroread$/;"	v
EXCLUSIVE_LOCKS_REQUIRED	src/base/thread_annotations.h	93;"	d
EXCLUSIVE_LOCKS_REQUIRED	src/central_freelist.h	/^  bool MakeCacheSpace() EXCLUSIVE_LOCKS_REQUIRED(lock_);$/;"	p	class:tcmalloc::CentralFreeList	access:private	signature:(lock_)
EXCLUSIVE_LOCKS_REQUIRED	src/central_freelist.h	/^  int FetchFromOneSpans(int N, void **start, void **end) EXCLUSIVE_LOCKS_REQUIRED(lock_);$/;"	p	class:tcmalloc::CentralFreeList	access:private	signature:(lock_)
EXCLUSIVE_LOCKS_REQUIRED	src/central_freelist.h	/^  int FetchFromOneSpansSafe(int N, void **start, void **end) EXCLUSIVE_LOCKS_REQUIRED(lock_);$/;"	p	class:tcmalloc::CentralFreeList	access:private	signature:(lock_)
EXCLUSIVE_LOCKS_REQUIRED	src/central_freelist.h	/^  void Populate() EXCLUSIVE_LOCKS_REQUIRED(lock_);$/;"	p	class:tcmalloc::CentralFreeList	access:private	signature:(lock_)
EXCLUSIVE_LOCKS_REQUIRED	src/central_freelist.h	/^  void ReleaseListToSpans(void *start) EXCLUSIVE_LOCKS_REQUIRED(lock_);$/;"	p	class:tcmalloc::CentralFreeList	access:private	signature:(lock_)
EXCLUSIVE_LOCKS_REQUIRED	src/central_freelist.h	/^  void ReleaseToSpans(void* object) EXCLUSIVE_LOCKS_REQUIRED(lock_);$/;"	p	class:tcmalloc::CentralFreeList	access:private	signature:(lock_)
EXCLUSIVE_LOCKS_REQUIRED	src/profile-handler.cc	/^  void UpdateTimer(bool enable) EXCLUSIVE_LOCKS_REQUIRED(signal_lock_);$/;"	p	class:ProfileHandler	file:	access:private	signature:(signal_lock_)
EXCLUSIVE_LOCK_FUNCTION	src/base/spinlock.h	/^  inline explicit SpinLockHolder(SpinLock* l) EXCLUSIVE_LOCK_FUNCTION(l)$/;"	f	class:SpinLockHolder	access:public	signature:(l)
EXCLUSIVE_LOCK_FUNCTION	src/base/thread_annotations.h	115;"	d
EXCLUSIVE_LOCK_FUNCTION	src/memory_region_map.h	/^  static void Lock() EXCLUSIVE_LOCK_FUNCTION(lock_);$/;"	p	class:MemoryRegionMap	access:public	signature:(lock_)
EXCLUSIVE_TRYLOCK_FUNCTION	src/base/spinlock.h	/^  inline bool TryLock() EXCLUSIVE_TRYLOCK_FUNCTION(true) {$/;"	f	class:SpinLock	access:public	signature:(true)
EXCLUSIVE_TRYLOCK_FUNCTION	src/base/thread_annotations.h	121;"	d
EXEMPLARY	COPYING	/^SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT$/;"	v
EXEMPLARY	packages/deb/copyright	/^SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT$/;"	v
EXPECT_EQ	src/base/logging.h	151;"	d
EXPECT_FALSE	src/base/logging.h	165;"	d
EXPECT_GE	src/base/logging.h	155;"	d
EXPECT_GT	src/base/logging.h	156;"	d
EXPECT_LE	src/base/logging.h	153;"	d
EXPECT_LT	src/base/logging.h	154;"	d
EXPECT_NE	src/base/logging.h	152;"	d
EXPECT_STREQ	src/base/logging.h	166;"	d
EXPECT_TRUE	src/base/logging.h	164;"	d
EXTERN_C	src/windows/port.h	495;"	d
EXTERN_C	src/windows/port.h	97;"	d
EXTERN_C	src/windows/port.h	99;"	d
EZ	src/.libs/libtcmalloc_internal_la-internal_logging.o	/^/;"	v
ElfClass	src/base/elf_mem_image.cc	/^template <> class ElfClass<32> {$/;"	c	namespace:base::__anon50	file:
ElfClass	src/base/elf_mem_image.cc	/^template <> class ElfClass<64> {$/;"	c	namespace:base::__anon50	file:
ElfClass	src/base/elf_mem_image.cc	/^template <int N> class ElfClass {$/;"	c	namespace:base::__anon50	file:
ElfMemImage	src/base/elf_mem_image.cc	/^ElfMemImage::ElfMemImage(const void *base) {$/;"	f	class:base::ElfMemImage	signature:(const void *base)
ElfMemImage	src/base/elf_mem_image.h	/^  explicit ElfMemImage(const void *base);$/;"	p	class:base::ElfMemImage	access:public	signature:(const void *base)
ElfMemImage	src/base/elf_mem_image.h	/^class ElfMemImage {$/;"	c	namespace:base
ElfW	src/base/elf_mem_image.cc	/^  static int ElfBind(const ElfW(Sym) *) {$/;"	f	class:base::__anon50::ElfClass	access:public	signature:(Sym)
ElfW	src/base/elf_mem_image.cc	/^  static int ElfType(const ElfW(Sym) *) {$/;"	f	class:base::__anon50::ElfClass	access:public	signature:(Sym)
EmergencyArenaPagesAllocator	src/emergency_malloc.cc	/^  class EmergencyArenaPagesAllocator : public LowLevelAlloc::PagesAllocator {$/;"	c	namespace:tcmalloc	file:	inherits:LowLevelAlloc::PagesAllocator
EmergencyCalloc	src/emergency_malloc.cc	/^  PERFTOOLS_DLL_DECL void *EmergencyCalloc(size_t n, size_t elem_size) {$/;"	f	namespace:tcmalloc	signature:(size_t n, size_t elem_size)
EmergencyCalloc	src/emergency_malloc.h	/^  PERFTOOLS_DLL_DECL void *EmergencyCalloc(size_t n, size_t elem_size);$/;"	p	namespace:tcmalloc	signature:(size_t n, size_t elem_size)
EmergencyCalloc	src/maybe_emergency_malloc.h	/^  static inline void *EmergencyCalloc(size_t n, size_t elem_size) {return NULL;}$/;"	f	namespace:tcmalloc	signature:(size_t n, size_t elem_size)
EmergencyFree	src/emergency_malloc.cc	/^  PERFTOOLS_DLL_DECL void EmergencyFree(void *p) {$/;"	f	namespace:tcmalloc	signature:(void *p)
EmergencyFree	src/emergency_malloc.h	/^  PERFTOOLS_DLL_DECL void EmergencyFree(void *p);$/;"	p	namespace:tcmalloc	signature:(void *p)
EmergencyFree	src/maybe_emergency_malloc.h	/^  static inline void EmergencyFree(void *p) {}$/;"	f	namespace:tcmalloc	signature:(void *p)
EmergencyMalloc	src/emergency_malloc.cc	/^  PERFTOOLS_DLL_DECL void *EmergencyMalloc(size_t size) {$/;"	f	namespace:tcmalloc	signature:(size_t size)
EmergencyMalloc	src/emergency_malloc.h	/^  PERFTOOLS_DLL_DECL void *EmergencyMalloc(size_t size);$/;"	p	namespace:tcmalloc	signature:(size_t size)
EmergencyMalloc	src/maybe_emergency_malloc.h	/^  static inline void *EmergencyMalloc(size_t size) {return NULL;}$/;"	f	namespace:tcmalloc	signature:(size_t size)
EmergencyRealloc	src/emergency_malloc.cc	/^  PERFTOOLS_DLL_DECL void *EmergencyRealloc(void *_old_ptr, size_t new_size) {$/;"	f	namespace:tcmalloc	signature:(void *_old_ptr, size_t new_size)
EmergencyRealloc	src/emergency_malloc.h	/^  PERFTOOLS_DLL_DECL void *EmergencyRealloc(void *old_ptr, size_t new_size);$/;"	p	namespace:tcmalloc	signature:(void *old_ptr, size_t new_size)
EmergencyRealloc	src/maybe_emergency_malloc.h	/^  static inline void *EmergencyRealloc(void *old_ptr, size_t new_size) {return NULL;}$/;"	f	namespace:tcmalloc	signature:(void *old_ptr, size_t new_size)
Empty	src/heap-profile-table.h	/^  bool Empty() const {$/;"	f	class:HeapProfileTable::Snapshot	access:public	signature:() const
EnableHandler	src/profiler.cc	/^  void EnableHandler();$/;"	p	class:CpuProfiler	file:	access:private	signature:()
EnableHandler	src/profiler.cc	/^void CpuProfiler::EnableHandler() {$/;"	f	class:CpuProfiler	signature:()
Enabled	src/profiler.cc	/^  bool Enabled();$/;"	p	class:CpuProfiler	file:	access:public	signature:()
Enabled	src/profiler.cc	/^bool CpuProfiler::Enabled() {$/;"	f	class:CpuProfiler	signature:()
EndRegionLocked	src/memory_region_map.cc	/^MemoryRegionMap::RegionIterator MemoryRegionMap::EndRegionLocked() {$/;"	f	class:MemoryRegionMap	signature:()
EndRegionLocked	src/memory_region_map.h	/^  static RegionIterator EndRegionLocked();$/;"	p	class:MemoryRegionMap	access:public	signature:()
Ensure	src/pagemap.h	/^  bool Ensure(Number start, size_t n) {$/;"	f	class:TCMalloc_PageMap2	access:public	signature:(Number start, size_t n)
Ensure	src/pagemap.h	/^  bool Ensure(Number start, size_t n) {$/;"	f	class:TCMalloc_PageMap3	access:public	signature:(Number start, size_t n)
Ensure	src/pagemap.h	/^  bool Ensure(Number x, size_t n) {$/;"	f	class:TCMalloc_PageMap1	access:public	signature:(Number x, size_t n)
EnsureLimit	src/page_heap.cc	/^bool PageHeap::EnsureLimit(Length n, bool withRelease)$/;"	f	class:tcmalloc::PageHeap	signature:(Length n, bool withRelease)
EnsureLimit	src/page_heap.h	/^  bool EnsureLimit(Length n, bool allowRelease = true);$/;"	p	class:tcmalloc::PageHeap	access:private	signature:(Length n, bool allowRelease = true)
EnterStacktraceScope	src/emergency_malloc_for_stacktrace.cc	/^  bool EnterStacktraceScope(void);$/;"	p	namespace:tcmalloc	file:	signature:(void)
EnterStacktraceScope	src/emergency_malloc_for_stacktrace.cc	/^bool tcmalloc::EnterStacktraceScope(void) {$/;"	f	class:tcmalloc	signature:(void)
EnterStacktraceScope	src/fake_stacktrace_scope.cc	/^  ATTRIBUTE_WEAK bool EnterStacktraceScope(void) {$/;"	f	namespace:tcmalloc	signature:(void)
EnterStacktraceScope	src/stacktrace.cc	/^  bool EnterStacktraceScope(void);$/;"	p	namespace:tcmalloc	file:	signature:(void)
Entry	src/addressmap-inl.h	/^  struct Entry {$/;"	s	class:AddressMap	access:private
Entry	src/heap-profile-table.cc	/^  Entry() : count(0), bytes(0) { }$/;"	f	struct:HeapProfileTable::Snapshot::Entry	access:public	signature:()
Entry	src/heap-profile-table.cc	/^struct HeapProfileTable::Snapshot::Entry {$/;"	s	class:HeapProfileTable::Snapshot	file:
Entry	src/profiledata.h	/^  struct Entry {$/;"	s	class:ProfileData	access:private
EnumSymProc	src/windows/nm-pdb.c	/^static BOOL CALLBACK EnumSymProc(PSYMBOL_INFO symbol_info,$/;"	f	file:	signature:(PSYMBOL_INFO symbol_info, ULONG symbol_size, PVOID user_context)
EnvToBool	src/base/commandlineflags.h	163;"	d
EnvToDouble	src/base/commandlineflags.h	172;"	d
EnvToInt	src/base/commandlineflags.h	166;"	d
EnvToInt64	src/base/commandlineflags.h	169;"	d
EnvToString	src/base/commandlineflags.h	160;"	d
Equivalent	src/heap-profile-stats.h	/^  bool Equivalent(const HeapProfileStats& other) const {$/;"	f	struct:HeapProfileStats	access:public	signature:(const HeapProfileStats& other) const
Event	src/span.cc	/^void Event(Span* span, char op, int v = 0) {$/;"	f	namespace:tcmalloc	signature:(Span* span, char op, int v = 0)
Event	src/span.h	/^void Event(Span* span, char op, int v = 0);$/;"	p	namespace:tcmalloc	signature:(Span* span, char op, int v = 0)
Event	src/span.h	71;"	d
Evict	src/profiledata.cc	/^void ProfileData::Evict(const Entry& entry) {$/;"	f	class:ProfileData	signature:(const Entry& entry)
Evict	src/profiledata.h	/^  void Evict(const Entry& entry);$/;"	p	class:ProfileData	access:private	signature:(const Entry& entry)
EvictRandomSizeClass	src/central_freelist.cc	/^bool CentralFreeList::EvictRandomSizeClass($/;"	f	class:tcmalloc::CentralFreeList	signature:( int locked_size_class, bool force)
EvictRandomSizeClass	src/central_freelist.h	/^  static bool EvictRandomSizeClass(int locked_size_class, bool force);$/;"	p	class:tcmalloc::CentralFreeList	access:private	signature:(int locked_size_class, bool force)
ExchangeSingular	src/malloc_hook-inl.h	/^  T ExchangeSingular(T new_val);$/;"	p	struct:base::internal::HookList	access:public	signature:(T new_val)
ExchangeSingular	src/malloc_hook.cc	/^T HookList<T>::ExchangeSingular(T value_as_t) {$/;"	f	class:base::internal::HookList	signature:(T value_as_t)
ExpectRunningSamples	src/tests/profiledata_unittest.cc	/^  void ExpectRunningSamples(int samples) {$/;"	f	class:__anon53::ProfileDataTest	access:protected	signature:(int samples)
ExpectSameState	src/tests/profiledata_unittest.cc	/^  void ExpectSameState(const ProfileData::State& before,$/;"	f	class:__anon53::ProfileDataTest	access:protected	signature:(const ProfileData::State& before, const ProfileData::State& after)
ExpectStopped	src/tests/profiledata_unittest.cc	/^  void ExpectStopped() {$/;"	f	class:__anon53::ProfileDataTest	access:protected	signature:()
ExtractStats	src/tcmalloc.cc	/^static void ExtractStats(TCMallocStats* r, uint64_t* class_count,$/;"	f	file:	signature:(TCMallocStats* r, uint64_t* class_count, PageHeap::SmallSpanStats* small_spans, PageHeap::LargeSpanStats* large_spans)
ExtractUntilChar	src/base/sysinfo.cc	/^static bool ExtractUntilChar(char *text, int c, char **endptr) {$/;"	f	file:	signature:(char *text, int c, char **endptr)
F	src/.libs/libtcmalloc_internal_la-stack_trace_table.o	/^[^/;"	v
F	src/.libs/libtcmalloc_minimal_internal_la-stack_trace_table.o	/^[^/;"	v
F	src/libtcmalloc_and_profiler_la-profile-handler.o	/^/;"	v
FAIL	src/tests/malloc_extension_c_test.c	47;"	d	file:
FATAL	src/base/logging.h	/^enum LogSeverity {INFO = -1, WARNING = -2, ERROR = -3, FATAL = -4};$/;"	e	enum:LogSeverity
FDWrite	src/profiledata.cc	/^static void FDWrite(int fd, const char* buf, size_t len) {$/;"	f	file:	signature:(int fd, const char* buf, size_t len)
FLAGS_allocweight	src/tests/tcmalloc_unittest.cc	/^static const int FLAGS_allocweight = 50;    \/\/ Weight for picking allocation$/;"	m	namespace:testing	file:
FLAGS_freeweight	src/tests/tcmalloc_unittest.cc	/^static const int FLAGS_freeweight = 50;     \/\/ Weight for picking free$/;"	m	namespace:testing	file:
FLAGS_lg_max_memalign	src/tests/tcmalloc_unittest.cc	/^static const int FLAGS_lg_max_memalign = 18; \/\/ lg of max alignment for memalign$/;"	m	namespace:testing	file:
FLAGS_lgmaxsize	src/tests/tcmalloc_unittest.cc	/^static const int FLAGS_lgmaxsize = 16;   \/\/ lg() of the max size object to alloc$/;"	m	namespace:testing	file:
FLAGS_log_every_n_tests	src/tests/tcmalloc_unittest.cc	/^static const int FLAGS_log_every_n_tests = 50000; \/\/ log exactly once$/;"	m	namespace:testing	file:
FLAGS_memalign_max_alignment_ratio	src/tests/tcmalloc_unittest.cc	/^static const double FLAGS_memalign_max_alignment_ratio = 6;  \/\/ alignment\/size$/;"	m	namespace:testing	file:
FLAGS_memalign_max_fraction	src/tests/tcmalloc_unittest.cc	/^static const double FLAGS_memalign_max_fraction = 0.4;  \/\/ max expected%$/;"	m	namespace:testing	file:
FLAGS_memalign_min_fraction	src/tests/tcmalloc_unittest.cc	/^static const double FLAGS_memalign_min_fraction = 0;    \/\/ min expected%$/;"	m	namespace:testing	file:
FLAGS_mock_tcmalloc_sample_parameter	src/tests/sampler_test.cc	/^const int64 FLAGS_mock_tcmalloc_sample_parameter = 1<<19;$/;"	v
FLAGS_numtests	src/tests/tcmalloc_unittest.cc	/^static const int FLAGS_numtests = 50000;$/;"	m	namespace:testing	file:
FLAGS_numthreads	src/tests/tcmalloc_unittest.cc	/^static const int FLAGS_numthreads = 10;  \/\/ Number of threads$/;"	m	namespace:testing	file:
FLAGS_passweight	src/tests/tcmalloc_unittest.cc	/^static const int FLAGS_passweight = 1;      \/\/ Weight for passing object$/;"	m	namespace:testing	file:
FLAGS_tcmalloc_transfer_num_objects	lidong_read	/^FLAGS_tcmalloc_transfer_num_objects;$/;"	v
FLAGS_tcmalloc_transfer_num_objects	src/common.cc	/^static int32 FLAGS_tcmalloc_transfer_num_objects;$/;"	m	namespace:tcmalloc	file:
FLAGS_threadmb	src/tests/tcmalloc_unittest.cc	/^static const int FLAGS_threadmb = 4;     \/\/ Max memory size allocated by thread$/;"	m	namespace:testing	file:
FLAGS_updateweight	src/tests/tcmalloc_unittest.cc	/^static const int FLAGS_updateweight = 10;   \/\/ Weight for picking update$/;"	m	namespace:testing	file:
FOR	src/windows/shortproc.asm	/^; LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR$/;"	v
FRAME	src/base/elfcore.h	139;"	d
FRAME	src/base/elfcore.h	192;"	d
FRAME	src/base/elfcore.h	257;"	d
FRAME	src/base/elfcore.h	289;"	d
FRAME	src/base/elfcore.h	351;"	d
FRAME_MIN_SIZE	src/base/linux_syscall_support.h	2050;"	d
FRAME_TOC_SAVE	src/base/linux_syscall_support.h	2051;"	d
FREE	src/gperftools/malloc_extension.h	/^    FREE,                 \/\/ Range is currently free$/;"	e	enum:base::MallocRange::Type
FREE	src/tests/tcmalloc_unittest.cc	/^  enum Type { ALLOC, FREE, UPDATE, PASS };$/;"	e	enum:testing::TesterThread::Type	file:
FUJITSU_PROC	config.guess	/^	FUJITSU_PROC=`uname -m | tr 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' 'abcdefghijklmnopqrstuvwxyz'`$/;"	v
FUTEX_PRIVATE_FLAG	src/base/spinlock_linux-inl.h	43;"	d
FUTEX_WAIT	src/base/spinlock_linux-inl.h	41;"	d
FUTEX_WAKE	src/base/spinlock_linux-inl.h	42;"	d
FastInterlockedCompareExchange	src/base/atomicops-internals-windows.h	/^inline LONG FastInterlockedCompareExchange(volatile LONG* ptr,$/;"	f	signature:(volatile LONG* ptr, LONG newval, LONG oldval)
FastInterlockedCompareExchangePointer	src/base/atomicops-internals-windows.h	/^inline PVOID FastInterlockedCompareExchangePointer(volatile PVOID* ptr,$/;"	f	signature:(volatile PVOID* ptr, PVOID newval, PVOID oldval)
FastInterlockedExchange	src/base/atomicops-internals-windows.h	/^inline LONG FastInterlockedExchange(volatile LONG* ptr, LONG newval) {$/;"	f	signature:(volatile LONG* ptr, LONG newval)
FastInterlockedExchangeAdd	src/base/atomicops-internals-windows.h	/^inline LONG FastInterlockedExchangeAdd(volatile LONG* ptr, LONG increment) {$/;"	f	signature:(volatile LONG* ptr, LONG increment)
FastInterlockedExchangeAdd64	src/base/atomicops-internals-windows.h	/^inline LONGLONG FastInterlockedExchangeAdd64(volatile LONGLONG* ptr,$/;"	f	signature:(volatile LONGLONG* ptr, LONGLONG increment)
FastInterlockedExchangePointer	src/base/atomicops-internals-windows.h	/^inline PVOID FastInterlockedExchangePointer(volatile PVOID* ptr, PVOID newval) {$/;"	f	signature:(volatile PVOID* ptr, PVOID newval)
FetchFromCentralCache	src/thread_cache.cc	/^void* ThreadCache::FetchFromCentralCache(uint32 cl, int32_t byte_size,$/;"	f	class:tcmalloc::ThreadCache	signature:(uint32 cl, int32_t byte_size, void *(*oom_handler)(size_t size))
FetchFromCentralCache	src/thread_cache.h	/^  void* FetchFromCentralCache(uint32 cl, int32_t byte_size,$/;"	p	class:tcmalloc::ThreadCache	access:private	signature:(uint32 cl, int32_t byte_size, void *(*oom_handler)(size_t size))
FetchFromOneSpans	src/central_freelist.cc	/^int CentralFreeList::FetchFromOneSpans(int N, void **start, void **end) {$/;"	f	class:tcmalloc::CentralFreeList	signature:(int N, void **start, void **end)
FetchFromOneSpansSafe	src/central_freelist.cc	/^int CentralFreeList::FetchFromOneSpansSafe(int N, void **start, void **end) {$/;"	f	class:tcmalloc::CentralFreeList	signature:(int N, void **start, void **end)
FetchProgramName	src/pprof	/^sub FetchProgramName() {$/;"	f	signature:()
File	gperftools.sln	/^Microsoft Visual Studio Solution File, Format Version 8.00$/;"	v
FileDescriptor	src/tests/profiledata_unittest.cc	/^  explicit FileDescriptor(int fd) : fd_(fd) {}$/;"	f	struct:__anon53::FileDescriptor	access:public	signature:(int fd)
FileDescriptor	src/tests/profiledata_unittest.cc	/^struct FileDescriptor {$/;"	s	namespace:__anon53	file:
Fill	src/tests/memalign_unittest.cc	/^static void Fill(void* p, int n, char seed) {$/;"	f	file:	signature:(void* p, int n, char seed)
Fill	src/tests/realloc_unittest.cc	/^static void Fill(unsigned char* buffer, int n) {$/;"	f	file:	signature:(unsigned char* buffer, int n)
FillContents	src/tests/tcmalloc_unittest.cc	/^  void FillContents(Object* object) {$/;"	f	class:testing::TesterThread	access:public	signature:(Object* object)
FillOrderedProfile	src/heap-profile-table.cc	/^int HeapProfileTable::FillOrderedProfile(char buf[], int size) const {$/;"	f	class:HeapProfileTable	signature:(char buf[], int size) const
FillOrderedProfile	src/heap-profile-table.h	/^  int FillOrderedProfile(char buf[], int size) const;$/;"	p	class:HeapProfileTable	access:public	signature:(char buf[], int size) const
FillProcSelfMaps	src/base/sysinfo.cc	/^int FillProcSelfMaps(char buf[], int size, bool* wrote_all) {$/;"	f	namespace:tcmalloc	signature:(char buf[], int size, bool* wrote_all)
FillProcSelfMaps	src/base/sysinfo.h	/^int FillProcSelfMaps(char buf[], int size, bool* wrote_all);$/;"	p	namespace:tcmalloc	signature:(char buf[], int size, bool* wrote_all)
Find	src/addressmap-inl.h	/^  inline const Value* Find(Key key) const;$/;"	p	class:AddressMap	access:public	signature:(Key key) const
Find	src/addressmap-inl.h	/^inline const Value* AddressMap<Value>::Find(Key key) const {$/;"	f	class:AddressMap	signature:(Key key) const
FindAlloc	src/heap-profile-table.cc	/^bool HeapProfileTable::FindAlloc(const void* ptr, size_t* object_size) const {$/;"	f	class:HeapProfileTable	signature:(const void* ptr, size_t* object_size) const
FindAlloc	src/heap-profile-table.h	/^  bool FindAlloc(const void* ptr, size_t* object_size) const;$/;"	p	class:HeapProfileTable	access:public	signature:(const void* ptr, size_t* object_size) const
FindAllocDetails	src/heap-profile-table.cc	/^bool HeapProfileTable::FindAllocDetails(const void* ptr,$/;"	f	class:HeapProfileTable	signature:(const void* ptr, AllocInfo* info) const
FindAllocDetails	src/heap-profile-table.h	/^  bool FindAllocDetails(const void* ptr, AllocInfo* info) const;$/;"	p	class:HeapProfileTable	access:public	signature:(const void* ptr, AllocInfo* info) const
FindAndMarkStackRegion	src/memory_region_map.cc	/^bool MemoryRegionMap::FindAndMarkStackRegion(uintptr_t stack_top,$/;"	f	class:MemoryRegionMap	signature:(uintptr_t stack_top, Region* result)
FindAndMarkStackRegion	src/memory_region_map.h	/^  static bool FindAndMarkStackRegion(uintptr_t stack_top, Region* result);$/;"	p	class:MemoryRegionMap	access:public	signature:(uintptr_t stack_top, Region* result)
FindAndRemove	src/addressmap-inl.h	/^  bool FindAndRemove(Key key, Value* removed_value);$/;"	p	class:AddressMap	access:public	signature:(Key key, Value* removed_value)
FindAndRemove	src/addressmap-inl.h	/^bool AddressMap<Value>::FindAndRemove(Key key, Value* removed_value) {$/;"	f	class:AddressMap	signature:(Key key, Value* removed_value)
FindCluster	src/addressmap-inl.h	/^  Cluster* FindCluster(Number address, bool create) {$/;"	f	class:AddressMap	access:private	signature:(Number address, bool create)
FindInside	src/addressmap-inl.h	/^  const Value* FindInside(ValueSizeFunc size_func, size_t max_size,$/;"	p	class:AddressMap	access:public	signature:(ValueSizeFunc size_func, size_t max_size, Key key, Key* res_key)
FindInside	src/addressmap-inl.h	/^const Value* AddressMap<Value>::FindInside(ValueSizeFunc size_func,$/;"	f	class:AddressMap	signature:(ValueSizeFunc size_func, size_t max_size, Key key, Key* res_key)
FindInsideAlloc	src/heap-profile-table.cc	/^bool HeapProfileTable::FindInsideAlloc(const void* ptr,$/;"	f	class:HeapProfileTable	signature:(const void* ptr, size_t max_size, const void** object_ptr, size_t* object_size) const
FindInsideAlloc	src/heap-profile-table.h	/^  bool FindInsideAlloc(const void* ptr, size_t max_size,$/;"	p	class:HeapProfileTable	access:public	signature:(const void* ptr, size_t max_size, const void** object_ptr, size_t* object_size) const
FindMutable	src/addressmap-inl.h	/^  inline Value* FindMutable(Key key);$/;"	p	class:AddressMap	access:public	signature:(Key key)
FindMutable	src/addressmap-inl.h	/^inline Value* AddressMap<Value>::FindMutable(Key key) {$/;"	f	class:AddressMap	signature:(Key key)
FindRegion	src/memory_region_map.cc	/^bool MemoryRegionMap::FindRegion(uintptr_t addr, Region* result) {$/;"	f	class:MemoryRegionMap	signature:(uintptr_t addr, Region* result)
FindRegion	src/memory_region_map.h	/^  static bool FindRegion(uintptr_t addr, Region* result);$/;"	p	class:MemoryRegionMap	access:public	signature:(uintptr_t addr, Region* result)
FixupPrivEndLocked	src/malloc_hook-inl.h	/^  void FixupPrivEndLocked();$/;"	p	struct:base::internal::HookList	access:public	signature:()
FixupPrivEndLocked	src/malloc_hook.cc	/^void HookList<T>::FixupPrivEndLocked() {$/;"	f	class:base::internal::HookList	signature:()
FlushEvicted	src/profiledata.cc	/^void ProfileData::FlushEvicted() {$/;"	f	class:ProfileData	signature:()
FlushEvicted	src/profiledata.h	/^  void FlushEvicted();$/;"	p	class:ProfileData	access:private	signature:()
FlushTable	src/profiledata.cc	/^void ProfileData::FlushTable() {$/;"	f	class:ProfileData	signature:()
FlushTable	src/profiledata.h	/^  void FlushTable();$/;"	p	class:ProfileData	access:public	signature:()
FlushTable	src/profiler.cc	/^  void FlushTable();$/;"	p	class:CpuProfiler	file:	access:public	signature:()
FlushTable	src/profiler.cc	/^void CpuProfiler::FlushTable() {$/;"	f	class:CpuProfiler	signature:()
FormatLine	src/base/sysinfo.cc	/^int ProcMapsIterator::FormatLine(char* buffer, int bufsize,$/;"	f	class:ProcMapsIterator	signature:(char* buffer, int bufsize, uint64 start, uint64 end, const char *flags, uint64 offset, int64 inode, const char *filename, dev_t dev)
FormatLine	src/base/sysinfo.h	/^  static int FormatLine(char* buffer, int bufsize,$/;"	p	class:ProcMapsIterator	access:public	signature:(char* buffer, int bufsize, uint64 start, uint64 end, const char *flags, uint64 offset, int64 inode, const char *filename, dev_t dev)
Foundation	INSTALL	/^Foundation, Inc.$/;"	v
Foundation	m4/libtool.m4	/^Copyright (C) 2008 Free Software Foundation, Inc.$/;"	v
Frame	src/base/elfcore.h	/^  typedef struct Frame {$/;"	s
Frame	src/base/elfcore.h	/^  } Frame;$/;"	t	typeref:struct:Frame
Frame::arm	src/base/elfcore.h	/^    struct arm_regs arm;$/;"	m	struct:Frame	typeref:struct:Frame::arm_regs	access:public
Frame::errno_	src/base/elfcore.h	/^    int              errno_;$/;"	m	struct:Frame	access:public
Frame::errno_	src/base/elfcore.h	/^    int             errno_;$/;"	m	struct:Frame	access:public
Frame::mips_regs	src/base/elfcore.h	/^    struct mips_regs mips_regs;$/;"	m	struct:Frame	typeref:struct:Frame::mips_regs	access:public
Frame::tid	src/base/elfcore.h	/^    pid_t            tid;$/;"	m	struct:Frame	access:public
Frame::tid	src/base/elfcore.h	/^    pid_t           tid;$/;"	m	struct:Frame	access:public
Frame::tid	src/base/elfcore.h	/^    pid_t tid;$/;"	m	struct:Frame	access:public
Frame::uregs	src/base/elfcore.h	/^    struct i386_regs uregs;$/;"	m	struct:Frame	typeref:struct:Frame::i386_regs	access:public
Francis	src/windows/shortproc.asm	/^; Author: Scott Francis$/;"	v
Free	src/base/low_level_alloc.cc	/^void LowLevelAlloc::Free(void *v) {$/;"	f	class:LowLevelAlloc	signature:(void *v)
Free	src/heap-checker.cc	/^  static void Free(void* p) {$/;"	f	class:HeapLeakChecker::Allocator	access:public	signature:(void* p)
Free	src/heap-checker.cc	/^  static void Free(void* p, size_t \/* n *\/) {$/;"	f	class:HeapLeakChecker::Allocator	access:public	signature:(void* p, size_t )
Free	src/memory_region_map.h	/^    static void Free(const void *p, size_t \/* n *\/) {$/;"	f	struct:MemoryRegionMap::MyAllocator	access:public	signature:(const void *p, size_t )
FreeHook	src/tests/low_level_alloc_unittest.cc	/^static void FreeHook(const void *p) {$/;"	f	file:	signature:(const void *p)
FreeList	src/thread_cache.h	/^  class FreeList {$/;"	c	class:tcmalloc::ThreadCache	access:private
FreeListInfo	src/gperftools/malloc_extension.h	/^  struct FreeListInfo {$/;"	s	class:MallocExtension	access:public
FreeObject	src/tests/tcmalloc_unittest.cc	/^  void FreeObject() {$/;"	f	class:testing::TesterThread	access:public	signature:()
FreePreambleBlock	src/windows/preamble_patcher.cc	/^void PreamblePatcher::FreePreambleBlock(unsigned char* block) {$/;"	f	class:sidestep::PreamblePatcher	signature:(unsigned char* block)
FreePreambleBlock	src/windows/preamble_patcher.h	/^  static void FreePreambleBlock(unsigned char* block);$/;"	p	class:sidestep::PreamblePatcher	access:public	signature:(unsigned char* block)
FreeQueue	src/debugallocation.cc	/^  FreeQueue() : q_front_(0), q_back_(0) {}$/;"	f	class:FreeQueue	access:public	signature:()
FreeQueue	src/debugallocation.cc	/^class FreeQueue {$/;"	c	file:
FreeQueue::FreeQueue	src/debugallocation.cc	/^  FreeQueue() : q_front_(0), q_back_(0) {}$/;"	f	class:FreeQueue	access:public	signature:()
FreeQueue::Full	src/debugallocation.cc	/^  bool Full() {$/;"	f	class:FreeQueue	access:public	signature:()
FreeQueue::Pop	src/debugallocation.cc	/^  QueueEntry Pop() {$/;"	f	class:FreeQueue	access:public	signature:()
FreeQueue::Push	src/debugallocation.cc	/^  void Push(const QueueEntry& block) {$/;"	f	class:FreeQueue	access:public	signature:(const QueueEntry& block)
FreeQueue::kFreeQueueSize	src/debugallocation.cc	/^  static const int kFreeQueueSize = 1024;$/;"	m	class:FreeQueue	file:	access:private
FreeQueue::q_	src/debugallocation.cc	/^  QueueEntry q_[kFreeQueueSize];$/;"	m	class:FreeQueue	file:	access:private
FreeQueue::q_back_	src/debugallocation.cc	/^  int q_back_;$/;"	m	class:FreeQueue	file:	access:private
FreeQueue::q_front_	src/debugallocation.cc	/^  int q_front_;$/;"	m	class:FreeQueue	file:	access:private
FreeQueue::size	src/debugallocation.cc	/^  size_t size() const {$/;"	f	class:FreeQueue	access:public	signature:() const
FreeQueueSize	src/debugallocation.cc	/^  static size_t FreeQueueSize() {$/;"	f	class:MallocBlock	access:public	signature:()
FreeTestSTLAllocInverse	src/tests/heap-checker_unittest.cc	/^static void FreeTestSTLAllocInverse(IntSet** setx) {$/;"	f	file:	signature:(IntSet** setx)
FromRawPointer	src/debugallocation.cc	/^  static MallocBlock* FromRawPointer(void* p) {$/;"	f	class:MallocBlock	access:public	signature:(void* p)
FromRawPointer	src/debugallocation.cc	/^  static const MallocBlock* FromRawPointer(const void* p) {$/;"	f	class:MallocBlock	access:public	signature:(const void* p)
Ft	src/tests/frag_unittest-frag_unittest.o	/^y/;"	v
Ft	src/tests/heap_profiler_debug_unittest-heap-profiler_unittest.o	/^/;"	v
Ft	src/tests/heap_profiler_unittest-heap-profiler_unittest.o	/^/;"	v
Full	src/debugallocation.cc	/^  bool Full() {$/;"	f	class:FreeQueue	access:public	signature:()
FunctionAndId	src/tests/testutil.cc	/^struct FunctionAndId {$/;"	s	file:
FunctionAndId::id	src/tests/testutil.cc	/^  int id;$/;"	m	struct:FunctionAndId	file:	access:public
FunctionAndId::ptr_to_function	src/tests/testutil.cc	/^  void (*ptr_to_function)(int);$/;"	m	struct:FunctionAndId	file:	access:public
FunctionInfo	src/windows/patch_functions.cc	/^  struct FunctionInfo {$/;"	s	class:__anon13::WindowsInfo	file:	access:private
FunctionSignature	src/tests/heap-checker_unittest.cc	/^  typedef void (*FunctionSignature)();$/;"	t	class:Callback0	file:	access:public
FunctionSignature	src/tests/heap-checker_unittest.cc	/^  typedef void (*FunctionSignature)(P1);$/;"	t	class:Callback1	file:	access:public
FunctionSignature	src/tests/heap-checker_unittest.cc	/^  typedef void (*FunctionSignature)(P1,P2);$/;"	t	class:Callback2	file:	access:public
G	benchmark/unwind_bench-getcontext_light.o	/^/;"	v
G	src/.libs/libtcmalloc_internal_la-internal_logging.o	/^/;"	v
G	src/libtcmalloc_internal_la-internal_logging.o	/^/;"	v
G	src/tests/markidle_unittest-testutil.o	/^/;"	v
G	src/tests/memalign_debug_unittest-testutil.o	/^/;"	v
G	src/tests/memalign_unittest-testutil.o	/^/;"	v
G	src/tests/tcmalloc_and_profiler_unittest-testutil.o	/^/;"	v
G	src/tests/tcmalloc_both_unittest-testutil.o	/^/;"	v
G	src/tests/tcmalloc_debug_unittest-testutil.o	/^/;"	v
G	src/tests/tcmalloc_minimal_debug_unittest-testutil.o	/^/;"	v
G	src/tests/tcmalloc_minimal_unittest-testutil.o	/^/;"	v
G	src/tests/tcmalloc_unittest-testutil.o	/^/;"	v
G	src/tests/thread_dealloc_unittest-testutil.o	/^/;"	v
GCC_VERSION	src/base/atomicops.h	101;"	d
GDB	docs/heap_checker.html	/^running under GDB, because the ptrace functionality needed for finding$/;"	v
GETDENTS	src/base/linux_syscall_support.h	2472;"	d
GETENV_SAFE_H	src/getenv_safe.h	33;"	d
GET_STACK_TRACE_OR_FRAMES	src/stacktrace_impl_setup-inl.h	49;"	d
GET_STACK_TRACE_OR_FRAMES	src/stacktrace_impl_setup-inl.h	54;"	d
GET_STACK_TRACE_OR_FRAMES	src/stacktrace_impl_setup-inl.h	58;"	d
GET_STACK_TRACE_OR_FRAMES	src/stacktrace_impl_setup-inl.h	63;"	d
GET_STACK_TRACE_OR_FRAMES	src/stacktrace_impl_setup-inl.h	67;"	d
GET_STACK_TRACE_OR_FRAMES	src/stacktrace_impl_setup-inl.h	73;"	d
GET_STACK_TRACE_OR_FRAMES	src/stacktrace_impl_setup-inl.h	77;"	d
GET_STACK_TRACE_OR_FRAMES	src/stacktrace_impl_setup-inl.h	83;"	d
GG_ULONGLONG	src/tests/atomicops_unittest.cc	39;"	d	file:
GLOB_NOMATCH	src/heap-profile-table.cc	45;"	d	file:
GOOGLE_BASE_WINDOWS_H_	src/windows/port.h	42;"	d
GOOGLE_MAYBE_THREADS_H_	src/maybe_threads.h	40;"	d
GOOGLE_MAYBE_THREADS_H_	src/windows/port.h	146;"	d
GOOGLE_MUTEX_H_	src/base/simple_mutex.h	106;"	d
GOOGLE_PERFTOOLS_MINI_DISASSEMBLER_H_	src/windows/mini_disassembler.h	38;"	d
GOOGLE_PERFTOOLS_MINI_DISASSEMBLER_TYPES_H_	src/windows/mini_disassembler_types.h	39;"	d
GOOGLE_PERFTOOLS_PREAMBLE_PATCHER_H_	src/windows/preamble_patcher.h	39;"	d
GOOGLE_PERFTOOLS_WINDOWS_CONFIG_H_	src/windows/config.h	13;"	d
GOOGLE_PERFTOOLS_WINDOWS_CONFIG_H_	src/windows/config.h	17;"	d
GOOGLE_PERFTOOLS_WINDOWS_MINGW_H_	src/windows/mingw.h	40;"	d
GOOGLE_STACKTRACE_H_	src/gperftools/stacktrace.h	38;"	d
GPERFTOOLS_CONFIG_H_	configure.ac	602;"	d	file:
GPERFTOOLS_CONFIG_H_	src/config.h	6;"	d
GPERFTOOLS_CONFIG_H_	src/config.h.in	5;"	d	file:
GPERFTOOLS_CONFIG_H_	src/windows/config.h	19;"	d
GPERFTOOLS_SUPPRESS_LEGACY_WARNING	src/tests/simple_compat_test.cc	42;"	d	file:
GPRIuPTHREAD	src/base/basictypes.h	112;"	d
GPRIxPTHREAD	src/base/basictypes.h	113;"	d
GROWS_TOWARDS_HIGH_ADDRESSES	src/heap-checker.cc	/^  GROWS_TOWARDS_HIGH_ADDRESSES,$/;"	e	enum:StackDirection	file:
GROWS_TOWARDS_LOW_ADDRESSES	src/heap-checker.cc	/^  GROWS_TOWARDS_LOW_ADDRESSES,$/;"	e	enum:StackDirection	file:
GST_SUFFIX	src/stacktrace.cc	107;"	d	file:
GST_SUFFIX	src/stacktrace.cc	109;"	d	file:
GST_SUFFIX	src/stacktrace.cc	116;"	d	file:
GST_SUFFIX	src/stacktrace.cc	118;"	d	file:
GST_SUFFIX	src/stacktrace.cc	129;"	d	file:
GST_SUFFIX	src/stacktrace.cc	131;"	d	file:
GST_SUFFIX	src/stacktrace.cc	138;"	d	file:
GST_SUFFIX	src/stacktrace.cc	140;"	d	file:
GST_SUFFIX	src/stacktrace.cc	147;"	d	file:
GST_SUFFIX	src/stacktrace.cc	149;"	d	file:
GST_SUFFIX	src/stacktrace.cc	158;"	d	file:
GST_SUFFIX	src/stacktrace.cc	160;"	d	file:
GST_SUFFIX	src/stacktrace.cc	87;"	d	file:
GST_SUFFIX	src/stacktrace.cc	89;"	d	file:
GST_SUFFIX	src/stacktrace.cc	96;"	d	file:
GST_SUFFIX	src/stacktrace.cc	98;"	d	file:
GUARDED_BY	src/base/thread_annotations.h	63;"	d
GUARDED_BY	src/memory_region_map.h	/^  static HeapProfileBucket saved_buckets_[20] GUARDED_BY(lock_);$/;"	p	class:MemoryRegionMap	access:private	signature:(lock_)
GUARDED_BY	src/memory_region_map.h	/^  static HeapProfileBucket** bucket_table_ GUARDED_BY(lock_);$/;"	p	class:MemoryRegionMap	access:private	signature:(lock_)
GUARDED_BY	src/memory_region_map.h	/^  static const void* saved_buckets_keys_[20][kMaxStackDepth] GUARDED_BY(lock_);$/;"	p	class:MemoryRegionMap	access:private	signature:(lock_)
GUARDED_BY	src/memory_region_map.h	/^  static int num_buckets_ GUARDED_BY(lock_);$/;"	p	class:MemoryRegionMap	access:private	signature:(lock_)
GUARDED_BY	src/memory_region_map.h	/^  static int saved_buckets_count_ GUARDED_BY(lock_);$/;"	p	class:MemoryRegionMap	access:private	signature:(lock_)
GUARDED_BY	src/profile-handler.cc	/^  CallbackList callbacks_ GUARDED_BY(signal_lock_);$/;"	p	class:ProfileHandler	file:	access:private	signature:(signal_lock_)
GUARDED_BY	src/profile-handler.cc	/^  int32 callback_count_ GUARDED_BY(control_lock_);$/;"	p	class:ProfileHandler	file:	access:private	signature:(control_lock_)
GUARDED_BY	src/profile-handler.cc	/^  int64 interrupts_ GUARDED_BY(signal_lock_);$/;"	p	class:ProfileHandler	file:	access:private	signature:(signal_lock_)
GUARDED_VAR	src/base/thread_annotations.h	64;"	d
GV	src/pprof	/^my @GV = ("gv");$/;"	v
GenericFnPtr	src/windows/patch_functions.cc	/^typedef void (*GenericFnPtr)();$/;"	t	namespace:__anon13	file:
GetAggressiveDecommit	src/page_heap.h	/^  bool GetAggressiveDecommit(void) {return aggressive_decommit_;}$/;"	f	class:tcmalloc::PageHeap	access:public	signature:(void)
GetAllocCaller	src/gperftools/heap-checker.h	/^  static const void* GetAllocCaller(void* ptr);$/;"	p	class:HeapLeakChecker	access:private	signature:(void* ptr)
GetAllocCaller	src/heap-checker.cc	/^const void* HeapLeakChecker::GetAllocCaller(void* ptr) {$/;"	f	class:HeapLeakChecker	signature:(void* ptr)
GetAllocatedSize	src/debugallocation.cc	/^  virtual size_t GetAllocatedSize(const void* p) {$/;"	f	class:DebugMallocImplementation	access:public	signature:(const void* p)
GetAllocatedSize	src/gperftools/malloc_extension.h	/^  virtual size_t GetAllocatedSize(const void* p);$/;"	p	class:MallocExtension	access:public	signature:(const void* p)
GetAllocatedSize	src/malloc_extension.cc	/^size_t MallocExtension::GetAllocatedSize(const void* p) {$/;"	f	class:MallocExtension	signature:(const void* p)
GetAllocatedSize	src/tcmalloc.cc	/^  virtual size_t GetAllocatedSize(const void* ptr);$/;"	p	class:TCMallocImplementation	file:	access:public	signature:(const void* ptr)
GetAllocatedSize	src/tcmalloc.cc	/^size_t TCMallocImplementation::GetAllocatedSize(const void* ptr) {$/;"	f	class:TCMallocImplementation	signature:(const void* ptr)
GetBucket	src/heap-profile-table.cc	/^HeapProfileTable::Bucket* HeapProfileTable::GetBucket(int depth,$/;"	f	class:HeapProfileTable	signature:(int depth, const void* const key[])
GetBucket	src/heap-profile-table.h	/^  Bucket* GetBucket(int depth, const void* const key[]);$/;"	p	class:HeapProfileTable	access:private	signature:(int depth, const void* const key[])
GetBucket	src/memory_region_map.cc	/^HeapProfileBucket* MemoryRegionMap::GetBucket(int depth,$/;"	f	class:MemoryRegionMap	signature:(int depth, const void* const key[])
GetBucket	src/memory_region_map.h	/^  static HeapProfileBucket* GetBucket(int depth, const void* const key[]);$/;"	p	class:MemoryRegionMap	access:public	signature:(int depth, const void* const key[])
GetCache	src/thread_cache.h	/^  static ThreadCache* GetCache();$/;"	p	class:tcmalloc::ThreadCache	access:public	signature:()
GetCache	src/thread_cache.h	/^inline ThreadCache* ThreadCache::GetCache() {$/;"	f	class:tcmalloc::ThreadCache	signature:()
GetCacheIfPresent	src/thread_cache.h	/^  static ThreadCache* GetCacheIfPresent();$/;"	p	class:tcmalloc::ThreadCache	access:public	signature:()
GetCacheIfPresent	src/thread_cache.h	/^inline ThreadCache* ThreadCache::GetCacheIfPresent() {$/;"	f	class:tcmalloc::ThreadCache	signature:()
GetCacheWhichMustBePresent	src/thread_cache.h	/^  static ThreadCache* GetCacheWhichMustBePresent();$/;"	p	class:tcmalloc::ThreadCache	access:public	signature:()
GetCacheWhichMustBePresent	src/thread_cache.h	/^inline ThreadCache* ThreadCache::GetCacheWhichMustBePresent() {$/;"	f	class:tcmalloc::ThreadCache	signature:()
GetCallbackCount	src/tests/profile-handler_unittest.cc	/^  uint32 GetCallbackCount() {$/;"	f	class:__anon56::ProfileHandlerTest	access:protected	signature:()
GetCallerStackTrace	src/gperftools/malloc_hook.h	/^  inline static int GetCallerStackTrace(void** result, int max_depth,$/;"	f	class:MallocHook	access:public	signature:(void** result, int max_depth, int skip_count)
GetCallerStackTrace	src/heap-profile-table.cc	/^int HeapProfileTable::GetCallerStackTrace($/;"	f	class:HeapProfileTable	signature:( int skip_count, void* stack[kMaxStackDepth])
GetCallerStackTrace	src/heap-profile-table.h	/^  static int GetCallerStackTrace(int skip_count, void* stack[kMaxStackDepth]);$/;"	p	class:HeapProfileTable	access:public	signature:(int skip_count, void* stack[kMaxStackDepth])
GetCurrentState	src/profiledata.cc	/^void ProfileData::GetCurrentState(State* state) const {$/;"	f	class:ProfileData	signature:(State* state) const
GetCurrentState	src/profiledata.h	/^  void GetCurrentState(State* state) const;$/;"	p	class:ProfileData	access:public	signature:(State* state) const
GetCurrentState	src/profiler.cc	/^  void GetCurrentState(ProfilerState* state);$/;"	p	class:CpuProfiler	file:	access:public	signature:(ProfilerState* state)
GetCurrentState	src/profiler.cc	/^void CpuProfiler::GetCurrentState(ProfilerState* state) {$/;"	f	class:CpuProfiler	signature:(ProfilerState* state)
GetDefaultPagesAllocator	src/base/low_level_alloc.cc	/^LowLevelAlloc::PagesAllocator *LowLevelAlloc::GetDefaultPagesAllocator(void) {$/;"	f	class:LowLevelAlloc	signature:(void)
GetDefaultPagesAllocator	src/base/low_level_alloc.h	/^  static PagesAllocator *GetDefaultPagesAllocator(void);$/;"	p	class:LowLevelAlloc	access:public	signature:(void)
GetDeleteHook	src/gperftools/malloc_hook.h	/^  inline static DeleteHook GetDeleteHook();$/;"	p	class:MallocHook	access:public	signature:()
GetDeleteHook	src/malloc_hook-inl.h	/^inline MallocHook::DeleteHook MallocHook::GetDeleteHook() {$/;"	f	class:MallocHook	signature:()
GetDescriptor	src/page_heap.h	/^  Span* GetDescriptor(PageID p) const {$/;"	f	class:tcmalloc::PageHeap	access:public	signature:(PageID p) const
GetDisableChecksStart	src/gperftools/heap-checker.h	/^  static void* GetDisableChecksStart();$/;"	p	class:HeapLeakChecker	access:private	signature:()
GetDynsym	src/base/elf_mem_image.cc	/^const ElfW(Sym) *ElfMemImage::GetDynsym(int index) const {$/;"	f	class:base::ElfMemImage	signature:(int index) const
GetDynsym	src/base/elf_mem_image.h	/^  const ElfW(Sym)*     GetDynsym(int index) const;$/;"	p	class:base::ElfMemImage	access:public	signature:(int index) const
GetEstimatedAllocatedSize	src/debugallocation.cc	/^  virtual size_t GetEstimatedAllocatedSize(size_t size) {$/;"	f	class:DebugMallocImplementation	access:public	signature:(size_t size)
GetEstimatedAllocatedSize	src/gperftools/malloc_extension.h	/^  virtual size_t GetEstimatedAllocatedSize(size_t size);$/;"	p	class:MallocExtension	access:public	signature:(size_t size)
GetEstimatedAllocatedSize	src/malloc_extension.cc	/^size_t MallocExtension::GetEstimatedAllocatedSize(size_t size) {$/;"	f	class:MallocExtension	signature:(size_t size)
GetEstimatedAllocatedSize	src/tcmalloc.cc	/^  virtual size_t GetEstimatedAllocatedSize(size_t size);$/;"	p	class:TCMallocImplementation	file:	access:public	signature:(size_t size)
GetEstimatedAllocatedSize	src/tcmalloc.cc	/^size_t TCMallocImplementation::GetEstimatedAllocatedSize(size_t size) {$/;"	f	class:TCMallocImplementation	signature:(size_t size)
GetFastPathCache	src/thread_cache.h	/^  static ThreadCache* GetFastPathCache();$/;"	p	class:tcmalloc::ThreadCache	access:public	signature:()
GetFastPathCache	src/thread_cache.h	/^inline ThreadCache* ThreadCache::GetFastPathCache() {$/;"	f	class:tcmalloc::ThreadCache	signature:()
GetFreeListSizes	src/debugallocation.cc	/^  virtual void GetFreeListSizes(vector<MallocExtension::FreeListInfo>* v) {$/;"	f	class:DebugMallocImplementation	access:public	signature:(vector<MallocExtension::FreeListInfo>* v)
GetFreeListSizes	src/gperftools/malloc_extension.h	/^  virtual void GetFreeListSizes(std::vector<FreeListInfo>* v);$/;"	p	class:MallocExtension	access:public	signature:(std::vector<FreeListInfo>* v)
GetFreeListSizes	src/malloc_extension.cc	/^void MallocExtension::GetFreeListSizes($/;"	f	class:MallocExtension	signature:( vector<MallocExtension::FreeListInfo>* v)
GetFreeListSizes	src/tcmalloc.cc	/^  virtual void GetFreeListSizes(vector<MallocExtension::FreeListInfo>* v) {$/;"	f	class:TCMallocImplementation	access:public	signature:(vector<MallocExtension::FreeListInfo>* v)
GetFunctionAddress	src/tests/heap-checker_unittest.cc	/^static inline uintptr_t GetFunctionAddress (void* (*func)(uintptr_t*))$/;"	f	file:	signature:(void* (*func)(uintptr_t*))
GetHeapGrowthStacks	src/gperftools/malloc_extension.h	/^  virtual void GetHeapGrowthStacks(MallocExtensionWriter* writer);$/;"	p	class:MallocExtension	access:public	signature:(MallocExtensionWriter* writer)
GetHeapGrowthStacks	src/malloc_extension.cc	/^void MallocExtension::GetHeapGrowthStacks(MallocExtensionWriter* writer) {$/;"	f	class:MallocExtension	signature:(MallocExtensionWriter* writer)
GetHeapProfile	src/gperftools/heap-profiler.h	/^PERFTOOLS_DLL_DECL char* GetHeapProfile();$/;"	p	signature:()
GetHeapProfile	src/heap-profiler.cc	/^extern "C" char* GetHeapProfile() {$/;"	f	signature:()
GetHeapSample	src/gperftools/malloc_extension.h	/^  virtual void GetHeapSample(MallocExtensionWriter* writer);$/;"	p	class:MallocExtension	access:public	signature:(MallocExtensionWriter* writer)
GetHeapSample	src/malloc_extension.cc	/^void MallocExtension::GetHeapSample(MallocExtensionWriter* writer) {$/;"	f	class:MallocExtension	signature:(MallocExtensionWriter* writer)
GetHeapSample	src/tcmalloc.cc	/^  virtual void GetHeapSample(MallocExtensionWriter* writer) {$/;"	f	class:TCMallocImplementation	access:public	signature:(MallocExtensionWriter* writer)
GetInterruptCount	src/tests/profile-handler_unittest.cc	/^  uint64 GetInterruptCount() {$/;"	f	class:__anon56::ProfileHandlerTest	access:protected	signature:()
GetLargeSpanStats	src/page_heap.cc	/^void PageHeap::GetLargeSpanStats(LargeSpanStats* result) {$/;"	f	class:tcmalloc::PageHeap	signature:(LargeSpanStats* result)
GetLargeSpanStats	src/page_heap.h	/^  void GetLargeSpanStats(LargeSpanStats* result);$/;"	p	class:tcmalloc::PageHeap	access:public	signature:(LargeSpanStats* result)
GetMemoryReleaseRate	src/gperftools/malloc_extension.h	/^  virtual double GetMemoryReleaseRate();$/;"	p	class:MallocExtension	access:public	signature:()
GetMemoryReleaseRate	src/malloc_extension.cc	/^double MallocExtension::GetMemoryReleaseRate() {$/;"	f	class:MallocExtension	signature:()
GetMemoryReleaseRate	src/tcmalloc.cc	/^  virtual double GetMemoryReleaseRate() {$/;"	f	class:TCMallocImplementation	access:public	signature:()
GetMmapHook	src/gperftools/malloc_hook.h	/^  inline static MmapHook GetMmapHook();$/;"	p	class:MallocHook	access:public	signature:()
GetMmapHook	src/malloc_hook-inl.h	/^inline MallocHook::MmapHook MallocHook::GetMmapHook() {$/;"	f	class:MallocHook	signature:()
GetMremapHook	src/gperftools/malloc_hook.h	/^  inline static MremapHook GetMremapHook();$/;"	p	class:MallocHook	access:public	signature:()
GetMremapHook	src/malloc_hook-inl.h	/^inline MallocHook::MremapHook MallocHook::GetMremapHook() {$/;"	f	class:MallocHook	signature:()
GetMunmapHook	src/gperftools/malloc_hook.h	/^  inline static MunmapHook GetMunmapHook();$/;"	p	class:MallocHook	access:public	signature:()
GetMunmapHook	src/malloc_hook-inl.h	/^inline MallocHook::MunmapHook MallocHook::GetMunmapHook() {$/;"	f	class:MallocHook	signature:()
GetNewHook	src/gperftools/malloc_hook.h	/^  inline static NewHook GetNewHook();$/;"	p	class:MallocHook	access:public	signature:()
GetNewHook	src/malloc_hook-inl.h	/^inline MallocHook::NewHook MallocHook::GetNewHook() {$/;"	f	class:MallocHook	signature:()
GetNextRange	src/page_heap.cc	/^bool PageHeap::GetNextRange(PageID start, base::MallocRange* r) {$/;"	f	class:tcmalloc::PageHeap	signature:(PageID start, base::MallocRange* r)
GetNextRange	src/page_heap.h	/^  bool GetNextRange(PageID start, base::MallocRange* r);$/;"	p	class:tcmalloc::PageHeap	access:public	signature:(PageID start, base::MallocRange* r)
GetNumSymbols	src/base/elf_mem_image.cc	/^int ElfMemImage::GetNumSymbols() const {$/;"	f	class:base::ElfMemImage	signature:() const
GetNumSymbols	src/base/elf_mem_image.h	/^  int                  GetNumSymbols() const;$/;"	p	class:base::ElfMemImage	access:public	signature:() const
GetNumericProperty	docs/tcmalloc.html	/^   MallocExtension::instance()->GetNumericProperty(property_name, &value);$/;"	p	class:object::structure	file:	access:private	signature:(property_name, &value)
GetNumericProperty	src/debugallocation.cc	/^  virtual bool GetNumericProperty(const char* name, size_t* value) {$/;"	f	class:DebugMallocImplementation	access:public	signature:(const char* name, size_t* value)
GetNumericProperty	src/gperftools/malloc_extension.h	/^  virtual bool GetNumericProperty(const char* property, size_t* value);$/;"	p	class:MallocExtension	access:public	signature:(const char* property, size_t* value)
GetNumericProperty	src/malloc_extension.cc	/^bool MallocExtension::GetNumericProperty(const char* property, size_t* value) {$/;"	f	class:MallocExtension	signature:(const char* property, size_t* value)
GetNumericProperty	src/tcmalloc.cc	/^  virtual bool GetNumericProperty(const char* name, size_t* value) {$/;"	f	class:TCMallocImplementation	access:public	signature:(const char* name, size_t* value)
GetOwnership	src/debugallocation.cc	/^  virtual MallocExtension::Ownership GetOwnership(const void* p) {$/;"	f	class:DebugMallocImplementation	access:public	signature:(const void* p)
GetOwnership	src/gperftools/malloc_extension.h	/^  virtual Ownership GetOwnership(const void* p);$/;"	p	class:MallocExtension	access:public	signature:(const void* p)
GetOwnership	src/malloc_extension.cc	/^MallocExtension::Ownership MallocExtension::GetOwnership(const void* p) {$/;"	f	class:MallocExtension	signature:(const void* p)
GetOwnership	src/tcmalloc.cc	/^  virtual Ownership GetOwnership(const void* ptr) {$/;"	f	class:TCMallocImplementation	access:public	signature:(const void* ptr)
GetPC	src/getpc.h	/^inline void* GetPC(const struct ucontext_t& signal_ucontext) {$/;"	f	signature:(const struct ucontext_t& signal_ucontext)
GetPC	src/getpc.h	/^inline void* GetPC(const ucontext_t& signal_ucontext) {$/;"	f	signature:(const ucontext_t& signal_ucontext)
GetPhdr	src/base/elf_mem_image.cc	/^const ElfW(Phdr) *ElfMemImage::GetPhdr(int index) const {$/;"	f	class:base::ElfMemImage	signature:(int index) const
GetPhdr	src/base/elf_mem_image.h	/^  const ElfW(Phdr)*    GetPhdr(int index) const;$/;"	p	class:base::ElfMemImage	access:public	signature:(int index) const
GetPreMmapHook	src/gperftools/malloc_hook.h	/^  inline static PreMmapHook GetPreMmapHook();$/;"	p	class:MallocHook	access:public	signature:()
GetPreMmapHook	src/malloc_hook-inl.h	/^inline MallocHook::PreMmapHook MallocHook::GetPreMmapHook() {$/;"	f	class:MallocHook	signature:()
GetPreSbrkHook	src/gperftools/malloc_hook.h	/^  inline static PreSbrkHook GetPreSbrkHook();$/;"	p	class:MallocHook	access:public	signature:()
GetPreSbrkHook	src/malloc_hook-inl.h	/^inline MallocHook::PreSbrkHook MallocHook::GetPreSbrkHook() {$/;"	f	class:MallocHook	signature:()
GetProgramInvocationName	src/symbolize.cc	/^static const char* GetProgramInvocationName() {$/;"	f	file:	signature:()
GetRunningOnValgrind	src/base/dynamic_annotations.c	/^static int GetRunningOnValgrind(void) {$/;"	f	file:	signature:(void)
GetSamplePeriod	src/sampler.cc	/^int Sampler::GetSamplePeriod() {$/;"	f	class:tcmalloc::Sampler	signature:()
GetSamplePeriod	src/sampler.h	/^  static int GetSamplePeriod();$/;"	p	class:tcmalloc::Sampler	access:public	signature:()
GetSamplePeriod	src/thread_cache.cc	/^int ThreadCache::GetSamplePeriod() {$/;"	f	class:tcmalloc::ThreadCache	signature:()
GetSamplePeriod	src/thread_cache.h	/^  int GetSamplePeriod();$/;"	p	class:tcmalloc::ThreadCache	access:public	signature:()
GetSbrkHook	src/gperftools/malloc_hook.h	/^  inline static SbrkHook GetSbrkHook();$/;"	p	class:MallocHook	access:public	signature:()
GetSbrkHook	src/malloc_hook-inl.h	/^inline MallocHook::SbrkHook MallocHook::GetSbrkHook() {$/;"	f	class:MallocHook	signature:()
GetSingular	src/malloc_hook-inl.h	/^  T GetSingular() const {$/;"	f	struct:base::internal::HookList	access:public	signature:() const
GetSizeClass	src/common.h	/^  inline bool ATTRIBUTE_ALWAYS_INLINE GetSizeClass(size_t size, uint32* cl) {$/;"	f	class:tcmalloc::SizeMap	access:public	signature:(size_t size, uint32* cl)
GetSizeClassOrZero	src/page_heap.h	/^  uint32 GetSizeClassOrZero(PageID p) const {$/;"	f	class:tcmalloc::PageHeap	access:public	signature:(PageID p) const
GetSizeWithCallback	src/tcmalloc.cc	/^inline size_t GetSizeWithCallback(const void* ptr,$/;"	f	namespace:__anon3	signature:(const void* ptr, size_t (*invalid_getsize_fn)(const void*))
GetSmallSpanStats	src/page_heap.cc	/^void PageHeap::GetSmallSpanStats(SmallSpanStats* result) {$/;"	f	class:tcmalloc::PageHeap	signature:(SmallSpanStats* result)
GetSmallSpanStats	src/page_heap.h	/^  void GetSmallSpanStats(SmallSpanStats* result);$/;"	p	class:tcmalloc::PageHeap	access:public	signature:(SmallSpanStats* result)
GetStackDirection	src/heap-checker.cc	/^static StackDirection ATTRIBUTE_NOINLINE GetStackDirection($/;"	f	file:	signature:( const uintptr_t *const ptr)
GetStackFrames	src/gperftools/stacktrace.h	/^extern PERFTOOLS_DLL_DECL int GetStackFrames(void** result, int* sizes, int max_depth,$/;"	p	signature:(void** result, int* sizes, int max_depth, int skip_count)
GetStackFrames	src/stacktrace.cc	/^PERFTOOLS_DLL_DECL int GetStackFrames(void** result, int* sizes, int max_depth,$/;"	f	signature:(void** result, int* sizes, int max_depth, int skip_count)
GetStackFramesPtr	src/stacktrace.cc	/^  int (*GetStackFramesPtr)(void** result, int* sizes, int max_depth,$/;"	m	struct:GetStackImplementation	file:	access:public
GetStackFramesWithContext	src/gperftools/stacktrace.h	/^extern PERFTOOLS_DLL_DECL int GetStackFramesWithContext(void** result, int* sizes, int max_depth,$/;"	p	signature:(void** result, int* sizes, int max_depth, int skip_count, const void *uc)
GetStackFramesWithContext	src/stacktrace.cc	/^PERFTOOLS_DLL_DECL int GetStackFramesWithContext(void** result, int* sizes, int max_depth,$/;"	f	signature:(void** result, int* sizes, int max_depth, int skip_count, const void *uc)
GetStackFramesWithContextPtr	src/stacktrace.cc	/^  int (*GetStackFramesWithContextPtr)(void** result, int* sizes, int max_depth,$/;"	m	struct:GetStackImplementation	file:	access:public
GetStackFramesWithContext_win32	src/stacktrace_win32-inl.h	/^static int GetStackFramesWithContext_win32(void** result, int* sizes, int max_depth,$/;"	f	signature:(void** result, int* sizes, int max_depth, int skip_count, const void *uc)
GetStackFrames_win32	src/stacktrace_win32-inl.h	/^static int GetStackFrames_win32(void** \/* pcs *\/,$/;"	f	signature:(void** , int* , int , int )
GetStackImplementation	src/stacktrace.cc	/^struct GetStackImplementation {$/;"	s	file:
GetStackImplementation::GetStackFramesPtr	src/stacktrace.cc	/^  int (*GetStackFramesPtr)(void** result, int* sizes, int max_depth,$/;"	m	struct:GetStackImplementation	file:	access:public
GetStackImplementation::GetStackFramesWithContextPtr	src/stacktrace.cc	/^  int (*GetStackFramesWithContextPtr)(void** result, int* sizes, int max_depth,$/;"	m	struct:GetStackImplementation	file:	access:public
GetStackImplementation::GetStackTracePtr	src/stacktrace.cc	/^  int (*GetStackTracePtr)(void** result, int max_depth,$/;"	m	struct:GetStackImplementation	file:	access:public
GetStackImplementation::GetStackTraceWithContextPtr	src/stacktrace.cc	/^  int (*GetStackTraceWithContextPtr)(void** result, int max_depth,$/;"	m	struct:GetStackImplementation	file:	access:public
GetStackImplementation::name	src/stacktrace.cc	/^  const char *name;$/;"	m	struct:GetStackImplementation	file:	access:public
GetStackTrace	src/gperftools/stacktrace.h	/^extern PERFTOOLS_DLL_DECL int GetStackTrace(void** result, int max_depth,$/;"	p	signature:(void** result, int max_depth, int skip_count)
GetStackTrace	src/malloc_hook.cc	61;"	d	file:
GetStackTrace	src/page_heap.h	63;"	d
GetStackTrace	src/stacktrace.cc	/^PERFTOOLS_DLL_DECL int GetStackTrace(void** result, int max_depth,$/;"	f	signature:(void** result, int max_depth, int skip_count)
GetStackTracePtr	src/stacktrace.cc	/^  int (*GetStackTracePtr)(void** result, int max_depth,$/;"	m	struct:GetStackImplementation	file:	access:public
GetStackTraceWithContext	src/gperftools/stacktrace.h	/^extern PERFTOOLS_DLL_DECL int GetStackTraceWithContext(void** result, int max_depth,$/;"	p	signature:(void** result, int max_depth, int skip_count, const void *uc)
GetStackTraceWithContext	src/stacktrace.cc	/^PERFTOOLS_DLL_DECL int GetStackTraceWithContext(void** result, int max_depth,$/;"	f	signature:(void** result, int max_depth, int skip_count, const void *uc)
GetStackTraceWithContextPtr	src/stacktrace.cc	/^  int (*GetStackTraceWithContextPtr)(void** result, int max_depth,$/;"	m	struct:GetStackImplementation	file:	access:public
GetStackTraceWithContext_win32	src/stacktrace_win32-inl.h	/^static int GetStackTraceWithContext_win32(void** result, int max_depth,$/;"	f	signature:(void** result, int max_depth, int skip_count, const void *uc)
GetStackTrace_win32	src/stacktrace_win32-inl.h	/^static int GetStackTrace_win32(void** result, int max_depth,$/;"	f	signature:(void** result, int max_depth, int skip_count)
GetState	src/profile-handler.cc	/^  void GetState(ProfileHandlerState* state);$/;"	p	class:ProfileHandler	file:	access:public	signature:(ProfileHandlerState* state)
GetState	src/profile-handler.cc	/^void ProfileHandler::GetState(ProfileHandlerState* state) {$/;"	f	class:ProfileHandler	signature:(ProfileHandlerState* state)
GetStats	docs/tcmalloc.html	/^   MallocExtension::instance()->GetStats(buffer, buffer_length);$/;"	p	class:object::structure	file:	access:private	signature:(buffer, buffer_length)
GetStats	src/gperftools/malloc_extension.h	/^  virtual void GetStats(char* buffer, int buffer_length);$/;"	p	class:MallocExtension	access:public	signature:(char* buffer, int buffer_length)
GetStats	src/malloc_extension.cc	/^void MallocExtension::GetStats(char* buffer, int length) {$/;"	f	class:MallocExtension	signature:(char* buffer, int length)
GetStats	src/tcmalloc.cc	/^  virtual void GetStats(char* buffer, int buffer_length) {$/;"	f	class:TCMallocImplementation	access:public	signature:(char* buffer, int buffer_length)
GetSymbol	src/symbolize.cc	/^const char* SymbolTable::GetSymbol(const void* addr) {$/;"	f	class:SymbolTable	signature:(const void* addr)
GetSymbol	src/symbolize.h	/^  const char* GetSymbol(const void* addr);$/;"	p	class:SymbolTable	access:public	signature:(const void* addr)
GetSystemAllocator	src/gperftools/malloc_extension.h	/^  virtual SysAllocator* GetSystemAllocator();$/;"	p	class:MallocExtension	access:public	signature:()
GetSystemAllocator	src/malloc_extension.cc	/^SysAllocator* MallocExtension::GetSystemAllocator() {$/;"	f	class:MallocExtension	signature:()
GetSystemAllocator	src/tcmalloc.cc	/^  virtual SysAllocator* GetSystemAllocator() {$/;"	f	class:TCMallocImplementation	access:public	signature:()
GetSystemCPUsCount	src/base/sysinfo.cc	/^int GetSystemCPUsCount()$/;"	f	signature:()
GetSystemCPUsCount	src/base/sysinfo.h	/^extern int GetSystemCPUsCount();$/;"	p	signature:()
GetThreadCacheSize	src/gperftools/malloc_extension.h	/^  virtual size_t GetThreadCacheSize();$/;"	p	class:MallocExtension	access:public	signature:()
GetThreadCacheSize	src/malloc_extension.cc	/^size_t MallocExtension::GetThreadCacheSize() {$/;"	f	class:MallocExtension	signature:()
GetThreadCacheSize	src/tcmalloc.cc	/^  virtual size_t GetThreadCacheSize() {$/;"	f	class:TCMallocImplementation	access:public	signature:()
GetThreadHeap	src/thread_cache.h	/^  static ThreadCache* GetThreadHeap();$/;"	p	class:tcmalloc::ThreadCache	access:public	signature:()
GetThreadHeap	src/thread_cache.h	/^inline ThreadCache* ThreadCache::GetThreadHeap() {$/;"	f	class:tcmalloc::ThreadCache	signature:()
GetThreadStats	src/thread_cache.cc	/^void ThreadCache::GetThreadStats(uint64_t* total_bytes, uint64_t* class_count) {$/;"	f	class:tcmalloc::ThreadCache	signature:(uint64_t* total_bytes, uint64_t* class_count)
GetThreadStats	src/thread_cache.h	/^  static void GetThreadStats(uint64_t* total_bytes, uint64_t* class_count);$/;"	p	class:tcmalloc::ThreadCache	access:public	signature:(uint64_t* total_bytes, uint64_t* class_count)
GetTotalThreadCacheSize	src/tests/markidle_unittest.cc	/^static size_t GetTotalThreadCacheSize() {$/;"	f	file:	signature:()
GetUniquePathFromEnv	src/base/sysinfo.cc	/^bool GetUniquePathFromEnv(const char* env_name, char* path) {$/;"	f	signature:(const char* env_name, char* path)
GetUniquePathFromEnv	src/base/sysinfo.h	/^extern bool GetUniquePathFromEnv(const char* env_name, char* path);$/;"	p	signature:(const char* env_name, char* path)
GetUnmappedBytes	src/tests/tcmalloc_unittest.cc	/^static size_t GetUnmappedBytes() {$/;"	f	namespace:testing	signature:()
GetVerdef	src/base/elf_mem_image.cc	/^const ElfW(Verdef) *ElfMemImage::GetVerdef(int index) const {$/;"	f	class:base::ElfMemImage	signature:(int index) const
GetVerdef	src/base/elf_mem_image.h	/^  const ElfW(Verdef)*  GetVerdef(int index) const;$/;"	p	class:base::ElfMemImage	access:public	signature:(int index) const
GetVersym	src/base/elf_mem_image.cc	/^const ElfW(Versym) *ElfMemImage::GetVersym(int index) const {$/;"	f	class:base::ElfMemImage	signature:(int index) const
GetVersym	src/base/elf_mem_image.h	/^  const ElfW(Versym)*  GetVersym(int index) const;$/;"	p	class:base::ElfMemImage	access:public	signature:(int index) const
GetenvBeforeMain	src/base/sysinfo.cc	/^const char* GetenvBeforeMain(const char* name) {$/;"	f	signature:(const char* name)
GetenvBeforeMain	src/base/sysinfo.h	/^extern const char* GetenvBeforeMain(const char* name);$/;"	p	signature:(const char* name)
Getopt::Long	src/pprof	/^use Getopt::Long;$/;"	m	class:Getopt	file:
GlobalChecker	src/gperftools/heap-checker.h	/^  static HeapLeakChecker* GlobalChecker();$/;"	p	class:HeapLeakChecker	access:public	signature:()
GlobalChecker	src/heap-checker.cc	/^HeapLeakChecker* HeapLeakChecker::GlobalChecker() {$/;"	f	class:HeapLeakChecker	signature:()
GlobalNallocx	src/tests/tcmalloc_unittest.cc	/^  GlobalNallocx() { CHECK_GT(nallocx(99, 0), 99); }$/;"	f	struct:testing::GlobalNallocx	access:public	signature:()
GlobalNallocx	src/tests/tcmalloc_unittest.cc	/^struct GlobalNallocx {$/;"	s	namespace:testing	file:
GlobalRegionCallerRangeMap	src/heap-checker.cc	/^           > GlobalRegionCallerRangeMap;$/;"	t	file:
Google	docs/heapprofile.html	/^<p>This is the heap profiler we use at Google, to explore how C++$/;"	v
GoogleInitializer	src/base/googleinit.h	/^  GoogleInitializer(const char* name, VoidFunction ctor, VoidFunction dtor)$/;"	f	class:GoogleInitializer	access:public	signature:(const char* name, VoidFunction ctor, VoidFunction dtor)
GoogleInitializer	src/base/googleinit.h	/^class GoogleInitializer {$/;"	c
GoogleInitializer::GoogleInitializer	src/base/googleinit.h	/^  GoogleInitializer(const char* name, VoidFunction ctor, VoidFunction dtor)$/;"	f	class:GoogleInitializer	access:public	signature:(const char* name, VoidFunction ctor, VoidFunction dtor)
GoogleInitializer::VoidFunction	src/base/googleinit.h	/^  typedef void (*VoidFunction)(void);$/;"	t	class:GoogleInitializer	access:public
GoogleInitializer::destructor_	src/base/googleinit.h	/^  const VoidFunction destructor_;$/;"	m	class:GoogleInitializer	access:private
GoogleInitializer::name_	src/base/googleinit.h	/^  const char* const name_;$/;"	m	class:GoogleInitializer	access:private
GoogleInitializer::~GoogleInitializer	src/base/googleinit.h	/^  ~GoogleInitializer() {$/;"	f	class:GoogleInitializer	access:public	signature:()
GrowHeap	src/page_heap.cc	/^bool PageHeap::GrowHeap(Length n) {$/;"	f	class:tcmalloc::PageHeap	signature:(Length n)
GrowHeap	src/page_heap.h	/^  bool GrowHeap(Length n);$/;"	p	class:tcmalloc::PageHeap	access:private	signature:(Length n)
H	benchmark/unwind_bench-getcontext_light.o	/^/;"	v
H	src/.libs/libtcmalloc_and_profiler_la-heap-checker.o	/^HEàH;EÐtDHEàHÇèòF/;"	v
H	src/.libs/libtcmalloc_debug_la-heap-checker.o	/^HEàH;EÐtDHEàHÇèòF/;"	v
H	src/.libs/libtcmalloc_internal_la-heap-profile-table.o	/^HEøHEøHÁèH1EøEôEô;E´|ÁHEøHÁàHEøHEøHÁèH1EøHEøÁº½jºÈ÷âÐÁèEäEäiÀ¿/;"	v
H	src/.libs/libtcmalloc_internal_la-internal_logging.o	/^/;"	v
H	src/.libs/libtcmalloc_internal_la-internal_logging.o	/^º/;"	v
H	src/.libs/libtcmalloc_internal_la-malloc_extension.o	/^HUðHuøHÇÿÑ¶ÀÉÃUHåè/;"	v
H	src/.libs/libtcmalloc_la-heap-checker.o	/^HEàH;EÐtDHEàHÇèòF/;"	v
H	src/.libs/libtcmalloc_minimal_internal_la-internal_logging.o	/^º/;"	v
H	src/.libs/libtcmalloc_minimal_internal_la-malloc_hook.o	/^/;"	v
H	src/.libs/profile-handler.o	/^ELF/;"	v
H	src/.libs/profiler.o	/^/;"	v
H	src/base/.libs/elf_mem_image.o	/^HøtGHøt3Høté/;"	v
H	src/libtcmalloc_and_profiler_la-heap-checker.o	/^¿/;"	v
H	src/libtcmalloc_and_profiler_la-profile-handler.o	/^/;"	v
H	src/libtcmalloc_debug_la-heap-checker.o	/^¿/;"	v
H	src/libtcmalloc_internal_la-heap-profile-table.o	/^HEøHEøHÁèH1EøEôEô;E´|ÁHEøHÁàHEøHEøHÁèH1EøHEøÁº½jºÈ÷âÐÁèEäEäiÀ¿/;"	v
H	src/libtcmalloc_internal_la-heap-profiler.o	/^ELF/;"	v
H	src/libtcmalloc_internal_la-stack_trace_table.o	/^/;"	v
H	src/libtcmalloc_la-heap-checker.o	/^¿/;"	v
H	src/libtcmalloc_minimal_internal_la-stack_trace_table.o	/^/;"	v
H	src/tcm_min_asserts_unittest-central_freelist.o	/^»/;"	v
H	src/tcm_min_asserts_unittest-page_heap.o	/^HE¨H/;"	v
H	src/tests/malloc_hook_test-testutil.o	/^ELF/;"	v
H	src/tests/markidle_unittest-markidle_unittest.o	/^HUø¾/;"	v
H	src/tests/markidle_unittest-testutil.o	/^ELF/;"	v
H	src/tests/memalign_debug_unittest-testutil.o	/^ELF/;"	v
H	src/tests/memalign_unittest-testutil.o	/^ELF/;"	v
H	src/tests/profiler3_unittest-testutil.o	/^ELF/;"	v
H	src/tests/profiler4_unittest-testutil.o	/^ELF/;"	v
H	src/tests/stacktrace_unittest.o	/^/;"	v
H	src/tests/tcm_min_asserts_unittest-testutil.o	/^ELF/;"	v
H	src/tests/tcmalloc_and_profiler_unittest-testutil.o	/^ELF/;"	v
H	src/tests/tcmalloc_both_unittest-testutil.o	/^ELF/;"	v
H	src/tests/tcmalloc_debug_unittest-testutil.o	/^ELF/;"	v
H	src/tests/tcmalloc_minimal_debug_unittest-testutil.o	/^ELF/;"	v
H	src/tests/tcmalloc_minimal_unittest-testutil.o	/^ELF/;"	v
H	src/tests/tcmalloc_unittest-testutil.o	/^ELF/;"	v
H	src/tests/thread_dealloc_unittest-testutil.o	/^ELF/;"	v
HAVE_ATTRIBUTE_SECTION_START	src/base/basictypes.h	300;"	d
HAVE_ATTRIBUTE_SECTION_START	src/base/basictypes.h	359;"	d
HAVE_BUILTIN_EXPECT	src/config.h	19;"	d
HAVE_BUILTIN_EXPECT	src/config.h.in	18;"	d	file:
HAVE_BUILTIN_STACK_POINTER	src/config.h.in	21;"	d	file:
HAVE_BUILTIN_STACK_POINTER	src/windows/config.h	36;"	d
HAVE_CONFLICT_SIGNAL_H	src/config.h.in	24;"	d	file:
HAVE_CONFLICT_SIGNAL_H	src/windows/config.h	39;"	d
HAVE_CYGWIN_SIGNAL_H	src/config.h.in	27;"	d	file:
HAVE_CYGWIN_SIGNAL_H	src/windows/config.h	42;"	d
HAVE_DECL_BACKTRACE	src/config.h.in	31;"	d	file:
HAVE_DECL_CFREE	src/config.h	36;"	d
HAVE_DECL_CFREE	src/config.h.in	35;"	d	file:
HAVE_DECL_CFREE	src/windows/config.h	46;"	d
HAVE_DECL_MEMALIGN	src/config.h	40;"	d
HAVE_DECL_MEMALIGN	src/config.h.in	39;"	d	file:
HAVE_DECL_MEMALIGN	src/windows/config.h	50;"	d
HAVE_DECL_NANOSLEEP	src/config.h.in	43;"	d	file:
HAVE_DECL_NANOSLEEP	src/windows/port.h	452;"	d
HAVE_DECL_POSIX_MEMALIGN	src/config.h	48;"	d
HAVE_DECL_POSIX_MEMALIGN	src/config.h.in	47;"	d	file:
HAVE_DECL_POSIX_MEMALIGN	src/windows/config.h	54;"	d
HAVE_DECL_PVALLOC	src/config.h	52;"	d
HAVE_DECL_PVALLOC	src/config.h.in	51;"	d	file:
HAVE_DECL_PVALLOC	src/windows/config.h	58;"	d
HAVE_DECL_SLEEP	src/config.h.in	55;"	d	file:
HAVE_DECL_SLEEP	src/windows/port.h	432;"	d
HAVE_DECL_UNAME	src/config.h	60;"	d
HAVE_DECL_UNAME	src/config.h.in	59;"	d	file:
HAVE_DECL_UNAME	src/windows/config.h	62;"	d
HAVE_DECL_VALLOC	src/config.h	64;"	d
HAVE_DECL_VALLOC	src/config.h.in	63;"	d	file:
HAVE_DECL_VALLOC	src/windows/config.h	66;"	d
HAVE_DLFCN_H	src/config.h	67;"	d
HAVE_DLFCN_H	src/config.h.in	66;"	d	file:
HAVE_DLFCN_H	src/windows/config.h	69;"	d
HAVE_ELF32_VERSYM	src/config.h	70;"	d
HAVE_ELF32_VERSYM	src/config.h.in	69;"	d	file:
HAVE_ELF32_VERSYM	src/windows/config.h	72;"	d
HAVE_ELF_MEM_IMAGE	src/base/elf_mem_image.h	48;"	d
HAVE_EXECINFO_H	src/config.h	73;"	d
HAVE_EXECINFO_H	src/config.h.in	72;"	d	file:
HAVE_EXECINFO_H	src/windows/config.h	75;"	d
HAVE_FCNTL_H	src/config.h	76;"	d
HAVE_FCNTL_H	src/config.h.in	75;"	d	file:
HAVE_FCNTL_H	src/windows/config.h	78;"	d
HAVE_FEATURES_H	src/config.h	79;"	d
HAVE_FEATURES_H	src/config.h.in	78;"	d	file:
HAVE_FEATURES_H	src/windows/config.h	81;"	d
HAVE_FORK	src/config.h	82;"	d
HAVE_FORK	src/config.h.in	81;"	d	file:
HAVE_FORK	src/windows/mingw.h	66;"	d
HAVE_GETEUID	src/config.h	85;"	d
HAVE_GETEUID	src/config.h.in	84;"	d	file:
HAVE_GETEUID	src/windows/config.h	84;"	d
HAVE_GETPAGESIZE	src/config.h	88;"	d
HAVE_GETPAGESIZE	src/config.h.in	87;"	d	file:
HAVE_GETPAGESIZE	src/windows/config.h	87;"	d
HAVE_GLOB_H	src/config.h	91;"	d
HAVE_GLOB_H	src/config.h.in	90;"	d	file:
HAVE_GLOB_H	src/windows/config.h	90;"	d
HAVE_GRP_H	src/config.h	94;"	d
HAVE_GRP_H	src/config.h.in	93;"	d	file:
HAVE_GRP_H	src/windows/config.h	93;"	d
HAVE_GST_arm	src/stacktrace.cc	142;"	d	file:
HAVE_GST_generic	src/stacktrace.cc	91;"	d	file:
HAVE_GST_instrument	src/stacktrace.cc	151;"	d	file:
HAVE_GST_libgcc	src/stacktrace.cc	100;"	d	file:
HAVE_GST_libunwind	src/stacktrace.cc	111;"	d	file:
HAVE_GST_ppc	src/stacktrace.cc	133;"	d	file:
HAVE_GST_win32	src/stacktrace.cc	162;"	d	file:
HAVE_GST_x86	src/stacktrace.cc	120;"	d	file:
HAVE_INTTYPES_H	src/config.h	97;"	d
HAVE_INTTYPES_H	src/config.h.in	96;"	d	file:
HAVE_INTTYPES_H	src/windows/config.h	96;"	d
HAVE_LIBUNWIND_H	src/config.h	100;"	d
HAVE_LIBUNWIND_H	src/config.h.in	99;"	d	file:
HAVE_LIBUNWIND_H	src/windows/config.h	99;"	d
HAVE_LINUX_PTRACE_H	src/config.h	103;"	d
HAVE_LINUX_PTRACE_H	src/config.h.in	102;"	d	file:
HAVE_LINUX_PTRACE_H	src/windows/config.h	102;"	d
HAVE_LINUX_SIGEV_THREAD_ID	src/config.h	106;"	d
HAVE_LINUX_SIGEV_THREAD_ID	src/config.h.in	105;"	d	file:
HAVE_MALLOC_H	src/config.h	109;"	d
HAVE_MALLOC_H	src/config.h.in	108;"	d	file:
HAVE_MALLOC_H	src/windows/config.h	105;"	d
HAVE_MALLOC_MALLOC_H	src/windows/config.h	108;"	d
HAVE_MEMORY_H	src/config.h	112;"	d
HAVE_MEMORY_H	src/config.h.in	111;"	d	file:
HAVE_MEMORY_H	src/windows/config.h	111;"	d
HAVE_MMAP	src/config.h	115;"	d
HAVE_MMAP	src/config.h.in	114;"	d	file:
HAVE_MMAP	src/windows/config.h	114;"	d
HAVE_NAMESPACES	src/config.h	118;"	d
HAVE_NAMESPACES	src/config.h.in	117;"	d	file:
HAVE_NAMESPACES	src/windows/config.h	117;"	d
HAVE_PID_T	src/windows/mingw.h	68;"	d
HAVE_POLL_H	src/config.h	121;"	d
HAVE_POLL_H	src/config.h.in	120;"	d	file:
HAVE_POLL_H	src/windows/config.h	120;"	d
HAVE_PROGRAM_INVOCATION_NAME	src/config.h	124;"	d
HAVE_PROGRAM_INVOCATION_NAME	src/config.h.in	123;"	d	file:
HAVE_PROGRAM_INVOCATION_NAME	src/windows/config.h	123;"	d
HAVE_PTHREAD	ChangeLog.old	/^	* BUGFIX: Fixed test to use HAVE_PTHREAD, not HAVE_PTHREADS (csilvers)$/;"	v
HAVE_PTHREAD	src/config.h	127;"	d
HAVE_PTHREAD	src/config.h.in	126;"	d	file:
HAVE_PTHREAD	src/windows/config.h	126;"	d
HAVE_PTHREAD	src/windows/mingw.h	63;"	d
HAVE_PTHREAD_DESPITE_ASKING_FOR	src/config.h.in	130;"	d	file:
HAVE_PWD_H	src/config.h	134;"	d
HAVE_PWD_H	src/config.h.in	133;"	d	file:
HAVE_PWD_H	src/windows/config.h	129;"	d
HAVE_SBRK	src/config.h	137;"	d
HAVE_SBRK	src/config.h.in	136;"	d	file:
HAVE_SBRK	src/windows/config.h	132;"	d
HAVE_SCHED_H	src/config.h	140;"	d
HAVE_SCHED_H	src/config.h.in	139;"	d	file:
HAVE_SCHED_H	src/windows/config.h	135;"	d
HAVE_SIZED_FREE_OPTION	benchmark/malloc_bench.cc	86;"	d	file:
HAVE_SNPRINTF	src/windows/config.h	30;"	d
HAVE_SNPRINTF	src/windows/config.h	32;"	d
HAVE_SNPRINTF	src/windows/mingw.h	57;"	d
HAVE_STDINT_H	src/config.h	143;"	d
HAVE_STDINT_H	src/config.h.in	142;"	d	file:
HAVE_STDINT_H	src/windows/config.h	139;"	d
HAVE_STDINT_H	src/windows/config.h	141;"	d
HAVE_STDLIB_H	src/config.h	146;"	d
HAVE_STDLIB_H	src/config.h.in	145;"	d	file:
HAVE_STDLIB_H	src/windows/config.h	145;"	d
HAVE_STRINGS_H	src/config.h	149;"	d
HAVE_STRINGS_H	src/config.h.in	148;"	d	file:
HAVE_STRINGS_H	src/windows/config.h	148;"	d
HAVE_STRING_H	src/config.h	152;"	d
HAVE_STRING_H	src/config.h.in	151;"	d	file:
HAVE_STRING_H	src/windows/config.h	151;"	d
HAVE_STRUCT_MALLINFO	src/config.h	155;"	d
HAVE_STRUCT_MALLINFO	src/config.h.in	154;"	d	file:
HAVE_STRUCT_MALLINFO	src/windows/config.h	154;"	d
HAVE_SYS_CDEFS_H	src/config.h	158;"	d
HAVE_SYS_CDEFS_H	src/config.h.in	157;"	d	file:
HAVE_SYS_CDEFS_H	src/windows/config.h	157;"	d
HAVE_SYS_MALLOC_H	src/windows/config.h	160;"	d
HAVE_SYS_PARAM_H	src/windows/config.h	163;"	d
HAVE_SYS_PRCTL_H	src/config.h	161;"	d
HAVE_SYS_PRCTL_H	src/config.h.in	160;"	d	file:
HAVE_SYS_PRCTL_H	src/windows/config.h	166;"	d
HAVE_SYS_RESOURCE_H	src/config.h	164;"	d
HAVE_SYS_RESOURCE_H	src/config.h.in	163;"	d	file:
HAVE_SYS_RESOURCE_H	src/windows/config.h	169;"	d
HAVE_SYS_SOCKET_H	src/config.h	167;"	d
HAVE_SYS_SOCKET_H	src/config.h.in	166;"	d	file:
HAVE_SYS_SOCKET_H	src/windows/config.h	172;"	d
HAVE_SYS_STAT_H	src/config.h	170;"	d
HAVE_SYS_STAT_H	src/config.h.in	169;"	d	file:
HAVE_SYS_STAT_H	src/windows/config.h	175;"	d
HAVE_SYS_SYSCALL_H	src/config.h	173;"	d
HAVE_SYS_SYSCALL_H	src/config.h.in	172;"	d	file:
HAVE_SYS_SYSCALL_H	src/windows/config.h	178;"	d
HAVE_SYS_TYPES_H	src/config.h	176;"	d
HAVE_SYS_TYPES_H	src/config.h.in	175;"	d	file:
HAVE_SYS_TYPES_H	src/windows/config.h	181;"	d
HAVE_SYS_UCONTEXT_H	src/config.h	179;"	d
HAVE_SYS_UCONTEXT_H	src/config.h.in	178;"	d	file:
HAVE_SYS_UCONTEXT_H	src/windows/config.h	184;"	d
HAVE_SYS_WAIT_H	src/config.h	182;"	d
HAVE_SYS_WAIT_H	src/config.h.in	181;"	d	file:
HAVE_SYS_WAIT_H	src/windows/config.h	187;"	d
HAVE_TLS	INSTALL	149;"	d	file:
HAVE_TLS	README	222;"	d	file:
HAVE_TLS	src/config.h	185;"	d
HAVE_TLS	src/config.h.in	184;"	d	file:
HAVE_TLS	src/windows/config.h	190;"	d
HAVE_UCONTEXT_H	src/config.h	188;"	d
HAVE_UCONTEXT_H	src/config.h.in	187;"	d	file:
HAVE_UCONTEXT_H	src/windows/config.h	193;"	d
HAVE_UNISTD_H	src/config.h	191;"	d
HAVE_UNISTD_H	src/config.h.in	190;"	d	file:
HAVE_UNISTD_H	src/windows/config.h	196;"	d
HAVE_UNWIND_BACKTRACE	src/config.h	194;"	d
HAVE_UNWIND_BACKTRACE	src/config.h.in	193;"	d	file:
HAVE_UNWIND_H	src/config.h	197;"	d
HAVE_UNWIND_H	src/config.h.in	196;"	d	file:
HAVE_UNWIND_H	src/windows/config.h	199;"	d
HAVE_VALGRIND_H	src/config.h.in	199;"	d	file:
HAVE_VALGRIND_H	src/windows/config.h	202;"	d
HAVE_VDSO_SUPPORT	src/base/vdso_support.h	64;"	d
HAVE___ATTRIBUTE__	src/config.h	203;"	d
HAVE___ATTRIBUTE__	src/config.h.in	202;"	d	file:
HAVE___ATTRIBUTE__	src/windows/config.h	205;"	d
HAVE___ATTRIBUTE__ALIGNED_FN	src/config.h	206;"	d
HAVE___ATTRIBUTE__ALIGNED_FN	src/config.h.in	205;"	d	file:
HAVE___ENVIRON	src/config.h	209;"	d
HAVE___ENVIRON	src/config.h.in	208;"	d	file:
HAVE___ENVIRON	src/windows/config.h	208;"	d
HAVE___INT64	src/config.h.in	211;"	d	file:
HAVE___INT64	src/windows/config.h	211;"	d
HCL_string	src/heap-checker.cc	/^                    > HCL_string;$/;"	t	file:
HEAPPROFILE	README	/^There are other environment variables, besides HEAPPROFILE, you can$/;"	v
HEAPPROFILE	docs/heapprofile.html	/^       <pre>% env HEAPPROFILE=\/tmp\/mybin.hprof \/usr\/local\/bin\/my_binary_compiled_with_tcmalloc<\/pre>$/;"	v
HEAP_PROFILER	heap-profiler_debug_unittest.sh	/^HEAP_PROFILER="${1:-$BINDIR\/heap-profiler_unittest}"$/;"	v
HEAP_PROFILER	heap-profiler_unittest.sh	/^HEAP_PROFILER="${1:-$BINDIR\/heap-profiler_unittest}"$/;"	v
HEAP_PROFILER	src/tests/heap-profiler_unittest.sh	/^HEAP_PROFILER="${1:-$BINDIR\/heap-profiler_unittest}"$/;"	v
HEAP_PROFILE_STATS_H_	src/heap-profile-stats.h	52;"	d
HP_ARCH	config.guess	/^                          32) HP_ARCH="hppa2.0n" ;;$/;"	v
HP_ARCH	config.guess	/^                      528) HP_ARCH="hppa1.1" ;; # CPU_PA_RISC1_1$/;"	v
HREF	docs/heapprofile.html	/^HREF="heap_checker.html">automatic heap-checking facility<\/A> built$/;"	v
HandleSavedRegionsLocked	src/memory_region_map.cc	/^inline void MemoryRegionMap::HandleSavedRegionsLocked($/;"	f	class:MemoryRegionMap	signature:( void (*insert_func)(const Region& region))
HandleSavedRegionsLocked	src/memory_region_map.h	/^  inline static void HandleSavedRegionsLocked($/;"	p	class:MemoryRegionMap	access:private	signature:( void (*insert_func)(const Region& region))
Has	src/tests/packed-cache_test.cc	/^static size_t Has(const PackedCache<kKeybits>& cache, uintptr_t key) {$/;"	f	file:	signature:(const PackedCache<kKeybits>& cache, uintptr_t key)
HasPosixThreads	src/base/sysinfo.h	/^bool HasPosixThreads();$/;"	p	signature:()
Hash	src/packed-cache-inl.h	/^  static T Hash(K key) {$/;"	f	class:PackedCache	access:private	signature:(K key)
HashInt	src/addressmap-inl.h	/^  static int HashInt(Number x) {$/;"	f	class:AddressMap	access:private	signature:(Number x)
HaveOnHeapLocked	src/gperftools/heap-checker.h	/^  static inline bool HaveOnHeapLocked(const void** ptr, size_t* object_size);$/;"	p	class:HeapLeakChecker	access:private	signature:(const void** ptr, size_t* object_size)
HaveOnHeapLocked	src/heap-checker.cc	/^inline bool HeapLeakChecker::HaveOnHeapLocked(const void** ptr,$/;"	f	class:HeapLeakChecker	signature:(const void** ptr, size_t* object_size)
HaveSystemRelease	src/tests/page_heap_test.cc	/^static bool HaveSystemRelease =$/;"	m	namespace:__anon55	file:
HaveSystemRelease	src/tests/tcmalloc_unittest.cc	/^static bool HaveSystemRelease =$/;"	m	namespace:testing	file:
Header	src/base/low_level_alloc.cc	/^    struct Header {$/;"	s	struct:low_level_alloc_internal::AllocList	file:	access:public
HeapBusyThreadBody	src/tests/heap-checker_unittest.cc	/^static void* HeapBusyThreadBody(void* a) {$/;"	f	file:	signature:(void* a)
HeapCleaner	src/gperftools/heap-checker.h	/^  HeapCleaner(void_function f);$/;"	p	class:HeapCleaner	access:public	signature:(void_function f)
HeapCleaner	src/gperftools/heap-checker.h	/^class PERFTOOLS_DLL_DECL HeapCleaner {$/;"	c
HeapCleaner	src/heap-checker.cc	/^HeapCleaner::HeapCleaner(void_function f) {$/;"	f	class:HeapCleaner	signature:(void_function f)
HeapCleaner::HeapCleaner	src/gperftools/heap-checker.h	/^  HeapCleaner(void_function f);$/;"	p	class:HeapCleaner	access:public	signature:(void_function f)
HeapCleaner::HeapCleaner	src/heap-checker.cc	/^HeapCleaner::HeapCleaner(void_function f) {$/;"	f	class:HeapCleaner	signature:(void_function f)
HeapCleaner::RunHeapCleanups	src/gperftools/heap-checker.h	/^  static void RunHeapCleanups();$/;"	p	class:HeapCleaner	access:public	signature:()
HeapCleaner::RunHeapCleanups	src/heap-checker.cc	/^void HeapCleaner::RunHeapCleanups() {$/;"	f	class:HeapCleaner	signature:()
HeapCleaner::heap_cleanups_	src/gperftools/heap-checker.h	/^  static std::vector<void_function>* heap_cleanups_;$/;"	m	class:HeapCleaner	access:private
HeapCleaner::heap_cleanups_	src/heap-checker.cc	/^vector<HeapCleaner::void_function>* HeapCleaner::heap_cleanups_ = NULL;$/;"	m	class:HeapCleaner	file:
HeapCleaner::void_function	src/gperftools/heap-checker.h	/^  typedef void (*void_function)(void);$/;"	t	class:HeapCleaner	access:public
HeapLeakChecker	src/gperftools/heap-checker.h	/^  HeapLeakChecker();$/;"	p	class:HeapLeakChecker	access:private	signature:()
HeapLeakChecker	src/gperftools/heap-checker.h	/^  HeapLeakChecker(const HeapLeakChecker&);$/;"	p	class:HeapLeakChecker	access:private	signature:(const HeapLeakChecker&)
HeapLeakChecker	src/gperftools/heap-checker.h	/^  explicit HeapLeakChecker(const char *name);$/;"	p	class:HeapLeakChecker	access:public	signature:(const char *name)
HeapLeakChecker	src/gperftools/heap-checker.h	/^class PERFTOOLS_DLL_DECL HeapLeakChecker {$/;"	c
HeapLeakChecker	src/heap-checker.cc	/^HeapLeakChecker::HeapLeakChecker() : lock_(new SpinLock) {$/;"	f	class:HeapLeakChecker	signature:()
HeapLeakChecker	src/heap-checker.cc	/^HeapLeakChecker::HeapLeakChecker(const char *name) : lock_(new SpinLock) {$/;"	f	class:HeapLeakChecker	signature:(const char *name)
HeapLeakChecker::Allocator	src/heap-checker.cc	/^class HeapLeakChecker::Allocator {$/;"	c	class:HeapLeakChecker	file:
HeapLeakChecker::Allocator::Allocate	src/heap-checker.cc	/^  static void* Allocate(size_t n) {$/;"	f	class:HeapLeakChecker::Allocator	access:public	signature:(size_t n)
HeapLeakChecker::Allocator::DeleteAndNull	src/heap-checker.cc	/^  template<typename T> static void DeleteAndNull(T** p) {$/;"	f	class:HeapLeakChecker::Allocator	access:public	signature:(T** p)
HeapLeakChecker::Allocator::DeleteAndNullIfNot	src/heap-checker.cc	/^  template<typename T> static void DeleteAndNullIfNot(T** p) {$/;"	f	class:HeapLeakChecker::Allocator	access:public	signature:(T** p)
HeapLeakChecker::Allocator::Free	src/heap-checker.cc	/^  static void Free(void* p) {$/;"	f	class:HeapLeakChecker::Allocator	access:public	signature:(void* p)
HeapLeakChecker::Allocator::Free	src/heap-checker.cc	/^  static void Free(void* p, size_t \/* n *\/) {$/;"	f	class:HeapLeakChecker::Allocator	access:public	signature:(void* p, size_t )
HeapLeakChecker::Allocator::Init	src/heap-checker.cc	/^  static void Init() {$/;"	f	class:HeapLeakChecker::Allocator	access:public	signature:()
HeapLeakChecker::Allocator::Shutdown	src/heap-checker.cc	/^  static void Shutdown() {$/;"	f	class:HeapLeakChecker::Allocator	access:public	signature:()
HeapLeakChecker::Allocator::alloc_count	src/heap-checker.cc	/^  static int alloc_count() {$/;"	f	class:HeapLeakChecker::Allocator	access:public	signature:()
HeapLeakChecker::Allocator::alloc_count_	src/heap-checker.cc	/^  static int alloc_count_;$/;"	m	class:HeapLeakChecker::Allocator	file:	access:private
HeapLeakChecker::Allocator::alloc_count_	src/heap-checker.cc	/^int HeapLeakChecker::Allocator::alloc_count_ = 0;$/;"	m	class:HeapLeakChecker::Allocator	file:
HeapLeakChecker::Allocator::arena_	src/heap-checker.cc	/^  static LowLevelAlloc::Arena* arena_;$/;"	m	class:HeapLeakChecker::Allocator	file:	access:private
HeapLeakChecker::Allocator::arena_	src/heap-checker.cc	/^LowLevelAlloc::Arena* HeapLeakChecker::Allocator::arena_ = NULL;$/;"	m	class:HeapLeakChecker::Allocator	file:
HeapLeakChecker::BeforeConstructorsLocked	src/gperftools/heap-checker.h	/^  static void BeforeConstructorsLocked();$/;"	p	class:HeapLeakChecker	access:private	signature:()
HeapLeakChecker::BeforeConstructorsLocked	src/heap-checker.cc	/^void HeapLeakChecker::BeforeConstructorsLocked() {$/;"	f	class:HeapLeakChecker	signature:()
HeapLeakChecker::BriefNoLeaks	src/gperftools/heap-checker.h	/^  bool BriefNoLeaks()  { return NoLeaks(); }$/;"	f	class:HeapLeakChecker	access:public	signature:()
HeapLeakChecker::BriefSameHeap	src/gperftools/heap-checker.h	/^  bool BriefSameHeap() { return NoLeaks(); }$/;"	f	class:HeapLeakChecker	access:public	signature:()
HeapLeakChecker::BytesLeaked	src/gperftools/heap-checker.h	/^  ssize_t BytesLeaked() const;$/;"	p	class:HeapLeakChecker	access:public	signature:() const
HeapLeakChecker::BytesLeaked	src/heap-checker.cc	/^ssize_t HeapLeakChecker::BytesLeaked() const {$/;"	f	class:HeapLeakChecker	signature:() const
HeapLeakChecker::CANT_OPEN_PROC_MAPS	src/gperftools/heap-checker.h	/^    CANT_OPEN_PROC_MAPS,$/;"	e	enum:HeapLeakChecker::ProcMapsResult
HeapLeakChecker::CancelGlobalCheck	src/gperftools/heap-checker.h	/^  static void CancelGlobalCheck();$/;"	p	class:HeapLeakChecker	access:public	signature:()
HeapLeakChecker::CancelGlobalCheck	src/heap-checker.cc	/^void HeapLeakChecker::CancelGlobalCheck() {$/;"	f	class:HeapLeakChecker	signature:()
HeapLeakChecker::Create	src/gperftools/heap-checker.h	/^  void Create(const char *name, bool make_start_snapshot);$/;"	p	class:HeapLeakChecker	access:private	signature:(const char *name, bool make_start_snapshot)
HeapLeakChecker::Create	src/heap-checker.cc	/^void HeapLeakChecker::Create(const char *name, bool make_start_snapshot) {$/;"	f	class:HeapLeakChecker	signature:(const char *name, bool make_start_snapshot)
HeapLeakChecker::DISABLE_LIBRARY_ALLOCS	src/gperftools/heap-checker.h	/^    DISABLE_LIBRARY_ALLOCS$/;"	e	enum:HeapLeakChecker::ProcMapsTask
HeapLeakChecker::DO_NOT_SYMBOLIZE	src/gperftools/heap-checker.h	/^  enum ShouldSymbolize { SYMBOLIZE, DO_NOT_SYMBOLIZE };$/;"	e	enum:HeapLeakChecker::ShouldSymbolize
HeapLeakChecker::DisableChecksFromToLocked	src/gperftools/heap-checker.h	/^  static void DisableChecksFromToLocked(const void* start_address,$/;"	p	class:HeapLeakChecker	access:private	signature:(const void* start_address, const void* end_address, int max_depth)
HeapLeakChecker::DisableChecksFromToLocked	src/heap-checker.cc	/^void HeapLeakChecker::DisableChecksFromToLocked(const void* start_address,$/;"	f	class:HeapLeakChecker	signature:(const void* start_address, const void* end_address, int max_depth)
HeapLeakChecker::DisableChecksIn	src/gperftools/heap-checker.h	/^  static void DisableChecksIn(const char* pattern);$/;"	p	class:HeapLeakChecker	access:private	signature:(const char* pattern)
HeapLeakChecker::DisableChecksIn	src/heap-checker.cc	/^void HeapLeakChecker::DisableChecksIn(const char* pattern) {$/;"	f	class:HeapLeakChecker	signature:(const char* pattern)
HeapLeakChecker::DisableChecksToHereFrom	src/gperftools/heap-checker.h	/^  static void DisableChecksToHereFrom(const void* start_address);$/;"	p	class:HeapLeakChecker	access:private	signature:(const void* start_address)
HeapLeakChecker::DisableLibraryAllocsLocked	src/gperftools/heap-checker.h	/^  static void DisableLibraryAllocsLocked(const char* library,$/;"	p	class:HeapLeakChecker	access:private	signature:(const char* library, uintptr_t start_address, uintptr_t end_address)
HeapLeakChecker::DisableLibraryAllocsLocked	src/heap-checker.cc	/^void HeapLeakChecker::DisableLibraryAllocsLocked(const char* library,$/;"	f	class:HeapLeakChecker	signature:(const char* library, uintptr_t start_address, uintptr_t end_address)
HeapLeakChecker::Disabler	src/gperftools/heap-checker.h	/^  class Disabler {$/;"	c	class:HeapLeakChecker	access:public
HeapLeakChecker::Disabler::Disabler	src/gperftools/heap-checker.h	/^    Disabler();$/;"	p	class:HeapLeakChecker::Disabler	access:public	signature:()
HeapLeakChecker::Disabler::Disabler	src/gperftools/heap-checker.h	/^    Disabler(const Disabler&);        \/\/ disallow copy$/;"	p	class:HeapLeakChecker::Disabler	access:private	signature:(const Disabler&)
HeapLeakChecker::Disabler::Disabler	src/heap-checker.cc	/^HeapLeakChecker::Disabler::Disabler() {$/;"	f	class:HeapLeakChecker::Disabler	signature:()
HeapLeakChecker::Disabler::operator =	src/gperftools/heap-checker.h	/^    void operator=(const Disabler&);  \/\/ and assign$/;"	p	class:HeapLeakChecker::Disabler	access:private	signature:(const Disabler&)
HeapLeakChecker::Disabler::~Disabler	src/gperftools/heap-checker.h	/^    ~Disabler();$/;"	p	class:HeapLeakChecker::Disabler	access:public	signature:()
HeapLeakChecker::Disabler::~Disabler	src/heap-checker.cc	/^HeapLeakChecker::Disabler::~Disabler() {$/;"	f	class:HeapLeakChecker::Disabler	signature:()
HeapLeakChecker::DoIgnoreObject	src/gperftools/heap-checker.h	/^  static void DoIgnoreObject(const void* ptr);$/;"	p	class:HeapLeakChecker	access:private	signature:(const void* ptr)
HeapLeakChecker::DoIgnoreObject	src/heap-checker.cc	/^void HeapLeakChecker::DoIgnoreObject(const void* ptr) {$/;"	f	class:HeapLeakChecker	signature:(const void* ptr)
HeapLeakChecker::DoMainHeapCheck	src/gperftools/heap-checker.h	/^  static bool DoMainHeapCheck();$/;"	p	class:HeapLeakChecker	access:private	signature:()
HeapLeakChecker::DoMainHeapCheck	src/heap-checker.cc	/^bool HeapLeakChecker::DoMainHeapCheck() {$/;"	f	class:HeapLeakChecker	signature:()
HeapLeakChecker::DoNoLeaks	src/gperftools/heap-checker.h	/^  bool DoNoLeaks(ShouldSymbolize should_symbolize);$/;"	p	class:HeapLeakChecker	access:private	signature:(ShouldSymbolize should_symbolize)
HeapLeakChecker::DoNoLeaks	src/heap-checker.cc	/^bool HeapLeakChecker::DoNoLeaks(ShouldSymbolize should_symbolize) {$/;"	f	class:HeapLeakChecker	signature:(ShouldSymbolize should_symbolize)
HeapLeakChecker::GetAllocCaller	src/gperftools/heap-checker.h	/^  static const void* GetAllocCaller(void* ptr);$/;"	p	class:HeapLeakChecker	access:private	signature:(void* ptr)
HeapLeakChecker::GetAllocCaller	src/heap-checker.cc	/^const void* HeapLeakChecker::GetAllocCaller(void* ptr) {$/;"	f	class:HeapLeakChecker	signature:(void* ptr)
HeapLeakChecker::GetDisableChecksStart	src/gperftools/heap-checker.h	/^  static void* GetDisableChecksStart();$/;"	p	class:HeapLeakChecker	access:private	signature:()
HeapLeakChecker::GlobalChecker	src/gperftools/heap-checker.h	/^  static HeapLeakChecker* GlobalChecker();$/;"	p	class:HeapLeakChecker	access:public	signature:()
HeapLeakChecker::GlobalChecker	src/heap-checker.cc	/^HeapLeakChecker* HeapLeakChecker::GlobalChecker() {$/;"	f	class:HeapLeakChecker	signature:()
HeapLeakChecker::HaveOnHeapLocked	src/gperftools/heap-checker.h	/^  static inline bool HaveOnHeapLocked(const void** ptr, size_t* object_size);$/;"	p	class:HeapLeakChecker	access:private	signature:(const void** ptr, size_t* object_size)
HeapLeakChecker::HaveOnHeapLocked	src/heap-checker.cc	/^inline bool HeapLeakChecker::HaveOnHeapLocked(const void** ptr,$/;"	f	class:HeapLeakChecker	signature:(const void** ptr, size_t* object_size)
HeapLeakChecker::HeapLeakChecker	src/gperftools/heap-checker.h	/^  HeapLeakChecker();$/;"	p	class:HeapLeakChecker	access:private	signature:()
HeapLeakChecker::HeapLeakChecker	src/gperftools/heap-checker.h	/^  HeapLeakChecker(const HeapLeakChecker&);$/;"	p	class:HeapLeakChecker	access:private	signature:(const HeapLeakChecker&)
HeapLeakChecker::HeapLeakChecker	src/gperftools/heap-checker.h	/^  explicit HeapLeakChecker(const char *name);$/;"	p	class:HeapLeakChecker	access:public	signature:(const char *name)
HeapLeakChecker::HeapLeakChecker	src/heap-checker.cc	/^HeapLeakChecker::HeapLeakChecker() : lock_(new SpinLock) {$/;"	f	class:HeapLeakChecker	signature:()
HeapLeakChecker::HeapLeakChecker	src/heap-checker.cc	/^HeapLeakChecker::HeapLeakChecker(const char *name) : lock_(new SpinLock) {$/;"	f	class:HeapLeakChecker	signature:(const char *name)
HeapLeakChecker::HeapLeakChecker_AfterDestructors	src/gperftools/heap-checker.h	/^  friend void HeapLeakChecker_AfterDestructors();$/;"	p	class:HeapLeakChecker	access:friend	signature:()
HeapLeakChecker::HeapLeakChecker_BeforeConstructors	src/gperftools/heap-checker.h	/^  friend void HeapLeakChecker_BeforeConstructors();$/;"	p	class:HeapLeakChecker	access:friend	signature:()
HeapLeakChecker::HeapLeakChecker_InternalInitStart	src/gperftools/heap-checker.h	/^  friend void HeapLeakChecker_InternalInitStart();$/;"	p	class:HeapLeakChecker	access:friend	signature:()
HeapLeakChecker::HeapLeakChecker_RunHeapCleanups	src/gperftools/heap-checker.h	/^  friend void HeapLeakChecker_RunHeapCleanups();$/;"	p	class:HeapLeakChecker	access:friend	signature:()
HeapLeakChecker::IgnoreAllLiveObjectsLocked	src/gperftools/heap-checker.h	/^  static void IgnoreAllLiveObjectsLocked(const void* self_stack_top);$/;"	p	class:HeapLeakChecker	access:private	signature:(const void* self_stack_top)
HeapLeakChecker::IgnoreAllLiveObjectsLocked	src/heap-checker.cc	/^void HeapLeakChecker::IgnoreAllLiveObjectsLocked(const void* self_stack_top) {$/;"	f	class:HeapLeakChecker	signature:(const void* self_stack_top)
HeapLeakChecker::IgnoreLiveObjectsLocked	src/gperftools/heap-checker.h	/^  static void IgnoreLiveObjectsLocked(const char* name, const char* name2);$/;"	p	class:HeapLeakChecker	access:private	signature:(const char* name, const char* name2)
HeapLeakChecker::IgnoreLiveObjectsLocked	src/heap-checker.cc	/^\/*static*\/ void HeapLeakChecker::IgnoreLiveObjectsLocked(const char* name,$/;"	f	class:HeapLeakChecker	signature:(const char* name, const char* name2)
HeapLeakChecker::IgnoreLiveThreadsLocked	src/gperftools/heap-checker.h	/^  static int IgnoreLiveThreadsLocked(void* parameter,$/;"	p	class:HeapLeakChecker	access:private	signature:(void* parameter, int num_threads, pid_t* thread_pids, va_list ap)
HeapLeakChecker::IgnoreLiveThreadsLocked	src/heap-checker.cc	/^\/*static*\/ int HeapLeakChecker::IgnoreLiveThreadsLocked(void* parameter,$/;"	f	class:HeapLeakChecker	signature:(void* parameter, int num_threads, pid_t* thread_pids, va_list )
HeapLeakChecker::IgnoreNonThreadLiveObjectsLocked	src/gperftools/heap-checker.h	/^  static void IgnoreNonThreadLiveObjectsLocked();$/;"	p	class:HeapLeakChecker	access:private	signature:()
HeapLeakChecker::IgnoreNonThreadLiveObjectsLocked	src/heap-checker.cc	/^void HeapLeakChecker::IgnoreNonThreadLiveObjectsLocked() {$/;"	f	class:HeapLeakChecker	signature:()
HeapLeakChecker::IgnoreObject	src/gperftools/heap-checker.h	/^  static T* IgnoreObject(T* ptr) {$/;"	f	class:HeapLeakChecker	access:public	signature:(T* ptr)
HeapLeakChecker::IsActive	src/gperftools/heap-checker.h	/^  static bool IsActive();$/;"	p	class:HeapLeakChecker	access:public	signature:()
HeapLeakChecker::IsActive	src/heap-checker.cc	/^bool HeapLeakChecker::IsActive() {$/;"	f	class:HeapLeakChecker	signature:()
HeapLeakChecker::MakeProfileNameLocked	src/gperftools/heap-checker.h	/^  char* MakeProfileNameLocked();$/;"	p	class:HeapLeakChecker	access:private	signature:()
HeapLeakChecker::MakeProfileNameLocked	src/heap-checker.cc	/^char* HeapLeakChecker::MakeProfileNameLocked() {$/;"	f	class:HeapLeakChecker	signature:()
HeapLeakChecker::NO_SHARED_LIBS_IN_PROC_MAPS	src/gperftools/heap-checker.h	/^    NO_SHARED_LIBS_IN_PROC_MAPS$/;"	e	enum:HeapLeakChecker::ProcMapsResult
HeapLeakChecker::NamedTwoDisabledLeaks	src/gperftools/heap-checker.h	/^  friend void NamedTwoDisabledLeaks();$/;"	p	class:HeapLeakChecker	access:friend	signature:()
HeapLeakChecker::NoGlobalLeaks	src/gperftools/heap-checker.h	/^  static bool NoGlobalLeaks();$/;"	p	class:HeapLeakChecker	access:public	signature:()
HeapLeakChecker::NoGlobalLeaks	src/heap-checker.cc	/^bool HeapLeakChecker::NoGlobalLeaks() {$/;"	f	class:HeapLeakChecker	signature:()
HeapLeakChecker::NoGlobalLeaksMaybeSymbolize	src/gperftools/heap-checker.h	/^  static bool NoGlobalLeaksMaybeSymbolize(ShouldSymbolize should_symbolize);$/;"	p	class:HeapLeakChecker	access:private	signature:(ShouldSymbolize should_symbolize)
HeapLeakChecker::NoGlobalLeaksMaybeSymbolize	src/heap-checker.cc	/^bool HeapLeakChecker::NoGlobalLeaksMaybeSymbolize($/;"	f	class:HeapLeakChecker	signature:( ShouldSymbolize should_symbolize)
HeapLeakChecker::NoLeaks	src/gperftools/heap-checker.h	/^  bool NoLeaks() { return DoNoLeaks(DO_NOT_SYMBOLIZE); }$/;"	f	class:HeapLeakChecker	access:public	signature:()
HeapLeakChecker::ObjectsLeaked	src/gperftools/heap-checker.h	/^  ssize_t ObjectsLeaked() const;$/;"	p	class:HeapLeakChecker	access:public	signature:() const
HeapLeakChecker::ObjectsLeaked	src/heap-checker.cc	/^ssize_t HeapLeakChecker::ObjectsLeaked() const {$/;"	f	class:HeapLeakChecker	signature:() const
HeapLeakChecker::PROC_MAPS_USED	src/gperftools/heap-checker.h	/^    PROC_MAPS_USED,$/;"	e	enum:HeapLeakChecker::ProcMapsResult
HeapLeakChecker::ProcMapsResult	src/gperftools/heap-checker.h	/^  enum ProcMapsResult {$/;"	g	class:HeapLeakChecker	access:private
HeapLeakChecker::ProcMapsTask	src/gperftools/heap-checker.h	/^  enum ProcMapsTask {$/;"	g	class:HeapLeakChecker	access:private
HeapLeakChecker::QuickNoLeaks	src/gperftools/heap-checker.h	/^  bool QuickNoLeaks()  { return NoLeaks(); }$/;"	f	class:HeapLeakChecker	access:public	signature:()
HeapLeakChecker::QuickSameHeap	src/gperftools/heap-checker.h	/^  bool QuickSameHeap() { return NoLeaks(); }$/;"	f	class:HeapLeakChecker	access:public	signature:()
HeapLeakChecker::RECORD_GLOBAL_DATA	src/gperftools/heap-checker.h	/^    RECORD_GLOBAL_DATA,$/;"	e	enum:HeapLeakChecker::ProcMapsTask
HeapLeakChecker::RangeDisabledLeaks	src/gperftools/heap-checker.h	/^  friend void RangeDisabledLeaks();$/;"	p	class:HeapLeakChecker	access:friend	signature:()
HeapLeakChecker::RangeValue	src/heap-checker.cc	/^struct HeapLeakChecker::RangeValue {$/;"	s	class:HeapLeakChecker	file:
HeapLeakChecker::RangeValue::max_depth	src/heap-checker.cc	/^  int       max_depth;      \/\/ the maximal stack depth to disable at$/;"	m	struct:HeapLeakChecker::RangeValue	file:	access:public
HeapLeakChecker::RangeValue::start_address	src/heap-checker.cc	/^  uintptr_t start_address;  \/\/ the start of the range$/;"	m	struct:HeapLeakChecker::RangeValue	file:	access:public
HeapLeakChecker::RunNamedDisabledLeaks	src/gperftools/heap-checker.h	/^  friend void* RunNamedDisabledLeaks(void*);$/;"	p	class:HeapLeakChecker	access:friend	signature:(void*)
HeapLeakChecker::SYMBOLIZE	src/gperftools/heap-checker.h	/^  enum ShouldSymbolize { SYMBOLIZE, DO_NOT_SYMBOLIZE };$/;"	e	enum:HeapLeakChecker::ShouldSymbolize
HeapLeakChecker::SameHeap	src/gperftools/heap-checker.h	/^  bool SameHeap()      { return NoLeaks(); }$/;"	f	class:HeapLeakChecker	access:public	signature:()
HeapLeakChecker::ShouldSymbolize	src/gperftools/heap-checker.h	/^  enum ShouldSymbolize { SYMBOLIZE, DO_NOT_SYMBOLIZE };$/;"	g	class:HeapLeakChecker	access:private
HeapLeakChecker::TestHeapLeakCheckerNamedDisabling	src/gperftools/heap-checker.h	/^  friend void TestHeapLeakCheckerNamedDisabling();$/;"	p	class:HeapLeakChecker	access:friend	signature:()
HeapLeakChecker::TurnItselfOffLocked	src/gperftools/heap-checker.h	/^  static void TurnItselfOffLocked();$/;"	p	class:HeapLeakChecker	access:private	signature:()
HeapLeakChecker::TurnItselfOffLocked	src/heap-checker.cc	/^void HeapLeakChecker::TurnItselfOffLocked() {$/;"	f	class:HeapLeakChecker	signature:()
HeapLeakChecker::UnIgnoreObject	src/gperftools/heap-checker.h	/^  static void UnIgnoreObject(const void* ptr);$/;"	p	class:HeapLeakChecker	access:public	signature:(const void* ptr)
HeapLeakChecker::UnIgnoreObject	src/heap-checker.cc	/^void HeapLeakChecker::UnIgnoreObject(const void* ptr) {$/;"	f	class:HeapLeakChecker	signature:(const void* ptr)
HeapLeakChecker::UseProcMapsLocked	src/gperftools/heap-checker.h	/^  static ProcMapsResult UseProcMapsLocked(ProcMapsTask proc_maps_task);$/;"	p	class:HeapLeakChecker	access:private	signature:(ProcMapsTask proc_maps_task)
HeapLeakChecker::UseProcMapsLocked	src/heap-checker.cc	/^HeapLeakChecker::ProcMapsResult HeapLeakChecker::UseProcMapsLocked($/;"	f	class:HeapLeakChecker	signature:( ProcMapsTask proc_maps_task)
HeapLeakChecker::VerifyHeapProfileTableStackGet	src/gperftools/heap-checker.h	/^  friend void VerifyHeapProfileTableStackGet();$/;"	p	class:HeapLeakChecker	access:friend	signature:()
HeapLeakChecker::has_checked_	src/gperftools/heap-checker.h	/^  bool has_checked_;  \/\/ if we have done the leak check, so these are ready:$/;"	m	class:HeapLeakChecker	access:private
HeapLeakChecker::inuse_allocs_increase_	src/gperftools/heap-checker.h	/^  ssize_t inuse_allocs_increase_;  \/\/ allocations-in-use increase$/;"	m	class:HeapLeakChecker	access:private
HeapLeakChecker::inuse_bytes_increase_	src/gperftools/heap-checker.h	/^  ssize_t inuse_bytes_increase_;  \/\/ bytes-in-use increase for this checker$/;"	m	class:HeapLeakChecker	access:private
HeapLeakChecker::keep_profiles_	src/gperftools/heap-checker.h	/^  bool keep_profiles_;  \/\/ iff we should keep the heap profiles we've made$/;"	m	class:HeapLeakChecker	access:private
HeapLeakChecker::lock_	src/gperftools/heap-checker.h	/^  class SpinLock* lock_;  \/\/ to make HeapLeakChecker objects thread-safe$/;"	m	class:HeapLeakChecker	typeref:class:HeapLeakChecker::SpinLock	access:private
HeapLeakChecker::name_	src/gperftools/heap-checker.h	/^  const char* name_;  \/\/ our remembered name (we own it)$/;"	m	class:HeapLeakChecker	access:private
HeapLeakChecker::operator =	src/gperftools/heap-checker.h	/^  void operator=(const HeapLeakChecker&);$/;"	p	class:HeapLeakChecker	access:private	signature:(const HeapLeakChecker&)
HeapLeakChecker::start_snapshot_	src/gperftools/heap-checker.h	/^  void* start_snapshot_;$/;"	m	class:HeapLeakChecker	access:private
HeapLeakChecker::~HeapLeakChecker	src/gperftools/heap-checker.h	/^  ~HeapLeakChecker();$/;"	p	class:HeapLeakChecker	access:public	signature:()
HeapLeakChecker::~HeapLeakChecker	src/heap-checker.cc	/^HeapLeakChecker::~HeapLeakChecker() {$/;"	f	class:HeapLeakChecker	signature:()
HeapLeakCheckerGlobalPrePost	src/heap-checker-bcad.cc	/^  HeapLeakCheckerGlobalPrePost() {$/;"	f	class:HeapLeakCheckerGlobalPrePost	access:public	signature:()
HeapLeakCheckerGlobalPrePost	src/heap-checker-bcad.cc	/^class HeapLeakCheckerGlobalPrePost {$/;"	c	file:
HeapLeakCheckerGlobalPrePost::HeapLeakCheckerGlobalPrePost	src/heap-checker-bcad.cc	/^  HeapLeakCheckerGlobalPrePost() {$/;"	f	class:HeapLeakCheckerGlobalPrePost	access:public	signature:()
HeapLeakCheckerGlobalPrePost::count_	src/heap-checker-bcad.cc	/^  static int count_;$/;"	m	class:HeapLeakCheckerGlobalPrePost	file:	access:private
HeapLeakCheckerGlobalPrePost::count_	src/heap-checker-bcad.cc	/^int HeapLeakCheckerGlobalPrePost::count_ = 0;$/;"	m	class:HeapLeakCheckerGlobalPrePost	file:
HeapLeakCheckerGlobalPrePost::~HeapLeakCheckerGlobalPrePost	src/heap-checker-bcad.cc	/^  ~HeapLeakCheckerGlobalPrePost() {$/;"	f	class:HeapLeakCheckerGlobalPrePost	access:public	signature:()
HeapLeakChecker_AfterDestructors	src/gperftools/heap-checker.h	/^  friend void HeapLeakChecker_AfterDestructors();$/;"	p	class:HeapLeakChecker	access:friend	signature:()
HeapLeakChecker_AfterDestructors	src/heap-checker-bcad.cc	/^extern void HeapLeakChecker_AfterDestructors();  \/\/ in heap-checker.cc$/;"	p	file:	signature:()
HeapLeakChecker_AfterDestructors	src/heap-checker.cc	/^void HeapLeakChecker_AfterDestructors() {$/;"	f	signature:()
HeapLeakChecker_BeforeConstructors	src/gperftools/heap-checker.h	/^  friend void HeapLeakChecker_BeforeConstructors();$/;"	p	class:HeapLeakChecker	access:friend	signature:()
HeapLeakChecker_BeforeConstructors	src/heap-checker.cc	/^void HeapLeakChecker_BeforeConstructors() {$/;"	f	signature:()
HeapLeakChecker_InternalInitStart	src/gperftools/heap-checker.h	/^  friend void HeapLeakChecker_InternalInitStart();$/;"	p	class:HeapLeakChecker	access:friend	signature:()
HeapLeakChecker_InternalInitStart	src/heap-checker.cc	/^void HeapLeakChecker_InternalInitStart() {$/;"	f	signature:()
HeapLeakChecker_RunHeapCleanups	src/gperftools/heap-checker.h	/^  friend void HeapLeakChecker_RunHeapCleanups();$/;"	p	class:HeapLeakChecker	access:friend	signature:()
HeapLeakChecker_RunHeapCleanups	src/heap-checker.cc	/^void HeapLeakChecker_RunHeapCleanups() {$/;"	f	signature:()
HeapProfileBucket	src/heap-profile-stats.h	/^struct HeapProfileBucket : public HeapProfileStats {$/;"	s	inherits:HeapProfileStats
HeapProfileBucket::depth	src/heap-profile-stats.h	/^  int depth;                \/\/ Depth of stack trace.$/;"	m	struct:HeapProfileBucket	access:public
HeapProfileBucket::hash	src/heap-profile-stats.h	/^  uintptr_t hash;           \/\/ Hash value of the stack trace.$/;"	m	struct:HeapProfileBucket	access:public
HeapProfileBucket::kMaxStackDepth	src/heap-profile-stats.h	/^  static const int kMaxStackDepth = 32;$/;"	m	struct:HeapProfileBucket	access:public
HeapProfileBucket::next	src/heap-profile-stats.h	/^  HeapProfileBucket* next;  \/\/ Next entry in hash-table.$/;"	m	struct:HeapProfileBucket	access:public
HeapProfileBucket::stack	src/heap-profile-stats.h	/^  const void** stack;       \/\/ Stack trace.$/;"	m	struct:HeapProfileBucket	access:public
HeapProfileEndWriter	src/heap-profiler.cc	/^struct HeapProfileEndWriter {$/;"	s	file:
HeapProfileEndWriter::~HeapProfileEndWriter	src/heap-profiler.cc	/^  ~HeapProfileEndWriter() {$/;"	f	struct:HeapProfileEndWriter	access:public	signature:()
HeapProfileStats	src/heap-profile-stats.h	/^struct HeapProfileStats {$/;"	s
HeapProfileStats::Equivalent	src/heap-profile-stats.h	/^  bool Equivalent(const HeapProfileStats& other) const {$/;"	f	struct:HeapProfileStats	access:public	signature:(const HeapProfileStats& other) const
HeapProfileStats::alloc_size	src/heap-profile-stats.h	/^  int64 alloc_size;  \/\/ Total size of all allocated objects so far.$/;"	m	struct:HeapProfileStats	access:public
HeapProfileStats::allocs	src/heap-profile-stats.h	/^  int32 allocs;      \/\/ Number of allocation calls.$/;"	m	struct:HeapProfileStats	access:public
HeapProfileStats::free_size	src/heap-profile-stats.h	/^  int64 free_size;   \/\/ Total size of all freed objects so far.$/;"	m	struct:HeapProfileStats	access:public
HeapProfileStats::frees	src/heap-profile-stats.h	/^  int32 frees;       \/\/ Number of free calls.$/;"	m	struct:HeapProfileStats	access:public
HeapProfileTable	src/heap-profile-table.cc	/^HeapProfileTable::HeapProfileTable(Allocator alloc,$/;"	f	class:HeapProfileTable	signature:(Allocator alloc, DeAllocator dealloc, bool profile_mmap)
HeapProfileTable	src/heap-profile-table.h	/^  HeapProfileTable(Allocator alloc, DeAllocator dealloc, bool profile_mmap);$/;"	p	class:HeapProfileTable	access:public	signature:(Allocator alloc, DeAllocator dealloc, bool profile_mmap)
HeapProfileTable	src/heap-profile-table.h	/^class HeapProfileTable {$/;"	c
HeapProfileTable::AddIfNonLive	src/heap-profile-table.cc	/^void HeapProfileTable::AddIfNonLive(const void* ptr, AllocValue* v,$/;"	f	class:HeapProfileTable	signature:(const void* ptr, AllocValue* v, AddNonLiveArgs* arg)
HeapProfileTable::AddIfNonLive	src/heap-profile-table.h	/^  static void AddIfNonLive(const void* ptr, AllocValue* v,$/;"	p	class:HeapProfileTable	access:private	signature:(const void* ptr, AllocValue* v, AddNonLiveArgs* arg)
HeapProfileTable::AddNonLiveArgs	src/heap-profile-table.h	/^  struct AddNonLiveArgs {$/;"	s	class:HeapProfileTable	access:private
HeapProfileTable::AddNonLiveArgs::base	src/heap-profile-table.h	/^    Snapshot* base;$/;"	m	struct:HeapProfileTable::AddNonLiveArgs	access:public
HeapProfileTable::AddNonLiveArgs::dest	src/heap-profile-table.h	/^    Snapshot* dest;$/;"	m	struct:HeapProfileTable::AddNonLiveArgs	access:public
HeapProfileTable::AddToSnapshot	src/heap-profile-table.cc	/^void HeapProfileTable::AddToSnapshot(const void* ptr, AllocValue* v,$/;"	f	class:HeapProfileTable	signature:(const void* ptr, AllocValue* v, Snapshot* snapshot)
HeapProfileTable::AddToSnapshot	src/heap-profile-table.h	/^  static void AddToSnapshot(const void* ptr, AllocValue* v, Snapshot* s);$/;"	p	class:HeapProfileTable	access:private	signature:(const void* ptr, AllocValue* v, Snapshot* s)
HeapProfileTable::AllocContextInfo	src/heap-profile-table.h	/^  struct AllocContextInfo : public Stats {$/;"	s	class:HeapProfileTable	inherits:Stats	access:public
HeapProfileTable::AllocContextInfo::call_stack	src/heap-profile-table.h	/^    const void* const* call_stack;  \/\/ Stack trace$/;"	m	struct:HeapProfileTable::AllocContextInfo	access:public
HeapProfileTable::AllocContextInfo::stack_depth	src/heap-profile-table.h	/^    int stack_depth;                \/\/ Depth of stack trace$/;"	m	struct:HeapProfileTable::AllocContextInfo	access:public
HeapProfileTable::AllocContextIterator	src/heap-profile-table.h	/^  typedef void (*AllocContextIterator)(const AllocContextInfo& info);$/;"	t	class:HeapProfileTable	access:public
HeapProfileTable::AllocInfo	src/heap-profile-table.h	/^  struct AllocInfo {$/;"	s	class:HeapProfileTable	access:public
HeapProfileTable::AllocInfo::call_stack	src/heap-profile-table.h	/^    const void* const* call_stack;  \/\/ call stack that made the allocation call$/;"	m	struct:HeapProfileTable::AllocInfo	access:public
HeapProfileTable::AllocInfo::ignored	src/heap-profile-table.h	/^    bool ignored;$/;"	m	struct:HeapProfileTable::AllocInfo	access:public
HeapProfileTable::AllocInfo::live	src/heap-profile-table.h	/^    bool live;$/;"	m	struct:HeapProfileTable::AllocInfo	access:public
HeapProfileTable::AllocInfo::object_size	src/heap-profile-table.h	/^    size_t object_size;  \/\/ size of the allocation$/;"	m	struct:HeapProfileTable::AllocInfo	access:public
HeapProfileTable::AllocInfo::stack_depth	src/heap-profile-table.h	/^    int stack_depth;  \/\/ depth of call_stack$/;"	m	struct:HeapProfileTable::AllocInfo	access:public
HeapProfileTable::AllocIterator	src/heap-profile-table.h	/^  typedef void (*AllocIterator)(const void* ptr, const AllocInfo& info);$/;"	t	class:HeapProfileTable	access:public
HeapProfileTable::AllocValue	src/heap-profile-table.h	/^  struct AllocValue {$/;"	s	class:HeapProfileTable	access:private
HeapProfileTable::AllocValue::bucket	src/heap-profile-table.h	/^    Bucket* bucket() const {$/;"	f	struct:HeapProfileTable::AllocValue	access:public	signature:() const
HeapProfileTable::AllocValue::bucket_rep	src/heap-profile-table.h	/^    uintptr_t bucket_rep;$/;"	m	struct:HeapProfileTable::AllocValue	access:private
HeapProfileTable::AllocValue::bytes	src/heap-profile-table.h	/^    size_t  bytes;   \/\/ Number of bytes in this allocation$/;"	m	struct:HeapProfileTable::AllocValue	access:public
HeapProfileTable::AllocValue::ignore	src/heap-profile-table.h	/^    bool ignore() const { return bucket_rep & kIgnore; }$/;"	f	struct:HeapProfileTable::AllocValue	access:public	signature:() const
HeapProfileTable::AllocValue::kIgnore	src/heap-profile-table.h	/^    static const int kIgnore = 2;$/;"	m	struct:HeapProfileTable::AllocValue	access:private
HeapProfileTable::AllocValue::kLive	src/heap-profile-table.h	/^    static const int kLive = 1;$/;"	m	struct:HeapProfileTable::AllocValue	access:private
HeapProfileTable::AllocValue::kMask	src/heap-profile-table.h	/^    static const int kMask = kLive | kIgnore;$/;"	m	struct:HeapProfileTable::AllocValue	access:private
HeapProfileTable::AllocValue::live	src/heap-profile-table.h	/^    bool live() const { return bucket_rep & kLive; }$/;"	f	struct:HeapProfileTable::AllocValue	access:public	signature:() const
HeapProfileTable::AllocValue::set_bucket	src/heap-profile-table.h	/^    void set_bucket(Bucket* b) { bucket_rep = reinterpret_cast<uintptr_t>(b); }$/;"	f	struct:HeapProfileTable::AllocValue	access:public	signature:(Bucket* b)
HeapProfileTable::AllocValue::set_ignore	src/heap-profile-table.h	/^    void set_ignore(bool r) {$/;"	f	struct:HeapProfileTable::AllocValue	access:public	signature:(bool r)
HeapProfileTable::AllocValue::set_live	src/heap-profile-table.h	/^    void set_live(bool l) {$/;"	f	struct:HeapProfileTable::AllocValue	access:public	signature:(bool l)
HeapProfileTable::AllocValueSize	src/heap-profile-table.h	/^  static size_t AllocValueSize(const AllocValue& v) { return v.bytes; }$/;"	f	class:HeapProfileTable	access:private	signature:(const AllocValue& v)
HeapProfileTable::AllocationMap	src/heap-profile-table.h	/^  typedef AddressMap<AllocValue> AllocationMap;$/;"	t	class:HeapProfileTable	access:private
HeapProfileTable::Allocator	src/heap-profile-table.h	/^  typedef void* (*Allocator)(size_t size);$/;"	t	class:HeapProfileTable	access:public
HeapProfileTable::Bucket	src/heap-profile-table.h	/^  typedef HeapProfileBucket Bucket;$/;"	t	class:HeapProfileTable	access:private
HeapProfileTable::BufferArgs	src/heap-profile-table.h	/^  struct BufferArgs {$/;"	s	class:HeapProfileTable	access:private
HeapProfileTable::BufferArgs::BufferArgs	src/heap-profile-table.h	/^    BufferArgs(char* buf_arg, int buflen_arg, int bufsize_arg)$/;"	f	struct:HeapProfileTable::BufferArgs	access:public	signature:(char* buf_arg, int buflen_arg, int bufsize_arg)
HeapProfileTable::BufferArgs::DISALLOW_COPY_AND_ASSIGN	src/heap-profile-table.h	/^    DISALLOW_COPY_AND_ASSIGN(BufferArgs);$/;"	p	struct:HeapProfileTable::BufferArgs	access:public	signature:(BufferArgs)
HeapProfileTable::BufferArgs::buf	src/heap-profile-table.h	/^    char* buf;$/;"	m	struct:HeapProfileTable::BufferArgs	access:public
HeapProfileTable::BufferArgs::buflen	src/heap-profile-table.h	/^    int buflen;$/;"	m	struct:HeapProfileTable::BufferArgs	access:public
HeapProfileTable::BufferArgs::bufsize	src/heap-profile-table.h	/^    int bufsize;$/;"	m	struct:HeapProfileTable::BufferArgs	access:public
HeapProfileTable::CleanupOldProfiles	src/heap-profile-table.cc	/^void HeapProfileTable::CleanupOldProfiles(const char* prefix) {$/;"	f	class:HeapProfileTable	signature:(const char* prefix)
HeapProfileTable::CleanupOldProfiles	src/heap-profile-table.h	/^  static void CleanupOldProfiles(const char* prefix);$/;"	p	class:HeapProfileTable	access:public	signature:(const char* prefix)
HeapProfileTable::DISALLOW_COPY_AND_ASSIGN	src/heap-profile-table.h	/^  DISALLOW_COPY_AND_ASSIGN(HeapProfileTable);$/;"	p	class:HeapProfileTable	access:private	signature:(HeapProfileTable)
HeapProfileTable::DeAllocator	src/heap-profile-table.h	/^  typedef void  (*DeAllocator)(void* ptr);$/;"	t	class:HeapProfileTable	access:public
HeapProfileTable::DumpArgs	src/heap-profile-table.h	/^  struct DumpArgs {$/;"	s	class:HeapProfileTable	access:private
HeapProfileTable::DumpArgs::DumpArgs	src/heap-profile-table.h	/^    DumpArgs(RawFD fd_arg, Stats* profile_stats_arg)$/;"	f	struct:HeapProfileTable::DumpArgs	access:public	signature:(RawFD fd_arg, Stats* profile_stats_arg)
HeapProfileTable::DumpArgs::fd	src/heap-profile-table.h	/^    RawFD fd;  \/\/ file to write to$/;"	m	struct:HeapProfileTable::DumpArgs	access:public
HeapProfileTable::DumpArgs::profile_stats	src/heap-profile-table.h	/^    Stats* profile_stats;  \/\/ stats to update (may be NULL)$/;"	m	struct:HeapProfileTable::DumpArgs	access:public
HeapProfileTable::DumpBucketIterator	src/heap-profile-table.cc	/^void HeapProfileTable::DumpBucketIterator(const Bucket* bucket,$/;"	f	class:HeapProfileTable	signature:(const Bucket* bucket, BufferArgs* args)
HeapProfileTable::DumpBucketIterator	src/heap-profile-table.h	/^  inline static void DumpBucketIterator(const Bucket* bucket,$/;"	p	class:HeapProfileTable	access:private	signature:(const Bucket* bucket, BufferArgs* args)
HeapProfileTable::DumpNonLiveIterator	src/heap-profile-table.cc	/^void HeapProfileTable::DumpNonLiveIterator(const void* ptr, AllocValue* v,$/;"	f	class:HeapProfileTable	signature:(const void* ptr, AllocValue* v, const DumpArgs& args)
HeapProfileTable::DumpNonLiveIterator	src/heap-profile-table.h	/^  inline static void DumpNonLiveIterator(const void* ptr, AllocValue* v,$/;"	p	class:HeapProfileTable	access:private	signature:(const void* ptr, AllocValue* v, const DumpArgs& args)
HeapProfileTable::FillOrderedProfile	src/heap-profile-table.cc	/^int HeapProfileTable::FillOrderedProfile(char buf[], int size) const {$/;"	f	class:HeapProfileTable	signature:(char buf[], int size) const
HeapProfileTable::FillOrderedProfile	src/heap-profile-table.h	/^  int FillOrderedProfile(char buf[], int size) const;$/;"	p	class:HeapProfileTable	access:public	signature:(char buf[], int size) const
HeapProfileTable::FindAlloc	src/heap-profile-table.cc	/^bool HeapProfileTable::FindAlloc(const void* ptr, size_t* object_size) const {$/;"	f	class:HeapProfileTable	signature:(const void* ptr, size_t* object_size) const
HeapProfileTable::FindAlloc	src/heap-profile-table.h	/^  bool FindAlloc(const void* ptr, size_t* object_size) const;$/;"	p	class:HeapProfileTable	access:public	signature:(const void* ptr, size_t* object_size) const
HeapProfileTable::FindAllocDetails	src/heap-profile-table.cc	/^bool HeapProfileTable::FindAllocDetails(const void* ptr,$/;"	f	class:HeapProfileTable	signature:(const void* ptr, AllocInfo* info) const
HeapProfileTable::FindAllocDetails	src/heap-profile-table.h	/^  bool FindAllocDetails(const void* ptr, AllocInfo* info) const;$/;"	p	class:HeapProfileTable	access:public	signature:(const void* ptr, AllocInfo* info) const
HeapProfileTable::FindInsideAlloc	src/heap-profile-table.cc	/^bool HeapProfileTable::FindInsideAlloc(const void* ptr,$/;"	f	class:HeapProfileTable	signature:(const void* ptr, size_t max_size, const void** object_ptr, size_t* object_size) const
HeapProfileTable::FindInsideAlloc	src/heap-profile-table.h	/^  bool FindInsideAlloc(const void* ptr, size_t max_size,$/;"	p	class:HeapProfileTable	access:public	signature:(const void* ptr, size_t max_size, const void** object_ptr, size_t* object_size) const
HeapProfileTable::GetBucket	src/heap-profile-table.cc	/^HeapProfileTable::Bucket* HeapProfileTable::GetBucket(int depth,$/;"	f	class:HeapProfileTable	signature:(int depth, const void* const key[])
HeapProfileTable::GetBucket	src/heap-profile-table.h	/^  Bucket* GetBucket(int depth, const void* const key[]);$/;"	p	class:HeapProfileTable	access:private	signature:(int depth, const void* const key[])
HeapProfileTable::GetCallerStackTrace	src/heap-profile-table.cc	/^int HeapProfileTable::GetCallerStackTrace($/;"	f	class:HeapProfileTable	signature:( int skip_count, void* stack[kMaxStackDepth])
HeapProfileTable::GetCallerStackTrace	src/heap-profile-table.h	/^  static int GetCallerStackTrace(int skip_count, void* stack[kMaxStackDepth]);$/;"	p	class:HeapProfileTable	access:public	signature:(int skip_count, void* stack[kMaxStackDepth])
HeapProfileTable::HeapProfileTable	src/heap-profile-table.cc	/^HeapProfileTable::HeapProfileTable(Allocator alloc,$/;"	f	class:HeapProfileTable	signature:(Allocator alloc, DeAllocator dealloc, bool profile_mmap)
HeapProfileTable::HeapProfileTable	src/heap-profile-table.h	/^  HeapProfileTable(Allocator alloc, DeAllocator dealloc, bool profile_mmap);$/;"	p	class:HeapProfileTable	access:public	signature:(Allocator alloc, DeAllocator dealloc, bool profile_mmap)
HeapProfileTable::IterateAllocs	src/heap-profile-table.h	/^  void IterateAllocs(AllocIterator callback) const {$/;"	f	class:HeapProfileTable	access:public	signature:(AllocIterator callback) const
HeapProfileTable::IterateOrderedAllocContexts	src/heap-profile-table.cc	/^void HeapProfileTable::IterateOrderedAllocContexts($/;"	f	class:HeapProfileTable	signature:( AllocContextIterator callback) const
HeapProfileTable::IterateOrderedAllocContexts	src/heap-profile-table.h	/^  void IterateOrderedAllocContexts(AllocContextIterator callback) const;$/;"	p	class:HeapProfileTable	access:public	signature:(AllocContextIterator callback) const
HeapProfileTable::MakeSortedBucketList	src/heap-profile-table.cc	/^HeapProfileTable::MakeSortedBucketList() const {$/;"	f	class:HeapProfileTable	signature:() const
HeapProfileTable::MakeSortedBucketList	src/heap-profile-table.h	/^  Bucket** MakeSortedBucketList() const;$/;"	p	class:HeapProfileTable	access:private	signature:() const
HeapProfileTable::MapArgsAllocIterator	src/heap-profile-table.h	/^  static void MapArgsAllocIterator(const void* ptr, AllocValue* v,$/;"	f	class:HeapProfileTable	access:private	signature:(const void* ptr, AllocValue* v, AllocIterator callback)
HeapProfileTable::MarkAsIgnored	src/heap-profile-table.cc	/^void HeapProfileTable::MarkAsIgnored(const void* ptr) {$/;"	f	class:HeapProfileTable	signature:(const void* ptr)
HeapProfileTable::MarkAsIgnored	src/heap-profile-table.h	/^  void MarkAsIgnored(const void* ptr);$/;"	p	class:HeapProfileTable	access:public	signature:(const void* ptr)
HeapProfileTable::MarkAsLive	src/heap-profile-table.cc	/^bool HeapProfileTable::MarkAsLive(const void* ptr) {$/;"	f	class:HeapProfileTable	signature:(const void* ptr)
HeapProfileTable::MarkAsLive	src/heap-profile-table.h	/^  bool MarkAsLive(const void* ptr);$/;"	p	class:HeapProfileTable	access:public	signature:(const void* ptr)
HeapProfileTable::NonLiveSnapshot	src/heap-profile-table.cc	/^HeapProfileTable::Snapshot* HeapProfileTable::NonLiveSnapshot($/;"	f	class:HeapProfileTable	signature:( Snapshot* base)
HeapProfileTable::NonLiveSnapshot	src/heap-profile-table.h	/^  Snapshot* NonLiveSnapshot(Snapshot* base);$/;"	p	class:HeapProfileTable	access:public	signature:(Snapshot* base)
HeapProfileTable::RecordAlloc	src/heap-profile-table.cc	/^void HeapProfileTable::RecordAlloc($/;"	f	class:HeapProfileTable	signature:( const void* ptr, size_t bytes, int stack_depth, const void* const call_stack[])
HeapProfileTable::RecordAlloc	src/heap-profile-table.h	/^  void RecordAlloc(const void* ptr, size_t bytes,$/;"	p	class:HeapProfileTable	access:public	signature:(const void* ptr, size_t bytes, int stack_depth, const void* const call_stack[])
HeapProfileTable::RecordFree	src/heap-profile-table.cc	/^void HeapProfileTable::RecordFree(const void* ptr) {$/;"	f	class:HeapProfileTable	signature:(const void* ptr)
HeapProfileTable::RecordFree	src/heap-profile-table.h	/^  void RecordFree(const void* ptr);$/;"	p	class:HeapProfileTable	access:public	signature:(const void* ptr)
HeapProfileTable::ReleaseSnapshot	src/heap-profile-table.cc	/^void HeapProfileTable::ReleaseSnapshot(Snapshot* s) {$/;"	f	class:HeapProfileTable	signature:(Snapshot* s)
HeapProfileTable::ReleaseSnapshot	src/heap-profile-table.h	/^  void ReleaseSnapshot(Snapshot* snapshot);$/;"	p	class:HeapProfileTable	access:public	signature:(Snapshot* snapshot)
HeapProfileTable::Snapshot	src/heap-profile-table.h	/^class HeapProfileTable::Snapshot {$/;"	c	class:HeapProfileTable
HeapProfileTable::Snapshot::Add	src/heap-profile-table.h	/^  inline void Add(const void* ptr, const AllocValue& v) {$/;"	f	class:HeapProfileTable::Snapshot	access:private	signature:(const void* ptr, const AllocValue& v)
HeapProfileTable::Snapshot::DISALLOW_COPY_AND_ASSIGN	src/heap-profile-table.h	/^  DISALLOW_COPY_AND_ASSIGN(Snapshot);$/;"	p	class:HeapProfileTable::Snapshot	access:private	signature:(Snapshot)
HeapProfileTable::Snapshot::Empty	src/heap-profile-table.h	/^  bool Empty() const {$/;"	f	class:HeapProfileTable::Snapshot	access:public	signature:() const
HeapProfileTable::Snapshot::Entry	src/heap-profile-table.cc	/^struct HeapProfileTable::Snapshot::Entry {$/;"	s	class:HeapProfileTable::Snapshot	file:
HeapProfileTable::Snapshot::Entry::Entry	src/heap-profile-table.cc	/^  Entry() : count(0), bytes(0) { }$/;"	f	struct:HeapProfileTable::Snapshot::Entry	access:public	signature:()
HeapProfileTable::Snapshot::Entry::bucket	src/heap-profile-table.cc	/^  Bucket* bucket;$/;"	m	struct:HeapProfileTable::Snapshot::Entry	file:	access:public
HeapProfileTable::Snapshot::Entry::bytes	src/heap-profile-table.cc	/^  int bytes;$/;"	m	struct:HeapProfileTable::Snapshot::Entry	file:	access:public
HeapProfileTable::Snapshot::Entry::count	src/heap-profile-table.cc	/^  int count;$/;"	m	struct:HeapProfileTable::Snapshot::Entry	file:	access:public
HeapProfileTable::Snapshot::Entry::operator <	src/heap-profile-table.cc	/^  bool operator<(const Entry& x) const {$/;"	f	struct:HeapProfileTable::Snapshot::Entry	access:public	signature:(const Entry& x) const
HeapProfileTable::Snapshot::ReportCallback	src/heap-profile-table.cc	/^void HeapProfileTable::Snapshot::ReportCallback(const void* ptr,$/;"	f	class:HeapProfileTable::Snapshot	signature:(const void* ptr, AllocValue* v, ReportState* state)
HeapProfileTable::Snapshot::ReportCallback	src/heap-profile-table.h	/^  static void ReportCallback(const void* ptr, AllocValue* v, ReportState*);$/;"	p	class:HeapProfileTable::Snapshot	access:private	signature:(const void* ptr, AllocValue* v, ReportState*)
HeapProfileTable::Snapshot::ReportIndividualObjects	src/heap-profile-table.cc	/^void HeapProfileTable::Snapshot::ReportIndividualObjects() {$/;"	f	class:HeapProfileTable::Snapshot	signature:()
HeapProfileTable::Snapshot::ReportIndividualObjects	src/heap-profile-table.h	/^  void ReportIndividualObjects();$/;"	p	class:HeapProfileTable::Snapshot	access:public	signature:()
HeapProfileTable::Snapshot::ReportLeaks	src/heap-profile-table.cc	/^void HeapProfileTable::Snapshot::ReportLeaks(const char* checker_name,$/;"	f	class:HeapProfileTable::Snapshot	signature:(const char* checker_name, const char* filename, bool should_symbolize)
HeapProfileTable::Snapshot::ReportLeaks	src/heap-profile-table.h	/^  void ReportLeaks(const char* checker_name, const char* filename,$/;"	p	class:HeapProfileTable::Snapshot	access:public	signature:(const char* checker_name, const char* filename, bool should_symbolize)
HeapProfileTable::Snapshot::ReportObject	src/heap-profile-table.cc	/^void HeapProfileTable::Snapshot::ReportObject(const void* ptr,$/;"	f	class:HeapProfileTable::Snapshot	signature:(const void* ptr, AllocValue* v, char* unused)
HeapProfileTable::Snapshot::ReportObject	src/heap-profile-table.h	/^  static void ReportObject(const void* ptr, AllocValue* v, char*);$/;"	p	class:HeapProfileTable::Snapshot	access:private	signature:(const void* ptr, AllocValue* v, char*)
HeapProfileTable::Snapshot::ReportState	src/heap-profile-table.cc	/^struct HeapProfileTable::Snapshot::ReportState {$/;"	s	class:HeapProfileTable::Snapshot	file:
HeapProfileTable::Snapshot::ReportState::buckets_	src/heap-profile-table.cc	/^  map<Bucket*, Entry> buckets_;$/;"	m	struct:HeapProfileTable::Snapshot::ReportState	file:	access:public
HeapProfileTable::Snapshot::Snapshot	src/heap-profile-table.h	/^  Snapshot(Allocator alloc, DeAllocator dealloc) : map_(alloc, dealloc) {$/;"	f	class:HeapProfileTable::Snapshot	access:private	signature:(Allocator alloc, DeAllocator dealloc)
HeapProfileTable::Snapshot::map_	src/heap-profile-table.h	/^  AllocationMap map_;$/;"	m	class:HeapProfileTable::Snapshot	access:private
HeapProfileTable::Snapshot::total	src/heap-profile-table.h	/^  const Stats& total() const { return total_; }$/;"	f	class:HeapProfileTable::Snapshot	access:public	signature:() const
HeapProfileTable::Snapshot::total_	src/heap-profile-table.h	/^  Bucket total_;$/;"	m	class:HeapProfileTable::Snapshot	access:private
HeapProfileTable::Stats	src/heap-profile-table.h	/^  typedef HeapProfileStats Stats;$/;"	t	class:HeapProfileTable	access:public
HeapProfileTable::TakeSnapshot	src/heap-profile-table.cc	/^HeapProfileTable::Snapshot* HeapProfileTable::TakeSnapshot() {$/;"	f	class:HeapProfileTable	signature:()
HeapProfileTable::TakeSnapshot	src/heap-profile-table.h	/^  Snapshot* TakeSnapshot();$/;"	p	class:HeapProfileTable	access:public	signature:()
HeapProfileTable::UnparseBucket	src/heap-profile-table.cc	/^int HeapProfileTable::UnparseBucket(const Bucket& b,$/;"	f	class:HeapProfileTable	signature:(const Bucket& b, char* buf, int buflen, int bufsize, const char* extra, Stats* profile_stats)
HeapProfileTable::UnparseBucket	src/heap-profile-table.h	/^  static int UnparseBucket(const Bucket& b,$/;"	p	class:HeapProfileTable	access:private	signature:(const Bucket& b, char* buf, int buflen, int bufsize, const char* extra, Stats* profile_stats)
HeapProfileTable::WriteProfile	src/heap-profile-table.cc	/^bool HeapProfileTable::WriteProfile(const char* file_name,$/;"	f	class:HeapProfileTable	signature:(const char* file_name, const Bucket& total, AllocationMap* allocations)
HeapProfileTable::WriteProfile	src/heap-profile-table.h	/^  static bool WriteProfile(const char* file_name,$/;"	p	class:HeapProfileTable	access:private	signature:(const char* file_name, const Bucket& total, AllocationMap* allocations)
HeapProfileTable::address_map_	src/heap-profile-table.h	/^  AllocationMap* address_map_;$/;"	m	class:HeapProfileTable	access:private
HeapProfileTable::alloc_	src/heap-profile-table.h	/^  Allocator alloc_;$/;"	m	class:HeapProfileTable	access:private
HeapProfileTable::bucket_table_	src/heap-profile-table.h	/^  Bucket** bucket_table_;$/;"	m	class:HeapProfileTable	access:private
HeapProfileTable::dealloc_	src/heap-profile-table.h	/^  DeAllocator dealloc_;$/;"	m	class:HeapProfileTable	access:private
HeapProfileTable::kFileExt	src/heap-profile-table.cc	/^const char HeapProfileTable::kFileExt[] = ".heap";$/;"	m	class:HeapProfileTable	file:
HeapProfileTable::kFileExt	src/heap-profile-table.h	/^  static const char kFileExt[];$/;"	m	class:HeapProfileTable	access:public
HeapProfileTable::kMaxStackDepth	src/heap-profile-table.cc	/^\/*static*\/ const int HeapProfileTable::kMaxStackDepth;$/;"	m	class:HeapProfileTable	file:
HeapProfileTable::kMaxStackDepth	src/heap-profile-table.h	/^  static const int kMaxStackDepth = 32;$/;"	m	class:HeapProfileTable	access:public
HeapProfileTable::num_buckets_	src/heap-profile-table.h	/^  int num_buckets_;$/;"	m	class:HeapProfileTable	access:private
HeapProfileTable::profile_mmap_	src/heap-profile-table.h	/^  bool profile_mmap_;$/;"	m	class:HeapProfileTable	access:private
HeapProfileTable::total	src/heap-profile-table.h	/^  const Stats& total() const { return total_; }$/;"	f	class:HeapProfileTable	access:public	signature:() const
HeapProfileTable::total_	src/heap-profile-table.h	/^  Bucket total_;$/;"	m	class:HeapProfileTable	access:private
HeapProfileTable::~HeapProfileTable	src/heap-profile-table.cc	/^HeapProfileTable::~HeapProfileTable() {$/;"	f	class:HeapProfileTable	signature:()
HeapProfileTable::~HeapProfileTable	src/heap-profile-table.h	/^  ~HeapProfileTable();$/;"	p	class:HeapProfileTable	access:public	signature:()
HeapProfilerDump	src/gperftools/heap-profiler.h	/^PERFTOOLS_DLL_DECL void HeapProfilerDump(const char *reason);$/;"	p	signature:(const char *reason)
HeapProfilerDump	src/heap-profiler.cc	/^extern "C" void HeapProfilerDump(const char *reason) {$/;"	f	signature:(const char *reason)
HeapProfilerDumpSignal	src/heap-profiler.cc	/^static void HeapProfilerDumpSignal(int signal_number) {$/;"	f	file:	signature:(int signal_number)
HeapProfilerInit	src/heap-profiler.cc	/^static void HeapProfilerInit() {$/;"	f	file:	signature:()
HeapProfilerStart	src/gperftools/heap-profiler.h	/^PERFTOOLS_DLL_DECL void HeapProfilerStart(const char* prefix);$/;"	p	signature:(const char* prefix)
HeapProfilerStart	src/heap-profiler.cc	/^extern "C" void HeapProfilerStart(const char* prefix) {$/;"	f	signature:(const char* prefix)
HeapProfilerStop	src/gperftools/heap-profiler.h	/^PERFTOOLS_DLL_DECL void HeapProfilerStop();$/;"	p	signature:()
HeapProfilerStop	src/heap-profiler.cc	/^extern "C" void HeapProfilerStop() {$/;"	f	signature:()
HeapsInUse	src/thread_cache.h	/^  static inline int HeapsInUse();$/;"	p	class:tcmalloc::ThreadCache	access:public	signature:()
HeapsInUse	src/thread_cache.h	/^inline int ThreadCache::HeapsInUse() {$/;"	f	class:tcmalloc::ThreadCache	signature:()
HiddenPointer	src/gperftools/heap-checker.h	/^  explicit HiddenPointer(T* t)$/;"	f	class:HiddenPointer	access:public	signature:(T* t)
HiddenPointer	src/gperftools/heap-checker.h	/^class HiddenPointer {$/;"	c
HiddenPointer::HiddenPointer	src/gperftools/heap-checker.h	/^  explicit HiddenPointer(T* t)$/;"	f	class:HiddenPointer	access:public	signature:(T* t)
HiddenPointer::get	src/gperftools/heap-checker.h	/^  T* get() const { return reinterpret_cast<T*>(masked_t_ ^ kHideMask); }$/;"	f	class:HiddenPointer	access:public	signature:() const
HiddenPointer::kHideMask	src/gperftools/heap-checker.h	/^  static const uintptr_t kHideMask =$/;"	m	class:HiddenPointer	access:private
HiddenPointer::masked_t_	src/gperftools/heap-checker.h	/^  uintptr_t masked_t_;$/;"	m	class:HiddenPointer	access:private
Hide	src/tests/heap-checker_unittest.cc	/^static void Hide(T** ptr) {$/;"	f	file:	signature:(T** ptr)
HookIncrementNumber	src/windows/preamble_patcher_test.cc	/^int HookIncrementNumber(int i) {$/;"	f	namespace:__anon12	signature:(int i)
HookList	src/malloc_hook-inl.h	/^struct PERFTOOLS_DLL_DECL HookList {$/;"	s	namespace:base::internal
However	docs/pprof_remote_servers.html	/^necessary functionality "for free."  However, it's easy to generate$/;"	v
HugetlbSysAllocator	src/memfs_malloc.cc	/^  explicit HugetlbSysAllocator(SysAllocator* fallback)$/;"	f	class:HugetlbSysAllocator	access:public	signature:(SysAllocator* fallback)
HugetlbSysAllocator	src/memfs_malloc.cc	/^class HugetlbSysAllocator: public SysAllocator {$/;"	c	file:	inherits:SysAllocator
HugetlbSysAllocator::Alloc	src/memfs_malloc.cc	/^  void* Alloc(size_t size, size_t *actual_size, size_t alignment);$/;"	p	class:HugetlbSysAllocator	file:	access:public	signature:(size_t size, size_t *actual_size, size_t alignment)
HugetlbSysAllocator::Alloc	src/memfs_malloc.cc	/^void* HugetlbSysAllocator::Alloc(size_t size, size_t *actual_size,$/;"	f	class:HugetlbSysAllocator	signature:(size_t size, size_t *actual_size, size_t alignment)
HugetlbSysAllocator::AllocInternal	src/memfs_malloc.cc	/^  void* AllocInternal(size_t size, size_t *actual_size, size_t alignment);$/;"	p	class:HugetlbSysAllocator	file:	access:private	signature:(size_t size, size_t *actual_size, size_t alignment)
HugetlbSysAllocator::AllocInternal	src/memfs_malloc.cc	/^void* HugetlbSysAllocator::AllocInternal(size_t size, size_t* actual_size,$/;"	f	class:HugetlbSysAllocator	signature:(size_t size, size_t* actual_size, size_t alignment)
HugetlbSysAllocator::HugetlbSysAllocator	src/memfs_malloc.cc	/^  explicit HugetlbSysAllocator(SysAllocator* fallback)$/;"	f	class:HugetlbSysAllocator	access:public	signature:(SysAllocator* fallback)
HugetlbSysAllocator::Initialize	src/memfs_malloc.cc	/^  bool Initialize();$/;"	p	class:HugetlbSysAllocator	file:	access:public	signature:()
HugetlbSysAllocator::Initialize	src/memfs_malloc.cc	/^bool HugetlbSysAllocator::Initialize() {$/;"	f	class:HugetlbSysAllocator	signature:()
HugetlbSysAllocator::big_page_size_	src/memfs_malloc.cc	/^  int64 big_page_size_;$/;"	m	class:HugetlbSysAllocator	file:	access:private
HugetlbSysAllocator::failed_	src/memfs_malloc.cc	/^  bool failed_;          \/\/ Whether failed to allocate memory.$/;"	m	class:HugetlbSysAllocator	file:	access:public
HugetlbSysAllocator::fallback_	src/memfs_malloc.cc	/^  SysAllocator* fallback_;  \/\/ Default system allocator to fall back to.$/;"	m	class:HugetlbSysAllocator	file:	access:private
HugetlbSysAllocator::hugetlb_base_	src/memfs_malloc.cc	/^  off_t hugetlb_base_;$/;"	m	class:HugetlbSysAllocator	file:	access:private
HugetlbSysAllocator::hugetlb_fd_	src/memfs_malloc.cc	/^  int hugetlb_fd_;       \/\/ file descriptor for hugetlb$/;"	m	class:HugetlbSysAllocator	file:	access:private
I	src/.libs/libtcmalloc_internal_la-fake_stacktrace_scope.o	/^/;"	v
I	src/.libs/libtcmalloc_internal_la-malloc_extension.o	/^/;"	v
I	src/tests/malloc_hook_test-testutil.o	/^/;"	v
I	src/tests/markidle_unittest-testutil.o	/^/;"	v
I	src/tests/memalign_debug_unittest-testutil.o	/^/;"	v
I	src/tests/memalign_unittest-testutil.o	/^/;"	v
I	src/tests/packed_cache_test-packed-cache_test.o	/^/;"	v
I	src/tests/profile_handler_unittest-profile-handler_unittest.o	/^$/;"	v
I	src/tests/profile_handler_unittest-profile-handler_unittest.o	/^/;"	v
I	src/tests/profiler3_unittest-testutil.o	/^/;"	v
I	src/tests/profiler4_unittest-testutil.o	/^/;"	v
I	src/tests/tcm_min_asserts_unittest-testutil.o	/^/;"	v
I	src/tests/tcmalloc_and_profiler_unittest-testutil.o	/^/;"	v
I	src/tests/tcmalloc_both_unittest-testutil.o	/^/;"	v
I	src/tests/tcmalloc_debug_unittest-testutil.o	/^/;"	v
I	src/tests/tcmalloc_minimal_debug_unittest-testutil.o	/^/;"	v
I	src/tests/tcmalloc_minimal_unittest-testutil.o	/^/;"	v
I	src/tests/tcmalloc_unittest-testutil.o	/^/;"	v
I	src/tests/thread_dealloc_unittest-testutil.o	/^/;"	v
IBM_ARCH	config.guess	/^		IBM_ARCH=rs6000$/;"	v
IBM_CPU_ID	config.guess	/^	IBM_CPU_ID=`\/usr\/sbin\/lsdev -C -c processor -S available | sed 1q | awk '{ print $1 }'`$/;"	v
IBM_REV	config.guess	/^		IBM_REV=`\/usr\/bin\/oslevel`$/;"	v
IFS	m4/libtool.m4	/^    IFS="$lt_save_ifs"$/;"	v
IFS	m4/libtool.m4	/^  IFS="$lt_save_ifs"$/;"	v
IF_DEBUG_EXPECT_DEATH	src/tests/debugallocation_test.cc	71;"	d	file:
IGNORED_ON_HEAP	src/heap-checker.cc	/^  IGNORED_ON_HEAP,   \/\/ Is a live (ignored) object on heap$/;"	e	enum:ObjectPlacement	file:
INCIDENTAL	COPYING	/^OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,$/;"	v
INCIDENTAL	packages/deb/copyright	/^OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,$/;"	v
INCIDENTAL	src/windows/shortproc.asm	/^; OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,$/;"	v
INCLUDING	COPYING	/^"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT$/;"	v
INCLUDING	packages/deb/copyright	/^"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT$/;"	v
INCLUDING	src/windows/shortproc.asm	/^; "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT$/;"	v
INDIRECT	COPYING	/^OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,$/;"	v
INDIRECT	packages/deb/copyright	/^OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,$/;"	v
INDIRECT	src/windows/shortproc.asm	/^; OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,$/;"	v
INFO	src/base/logging.h	/^enum LogSeverity {INFO = -1, WARNING = -2, ERROR = -3, FATAL = -4};$/;"	e	enum:LogSeverity
INIT_ADDRESS_RANGE	src/tests/stacktrace_unittest.cc	60;"	d	file:
INIT_ADDRESS_RANGE	src/tests/stacktrace_unittest.cc	90;"	d	file:
INIT_ATTRIBUTE_SECTION_VARS	src/base/basictypes.h	292;"	d
INIT_ATTRIBUTE_SECTION_VARS	src/base/basictypes.h	348;"	d
INIT_ATTRIBUTE_SECTION_VARS	src/base/basictypes.h	364;"	d
INIT_HOOK_LIST	src/malloc_hook.cc	253;"	d	file:
INIT_HOOK_LIST	src/malloc_hook.cc	278;"	d	file:
INIT_HOOK_LIST	src/tests/malloc_hook_test.cc	120;"	d	file:
INIT_HOOK_LIST_WITH_VALUE	src/malloc_hook.cc	254;"	d	file:
INIT_HOOK_LIST_WITH_VALUE	src/malloc_hook.cc	277;"	d	file:
INSTALL_PREFIX	src/config.h	215;"	d
INSTALL_PREFIX	src/config.h.in	214;"	d	file:
INSTALL_PREFIX	src/windows/config.h	214;"	d
INT32_EQUALS_INTPTR	src/config.h.in	217;"	d	file:
INT32_EQUALS_INTPTR	src/windows/config.h	217;"	d
INTERIOR_BITS	src/pagemap.h	/^  static const int INTERIOR_BITS = (BITS + 2) \/ 3; \/\/ Round-up$/;"	m	class:TCMalloc_PageMap3	access:private
INTERIOR_LENGTH	src/pagemap.h	/^  static const int INTERIOR_LENGTH = 1 << INTERIOR_BITS;$/;"	m	class:TCMalloc_PageMap3	access:private
INUSE	src/gperftools/malloc_extension.h	/^    INUSE,                \/\/ Application is using this range$/;"	e	enum:base::MallocRange::Type
INVOKE_HOOKS	src/malloc_hook.cc	477;"	d	file:
INVOKE_HOOKS	src/malloc_hook.cc	568;"	d	file:
INVOKE_REPLACEMENT	src/malloc_hook.cc	487;"	d	file:
IN_GLOBAL_DATA	src/heap-checker.cc	/^  IN_GLOBAL_DATA,    \/\/ Is part of global data region of the executable$/;"	e	enum:ObjectPlacement	file:
IN_USE	src/span.h	/^  enum { IN_USE, ON_NORMAL_FREELIST, ON_RETURNED_FREELIST };$/;"	e	enum:tcmalloc::Span::__anon6
IOS_64	src/windows/mini_disassembler_types.h	/^  IOS_64 = 0x00001000$/;"	e	enum:sidestep::ImmediateOperandSize
IOS_DEFAULT	src/windows/mini_disassembler_types.h	/^  IOS_DEFAULT = 0x0,$/;"	e	enum:sidestep::ImmediateOperandSize
IOS_MASK	src/windows/mini_disassembler_types.h	/^  IOS_MASK = 0x0000F000,$/;"	e	enum:sidestep::ImmediateOperandSize
IP	src/base/elfcore.h	115;"	d
IP	src/base/elfcore.h	72;"	d
IP	src/base/elfcore.h	96;"	d
IS_STACK_FRAMES	src/stacktrace_impl_setup-inl.h	47;"	d
IS_STACK_FRAMES	src/stacktrace_impl_setup-inl.h	52;"	d
IS_STACK_FRAMES	src/stacktrace_impl_setup-inl.h	56;"	d
IS_STACK_FRAMES	src/stacktrace_impl_setup-inl.h	61;"	d
IS_STACK_FRAMES	src/stacktrace_impl_setup-inl.h	65;"	d
IS_STACK_FRAMES	src/stacktrace_impl_setup-inl.h	71;"	d
IS_STACK_FRAMES	src/stacktrace_impl_setup-inl.h	75;"	d
IS_STACK_FRAMES	src/stacktrace_impl_setup-inl.h	81;"	d
IS_WITH_CONTEXT	src/stacktrace_impl_setup-inl.h	48;"	d
IS_WITH_CONTEXT	src/stacktrace_impl_setup-inl.h	53;"	d
IS_WITH_CONTEXT	src/stacktrace_impl_setup-inl.h	57;"	d
IS_WITH_CONTEXT	src/stacktrace_impl_setup-inl.h	62;"	d
IS_WITH_CONTEXT	src/stacktrace_impl_setup-inl.h	66;"	d
IS_WITH_CONTEXT	src/stacktrace_impl_setup-inl.h	72;"	d
IS_WITH_CONTEXT	src/stacktrace_impl_setup-inl.h	76;"	d
IS_WITH_CONTEXT	src/stacktrace_impl_setup-inl.h	82;"	d
IT_GENERIC	src/windows/mini_disassembler_types.h	/^  IT_GENERIC,$/;"	e	enum:sidestep::InstructionType
IT_JUMP	src/windows/mini_disassembler_types.h	/^  IT_JUMP,$/;"	e	enum:sidestep::InstructionType
IT_PREFIX	src/windows/mini_disassembler_types.h	/^  IT_PREFIX,$/;"	e	enum:sidestep::InstructionType
IT_PREFIX_ADDRESS	src/windows/mini_disassembler_types.h	/^  IT_PREFIX_ADDRESS,$/;"	e	enum:sidestep::InstructionType
IT_PREFIX_OPERAND	src/windows/mini_disassembler_types.h	/^  IT_PREFIX_OPERAND,$/;"	e	enum:sidestep::InstructionType
IT_REFERENCE	src/windows/mini_disassembler_types.h	/^  IT_REFERENCE,$/;"	e	enum:sidestep::InstructionType
IT_RETURN	src/windows/mini_disassembler_types.h	/^  IT_RETURN,$/;"	e	enum:sidestep::InstructionType
IT_UNKNOWN	src/windows/mini_disassembler_types.h	/^  IT_UNKNOWN,$/;"	e	enum:sidestep::InstructionType
IT_UNUSED	src/windows/mini_disassembler_types.h	/^  IT_UNUSED,$/;"	e	enum:sidestep::InstructionType
I_WRAP_SONAME_FNNAME_ZU	src/third_party/valgrind.h	584;"	d
I_WRAP_SONAME_FNNAME_ZZ	src/third_party/valgrind.h	587;"	d
IgnoreAllLiveObjectsLocked	src/gperftools/heap-checker.h	/^  static void IgnoreAllLiveObjectsLocked(const void* self_stack_top);$/;"	p	class:HeapLeakChecker	access:private	signature:(const void* self_stack_top)
IgnoreAllLiveObjectsLocked	src/heap-checker.cc	/^void HeapLeakChecker::IgnoreAllLiveObjectsLocked(const void* self_stack_top) {$/;"	f	class:HeapLeakChecker	signature:(const void* self_stack_top)
IgnoreLiveObjectsLocked	src/gperftools/heap-checker.h	/^  static void IgnoreLiveObjectsLocked(const char* name, const char* name2);$/;"	p	class:HeapLeakChecker	access:private	signature:(const char* name, const char* name2)
IgnoreLiveObjectsLocked	src/heap-checker.cc	/^\/*static*\/ void HeapLeakChecker::IgnoreLiveObjectsLocked(const char* name,$/;"	f	class:HeapLeakChecker	signature:(const char* name, const char* name2)
IgnoreLiveThreadsLocked	src/gperftools/heap-checker.h	/^  static int IgnoreLiveThreadsLocked(void* parameter,$/;"	p	class:HeapLeakChecker	access:private	signature:(void* parameter, int num_threads, pid_t* thread_pids, va_list ap)
IgnoreLiveThreadsLocked	src/heap-checker.cc	/^\/*static*\/ int HeapLeakChecker::IgnoreLiveThreadsLocked(void* parameter,$/;"	f	class:HeapLeakChecker	signature:(void* parameter, int num_threads, pid_t* thread_pids, va_list )
IgnoreNonThreadLiveObjectsLocked	src/gperftools/heap-checker.h	/^  static void IgnoreNonThreadLiveObjectsLocked();$/;"	p	class:HeapLeakChecker	access:private	signature:()
IgnoreNonThreadLiveObjectsLocked	src/heap-checker.cc	/^void HeapLeakChecker::IgnoreNonThreadLiveObjectsLocked() {$/;"	f	class:HeapLeakChecker	signature:()
IgnoreObject	src/gperftools/heap-checker.h	/^  static T* IgnoreObject(T* ptr) {$/;"	f	class:HeapLeakChecker	access:public	signature:(T* ptr)
IgnoredObjectsMap	src/heap-checker.cc	/^           > IgnoredObjectsMap;$/;"	t	file:
ImmediateOperandSize	src/windows/mini_disassembler_types.h	/^enum ImmediateOperandSize {$/;"	g	namespace:sidestep
InHookCaller	src/malloc_hook.cc	/^static inline bool InHookCaller(const void* caller) {$/;"	f	file:	signature:(const void* caller)
IncreaseCacheLimit	src/thread_cache.cc	/^void ThreadCache::IncreaseCacheLimit() {$/;"	f	class:tcmalloc::ThreadCache	signature:()
IncreaseCacheLimit	src/thread_cache.h	/^  void IncreaseCacheLimit();$/;"	p	class:tcmalloc::ThreadCache	access:private	signature:()
IncreaseCacheLimitLocked	src/thread_cache.cc	/^void ThreadCache::IncreaseCacheLimitLocked() {$/;"	f	class:tcmalloc::ThreadCache	signature:()
IncreaseCacheLimitLocked	src/thread_cache.h	/^  void IncreaseCacheLimitLocked();$/;"	p	class:tcmalloc::ThreadCache	access:private	signature:()
IncrementNumber	src/windows/preamble_patcher_test.cc	/^int __declspec(noinline) IncrementNumber(int i) {$/;"	f	namespace:__anon12	signature:(int i)
IncrementalScavenge	src/page_heap.cc	/^void PageHeap::IncrementalScavenge(Length n) {$/;"	f	class:tcmalloc::PageHeap	signature:(Length n)
IncrementalScavenge	src/page_heap.h	/^  void IncrementalScavenge(Length n);$/;"	p	class:tcmalloc::PageHeap	access:private	signature:(Length n)
IncrementingFunc	src/windows/preamble_patcher_test.cc	/^typedef int (*IncrementingFunc)(int);$/;"	t	namespace:__anon12	file:
Init	src/base/elf_mem_image.cc	/^void ElfMemImage::Init(const void *base) {$/;"	f	class:base::ElfMemImage	signature:(const void *base)
Init	src/base/elf_mem_image.h	/^  void                 Init(const void *base);$/;"	p	class:base::ElfMemImage	access:public	signature:(const void *base)
Init	src/base/sysinfo.cc	/^void ProcMapsIterator::Init(pid_t pid, Buffer *buffer,$/;"	f	class:ProcMapsIterator	signature:(pid_t pid, Buffer *buffer, bool use_maps_backing)
Init	src/base/sysinfo.h	/^  void Init(pid_t pid, Buffer *buffer, bool use_maps_backing);$/;"	p	class:ProcMapsIterator	access:private	signature:(pid_t pid, Buffer *buffer, bool use_maps_backing)
Init	src/base/vdso_support.cc	/^const void *VDSOSupport::Init() {$/;"	f	class:base::VDSOSupport	signature:()
Init	src/base/vdso_support.h	/^  static const void *Init();$/;"	p	class:base::VDSOSupport	access:public	signature:()
Init	src/central_freelist.cc	/^void CentralFreeList::Init(size_t cl) {$/;"	f	class:tcmalloc::CentralFreeList	signature:(size_t cl)
Init	src/central_freelist.h	/^  void Init(size_t cl);$/;"	p	class:tcmalloc::CentralFreeList	access:public	signature:(size_t cl)
Init	src/common.cc	/^void SizeMap::Init() {$/;"	f	class:tcmalloc::SizeMap	signature:()
Init	src/common.h	/^  void Init();$/;"	p	class:tcmalloc::SizeMap	access:public	signature:()
Init	src/heap-checker.cc	/^  static void Init() {$/;"	f	class:HeapLeakChecker::Allocator	access:public	signature:()
Init	src/memory_region_map.cc	/^void MemoryRegionMap::Init(int max_stack_depth, bool use_buckets) {$/;"	f	class:MemoryRegionMap	signature:(int max_stack_depth, bool use_buckets)
Init	src/memory_region_map.h	/^  static void Init(int max_stack_depth, bool use_buckets);$/;"	p	class:MemoryRegionMap	access:public	signature:(int max_stack_depth, bool use_buckets)
Init	src/page_heap_allocator.h	/^  void Init() {$/;"	f	class:tcmalloc::PageHeapAllocator	access:public	signature:()
Init	src/pprof	/^sub Init() {$/;"	f	signature:()
Init	src/profile-handler.cc	/^  static void Init();$/;"	p	class:ProfileHandler	file:	access:private	signature:()
Init	src/profile-handler.cc	/^void ProfileHandler::Init() {$/;"	f	class:ProfileHandler	signature:()
Init	src/sampler.cc	/^void Sampler::Init(uint64_t seed) {$/;"	f	class:tcmalloc::Sampler	signature:(uint64_t seed)
Init	src/sampler.h	/^  void Init(uint64_t seed);$/;"	p	class:tcmalloc::Sampler	access:public	signature:(uint64_t seed)
Init	src/tests/sampler_test.cc	/^  void Init(uint32_t seed);$/;"	p	class:OldSampler	file:	access:public	signature:(uint32_t seed)
Init	src/tests/sampler_test.cc	/^void OldSampler::Init(uint32_t seed) {$/;"	f	class:OldSampler	signature:(uint32_t seed)
Init	src/thread_cache.cc	/^void ThreadCache::Init(pthread_t tid) {$/;"	f	class:tcmalloc::ThreadCache	signature:(pthread_t tid)
Init	src/thread_cache.h	/^    void Init(size_t size) {$/;"	f	class:tcmalloc::ThreadCache::FreeList	access:public	signature:(size_t size)
Init	src/thread_cache.h	/^  void Init(pthread_t tid);$/;"	p	class:tcmalloc::ThreadCache	access:public	signature:(pthread_t tid)
InitDeletedBuffer	src/debugallocation.cc	/^  static void InitDeletedBuffer() {$/;"	f	class:MallocBlock	access:public	signature:()
InitEmergencyMalloc	src/emergency_malloc.cc	/^  static void InitEmergencyMalloc(void) {$/;"	f	namespace:tcmalloc	signature:(void)
InitLateMaybeRecursive	src/static_vars.cc	/^void Static::InitLateMaybeRecursive() {$/;"	f	class:tcmalloc::Static	signature:()
InitLateMaybeRecursive	src/static_vars.h	/^  static void InitLateMaybeRecursive();$/;"	p	class:tcmalloc::Static	access:public	signature:()
InitModule	src/base/spinlock_linux-inl.h	/^  InitModule() {$/;"	f	struct:__anon45::InitModule	access:public	signature:()
InitModule	src/base/spinlock_linux-inl.h	/^static struct InitModule {$/;"	s	namespace:__anon45
InitModule	src/malloc_extension.cc	/^static void InitModule() {$/;"	f	file:	signature:()
InitModule	src/thread_cache.cc	/^void ThreadCache::InitModule() {$/;"	f	class:tcmalloc::ThreadCache	signature:()
InitModule	src/thread_cache.h	/^  static void         InitModule();$/;"	p	class:tcmalloc::ThreadCache	access:public	signature:()
InitStaticVars	src/static_vars.cc	/^void Static::InitStaticVars() {$/;"	f	class:tcmalloc::Static	signature:()
InitStaticVars	src/static_vars.h	/^  static void InitStaticVars();$/;"	p	class:tcmalloc::Static	access:public	signature:()
InitStatics	src/tests/sampler_test.cc	/^  static void InitStatics() {$/;"	f	class:OldSampler	access:public	signature:()
InitSystemAllocators	src/system-alloc.cc	/^void InitSystemAllocators(void) {$/;"	f	signature:(void)
InitSystemAllocators	src/windows/system-alloc.cc	/^void InitSystemAllocators(void) {$/;"	f	signature:(void)
InitTCMallocTransferNumObjects	src/common.cc	/^static inline void InitTCMallocTransferNumObjects()$/;"	f	namespace:tcmalloc	signature:()
InitTSD	src/thread_cache.cc	/^void ThreadCache::InitTSD() {$/;"	f	class:tcmalloc::ThreadCache	signature:()
InitTSD	src/thread_cache.h	/^  static void         InitTSD();$/;"	p	class:tcmalloc::ThreadCache	access:public	signature:()
InitThreadDisableCounter	src/heap-checker.cc	/^  InitThreadDisableCounter() {$/;"	f	class:InitThreadDisableCounter	access:public	signature:()
InitThreadDisableCounter	src/heap-checker.cc	/^class InitThreadDisableCounter {$/;"	c	file:
InitThreadDisableCounter::InitThreadDisableCounter	src/heap-checker.cc	/^  InitThreadDisableCounter() {$/;"	f	class:InitThreadDisableCounter	access:public	signature:()
InitialNewHook	src/malloc_hook.cc	/^void InitialNewHook(const void* ptr, size_t size) {$/;"	f	namespace:__anon51	signature:(const void* ptr, size_t size)
InitialPreMMapHook	src/malloc_hook.cc	/^void InitialPreMMapHook(const void* start,$/;"	f	namespace:__anon51	signature:(const void* start, size_t size, int protection, int flags, int fd, off_t offset)
InitialPreSbrkHook	src/malloc_hook.cc	/^void InitialPreSbrkHook(ptrdiff_t increment) {$/;"	f	namespace:__anon51	signature:(ptrdiff_t increment)
Initialize	src/debugallocation.cc	/^  void Initialize(size_t size, int type) {$/;"	f	class:MallocBlock	file:	access:private	signature:(size_t size, int type)
Initialize	src/gperftools/malloc_extension.h	/^  static void Initialize();$/;"	p	class:MallocExtension	access:public	signature:()
Initialize	src/malloc_extension.cc	/^void MallocExtension::Initialize() {$/;"	f	class:MallocExtension	signature:()
Initialize	src/memfs_malloc.cc	/^  bool Initialize();$/;"	p	class:HugetlbSysAllocator	file:	access:public	signature:()
Initialize	src/memfs_malloc.cc	/^bool HugetlbSysAllocator::Initialize() {$/;"	f	class:HugetlbSysAllocator	signature:()
Initialize	src/windows/mini_disassembler.cc	/^void MiniDisassembler::Initialize() {$/;"	f	class:sidestep::MiniDisassembler	signature:()
Initialize	src/windows/mini_disassembler.h	/^  void Initialize();$/;"	p	class:sidestep::MiniDisassembler	access:private	signature:()
Initialize	src/windows/preamble_patcher.cc	/^void PreamblePatcher::Initialize() {$/;"	f	class:sidestep::PreamblePatcher	signature:()
Initialize	src/windows/preamble_patcher.h	/^  static void Initialize();$/;"	p	class:sidestep::PreamblePatcher	access:private	signature:()
Initialized	src/tests/heap-checker_unittest.cc	/^struct Initialized { };$/;"	s	file:
Inner	src/tests/heap-checker_unittest.cc	/^    Inner(Nesting* p) : parent(p) {}$/;"	f	struct:Nesting::Inner	access:public	signature:(Nesting* p)
Inner	src/tests/heap-checker_unittest.cc	/^  struct Inner {$/;"	s	struct:Nesting	file:	access:public
Insert	src/addressmap-inl.h	/^  void Insert(Key key, Value value);$/;"	p	class:AddressMap	access:public	signature:(Key key, Value value)
Insert	src/addressmap-inl.h	/^void AddressMap<Value>::Insert(Key key, Value value) {$/;"	f	class:AddressMap	signature:(Key key, Value value)
InsertRange	src/central_freelist.cc	/^void CentralFreeList::InsertRange(void *start, void *end, int N) {$/;"	f	class:tcmalloc::CentralFreeList	signature:(void *start, void *end, int N)
InsertRange	src/central_freelist.h	/^  void InsertRange(void *start, void *end, int N);$/;"	p	class:tcmalloc::CentralFreeList	access:public	signature:(void *start, void *end, int N)
InsertRegionLocked	src/memory_region_map.cc	/^inline void MemoryRegionMap::InsertRegionLocked(const Region& region) {$/;"	f	class:MemoryRegionMap	signature:(const Region& region)
InsertRegionLocked	src/memory_region_map.h	/^  inline static void InsertRegionLocked(const Region& region);$/;"	p	class:MemoryRegionMap	access:private	signature:(const Region& region)
Instance	src/profile-handler.cc	/^  static ProfileHandler* Instance();$/;"	p	class:ProfileHandler	file:	access:public	signature:()
Instance	src/profile-handler.cc	/^ProfileHandler* ProfileHandler::Instance() {$/;"	f	class:ProfileHandler	signature:()
InstructionType	src/windows/mini_disassembler_types.h	/^enum InstructionType {$/;"	g	namespace:sidestep
IntLog2	src/base/low_level_alloc.cc	/^static int IntLog2(size_t size, size_t base) {$/;"	f	file:	signature:(size_t size, size_t base)
IntSet	src/tests/heap-checker_unittest.cc	/^typedef set<int> IntSet;$/;"	t	file:
InterfaceA	src/tests/heap-checker_unittest.cc	/^  InterfaceA() { }$/;"	f	class:InterfaceA	access:protected	signature:()
InterfaceA	src/tests/heap-checker_unittest.cc	/^class InterfaceA {$/;"	c	file:
InterfaceA::A	src/tests/heap-checker_unittest.cc	/^  virtual void A() = 0;$/;"	p	class:InterfaceA	file:	access:public	signature:()
InterfaceA::InterfaceA	src/tests/heap-checker_unittest.cc	/^  InterfaceA() { }$/;"	f	class:InterfaceA	access:protected	signature:()
InterfaceA::~InterfaceA	src/tests/heap-checker_unittest.cc	/^  virtual ~InterfaceA() { }$/;"	f	class:InterfaceA	access:public	signature:()
InterfaceB	src/tests/heap-checker_unittest.cc	/^  InterfaceB() { }$/;"	f	class:InterfaceB	access:protected	signature:()
InterfaceB	src/tests/heap-checker_unittest.cc	/^class InterfaceB {$/;"	c	file:
InterfaceB::B	src/tests/heap-checker_unittest.cc	/^  virtual void B() = 0;$/;"	p	class:InterfaceB	file:	access:public	signature:()
InterfaceB::InterfaceB	src/tests/heap-checker_unittest.cc	/^  InterfaceB() { }$/;"	f	class:InterfaceB	access:protected	signature:()
InterfaceB::~InterfaceB	src/tests/heap-checker_unittest.cc	/^  virtual ~InterfaceB() { }$/;"	f	class:InterfaceB	access:public	signature:()
InterfaceC	src/tests/heap-checker_unittest.cc	/^  InterfaceC() { }$/;"	f	class:InterfaceC	access:protected	signature:()
InterfaceC	src/tests/heap-checker_unittest.cc	/^class InterfaceC : public InterfaceA {$/;"	c	file:	inherits:InterfaceA
InterfaceC::C	src/tests/heap-checker_unittest.cc	/^  virtual void C() = 0;$/;"	p	class:InterfaceC	file:	access:public	signature:()
InterfaceC::InterfaceC	src/tests/heap-checker_unittest.cc	/^  InterfaceC() { }$/;"	f	class:InterfaceC	access:protected	signature:()
InterfaceC::~InterfaceC	src/tests/heap-checker_unittest.cc	/^  virtual ~InterfaceC() { }$/;"	f	class:InterfaceC	access:public	signature:()
InternalGetCoreDump	src/base/elfcore.h	/^int InternalGetCoreDump(void *frame, int num_threads, pid_t *thread_pids,$/;"	p	signature:(void *frame, int num_threads, pid_t *thread_pids, va_list ap )
InvalidFree	src/tcmalloc.cc	/^ATTRIBUTE_NOINLINE void InvalidFree(void* ptr) {$/;"	f	namespace:__anon2	signature:(void* ptr)
InvalidGetAllocatedSize	src/tcmalloc.cc	/^size_t InvalidGetAllocatedSize(const void* ptr) {$/;"	f	namespace:__anon2	signature:(const void* ptr)
InvalidGetSizeForRealloc	src/tcmalloc.cc	/^size_t InvalidGetSizeForRealloc(const void* old_ptr) {$/;"	f	namespace:__anon2	signature:(const void* old_ptr)
Invalidate	src/packed-cache-inl.h	/^  void Invalidate(K key) {$/;"	f	class:PackedCache	access:public	signature:(K key)
InvalidateCachedSizeClass	src/page_heap.h	/^  void InvalidateCachedSizeClass(PageID p) { pagemap_cache_.Invalidate(p); }$/;"	f	class:tcmalloc::PageHeap	access:public	signature:(PageID p)
InvokeDeleteHook	src/gperftools/malloc_hook.h	/^  inline static void InvokeDeleteHook(const void* p);$/;"	p	class:MallocHook	access:public	signature:(const void* p)
InvokeDeleteHook	src/malloc_hook-inl.h	/^inline void MallocHook::InvokeDeleteHook(const void* p) {$/;"	f	class:MallocHook	signature:(const void* p)
InvokeDeleteHookSlow	src/gperftools/malloc_hook.h	/^  static void InvokeDeleteHookSlow(const void* p);$/;"	p	class:MallocHook	access:private	signature:(const void* p)
InvokeDeleteHookSlow	src/malloc_hook.cc	/^void MallocHook::InvokeDeleteHookSlow(const void* p) {$/;"	f	class:MallocHook	signature:(const void* p)
InvokeMmapHook	src/gperftools/malloc_hook.h	/^  inline static void InvokeMmapHook(const void* result,$/;"	p	class:MallocHook	access:public	signature:(const void* result, const void* start, size_t size, int protection, int flags, int fd, off_t offset)
InvokeMmapHook	src/malloc_hook-inl.h	/^inline void MallocHook::InvokeMmapHook(const void* result,$/;"	f	class:MallocHook	signature:(const void* result, const void* start, size_t size, int protection, int flags, int fd, off_t offset)
InvokeMmapHookSlow	src/gperftools/malloc_hook.h	/^  static void InvokeMmapHookSlow(const void* result,$/;"	p	class:MallocHook	access:private	signature:(const void* result, const void* start, size_t size, int protection, int flags, int fd, off_t offset)
InvokeMmapHookSlow	src/malloc_hook.cc	/^void MallocHook::InvokeMmapHookSlow(const void* result,$/;"	f	class:MallocHook	signature:(const void* result, const void* start, size_t size, int protection, int flags, int fd, off_t offset)
InvokeMmapReplacement	src/gperftools/malloc_hook.h	/^  inline static bool InvokeMmapReplacement(const void* start,$/;"	p	class:MallocHook	access:public	signature:(const void* start, size_t size, int protection, int flags, int fd, off_t offset, void** result)
InvokeMmapReplacement	src/malloc_hook-inl.h	/^inline bool MallocHook::InvokeMmapReplacement(const void* start,$/;"	f	class:MallocHook	signature:(const void* start, size_t size, int protection, int flags, int fd, off_t offset, void** result)
InvokeMmapReplacementSlow	src/gperftools/malloc_hook.h	/^  static bool InvokeMmapReplacementSlow(const void* start,$/;"	p	class:MallocHook	access:private	signature:(const void* start, size_t size, int protection, int flags, int fd, off_t offset, void** result)
InvokeMmapReplacementSlow	src/malloc_hook.cc	/^bool MallocHook::InvokeMmapReplacementSlow(const void* start,$/;"	f	class:MallocHook	signature:(const void* start, size_t size, int protection, int flags, int fd, off_t offset, void** result)
InvokeMremapHook	src/gperftools/malloc_hook.h	/^  inline static void InvokeMremapHook(const void* result,$/;"	p	class:MallocHook	access:public	signature:(const void* result, const void* old_addr, size_t old_size, size_t new_size, int flags, const void* new_addr)
InvokeMremapHook	src/malloc_hook-inl.h	/^inline void MallocHook::InvokeMremapHook(const void* result,$/;"	f	class:MallocHook	signature:(const void* result, const void* old_addr, size_t old_size, size_t new_size, int flags, const void* new_addr)
InvokeMremapHookSlow	src/gperftools/malloc_hook.h	/^  static void InvokeMremapHookSlow(const void* result,$/;"	p	class:MallocHook	access:private	signature:(const void* result, const void* old_addr, size_t old_size, size_t new_size, int flags, const void* new_addr)
InvokeMremapHookSlow	src/malloc_hook.cc	/^void MallocHook::InvokeMremapHookSlow(const void* result,$/;"	f	class:MallocHook	signature:(const void* result, const void* old_addr, size_t old_size, size_t new_size, int flags, const void* new_addr)
InvokeMunmapHook	src/gperftools/malloc_hook.h	/^  inline static void InvokeMunmapHook(const void* p, size_t size);$/;"	p	class:MallocHook	access:public	signature:(const void* p, size_t size)
InvokeMunmapHook	src/malloc_hook-inl.h	/^inline void MallocHook::InvokeMunmapHook(const void* p, size_t size) {$/;"	f	class:MallocHook	signature:(const void* p, size_t size)
InvokeMunmapHookSlow	src/gperftools/malloc_hook.h	/^  static void InvokeMunmapHookSlow(const void* p, size_t size);$/;"	p	class:MallocHook	access:private	signature:(const void* p, size_t size)
InvokeMunmapHookSlow	src/malloc_hook.cc	/^void MallocHook::InvokeMunmapHookSlow(const void* p, size_t s) {$/;"	f	class:MallocHook	signature:(const void* p, size_t s)
InvokeMunmapReplacement	src/gperftools/malloc_hook.h	/^  inline static bool InvokeMunmapReplacement(const void* p,$/;"	p	class:MallocHook	access:public	signature:(const void* p, size_t size, int* result)
InvokeMunmapReplacement	src/malloc_hook-inl.h	/^inline bool MallocHook::InvokeMunmapReplacement($/;"	f	class:MallocHook	signature:( const void* p, size_t size, int* result)
InvokeMunmapReplacementSlow	src/gperftools/malloc_hook.h	/^  static bool InvokeMunmapReplacementSlow(const void* p,$/;"	p	class:MallocHook	access:private	signature:(const void* p, size_t size, int* result)
InvokeMunmapReplacementSlow	src/malloc_hook.cc	/^bool MallocHook::InvokeMunmapReplacementSlow(const void* p,$/;"	f	class:MallocHook	signature:(const void* p, size_t s, int* result)
InvokeNewHook	src/gperftools/malloc_hook.h	/^  inline static void InvokeNewHook(const void* p, size_t s);$/;"	p	class:MallocHook	access:public	signature:(const void* p, size_t s)
InvokeNewHook	src/malloc_hook-inl.h	/^inline void MallocHook::InvokeNewHook(const void* p, size_t s) {$/;"	f	class:MallocHook	signature:(const void* p, size_t s)
InvokeNewHookSlow	src/gperftools/malloc_hook.h	/^  static void InvokeNewHookSlow(const void* p, size_t s);$/;"	p	class:MallocHook	access:private	signature:(const void* p, size_t s)
InvokeNewHookSlow	src/malloc_hook.cc	/^void MallocHook::InvokeNewHookSlow(const void* p, size_t s) {$/;"	f	class:MallocHook	signature:(const void* p, size_t s)
InvokePreMmapHook	src/gperftools/malloc_hook.h	/^  inline static void InvokePreMmapHook(const void* start,$/;"	p	class:MallocHook	access:public	signature:(const void* start, size_t size, int protection, int flags, int fd, off_t offset)
InvokePreMmapHook	src/malloc_hook-inl.h	/^inline void MallocHook::InvokePreMmapHook(const void* start,$/;"	f	class:MallocHook	signature:(const void* start, size_t size, int protection, int flags, int fd, off_t offset)
InvokePreMmapHookSlow	src/gperftools/malloc_hook.h	/^  static void InvokePreMmapHookSlow(const void* start,$/;"	p	class:MallocHook	access:private	signature:(const void* start, size_t size, int protection, int flags, int fd, off_t offset)
InvokePreMmapHookSlow	src/malloc_hook.cc	/^void MallocHook::InvokePreMmapHookSlow(const void* start,$/;"	f	class:MallocHook	signature:(const void* start, size_t size, int protection, int flags, int fd, off_t offset)
InvokePreSbrkHook	src/gperftools/malloc_hook.h	/^  inline static void InvokePreSbrkHook(ptrdiff_t increment);$/;"	p	class:MallocHook	access:public	signature:(ptrdiff_t increment)
InvokePreSbrkHook	src/malloc_hook-inl.h	/^inline void MallocHook::InvokePreSbrkHook(ptrdiff_t increment) {$/;"	f	class:MallocHook	signature:(ptrdiff_t increment)
InvokePreSbrkHookSlow	src/gperftools/malloc_hook.h	/^  static void InvokePreSbrkHookSlow(ptrdiff_t increment);$/;"	p	class:MallocHook	access:private	signature:(ptrdiff_t increment)
InvokePreSbrkHookSlow	src/malloc_hook.cc	/^void MallocHook::InvokePreSbrkHookSlow(ptrdiff_t increment) {$/;"	f	class:MallocHook	signature:(ptrdiff_t increment)
InvokeSbrkHook	src/gperftools/malloc_hook.h	/^  inline static void InvokeSbrkHook(const void* result, ptrdiff_t increment);$/;"	p	class:MallocHook	access:public	signature:(const void* result, ptrdiff_t increment)
InvokeSbrkHook	src/malloc_hook-inl.h	/^inline void MallocHook::InvokeSbrkHook(const void* result,$/;"	f	class:MallocHook	signature:(const void* result, ptrdiff_t increment)
InvokeSbrkHookSlow	src/gperftools/malloc_hook.h	/^  static void InvokeSbrkHookSlow(const void* result, ptrdiff_t increment);$/;"	p	class:MallocHook	access:private	signature:(const void* result, ptrdiff_t increment)
InvokeSbrkHookSlow	src/malloc_hook.cc	/^void MallocHook::InvokeSbrkHookSlow(const void* result, ptrdiff_t increment) {$/;"	f	class:MallocHook	signature:(const void* result, ptrdiff_t increment)
IsActive	src/gperftools/heap-checker.h	/^  static bool IsActive();$/;"	p	class:HeapLeakChecker	access:public	signature:()
IsActive	src/heap-checker.cc	/^bool HeapLeakChecker::IsActive() {$/;"	f	class:HeapLeakChecker	signature:()
IsDebuggerAttached	src/heap-checker.cc	/^static bool IsDebuggerAttached(void) {    \/\/ only works under linux, probably$/;"	f	file:	signature:(void)
IsEmergencyPtr	src/emergency_malloc.h	/^  static inline bool IsEmergencyPtr(const void *_ptr) {$/;"	f	namespace:tcmalloc	signature:(const void *_ptr)
IsEmergencyPtr	src/maybe_emergency_malloc.h	/^  static inline bool IsEmergencyPtr(const void *_ptr) {$/;"	f	namespace:tcmalloc	signature:(const void *_ptr)
IsHeapProfilerRunning	src/gperftools/heap-profiler.h	/^int IsHeapProfilerRunning();$/;"	p	signature:()
IsHeapProfilerRunning	src/heap-profiler.cc	/^extern "C" int IsHeapProfilerRunning() {$/;"	f	signature:()
IsHeld	src/base/spinlock.h	/^  inline bool IsHeld() const {$/;"	f	class:SpinLock	access:public	signature:() const
IsInited	src/static_vars.h	/^  static bool IsInited() { return inited_; }$/;"	f	class:tcmalloc::Static	access:public	signature:()
IsLibraryNamed	src/heap-checker.cc	/^static bool IsLibraryNamed(const char* library, const char* library_base) {$/;"	f	file:	signature:(const char* library, const char* library_base)
IsMMapped	src/debugallocation.cc	/^  bool IsMMapped() const { return kMagicMMap == magic1_; }$/;"	f	class:MallocBlock	file:	access:private	signature:() const
IsMovWithDisplacement	src/windows/preamble_patcher.cc	/^bool PreamblePatcher::IsMovWithDisplacement($/;"	f	class:sidestep::PreamblePatcher	signature:( unsigned char* target, unsigned int instruction_size)
IsMovWithDisplacement	src/windows/preamble_patcher.h	/^  static bool IsMovWithDisplacement(unsigned char* target,$/;"	p	class:sidestep::PreamblePatcher	access:private	signature:(unsigned char* target, unsigned int instruction_size)
IsNearAbsoluteCall	src/windows/preamble_patcher.cc	/^bool PreamblePatcher::IsNearAbsoluteCall($/;"	f	class:sidestep::PreamblePatcher	signature:( unsigned char* target, unsigned int instruction_size)
IsNearAbsoluteCall	src/windows/preamble_patcher.h	/^  static bool IsNearAbsoluteCall(unsigned char* target,$/;"	p	class:sidestep::PreamblePatcher	access:private	signature:(unsigned char* target, unsigned int instruction_size)
IsNearConditionalJump	src/windows/preamble_patcher.cc	/^bool PreamblePatcher::IsNearConditionalJump($/;"	f	class:sidestep::PreamblePatcher	signature:( unsigned char* target, unsigned int instruction_size)
IsNearConditionalJump	src/windows/preamble_patcher.h	/^  static bool IsNearConditionalJump(unsigned char* target,$/;"	p	class:sidestep::PreamblePatcher	access:private	signature:(unsigned char* target, unsigned int instruction_size)
IsNearRelativeCall	src/windows/preamble_patcher.cc	/^bool PreamblePatcher::IsNearRelativeCall($/;"	f	class:sidestep::PreamblePatcher	signature:( unsigned char* target, unsigned int instruction_size)
IsNearRelativeCall	src/windows/preamble_patcher.h	/^  static bool IsNearRelativeCall(unsigned char* target,$/;"	p	class:sidestep::PreamblePatcher	access:private	signature:(unsigned char* target, unsigned int instruction_size)
IsNearRelativeJump	src/windows/preamble_patcher.cc	/^bool PreamblePatcher::IsNearRelativeJump($/;"	f	class:sidestep::PreamblePatcher	signature:( unsigned char* target, unsigned int instruction_size)
IsNearRelativeJump	src/windows/preamble_patcher.h	/^  static bool IsNearRelativeJump(unsigned char* target,$/;"	p	class:sidestep::PreamblePatcher	access:private	signature:(unsigned char* target, unsigned int instruction_size)
IsOneThread	src/heap-checker.cc	/^static int IsOneThread(void* parameter, int num_threads,$/;"	f	file:	signature:(void* parameter, int num_threads, pid_t* thread_pids, va_list ap)
IsPresent	src/base/elf_mem_image.h	/^  bool                 IsPresent() const { return ehdr_ != NULL; }$/;"	f	class:base::ElfMemImage	access:public	signature:() const
IsPresent	src/base/vdso_support.h	/^  bool IsPresent() const { return image_.IsPresent(); }$/;"	f	class:base::VDSOSupport	access:public	signature:() const
IsRecordingLocked	src/memory_region_map.cc	/^bool MemoryRegionMap::IsRecordingLocked() {$/;"	f	class:MemoryRegionMap	signature:()
IsRecordingLocked	src/memory_region_map.h	/^  static bool IsRecordingLocked();$/;"	p	class:MemoryRegionMap	access:public	signature:()
IsShortConditionalJump	src/windows/preamble_patcher.cc	/^bool PreamblePatcher::IsShortConditionalJump($/;"	f	class:sidestep::PreamblePatcher	signature:( unsigned char* target, unsigned int instruction_size)
IsShortConditionalJump	src/windows/preamble_patcher.h	/^  static bool IsShortConditionalJump(unsigned char* target,$/;"	p	class:sidestep::PreamblePatcher	access:private	signature:(unsigned char* target, unsigned int instruction_size)
IsShortJump	src/windows/preamble_patcher.cc	/^bool PreamblePatcher::IsShortJump($/;"	f	class:sidestep::PreamblePatcher	signature:( unsigned char* target, unsigned int instruction_size)
IsShortJump	src/windows/preamble_patcher.h	/^  static bool IsShortJump(unsigned char *target, unsigned int instruction_size);$/;"	p	class:sidestep::PreamblePatcher	access:private	signature:(unsigned char *target, unsigned int instruction_size)
IsSignalHandlerAvailable	src/profile-handler.cc	/^  bool IsSignalHandlerAvailable();$/;"	p	class:ProfileHandler	file:	access:private	signature:()
IsSignalHandlerAvailable	src/profile-handler.cc	/^bool ProfileHandler::IsSignalHandlerAvailable() {$/;"	f	class:ProfileHandler	signature:()
IsStacktraceAllowed	src/stacktrace.cc	/^    bool IsStacktraceAllowed() {$/;"	f	class:__anon20::StacktraceScope	access:public	signature:()
IsTimerEnabled	src/tests/profile-handler_unittest.cc	/^bool IsTimerEnabled() {$/;"	f	namespace:__anon56	signature:()
IsUseEmergencyMalloc	src/thread_cache.h	/^  static bool         IsUseEmergencyMalloc();$/;"	p	class:tcmalloc::ThreadCache	access:public	signature:()
IsUseEmergencyMalloc	src/thread_cache.h	/^inline bool ThreadCache::IsUseEmergencyMalloc() {$/;"	f	class:tcmalloc::ThreadCache	signature:()
IsValidMagicValue	src/debugallocation.cc	/^  bool IsValidMagicValue(size_t value) const {$/;"	f	class:MallocBlock	file:	access:private	signature:(size_t value) const
Iterate	src/addressmap-inl.h	/^  inline void Iterate(void (*callback)(Key, Value*, Type), Type arg) const;$/;"	p	class:AddressMap	access:public	signature:(void (*callback)(Key, Value*, Type), Type arg) const
Iterate	src/addressmap-inl.h	/^inline void AddressMap<Value>::Iterate(void (*callback)(Key, Value*, Type),$/;"	f	class:AddressMap	signature:(void (*callback)(Key, Value*, Type), Type arg) const
IterateAllocs	src/heap-profile-table.h	/^  void IterateAllocs(AllocIterator callback) const {$/;"	f	class:HeapProfileTable	access:public	signature:(AllocIterator callback) const
IterateBuckets	src/memory_region_map.h	/^  static void IterateBuckets(void (*callback)(const HeapProfileBucket*, Type),$/;"	p	class:MemoryRegionMap	access:public	signature:(void (*callback)(const HeapProfileBucket*, Type), Type arg)
IterateBuckets	src/memory_region_map.h	/^void MemoryRegionMap::IterateBuckets($/;"	f	class:MemoryRegionMap	signature:( void (*callback)(const HeapProfileBucket*, Type), Type callback_arg)
IterateOrderedAllocContexts	src/heap-profile-table.cc	/^void HeapProfileTable::IterateOrderedAllocContexts($/;"	f	class:HeapProfileTable	signature:( AllocContextIterator callback) const
IterateOrderedAllocContexts	src/heap-profile-table.h	/^  void IterateOrderedAllocContexts(AllocContextIterator callback) const;$/;"	p	class:HeapProfileTable	access:public	signature:(AllocContextIterator callback) const
IterateOverRanges	src/tcmalloc.cc	/^static void IterateOverRanges(void* arg, MallocExtension::RangeFunction func) {$/;"	f	file:	signature:(void* arg, MallocExtension::RangeFunction func)
J	src/.libs/libtcmalloc_internal_la-internal_logging.o	/^/;"	v
Join	src/tests/profile-handler_unittest.cc	/^  void Join()  {$/;"	f	class:__anon56::Thread	access:public	signature:()
JumpAbsoluteFunction	src/windows/preamble_patcher_test.cc	/^extern "C" int JumpAbsoluteFunction(int);$/;"	p	namespace:__anon12	file:	signature:(int)
JumpNearCondFunction	src/windows/preamble_patcher_test.cc	/^extern "C" int JumpNearCondFunction(int);$/;"	p	namespace:__anon12	file:	signature:(int)
JumpShortCondFunction	src/windows/preamble_patcher_test.cc	/^extern "C" int JumpShortCondFunction(int);$/;"	p	namespace:__anon12	file:	signature:(int)
K	docs/tcmalloc.html	/^efficient than PTMalloc2. For max allocation sizes &lt;32K, TCMalloc$/;"	m	class:object::structure	file:	access:private
K	src/.libs/libtcmalloc_minimal_internal_la-internal_logging.o	/^/;"	v
K	src/libtcmalloc_internal_la-central_freelist.o	/^/;"	v
K	src/libtcmalloc_internal_la-internal_logging.o	/^/;"	v
K	src/libtcmalloc_minimal_internal_la-central_freelist.o	/^/;"	v
K	src/packed-cache-inl.h	/^  typedef uintptr_t K;$/;"	t	class:PackedCache	access:public
KCACHEGRIND	src/pprof	/^my @KCACHEGRIND = ("kcachegrind");$/;"	v
KERNEL_DIRENT	src/base/linux_syscall_support.h	2471;"	d
KERNEL_NSIG	src/base/linux_syscall_support.h	281;"	d
KERNEL_NSIG	src/base/linux_syscall_support.h	283;"	d
Key	src/addressmap-inl.h	/^  typedef const void* Key;$/;"	t	class:AddressMap	access:public
KeyEqual	src/stack_trace_table.cc	/^bool StackTraceTable::Bucket::KeyEqual(uintptr_t h,$/;"	f	class:tcmalloc::StackTraceTable::Bucket	signature:(uintptr_t h, const StackTrace& t) const
KeyEqual	src/stack_trace_table.h	/^    bool KeyEqual(uintptr_t h, const StackTrace& t) const;$/;"	p	struct:tcmalloc::StackTraceTable::Bucket	access:public	signature:(uintptr_t h, const StackTrace& t) const
KeyFree	src/tests/heap-checker_unittest.cc	/^static void KeyFree(void* ptr) {$/;"	f	file:	signature:(void* ptr)
KeyInit	src/tests/heap-checker_unittest.cc	/^static void KeyInit() {$/;"	f	file:	signature:()
KeyToUpper	src/packed-cache-inl.h	/^  static T KeyToUpper(K k) {$/;"	f	class:PackedCache	access:private	signature:(K k)
L	src/.libs/libtcmalloc_internal_la-internal_logging.o	/^/;"	v
L	src/base/logging.o	/^/;"	v
L	src/tests/markidle_unittest-testutil.o	/^/;"	v
L	src/tests/memalign_debug_unittest-testutil.o	/^/;"	v
L	src/tests/memalign_unittest-testutil.o	/^/;"	v
L	src/tests/tcmalloc_and_profiler_unittest-testutil.o	/^/;"	v
L	src/tests/tcmalloc_both_unittest-testutil.o	/^/;"	v
L	src/tests/tcmalloc_debug_unittest-testutil.o	/^/;"	v
L	src/tests/tcmalloc_minimal_debug_unittest-testutil.o	/^/;"	v
L	src/tests/tcmalloc_minimal_unittest-testutil.o	/^/;"	v
L	src/tests/tcmalloc_unittest-testutil.o	/^/;"	v
L	src/tests/thread_dealloc_unittest-testutil.o	/^/;"	v
LASTARG	missing	/^        eval LASTARG="\\${$#}"$/;"	v
LD	m4/libtool.m4	/^	  LD="${LD-ld} -64"$/;"	v
LD	m4/libtool.m4	/^	  LD="${LD-ld} -melf32bmipn32"$/;"	v
LD	m4/libtool.m4	/^	  LD="${LD-ld} -n32"$/;"	v
LEAF_BITS	src/pagemap.h	/^  static const int LEAF_BITS = (BITS + 1) \/ 2;$/;"	m	class:TCMalloc_PageMap2	access:private
LEAF_BITS	src/pagemap.h	/^  static const int LEAF_BITS = BITS - 2*INTERIOR_BITS;$/;"	m	class:TCMalloc_PageMap3	access:private
LEAF_LENGTH	src/pagemap.h	/^  static const int LEAF_LENGTH = 1 << LEAF_BITS;$/;"	m	class:TCMalloc_PageMap2	access:private
LEAF_LENGTH	src/pagemap.h	/^  static const int LEAF_LENGTH = 1 << LEAF_BITS;$/;"	m	class:TCMalloc_PageMap3	access:private
LENGTH	src/pagemap.h	/^  static const int LENGTH = 1 << BITS;$/;"	m	class:TCMalloc_PageMap1	access:private
LIABILITY	COPYING	/^THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT$/;"	v
LIABILITY	packages/deb/copyright	/^THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT$/;"	v
LIABILITY	src/windows/shortproc.asm	/^; THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT$/;"	v
LIBC	config.guess	/^	LIBC=gnu$/;"	v
LIB_PATH	src/tests/maybe_threads_unittest.sh	/^  LIB_PATH="$UNITTEST_DIR\/.libs\/libtcmalloc_minimal.so"$/;"	v
LIB_PATH	src/tests/maybe_threads_unittest.sh	/^  LIB_PATH="$UNITTEST_DIR\/libtcmalloc_minimal.dylib"$/;"	v
LIB_PATH	src/tests/maybe_threads_unittest.sh	/^  LIB_PATH="$UNITTEST_DIR\/libtcmalloc_minimal.so"$/;"	v
LINKER_INITIALIZED	src/base/basictypes.h	/^enum LinkerInitialized { LINKER_INITIALIZED };$/;"	e	enum:base::LinkerInitialized
LINKER_INITIALIZED	src/base/simple_mutex.h	/^  enum LinkerInitialized { LINKER_INITIALIZED };$/;"	e	enum:MUTEX_NAMESPACE::Mutex::LinkerInitialized
LINKER_INITIALIZED	src/base/spinlock.cc	/^const base::LinkerInitialized SpinLock::LINKER_INITIALIZED =$/;"	m	class:SpinLock	file:
LINKER_INITIALIZED	src/base/spinlock.h	/^  static const base::LinkerInitialized LINKER_INITIALIZED;  \/\/ backwards compat$/;"	m	class:SpinLock	access:public
LLA_SkiplistDelete	src/base/low_level_alloc.cc	/^static void LLA_SkiplistDelete(AllocList *head, AllocList *e,$/;"	f	file:	signature:(AllocList *head, AllocList *e, AllocList **prev)
LLA_SkiplistInsert	src/base/low_level_alloc.cc	/^static void LLA_SkiplistInsert(AllocList *head, AllocList *e,$/;"	f	file:	signature:(AllocList *head, AllocList *e, AllocList **prev)
LLA_SkiplistLevels	src/base/low_level_alloc.cc	/^static int LLA_SkiplistLevels(size_t size, size_t base, bool random) {$/;"	f	file:	signature:(size_t size, size_t base, bool random)
LLA_SkiplistSearch	src/base/low_level_alloc.cc	/^static AllocList *LLA_SkiplistSearch(AllocList *head,$/;"	f	file:	signature:(AllocList *head, AllocList *e, AllocList **prev)
LOAD	src/stacktrace_powerpc-inl.h	100;"	d
LOAD	src/stacktrace_powerpc-inl.h	102;"	d
LOAD	src/stacktrace_powerpc-linux-inl.h	121;"	d
LOAD	src/stacktrace_powerpc-linux-inl.h	123;"	d
LOCKABLE	src/base/thread_annotations.h	109;"	d
LOCKS_EXCLUDED	src/base/thread_annotations.h	102;"	d
LOCKS_EXCLUDED	src/central_freelist.h	/^  bool ShrinkCache(int locked_size_class, bool force) LOCKS_EXCLUDED(lock_);$/;"	p	class:tcmalloc::CentralFreeList	access:private	signature:(lock_)
LOCK_RETURNED	src/base/thread_annotations.h	106;"	d
LOG	src/base/logging.h	/^inline void LOG(int lvl, const char* pat, ...)      { LOG_PRINTF(lvl, pat); }$/;"	f	signature:(int lvl, const char* pat, ...)
LOG	src/tests/sampler_test.cc	82;"	d	file:
LOG	src/tests/sampler_test.cc	85;"	d	file:
LOGF	src/tests/heap-checker_unittest.cc	169;"	d	file:
LOGSTREAM	src/tests/tcmalloc_unittest.cc	174;"	d	file:
LOG_IF	src/base/logging.h	/^inline void LOG_IF(int lvl, bool cond, const char* pat, ...) {$/;"	f	signature:(int lvl, bool cond, const char* pat, ...)
LOG_PRINTF	src/base/logging.h	218;"	d
LPMODULEENTRY32	src/base/sysinfo.cc	75;"	d	file:
LR	src/base/elfcore.h	116;"	d
LR	src/base/elfcore.h	97;"	d
LSS_ASMINPUT_0	src/base/linux_syscall_support.h	1959;"	d
LSS_ASMINPUT_0	src/base/linux_syscall_support.h	1960;"	d
LSS_ASMINPUT_1	src/base/linux_syscall_support.h	1961;"	d
LSS_ASMINPUT_1	src/base/linux_syscall_support.h	1962;"	d
LSS_ASMINPUT_2	src/base/linux_syscall_support.h	1963;"	d
LSS_ASMINPUT_2	src/base/linux_syscall_support.h	1964;"	d
LSS_ASMINPUT_3	src/base/linux_syscall_support.h	1965;"	d
LSS_ASMINPUT_3	src/base/linux_syscall_support.h	1966;"	d
LSS_ASMINPUT_4	src/base/linux_syscall_support.h	1967;"	d
LSS_ASMINPUT_4	src/base/linux_syscall_support.h	1968;"	d
LSS_ASMINPUT_5	src/base/linux_syscall_support.h	1969;"	d
LSS_ASMINPUT_5	src/base/linux_syscall_support.h	1970;"	d
LSS_ASMINPUT_6	src/base/linux_syscall_support.h	1971;"	d
LSS_ASMINPUT_6	src/base/linux_syscall_support.h	1972;"	d
LSS_BODY	src/base/linux_syscall_support.h	1059;"	d
LSS_BODY	src/base/linux_syscall_support.h	1060;"	d
LSS_BODY	src/base/linux_syscall_support.h	1313;"	d
LSS_BODY	src/base/linux_syscall_support.h	1314;"	d
LSS_BODY	src/base/linux_syscall_support.h	1530;"	d
LSS_BODY	src/base/linux_syscall_support.h	1531;"	d
LSS_BODY	src/base/linux_syscall_support.h	1718;"	d
LSS_BODY	src/base/linux_syscall_support.h	1719;"	d
LSS_BODY	src/base/linux_syscall_support.h	1973;"	d
LSS_BODY	src/base/linux_syscall_support.h	1974;"	d
LSS_BODY	src/base/linux_syscall_support.h	2202;"	d
LSS_BODY	src/base/linux_syscall_support.h	2203;"	d
LSS_BODY	src/base/linux_syscall_support.h	2324;"	d
LSS_BODY	src/base/linux_syscall_support.h	2325;"	d
LSS_BODY_ARG0	src/base/linux_syscall_support.h	1347;"	d
LSS_BODY_ARG0	src/base/linux_syscall_support.h	1354;"	d
LSS_BODY_ARG1	src/base/linux_syscall_support.h	1348;"	d
LSS_BODY_ARG1	src/base/linux_syscall_support.h	1355;"	d
LSS_BODY_ARG2	src/base/linux_syscall_support.h	1349;"	d
LSS_BODY_ARG2	src/base/linux_syscall_support.h	1357;"	d
LSS_BODY_ARG3	src/base/linux_syscall_support.h	1350;"	d
LSS_BODY_ARG3	src/base/linux_syscall_support.h	1359;"	d
LSS_BODY_ARG4	src/base/linux_syscall_support.h	1351;"	d
LSS_BODY_ARG4	src/base/linux_syscall_support.h	1361;"	d
LSS_BODY_ARG5	src/base/linux_syscall_support.h	1352;"	d
LSS_BODY_ARG5	src/base/linux_syscall_support.h	1363;"	d
LSS_BODY_ARG6	src/base/linux_syscall_support.h	1353;"	d
LSS_BODY_ARG6	src/base/linux_syscall_support.h	1365;"	d
LSS_BODY_ASM0	src/base/linux_syscall_support.h	1317;"	d
LSS_BODY_ASM0	src/base/linux_syscall_support.h	1324;"	d
LSS_BODY_ASM1	src/base/linux_syscall_support.h	1318;"	d
LSS_BODY_ASM1	src/base/linux_syscall_support.h	1325;"	d
LSS_BODY_ASM2	src/base/linux_syscall_support.h	1319;"	d
LSS_BODY_ASM2	src/base/linux_syscall_support.h	1326;"	d
LSS_BODY_ASM3	src/base/linux_syscall_support.h	1320;"	d
LSS_BODY_ASM3	src/base/linux_syscall_support.h	1327;"	d
LSS_BODY_ASM4	src/base/linux_syscall_support.h	1321;"	d
LSS_BODY_ASM4	src/base/linux_syscall_support.h	1328;"	d
LSS_BODY_ASM5	src/base/linux_syscall_support.h	1322;"	d
LSS_BODY_ASM5	src/base/linux_syscall_support.h	1329;"	d
LSS_BODY_ASM6	src/base/linux_syscall_support.h	1323;"	d
LSS_BODY_ASM6	src/base/linux_syscall_support.h	1330;"	d
LSS_BODY_CLOBBER0	src/base/linux_syscall_support.h	1332;"	d
LSS_BODY_CLOBBER0	src/base/linux_syscall_support.h	1339;"	d
LSS_BODY_CLOBBER1	src/base/linux_syscall_support.h	1333;"	d
LSS_BODY_CLOBBER1	src/base/linux_syscall_support.h	1340;"	d
LSS_BODY_CLOBBER2	src/base/linux_syscall_support.h	1334;"	d
LSS_BODY_CLOBBER2	src/base/linux_syscall_support.h	1341;"	d
LSS_BODY_CLOBBER3	src/base/linux_syscall_support.h	1335;"	d
LSS_BODY_CLOBBER3	src/base/linux_syscall_support.h	1342;"	d
LSS_BODY_CLOBBER4	src/base/linux_syscall_support.h	1336;"	d
LSS_BODY_CLOBBER4	src/base/linux_syscall_support.h	1343;"	d
LSS_BODY_CLOBBER5	src/base/linux_syscall_support.h	1337;"	d
LSS_BODY_CLOBBER5	src/base/linux_syscall_support.h	1344;"	d
LSS_BODY_CLOBBER6	src/base/linux_syscall_support.h	1338;"	d
LSS_BODY_CLOBBER6	src/base/linux_syscall_support.h	1345;"	d
LSS_ENTRYPOINT	src/base/linux_syscall_support.h	1282;"	d
LSS_ENTRYPOINT	src/base/linux_syscall_support.h	1283;"	d
LSS_ERRNO	src/base/linux_syscall_support.h	955;"	d
LSS_ERRNO	src/base/linux_syscall_support.h	960;"	d
LSS_ERRNO	src/base/linux_syscall_support.h	962;"	d
LSS_INLINE	src/base/linux_syscall_support.h	965;"	d
LSS_INLINE	src/base/linux_syscall_support.h	967;"	d
LSS_INLINE	src/base/linux_syscall_support.h	969;"	d
LSS_LOADARGS_0	src/base/linux_syscall_support.h	1932;"	d
LSS_LOADARGS_0	src/base/linux_syscall_support.h	1933;"	d
LSS_LOADARGS_1	src/base/linux_syscall_support.h	1935;"	d
LSS_LOADARGS_1	src/base/linux_syscall_support.h	1936;"	d
LSS_LOADARGS_2	src/base/linux_syscall_support.h	1939;"	d
LSS_LOADARGS_2	src/base/linux_syscall_support.h	1940;"	d
LSS_LOADARGS_3	src/base/linux_syscall_support.h	1943;"	d
LSS_LOADARGS_3	src/base/linux_syscall_support.h	1944;"	d
LSS_LOADARGS_4	src/base/linux_syscall_support.h	1947;"	d
LSS_LOADARGS_4	src/base/linux_syscall_support.h	1948;"	d
LSS_LOADARGS_5	src/base/linux_syscall_support.h	1951;"	d
LSS_LOADARGS_5	src/base/linux_syscall_support.h	1952;"	d
LSS_LOADARGS_6	src/base/linux_syscall_support.h	1955;"	d
LSS_LOADARGS_6	src/base/linux_syscall_support.h	1956;"	d
LSS_LOAD_ARG	src/base/linux_syscall_support.h	1527;"	d
LSS_LOAD_ARG	src/base/linux_syscall_support.h	1528;"	d
LSS_NAME	src/base/linux_syscall_support.h	/^    LSS_INLINE void (*LSS_NAME(restore)(void))(void) {$/;"	f	signature:(restore)
LSS_NAME	src/base/linux_syscall_support.h	/^    LSS_INLINE void (*LSS_NAME(restore_rt)(void))(void) {$/;"	f	signature:(restore_rt)
LSS_NAME	src/base/linux_syscall_support.h	975;"	d
LSS_NAME	src/base/linux_syscall_support.h	977;"	d
LSS_NAME	src/base/linux_syscall_support.h	979;"	d
LSS_NAME	src/base/linux_syscall_support.h	981;"	d
LSS_NAME	src/base/linux_syscall_support.h	983;"	d
LSS_NAME	src/base/linux_syscall_support.h	985;"	d
LSS_NAME	src/base/linux_syscall_support.h	987;"	d
LSS_NAME	src/base/linux_syscall_support.h	989;"	d
LSS_NAME	src/base/linux_syscall_support.h	991;"	d
LSS_NAME	src/base/linux_syscall_support.h	993;"	d
LSS_NAME	src/base/linux_syscall_support.h	995;"	d
LSS_NAME	src/base/linux_syscall_support.h	997;"	d
LSS_NAME	src/base/linux_syscall_support.h	999;"	d
LSS_REG	src/base/linux_syscall_support.h	1517;"	d
LSS_REG	src/base/linux_syscall_support.h	1518;"	d
LSS_REG	src/base/linux_syscall_support.h	1704;"	d
LSS_REG	src/base/linux_syscall_support.h	1705;"	d
LSS_REG	src/base/linux_syscall_support.h	2200;"	d
LSS_REG	src/base/linux_syscall_support.h	2201;"	d
LSS_REG	src/base/linux_syscall_support.h	2322;"	d
LSS_REG	src/base/linux_syscall_support.h	2323;"	d
LSS_RETURN	src/base/linux_syscall_support.h	1002;"	d
LSS_RETURN	src/base/linux_syscall_support.h	1008;"	d
LSS_RETURN	src/base/linux_syscall_support.h	1020;"	d
LSS_RETURN	src/base/linux_syscall_support.h	1032;"	d
LSS_RETURN	src/base/linux_syscall_support.h	1302;"	d
LSS_RETURN	src/base/linux_syscall_support.h	1303;"	d
LSS_SAVE_ARG	src/base/linux_syscall_support.h	1525;"	d
LSS_SAVE_ARG	src/base/linux_syscall_support.h	1526;"	d
LSS_SYSCALL_ARG	src/base/linux_syscall_support.h	1291;"	d
LSS_SYSCALL_ARG	src/base/linux_syscall_support.h	1292;"	d
LT_DLGLOBAL	m4/libtool.m4	1656;"	d	file:
LT_DLLAZY_OR_NOW	m4/libtool.m4	1669;"	d	file:
LT_OBJDIR	src/config.h	222;"	d
LT_OBJDIR	src/config.h.in	221;"	d	file:
LT_OBJDIR	src/windows/config.h	221;"	d
LargeSizeClass	src/common.h	/^  static inline size_t LargeSizeClass(size_t s) {$/;"	f	class:tcmalloc::SizeMap	access:private	signature:(size_t s)
LargeSpanStats	src/page_heap.h	/^  struct LargeSpanStats {$/;"	s	class:tcmalloc::PageHeap	access:public
Leaf	src/pagemap.h	/^  struct Leaf {$/;"	s	class:TCMalloc_PageMap2	access:private
Leaf	src/pagemap.h	/^  struct Leaf {$/;"	s	class:TCMalloc_PageMap3	access:private
Leave	src/base/low_level_alloc.cc	/^    void Leave() \/*UNLOCK_FUNCTION()*\/ {$/;"	f	class:__anon39::ArenaLock	access:public	signature:()
LeaveStacktraceScope	src/emergency_malloc_for_stacktrace.cc	/^  void LeaveStacktraceScope(void);$/;"	p	namespace:tcmalloc	file:	signature:(void)
LeaveStacktraceScope	src/emergency_malloc_for_stacktrace.cc	/^void tcmalloc::LeaveStacktraceScope(void) {$/;"	f	class:tcmalloc	signature:(void)
LeaveStacktraceScope	src/fake_stacktrace_scope.cc	/^  ATTRIBUTE_WEAK void LeaveStacktraceScope(void) {$/;"	f	namespace:tcmalloc	signature:(void)
LeaveStacktraceScope	src/stacktrace.cc	/^  void LeaveStacktraceScope(void);$/;"	p	namespace:tcmalloc	file:	signature:(void)
Length	src/common.h	/^typedef uintptr_t Length;$/;"	t
LgFloor	src/common.cc	/^static inline int LgFloor(size_t n) {$/;"	f	namespace:tcmalloc	signature:(size_t n)
LibcInfo	src/windows/patch_functions.cc	/^  LibcInfo() {$/;"	f	class:__anon13::LibcInfo	access:public	signature:()
LibcInfo	src/windows/patch_functions.cc	/^class LibcInfo {$/;"	c	namespace:__anon13	file:
LibcInfoWithPatchFunctions	src/windows/patch_functions.cc	/^template<int> class LibcInfoWithPatchFunctions : public LibcInfo {$/;"	c	namespace:__anon13	file:	inherits:LibcInfo
LibcInfoWithPatchFunctions::Perftools_delete	src/windows/patch_functions.cc	/^void LibcInfoWithPatchFunctions<T>::Perftools_delete(void *p) {$/;"	f	class:LibcInfoWithPatchFunctions	signature:(void *p)
LibcInfoWithPatchFunctions::Perftools_deletearray	src/windows/patch_functions.cc	/^void LibcInfoWithPatchFunctions<T>::Perftools_deletearray(void *p) {$/;"	f	class:LibcInfoWithPatchFunctions	signature:(void *p)
LibcInfoWithPatchFunctions::Perftools_new	src/windows/patch_functions.cc	/^void* LibcInfoWithPatchFunctions<T>::Perftools_new(size_t size) {$/;"	f	class:LibcInfoWithPatchFunctions	signature:(size_t size)
LibcInfoWithPatchFunctions::Perftools_newarray	src/windows/patch_functions.cc	/^void* LibcInfoWithPatchFunctions<T>::Perftools_newarray(size_t size) {$/;"	f	class:LibcInfoWithPatchFunctions	signature:(size_t size)
LibraryLiveObjectsStacks	src/heap-checker.cc	/^           > LibraryLiveObjectsStacks;$/;"	t	file:
LinkerInitialized	src/base/basictypes.h	/^enum LinkerInitialized { LINKER_INITIALIZED };$/;"	g	namespace:base
LinkerInitialized	src/base/simple_mutex.h	/^  enum LinkerInitialized { LINKER_INITIALIZED };$/;"	g	class:MUTEX_NAMESPACE::Mutex	access:public
Linux	docs/pprof_remote_servers.html	/^program-compile-time.  Another, at least on Linux, is to call out to$/;"	v
LinuxKernelCmpxchgFunc	src/base/atomicops-internals-arm-generic.h	/^typedef Atomic32 (*LinuxKernelCmpxchgFunc)(Atomic32 old_value,$/;"	t	namespace:base::subtle
LinuxKernelMemoryBarrierFunc	src/base/atomicops-internals-arm-generic.h	/^typedef void (*LinuxKernelMemoryBarrierFunc)(void);$/;"	t	namespace:base::subtle
ListAllProcessThreadsCallBack	src/base/thread_lister.h	/^typedef int (*ListAllProcessThreadsCallBack)(void *parameter,$/;"	t
ListTooLong	src/thread_cache.cc	/^void ThreadCache::ListTooLong(FreeList* list, uint32 cl) {$/;"	f	class:tcmalloc::ThreadCache	signature:(FreeList* list, uint32 cl)
ListTooLong	src/thread_cache.h	/^  void ListTooLong(FreeList* src, uint32 cl);$/;"	p	class:tcmalloc::ThreadCache	access:private	signature:(FreeList* src, uint32 cl)
ListTooLong	src/thread_cache.h	/^  void ListTooLong(void* ptr, uint32 cl);$/;"	p	class:tcmalloc::ThreadCache	access:private	signature:(void* ptr, uint32 cl)
ListerParams	src/base/linuxthreads.cc	/^struct ListerParams {$/;"	s	file:
ListerParams::altstack_mem	src/base/linuxthreads.cc	/^  char        *altstack_mem;$/;"	m	struct:ListerParams	file:	access:public
ListerParams::ap	src/base/linuxthreads.cc	/^  va_list     ap;$/;"	m	struct:ListerParams	file:	access:public
ListerParams::callback	src/base/linuxthreads.cc	/^  ListAllProcessThreadsCallBack callback;$/;"	m	struct:ListerParams	file:	access:public
ListerParams::err	src/base/linuxthreads.cc	/^  int         result, err;$/;"	m	struct:ListerParams	file:	access:public
ListerParams::lock	src/base/linuxthreads.cc	/^  sem_t       *lock;$/;"	m	struct:ListerParams	file:	access:public
ListerParams::parameter	src/base/linuxthreads.cc	/^  void        *parameter;$/;"	m	struct:ListerParams	file:	access:public
ListerParams::result	src/base/linuxthreads.cc	/^  int         result, err;$/;"	m	struct:ListerParams	file:	access:public
ListerThread	src/base/linuxthreads.cc	/^static void ListerThread(struct ListerParams *args) {$/;"	f	file:	signature:(struct ListerParams *args)
LiveObjectsStack	src/heap-checker.cc	/^              > LiveObjectsStack;$/;"	t	file:
Lock	src/base/simple_mutex.h	/^  inline void Lock();    \/\/ Block if needed until free then acquire exclusively$/;"	p	class:MUTEX_NAMESPACE::Mutex	access:public	signature:()
Lock	src/base/simple_mutex.h	/^void Mutex::Lock()         { SAFE_PTHREAD(pthread_mutex_lock); }$/;"	f	class:MUTEX_NAMESPACE::Mutex	signature:()
Lock	src/base/simple_mutex.h	/^void Mutex::Lock()         { SAFE_PTHREAD(pthread_rwlock_wrlock); }$/;"	f	class:MUTEX_NAMESPACE::Mutex	signature:()
Lock	src/base/simple_mutex.h	/^void Mutex::Lock()         { assert(--mutex_ == -1); }$/;"	f	class:MUTEX_NAMESPACE::Mutex	signature:()
Lock	src/base/simple_mutex.h	/^void Mutex::Lock()         { if (is_safe_) EnterCriticalSection(&mutex_); }$/;"	f	class:MUTEX_NAMESPACE::Mutex	signature:()
Lock	src/base/spinlock.h	/^  inline void Lock() \/*EXCLUSIVE_LOCK_FUNCTION()*\/ {$/;"	f	class:SpinLock	access:public	signature:()
Lock	src/central_freelist.h	/^  void Lock() {$/;"	f	class:tcmalloc::CentralFreeList	access:public	signature:()
Lock	src/memory_region_map.cc	/^void MemoryRegionMap::Lock() {$/;"	f	class:MemoryRegionMap	signature:()
LockHolder	src/memory_region_map.h	/^    LockHolder() { Lock(); }$/;"	f	class:MemoryRegionMap::LockHolder	access:public	signature:()
LockHolder	src/memory_region_map.h	/^  class LockHolder {$/;"	c	class:MemoryRegionMap	access:public
LockInverter	src/central_freelist.cc	/^  inline explicit LockInverter(SpinLock* held, SpinLock *temp)$/;"	f	class:tcmalloc::__anon19::LockInverter	access:public	signature:(SpinLock* held, SpinLock *temp)
LockInverter	src/central_freelist.cc	/^class LockInverter {$/;"	c	namespace:tcmalloc::__anon19	file:
LockIsHeld	src/memory_region_map.cc	/^bool MemoryRegionMap::LockIsHeld() {$/;"	f	class:MemoryRegionMap	signature:()
LockIsHeld	src/memory_region_map.h	/^  static bool LockIsHeld();$/;"	p	class:MemoryRegionMap	access:public	signature:()
Log	src/internal_logging.cc	/^void Log(LogMode mode, const char* filename, int line,$/;"	f	namespace:tcmalloc	signature:(LogMode mode, const char* filename, int line, LogItem a, LogItem b, LogItem c, LogItem d)
Log	src/internal_logging.h	/^extern PERFTOOLS_DLL_DECL void Log(LogMode mode, const char* filename, int line,$/;"	p	namespace:tcmalloc	signature:(LogMode mode, const char* filename, int line, LogItem a, LogItem b = LogItem(), LogItem c = LogItem(), LogItem d = LogItem())
LogAllLocked	src/memory_region_map.cc	/^void MemoryRegionMap::LogAllLocked() {$/;"	f	class:MemoryRegionMap	signature:()
LogAllLocked	src/memory_region_map.h	/^  static void LogAllLocked();$/;"	p	class:MemoryRegionMap	access:private	signature:()
LogHidden	src/tests/heap-checker_unittest.cc	/^static void LogHidden(const char* message, const void* ptr) {$/;"	f	file:	signature:(const char* message, const void* ptr)
LogItem	src/internal_logging.h	/^  LogItem()                     : tag_(kEnd)      { }$/;"	f	class:tcmalloc::LogItem	access:public	signature:()
LogItem	src/internal_logging.h	/^  LogItem(const char* v)        : tag_(kStr)      { u_.str = v; }$/;"	f	class:tcmalloc::LogItem	access:public	signature:(const char* v)
LogItem	src/internal_logging.h	/^  LogItem(const void* v)        : tag_(kPtr)      { u_.ptr = v; }$/;"	f	class:tcmalloc::LogItem	access:public	signature:(const void* v)
LogItem	src/internal_logging.h	/^  LogItem(int v)                : tag_(kSigned)   { u_.snum = v; }$/;"	f	class:tcmalloc::LogItem	access:public	signature:(int v)
LogItem	src/internal_logging.h	/^  LogItem(long long v)          : tag_(kSigned)   { u_.snum = v; }$/;"	f	class:tcmalloc::LogItem	access:public	signature:(long long v)
LogItem	src/internal_logging.h	/^  LogItem(long v)               : tag_(kSigned)   { u_.snum = v; }$/;"	f	class:tcmalloc::LogItem	access:public	signature:(long v)
LogItem	src/internal_logging.h	/^  LogItem(unsigned int v)       : tag_(kUnsigned) { u_.unum = v; }$/;"	f	class:tcmalloc::LogItem	access:public	signature:(unsigned int v)
LogItem	src/internal_logging.h	/^  LogItem(unsigned long long v) : tag_(kUnsigned) { u_.unum = v; }$/;"	f	class:tcmalloc::LogItem	access:public	signature:(unsigned long long v)
LogItem	src/internal_logging.h	/^  LogItem(unsigned long v)      : tag_(kUnsigned) { u_.unum = v; }$/;"	f	class:tcmalloc::LogItem	access:public	signature:(unsigned long v)
LogItem	src/internal_logging.h	/^class LogItem {$/;"	c	namespace:tcmalloc
LogMode	src/internal_logging.h	/^enum LogMode {$/;"	g	namespace:tcmalloc
LogPrintf	src/base/logging.h	/^inline void LogPrintf(int severity, const char* pat, va_list ap) {$/;"	f	signature:(int severity, const char* pat, va_list ap)
LogSeverity	src/base/logging.h	/^enum LogSeverity {INFO = -1, WARNING = -2, ERROR = -3, FATAL = -4};$/;"	g
Logger	src/internal_logging.cc	/^class Logger {$/;"	c	namespace:tcmalloc	file:
Long	src/pprof	/^use Getopt::Long;$/;"	m	class:Getopt	file:
LookupSymbol	src/base/elf_mem_image.cc	/^bool ElfMemImage::LookupSymbol(const char *name,$/;"	f	class:base::ElfMemImage	signature:(const char *name, const char *version, int type, SymbolInfo *info) const
LookupSymbol	src/base/elf_mem_image.h	/^  bool LookupSymbol(const char *name, const char *version,$/;"	p	class:base::ElfMemImage	access:public	signature:(const char *name, const char *version, int symbol_type, SymbolInfo *info_out) const
LookupSymbol	src/base/vdso_support.cc	/^bool VDSOSupport::LookupSymbol(const char *name,$/;"	f	class:base::VDSOSupport	signature:(const char *name, const char *version, int type, SymbolInfo *info) const
LookupSymbol	src/base/vdso_support.h	/^  bool LookupSymbol(const char *name, const char *version,$/;"	p	class:base::VDSOSupport	access:public	signature:(const char *name, const char *version, int symbol_type, SymbolInfo *info_out) const
LookupSymbolByAddress	src/base/elf_mem_image.cc	/^bool ElfMemImage::LookupSymbolByAddress(const void *address,$/;"	f	class:base::ElfMemImage	signature:(const void *address, SymbolInfo *info_out) const
LookupSymbolByAddress	src/base/elf_mem_image.h	/^  bool LookupSymbolByAddress(const void *address, SymbolInfo *info_out) const;$/;"	p	class:base::ElfMemImage	access:public	signature:(const void *address, SymbolInfo *info_out) const
LookupSymbolByAddress	src/base/vdso_support.cc	/^bool VDSOSupport::LookupSymbolByAddress(const void *address,$/;"	f	class:base::VDSOSupport	signature:(const void *address, SymbolInfo *info_out) const
LookupSymbolByAddress	src/base/vdso_support.h	/^  bool LookupSymbolByAddress(const void *address, SymbolInfo *info_out) const;$/;"	p	class:base::VDSOSupport	access:public	signature:(const void *address, SymbolInfo *info_out) const
LowLevelAlloc	src/base/low_level_alloc.h	/^  LowLevelAlloc();      \/\/ no instances$/;"	p	class:LowLevelAlloc	access:private	signature:()
LowLevelAlloc	src/base/low_level_alloc.h	/^class LowLevelAlloc {$/;"	c
LowLevelAlloc::ATTRIBUTE_SECTION	src/base/low_level_alloc.h	/^    ATTRIBUTE_SECTION(malloc_hook);$/;"	p	class:LowLevelAlloc	access:public	signature:(malloc_hook)
LowLevelAlloc::ATTRIBUTE_SECTION	src/base/low_level_alloc.h	/^  static void Free(void *s) ATTRIBUTE_SECTION(malloc_hook);$/;"	p	class:LowLevelAlloc	access:public	signature:(malloc_hook)
LowLevelAlloc::Alloc	src/base/low_level_alloc.cc	/^void *LowLevelAlloc::Alloc(size_t request) {$/;"	f	class:LowLevelAlloc	signature:(size_t request)
LowLevelAlloc::AllocWithArena	src/base/low_level_alloc.cc	/^void *LowLevelAlloc::AllocWithArena(size_t request, Arena *arena) {$/;"	f	class:LowLevelAlloc	signature:(size_t request, Arena *arena)
LowLevelAlloc::Arena	src/base/low_level_alloc.cc	/^struct LowLevelAlloc::Arena {$/;"	s	class:LowLevelAlloc	file:
LowLevelAlloc::Arena::Arena	src/base/low_level_alloc.cc	/^  Arena() : mu(SpinLock::LINKER_INITIALIZED) {} \/\/ does nothing; for static init$/;"	f	struct:LowLevelAlloc::Arena	access:public	signature:()
LowLevelAlloc::Arena::Arena	src/base/low_level_alloc.cc	/^  explicit Arena(int) : pagesize(0) {}  \/\/ set pagesize to zero explicitly$/;"	f	struct:LowLevelAlloc::Arena	access:public	signature:(int)
LowLevelAlloc::Arena::allocation_count	src/base/low_level_alloc.cc	/^  int32 allocation_count; \/\/ count of allocated blocks (under mu)$/;"	m	struct:LowLevelAlloc::Arena	file:	access:public
LowLevelAlloc::Arena::allocator	src/base/low_level_alloc.cc	/^  PagesAllocator *allocator;$/;"	m	struct:LowLevelAlloc::Arena	file:	access:public
LowLevelAlloc::Arena::flags	src/base/low_level_alloc.cc	/^  int32 flags;            \/\/ flags passed to NewArena (ro after init)$/;"	m	struct:LowLevelAlloc::Arena	file:	access:public
LowLevelAlloc::Arena::freelist	src/base/low_level_alloc.cc	/^  AllocList freelist;     \/\/ head of free list; sorted by addr (under mu)$/;"	m	struct:LowLevelAlloc::Arena	file:	access:public
LowLevelAlloc::Arena::min_size	src/base/low_level_alloc.cc	/^  size_t min_size;        \/\/ smallest allocation block size$/;"	m	struct:LowLevelAlloc::Arena	file:	access:public
LowLevelAlloc::Arena::mu	src/base/low_level_alloc.cc	/^  SpinLock mu;            \/\/ protects freelist, allocation_count,$/;"	m	struct:LowLevelAlloc::Arena	file:	access:public
LowLevelAlloc::Arena::pagesize	src/base/low_level_alloc.cc	/^  size_t pagesize;        \/\/ ==getpagesize()  (init under mu, then ro)$/;"	m	struct:LowLevelAlloc::Arena	file:	access:public
LowLevelAlloc::Arena::roundup	src/base/low_level_alloc.cc	/^  size_t roundup;         \/\/ lowest power of 2 >= max(16,sizeof (AllocList))$/;"	m	struct:LowLevelAlloc::Arena	file:	access:public
LowLevelAlloc::DefaultArena	src/base/low_level_alloc.cc	/^LowLevelAlloc::Arena *LowLevelAlloc::DefaultArena() {$/;"	f	class:LowLevelAlloc	signature:()
LowLevelAlloc::DefaultArena	src/base/low_level_alloc.h	/^  static Arena *DefaultArena();$/;"	p	class:LowLevelAlloc	access:public	signature:()
LowLevelAlloc::DeleteArena	src/base/low_level_alloc.cc	/^bool LowLevelAlloc::DeleteArena(Arena *arena) {$/;"	f	class:LowLevelAlloc	signature:(Arena *arena)
LowLevelAlloc::DeleteArena	src/base/low_level_alloc.h	/^  static bool DeleteArena(Arena *arena);$/;"	p	class:LowLevelAlloc	access:public	signature:(Arena *arena)
LowLevelAlloc::Free	src/base/low_level_alloc.cc	/^void LowLevelAlloc::Free(void *v) {$/;"	f	class:LowLevelAlloc	signature:(void *v)
LowLevelAlloc::GetDefaultPagesAllocator	src/base/low_level_alloc.cc	/^LowLevelAlloc::PagesAllocator *LowLevelAlloc::GetDefaultPagesAllocator(void) {$/;"	f	class:LowLevelAlloc	signature:(void)
LowLevelAlloc::GetDefaultPagesAllocator	src/base/low_level_alloc.h	/^  static PagesAllocator *GetDefaultPagesAllocator(void);$/;"	p	class:LowLevelAlloc	access:public	signature:(void)
LowLevelAlloc::LowLevelAlloc	src/base/low_level_alloc.h	/^  LowLevelAlloc();      \/\/ no instances$/;"	p	class:LowLevelAlloc	access:private	signature:()
LowLevelAlloc::NewArena	src/base/low_level_alloc.cc	/^LowLevelAlloc::Arena *LowLevelAlloc::NewArena(int32 flags,$/;"	f	class:LowLevelAlloc	signature:(int32 flags, Arena *meta_data_arena)
LowLevelAlloc::NewArena	src/base/low_level_alloc.h	/^  static Arena *NewArena(int32 flags, Arena *meta_data_arena);$/;"	p	class:LowLevelAlloc	access:public	signature:(int32 flags, Arena *meta_data_arena)
LowLevelAlloc::NewArenaWithCustomAlloc	src/base/low_level_alloc.cc	/^LowLevelAlloc::Arena *LowLevelAlloc::NewArenaWithCustomAlloc(int32 flags,$/;"	f	class:LowLevelAlloc	signature:(int32 flags, Arena *meta_data_arena, PagesAllocator *allocator)
LowLevelAlloc::NewArenaWithCustomAlloc	src/base/low_level_alloc.h	/^  static Arena *NewArenaWithCustomAlloc(int32 flags, Arena *meta_data_arena, PagesAllocator *allocator);$/;"	p	class:LowLevelAlloc	access:public	signature:(int32 flags, Arena *meta_data_arena, PagesAllocator *allocator)
LowLevelAlloc::PagesAllocator	src/base/low_level_alloc.h	/^  class PagesAllocator {$/;"	c	class:LowLevelAlloc	access:public
LowLevelAlloc::PagesAllocator::MapPages	src/base/low_level_alloc.h	/^    virtual void *MapPages(int32 flags, size_t size) = 0;$/;"	p	class:LowLevelAlloc::PagesAllocator	access:public	signature:(int32 flags, size_t size)
LowLevelAlloc::PagesAllocator::UnMapPages	src/base/low_level_alloc.h	/^    virtual void UnMapPages(int32 flags, void *addr, size_t size) = 0;$/;"	p	class:LowLevelAlloc::PagesAllocator	access:public	signature:(int32 flags, void *addr, size_t size)
LowLevelAlloc::PagesAllocator::~PagesAllocator	src/base/low_level_alloc.cc	/^LowLevelAlloc::PagesAllocator::~PagesAllocator() {$/;"	f	class:LowLevelAlloc::PagesAllocator	signature:()
LowLevelAlloc::PagesAllocator::~PagesAllocator	src/base/low_level_alloc.h	/^    virtual ~PagesAllocator();$/;"	p	class:LowLevelAlloc::PagesAllocator	access:public	signature:()
LowLevelAlloc::kAsyncSignalSafe	src/base/low_level_alloc.h	/^    kAsyncSignalSafe = 0x0002,$/;"	e	enum:LowLevelAlloc::__anon44
LowLevelAlloc::kCallMallocHook	src/base/low_level_alloc.h	/^    kCallMallocHook = 0x0001,$/;"	e	enum:LowLevelAlloc::__anon44
M	benchmark/unwind_bench-getcontext_light.o	/^/;"	v
M1	src/tests/profiler1_unittest-profiler_unittest.o	/^/;"	v
M1	src/tests/profiler2_unittest-profiler_unittest.o	/^/;"	v
MADV_DONTNEED	ChangeLog.old	/^	* PORTING: use MADV_FREE, not MADV_DONTNEED, on freebsd (csilvers)$/;"	v
MADV_FREE	ChangeLog.old	/^	* PORTING: use MADV_FREE, not MADV_DONTNEED, on freebsd (csilvers)$/;"	v
MADV_FREE	src/system-alloc.cc	70;"	d	file:
MADV_FREE	src/system-alloc.cc	77;"	d	file:
MAKE_HOOK_CALLBACK	src/tests/tcmalloc_unittest.cc	/^MAKE_HOOK_CALLBACK(DeleteHook, const void*);$/;"	p	namespace:testing	file:	signature:(DeleteHook, const void*)
MAKE_HOOK_CALLBACK	src/tests/tcmalloc_unittest.cc	/^MAKE_HOOK_CALLBACK(MmapHook, const void*, const void*, size_t, int, int, int,$/;"	p	namespace:testing	file:	signature:(MmapHook, const void*, const void*, size_t, int, int, int, off_t)
MAKE_HOOK_CALLBACK	src/tests/tcmalloc_unittest.cc	/^MAKE_HOOK_CALLBACK(MremapHook, const void*, const void*, size_t, size_t, int,$/;"	p	namespace:testing	file:	signature:(MremapHook, const void*, const void*, size_t, size_t, int, const void*)
MAKE_HOOK_CALLBACK	src/tests/tcmalloc_unittest.cc	/^MAKE_HOOK_CALLBACK(MunmapHook, const void *, size_t);$/;"	p	namespace:testing	file:	signature:(MunmapHook, const void *, size_t)
MAKE_HOOK_CALLBACK	src/tests/tcmalloc_unittest.cc	/^MAKE_HOOK_CALLBACK(NewHook, const void*, size_t);$/;"	p	namespace:testing	file:	signature:(NewHook, const void*, size_t)
MAKE_HOOK_CALLBACK	src/tests/tcmalloc_unittest.cc	/^MAKE_HOOK_CALLBACK(SbrkHook, const void *, ptrdiff_t);$/;"	p	namespace:testing	file:	signature:(SbrkHook, const void *, ptrdiff_t)
MAKE_HOOK_CALLBACK	src/tests/tcmalloc_unittest.cc	781;"	d	file:
MALLOCX_LG_ALIGN	src/gperftools/nallocx.h	17;"	d
MALLOC_HOOK_HAVE_DO_MMAP64	src/malloc_hook_mmap_linux.h	124;"	d
MALLOC_HOOK_HAVE_DO_MMAP64	src/malloc_hook_mmap_linux.h	240;"	d
MALLOC_HOOK_HAVE_DO_MMAP64	src/malloc_hook_mmap_linux.h	67;"	d
MALLOC_HOOK_MAYBE_VOLATILE	src/windows/config.h	224;"	d
MALLOC_HOOK_SYSCALL	src/malloc_hook_mmap_freebsd.h	135;"	d
MALLOC_HOOK_SYSCALL	src/malloc_hook_mmap_freebsd.h	54;"	d
MALLOC_HOOK_SYSCALL	src/malloc_hook_mmap_freebsd.h	56;"	d
MALLOC_TRACE	src/debugallocation.cc	1002;"	d	file:
MAP_ANONYMOUS	src/base/low_level_alloc.cc	55;"	d	file:
MAP_ANONYMOUS	src/debugallocation.cc	97;"	d	file:
MAP_ANONYMOUS	src/system-alloc.cc	62;"	d	file:
MAP_ANONYMOUS	src/tests/heap-checker_unittest.cc	113;"	d	file:
MAP_ANONYMOUS	src/tests/malloc_hook_test.cc	56;"	d	file:
MAP_ANONYMOUS	src/tests/tcmalloc_unittest.cc	171;"	d	file:
MAP_ANONYMOUS	src/windows/port.h	278;"	d
MAP_FAILED	src/memory_region_map.cc	111;"	d	file:
MAP_FAILED	src/windows/port.h	273;"	d
MAP_PRIVATE	src/windows/port.h	279;"	d
MAP_SHARED	src/windows/port.h	280;"	d
MAX_DEPTH	src/stacktrace_instrument-inl.h	62;"	d
MAX_FRAMES	benchmark/unwind_bench.cc	19;"	d	file:
MAX_PERTHREAD_VALS	src/maybe_threads.cc	80;"	d	file:
MAX_PREAMBLE_STUB_SIZE	src/windows/preamble_patcher.h	61;"	d
MAX_PREAMBLE_STUB_SIZE	src/windows/preamble_patcher.h	63;"	d
MAX_SSIZE	src/sampler.cc	78;"	d	file:
MAX_THREAD	src/stacktrace_instrument-inl.h	58;"	d
MAX_THREAD	src/stacktrace_instrument-inl.h	60;"	d
MAYBE_EMERGENCY_MALLOC_H	src/maybe_emergency_malloc.h	32;"	d
MAYBE_LIVE	src/heap-checker.cc	/^  MAYBE_LIVE,        \/\/ Is a piece of writable memory from \/proc\/self\/maps$/;"	e	enum:ObjectPlacement	file:
MIPSREG	src/base/elfcore.h	288;"	d
MIPS_SYSCALL_CLOBBERS	src/base/linux_syscall_support.h	1711;"	d
MIPS_SYSCALL_CLOBBERS	src/base/linux_syscall_support.h	1714;"	d
MODE_NOOP	benchmark/unwind_bench.cc	/^  MODE_NOOP,$/;"	e	enum:measure_mode	file:
MODE_WITHOUT_CONTEXT	benchmark/unwind_bench.cc	/^  MODE_WITHOUT_CONTEXT$/;"	e	enum:measure_mode	file:
MODE_WITH_CONTEXT	benchmark/unwind_bench.cc	/^  MODE_WITH_CONTEXT,$/;"	e	enum:measure_mode	file:
MODULEENTRY32	src/base/sysinfo.cc	71;"	d	file:
MODULEENTRY32	src/base/sysinfo.h	202;"	d
MODULEENTRY32	src/base/sysinfo.h	204;"	d
MREMAP_FIXED	src/base/linux_syscall_support.h	571;"	d
MREMAP_FIXED	src/memory_region_map.cc	135;"	d	file:
MREMAP_FIXED	src/windows/port.h	274;"	d
MUST_BE_ON_HEAP	src/heap-checker.cc	/^  MUST_BE_ON_HEAP,   \/\/ Must point to a live object of the matching size in the$/;"	e	enum:ObjectPlacement	file:
MUTEX_NAMESPACE	src/base/simple_mutex.h	/^namespace MUTEX_NAMESPACE {$/;"	n
MUTEX_NAMESPACE	src/base/simple_mutex.h	144;"	d
MUTEX_NAMESPACE	src/base/simple_mutex.h	330;"	d
MUTEX_NAMESPACE::Mutex	src/base/simple_mutex.h	/^class Mutex {$/;"	c	namespace:MUTEX_NAMESPACE
MUTEX_NAMESPACE::Mutex::LINKER_INITIALIZED	src/base/simple_mutex.h	/^  enum LinkerInitialized { LINKER_INITIALIZED };$/;"	e	enum:MUTEX_NAMESPACE::Mutex::LinkerInitialized
MUTEX_NAMESPACE::Mutex::LinkerInitialized	src/base/simple_mutex.h	/^  enum LinkerInitialized { LINKER_INITIALIZED };$/;"	g	class:MUTEX_NAMESPACE::Mutex	access:public
MUTEX_NAMESPACE::Mutex::Lock	src/base/simple_mutex.h	/^  inline void Lock();    \/\/ Block if needed until free then acquire exclusively$/;"	p	class:MUTEX_NAMESPACE::Mutex	access:public	signature:()
MUTEX_NAMESPACE::Mutex::Lock	src/base/simple_mutex.h	/^void Mutex::Lock()         { SAFE_PTHREAD(pthread_mutex_lock); }$/;"	f	class:MUTEX_NAMESPACE::Mutex	signature:()
MUTEX_NAMESPACE::Mutex::Lock	src/base/simple_mutex.h	/^void Mutex::Lock()         { SAFE_PTHREAD(pthread_rwlock_wrlock); }$/;"	f	class:MUTEX_NAMESPACE::Mutex	signature:()
MUTEX_NAMESPACE::Mutex::Lock	src/base/simple_mutex.h	/^void Mutex::Lock()         { assert(--mutex_ == -1); }$/;"	f	class:MUTEX_NAMESPACE::Mutex	signature:()
MUTEX_NAMESPACE::Mutex::Lock	src/base/simple_mutex.h	/^void Mutex::Lock()         { if (is_safe_) EnterCriticalSection(&mutex_); }$/;"	f	class:MUTEX_NAMESPACE::Mutex	signature:()
MUTEX_NAMESPACE::Mutex::Mutex	src/base/simple_mutex.h	/^  Mutex(Mutex* \/*ignored*\/) {}$/;"	f	class:MUTEX_NAMESPACE::Mutex	access:private	signature:(Mutex* )
MUTEX_NAMESPACE::Mutex::Mutex	src/base/simple_mutex.h	/^  Mutex(const Mutex&);$/;"	p	class:MUTEX_NAMESPACE::Mutex	access:private	signature:(const Mutex&)
MUTEX_NAMESPACE::Mutex::Mutex	src/base/simple_mutex.h	/^  inline Mutex();$/;"	p	class:MUTEX_NAMESPACE::Mutex	access:public	signature:()
MUTEX_NAMESPACE::Mutex::Mutex	src/base/simple_mutex.h	/^  inline Mutex(LinkerInitialized);$/;"	p	class:MUTEX_NAMESPACE::Mutex	access:public	signature:(LinkerInitialized)
MUTEX_NAMESPACE::Mutex::Mutex	src/base/simple_mutex.h	/^Mutex::Mutex() : destroy_(true) {$/;"	f	class:MUTEX_NAMESPACE::Mutex	signature:()
MUTEX_NAMESPACE::Mutex::Mutex	src/base/simple_mutex.h	/^Mutex::Mutex() : mutex_(0) { }$/;"	f	class:MUTEX_NAMESPACE::Mutex	signature:()
MUTEX_NAMESPACE::Mutex::Mutex	src/base/simple_mutex.h	/^Mutex::Mutex(LinkerInitialized) : destroy_(false) {$/;"	f	class:MUTEX_NAMESPACE::Mutex	signature:(LinkerInitialized)
MUTEX_NAMESPACE::Mutex::Mutex	src/base/simple_mutex.h	/^Mutex::Mutex(Mutex::LinkerInitialized) : destroy_(false) {$/;"	f	class:MUTEX_NAMESPACE::Mutex	signature:(Mutex::LinkerInitialized)
MUTEX_NAMESPACE::Mutex::Mutex	src/base/simple_mutex.h	/^Mutex::Mutex(Mutex::LinkerInitialized) : mutex_(0) { }$/;"	f	class:MUTEX_NAMESPACE::Mutex	signature:(Mutex::LinkerInitialized)
MUTEX_NAMESPACE::Mutex::ReaderLock	src/base/simple_mutex.h	/^  inline void ReaderLock();   \/\/ Block until free or shared then acquire a share$/;"	p	class:MUTEX_NAMESPACE::Mutex	access:public	signature:()
MUTEX_NAMESPACE::Mutex::ReaderLock	src/base/simple_mutex.h	/^void Mutex::ReaderLock()   { Lock(); }      \/\/ we don't have read-write locks$/;"	f	class:MUTEX_NAMESPACE::Mutex	signature:()
MUTEX_NAMESPACE::Mutex::ReaderLock	src/base/simple_mutex.h	/^void Mutex::ReaderLock()   { Lock(); }$/;"	f	class:MUTEX_NAMESPACE::Mutex	signature:()
MUTEX_NAMESPACE::Mutex::ReaderLock	src/base/simple_mutex.h	/^void Mutex::ReaderLock()   { SAFE_PTHREAD(pthread_rwlock_rdlock); }$/;"	f	class:MUTEX_NAMESPACE::Mutex	signature:()
MUTEX_NAMESPACE::Mutex::ReaderLock	src/base/simple_mutex.h	/^void Mutex::ReaderLock()   { assert(++mutex_ > 0); }$/;"	f	class:MUTEX_NAMESPACE::Mutex	signature:()
MUTEX_NAMESPACE::Mutex::ReaderUnlock	src/base/simple_mutex.h	/^  inline void ReaderUnlock(); \/\/ Release a read share of this Mutex$/;"	p	class:MUTEX_NAMESPACE::Mutex	access:public	signature:()
MUTEX_NAMESPACE::Mutex::ReaderUnlock	src/base/simple_mutex.h	/^void Mutex::ReaderUnlock() { SAFE_PTHREAD(pthread_rwlock_unlock); }$/;"	f	class:MUTEX_NAMESPACE::Mutex	signature:()
MUTEX_NAMESPACE::Mutex::ReaderUnlock	src/base/simple_mutex.h	/^void Mutex::ReaderUnlock() { Unlock(); }$/;"	f	class:MUTEX_NAMESPACE::Mutex	signature:()
MUTEX_NAMESPACE::Mutex::ReaderUnlock	src/base/simple_mutex.h	/^void Mutex::ReaderUnlock() { assert(mutex_-- > 0); }$/;"	f	class:MUTEX_NAMESPACE::Mutex	signature:()
MUTEX_NAMESPACE::Mutex::SetIsSafe	src/base/simple_mutex.h	/^  inline void SetIsSafe() { is_safe_ = true; }$/;"	f	class:MUTEX_NAMESPACE::Mutex	access:private	signature:()
MUTEX_NAMESPACE::Mutex::TryLock	src/base/simple_mutex.h	/^  inline bool TryLock(); \/\/ If free, Lock() and return true, else return false$/;"	p	class:MUTEX_NAMESPACE::Mutex	access:public	signature:()
MUTEX_NAMESPACE::Mutex::TryLock	src/base/simple_mutex.h	/^bool Mutex::TryLock()      { if (mutex_) return false; Lock(); return true; }$/;"	f	class:MUTEX_NAMESPACE::Mutex	signature:()
MUTEX_NAMESPACE::Mutex::TryLock	src/base/simple_mutex.h	/^bool Mutex::TryLock()      { return is_safe_ ?$/;"	f	class:MUTEX_NAMESPACE::Mutex	signature:()
MUTEX_NAMESPACE::Mutex::Unlock	src/base/simple_mutex.h	/^  inline void Unlock();  \/\/ Release a lock acquired via Lock()$/;"	p	class:MUTEX_NAMESPACE::Mutex	access:public	signature:()
MUTEX_NAMESPACE::Mutex::Unlock	src/base/simple_mutex.h	/^void Mutex::Unlock()       { SAFE_PTHREAD(pthread_mutex_unlock); }$/;"	f	class:MUTEX_NAMESPACE::Mutex	signature:()
MUTEX_NAMESPACE::Mutex::Unlock	src/base/simple_mutex.h	/^void Mutex::Unlock()       { SAFE_PTHREAD(pthread_rwlock_unlock); }$/;"	f	class:MUTEX_NAMESPACE::Mutex	signature:()
MUTEX_NAMESPACE::Mutex::Unlock	src/base/simple_mutex.h	/^void Mutex::Unlock()       { assert(mutex_++ == -1); }$/;"	f	class:MUTEX_NAMESPACE::Mutex	signature:()
MUTEX_NAMESPACE::Mutex::Unlock	src/base/simple_mutex.h	/^void Mutex::Unlock()       { if (is_safe_) LeaveCriticalSection(&mutex_); }$/;"	f	class:MUTEX_NAMESPACE::Mutex	signature:()
MUTEX_NAMESPACE::Mutex::WriterLock	src/base/simple_mutex.h	/^  inline void WriterLock() { Lock(); }     \/\/ Acquire an exclusive lock$/;"	f	class:MUTEX_NAMESPACE::Mutex	access:public	signature:()
MUTEX_NAMESPACE::Mutex::WriterUnlock	src/base/simple_mutex.h	/^  inline void WriterUnlock() { Unlock(); } \/\/ Release a lock from WriterLock()$/;"	f	class:MUTEX_NAMESPACE::Mutex	access:public	signature:()
MUTEX_NAMESPACE::Mutex::destroy_	src/base/simple_mutex.h	/^  bool destroy_;$/;"	m	class:MUTEX_NAMESPACE::Mutex	access:private
MUTEX_NAMESPACE::Mutex::is_safe_	src/base/simple_mutex.h	/^  volatile bool is_safe_;$/;"	m	class:MUTEX_NAMESPACE::Mutex	access:private
MUTEX_NAMESPACE::Mutex::mutex_	src/base/simple_mutex.h	/^  MutexType mutex_;$/;"	m	class:MUTEX_NAMESPACE::Mutex	access:private
MUTEX_NAMESPACE::Mutex::operator =	src/base/simple_mutex.h	/^  void operator=(const Mutex&);$/;"	p	class:MUTEX_NAMESPACE::Mutex	access:private	signature:(const Mutex&)
MUTEX_NAMESPACE::Mutex::~Mutex	src/base/simple_mutex.h	/^  inline ~Mutex();$/;"	p	class:MUTEX_NAMESPACE::Mutex	access:public	signature:()
MUTEX_NAMESPACE::Mutex::~Mutex	src/base/simple_mutex.h	/^Mutex::~Mutex()            { assert(mutex_ == 0); }$/;"	f	class:MUTEX_NAMESPACE::Mutex	signature:()
MUTEX_NAMESPACE::Mutex::~Mutex	src/base/simple_mutex.h	/^Mutex::~Mutex()            { if (destroy_) DeleteCriticalSection(&mutex_); }$/;"	f	class:MUTEX_NAMESPACE::Mutex	signature:()
MUTEX_NAMESPACE::Mutex::~Mutex	src/base/simple_mutex.h	/^Mutex::~Mutex()       { if (destroy_) SAFE_PTHREAD(pthread_mutex_destroy); }$/;"	f	class:MUTEX_NAMESPACE::Mutex	signature:()
MUTEX_NAMESPACE::Mutex::~Mutex	src/base/simple_mutex.h	/^Mutex::~Mutex()       { if (destroy_) SAFE_PTHREAD(pthread_rwlock_destroy); }$/;"	f	class:MUTEX_NAMESPACE::Mutex	signature:()
MUTEX_NAMESPACE::MutexLock	src/base/simple_mutex.h	/^class MutexLock {$/;"	c	namespace:MUTEX_NAMESPACE
MUTEX_NAMESPACE::MutexLock::MutexLock	src/base/simple_mutex.h	/^  MutexLock(const MutexLock&);$/;"	p	class:MUTEX_NAMESPACE::MutexLock	access:private	signature:(const MutexLock&)
MUTEX_NAMESPACE::MutexLock::MutexLock	src/base/simple_mutex.h	/^  explicit MutexLock(Mutex *mu) : mu_(mu) { mu_->Lock(); }$/;"	f	class:MUTEX_NAMESPACE::MutexLock	access:public	signature:(Mutex *mu)
MUTEX_NAMESPACE::MutexLock::mu_	src/base/simple_mutex.h	/^  Mutex * const mu_;$/;"	m	class:MUTEX_NAMESPACE::MutexLock	access:private
MUTEX_NAMESPACE::MutexLock::operator =	src/base/simple_mutex.h	/^  void operator=(const MutexLock&);$/;"	p	class:MUTEX_NAMESPACE::MutexLock	access:private	signature:(const MutexLock&)
MUTEX_NAMESPACE::MutexLock::~MutexLock	src/base/simple_mutex.h	/^  ~MutexLock() { mu_->Unlock(); }$/;"	f	class:MUTEX_NAMESPACE::MutexLock	access:public	signature:()
MUTEX_NAMESPACE::ReaderMutexLock	src/base/simple_mutex.h	/^class ReaderMutexLock {$/;"	c	namespace:MUTEX_NAMESPACE
MUTEX_NAMESPACE::ReaderMutexLock::ReaderMutexLock	src/base/simple_mutex.h	/^  ReaderMutexLock(const ReaderMutexLock&);$/;"	p	class:MUTEX_NAMESPACE::ReaderMutexLock	access:private	signature:(const ReaderMutexLock&)
MUTEX_NAMESPACE::ReaderMutexLock::ReaderMutexLock	src/base/simple_mutex.h	/^  explicit ReaderMutexLock(Mutex *mu) : mu_(mu) { mu_->ReaderLock(); }$/;"	f	class:MUTEX_NAMESPACE::ReaderMutexLock	access:public	signature:(Mutex *mu)
MUTEX_NAMESPACE::ReaderMutexLock::mu_	src/base/simple_mutex.h	/^  Mutex * const mu_;$/;"	m	class:MUTEX_NAMESPACE::ReaderMutexLock	access:private
MUTEX_NAMESPACE::ReaderMutexLock::operator =	src/base/simple_mutex.h	/^  void operator=(const ReaderMutexLock&);$/;"	p	class:MUTEX_NAMESPACE::ReaderMutexLock	access:private	signature:(const ReaderMutexLock&)
MUTEX_NAMESPACE::ReaderMutexLock::~ReaderMutexLock	src/base/simple_mutex.h	/^  ~ReaderMutexLock() { mu_->ReaderUnlock(); }$/;"	f	class:MUTEX_NAMESPACE::ReaderMutexLock	access:public	signature:()
MUTEX_NAMESPACE::WriterMutexLock	src/base/simple_mutex.h	/^class WriterMutexLock {$/;"	c	namespace:MUTEX_NAMESPACE
MUTEX_NAMESPACE::WriterMutexLock::WriterMutexLock	src/base/simple_mutex.h	/^  WriterMutexLock(const WriterMutexLock&);$/;"	p	class:MUTEX_NAMESPACE::WriterMutexLock	access:private	signature:(const WriterMutexLock&)
MUTEX_NAMESPACE::WriterMutexLock::WriterMutexLock	src/base/simple_mutex.h	/^  explicit WriterMutexLock(Mutex *mu) : mu_(mu) { mu_->WriterLock(); }$/;"	f	class:MUTEX_NAMESPACE::WriterMutexLock	access:public	signature:(Mutex *mu)
MUTEX_NAMESPACE::WriterMutexLock::mu_	src/base/simple_mutex.h	/^  Mutex * const mu_;$/;"	m	class:MUTEX_NAMESPACE::WriterMutexLock	access:private
MUTEX_NAMESPACE::WriterMutexLock::operator =	src/base/simple_mutex.h	/^  void operator=(const WriterMutexLock&);$/;"	p	class:MUTEX_NAMESPACE::WriterMutexLock	access:private	signature:(const WriterMutexLock&)
MUTEX_NAMESPACE::WriterMutexLock::~WriterMutexLock	src/base/simple_mutex.h	/^  ~WriterMutexLock() { mu_->WriterUnlock(); }$/;"	f	class:MUTEX_NAMESPACE::WriterMutexLock	access:public	signature:()
Magic	src/base/low_level_alloc.cc	/^inline static intptr_t Magic(intptr_t magic, AllocList::Header *ptr) {$/;"	f	file:	signature:(intptr_t magic, AllocList::Header *ptr)
Main	src/pprof	/^sub Main() {$/;"	f	signature:()
MakeALeak	src/tests/heap-checker_unittest.cc	/^static void MakeALeak(void** arr) {$/;"	f	file:	signature:(void** arr)
MakeCacheSpace	src/central_freelist.cc	/^bool CentralFreeList::MakeCacheSpace() {$/;"	f	class:tcmalloc::CentralFreeList	signature:()
MakeDeathLoop	src/tests/heap-checker_unittest.cc	/^static void MakeDeathLoop(void** arr1, void** arr2) {$/;"	f	file:	signature:(void** arr1, void** arr2)
MakeDisabledLiveCallbackLocked	src/heap-checker.cc	/^static void MakeDisabledLiveCallbackLocked($/;"	f	file:	signature:( const void* ptr, const HeapProfileTable::AllocInfo& info)
MakeIgnoredObjectsLiveCallbackLocked	src/heap-checker.cc	/^static void MakeIgnoredObjectsLiveCallbackLocked($/;"	f	file:	signature:( const void* ptr, const HeapProfileTable::AllocInfo& info)
MakeProfileNameLocked	src/gperftools/heap-checker.h	/^  char* MakeProfileNameLocked();$/;"	p	class:HeapLeakChecker	access:private	signature:()
MakeProfileNameLocked	src/heap-checker.cc	/^char* HeapLeakChecker::MakeProfileNameLocked() {$/;"	f	class:HeapLeakChecker	signature:()
MakeSortedBucketList	src/heap-profile-table.cc	/^HeapProfileTable::MakeSortedBucketList() const {$/;"	f	class:HeapProfileTable	signature:() const
MakeSortedBucketList	src/heap-profile-table.h	/^  Bucket** MakeSortedBucketList() const;$/;"	p	class:HeapProfileTable	access:private	signature:() const
MakeTestingHook	src/windows/auto_testing_hook.h	/^  static AutoTestingHookImpl<T> MakeTestingHook(T target_function,$/;"	f	class:sidestep::AutoTestingHookImpl	access:public	signature:(T target_function, T replacement_function, bool do_it)
MakeTestingHook	src/windows/auto_testing_hook.h	/^inline AutoTestingHookImpl<T> MakeTestingHook(T target, T replacement) {$/;"	f	namespace:sidestep	signature:(T target, T replacement)
MakeTestingHook	src/windows/auto_testing_hook.h	/^inline AutoTestingHookImpl<T> MakeTestingHook(T target,$/;"	f	namespace:sidestep	signature:(T target, T replacement, bool do_it)
MakeTestingHookHolder	src/windows/auto_testing_hook.h	/^  static AutoTestingHookImpl<T>* MakeTestingHookHolder(T target_function,$/;"	f	class:sidestep::AutoTestingHookImpl	access:public	signature:(T target_function, T replacement_function, bool do_it)
MakeTestingHookHolder	src/windows/auto_testing_hook.h	/^inline AutoTestingHookImpl<T>* MakeTestingHookHolder(T target, T replacement) {$/;"	f	namespace:sidestep	signature:(T target, T replacement)
MallocBlock	src/debugallocation.cc	/^class MallocBlock {$/;"	c	file:
MallocBlock::AllocMap	src/debugallocation.cc	/^  typedef AddressMap<int> AllocMap;$/;"	t	class:MallocBlock	file:	access:private
MallocBlock::AllocName	src/debugallocation.cc	/^  static const char* AllocName(int type) {$/;"	f	class:MallocBlock	file:	access:private	signature:(int type)
MallocBlock::Allocate	src/debugallocation.cc	/^  static MallocBlock* Allocate(size_t size, int type) {$/;"	f	class:MallocBlock	access:public	signature:(size_t size, int type)
MallocBlock::Check	src/debugallocation.cc	/^  void Check(int type) const {$/;"	f	class:MallocBlock	access:public	signature:(int type) const
MallocBlock::CheckAndClear	src/debugallocation.cc	/^  size_t CheckAndClear(int type, size_t given_size) {$/;"	f	class:MallocBlock	file:	access:private	signature:(int type, size_t given_size)
MallocBlock::CheckCallback	src/debugallocation.cc	/^  static void CheckCallback(const void* ptr, int* type, int dummy) {$/;"	f	class:MallocBlock	file:	access:private	signature:(const void* ptr, int* type, int dummy)
MallocBlock::CheckEverything	src/debugallocation.cc	/^  static bool CheckEverything() {$/;"	f	class:MallocBlock	access:public	signature:()
MallocBlock::CheckForCorruptedBuffer	src/debugallocation.cc	/^  static void CheckForCorruptedBuffer(const MallocBlockQueueEntry& queue_entry,$/;"	f	class:MallocBlock	access:public	signature:(const MallocBlockQueueEntry& queue_entry, size_t buffer_idx, const unsigned char* buffer, size_t size_of_buffer)
MallocBlock::CheckForDanglingWrites	src/debugallocation.cc	/^  static void CheckForDanglingWrites(const MallocBlockQueueEntry& queue_entry) {$/;"	f	class:MallocBlock	access:public	signature:(const MallocBlockQueueEntry& queue_entry)
MallocBlock::CheckLocked	src/debugallocation.cc	/^  void CheckLocked(int type) const {$/;"	f	class:MallocBlock	file:	access:private	signature:(int type) const
MallocBlock::DeallocName	src/debugallocation.cc	/^  static const char* DeallocName(int type) {$/;"	f	class:MallocBlock	file:	access:private	signature:(int type)
MallocBlock::Deallocate	src/debugallocation.cc	/^  void Deallocate(int type, size_t given_size) {$/;"	f	class:MallocBlock	access:public	signature:(int type, size_t given_size)
MallocBlock::FreeQueueSize	src/debugallocation.cc	/^  static size_t FreeQueueSize() {$/;"	f	class:MallocBlock	access:public	signature:()
MallocBlock::FromRawPointer	src/debugallocation.cc	/^  static MallocBlock* FromRawPointer(void* p) {$/;"	f	class:MallocBlock	access:public	signature:(void* p)
MallocBlock::FromRawPointer	src/debugallocation.cc	/^  static const MallocBlock* FromRawPointer(const void* p) {$/;"	f	class:MallocBlock	access:public	signature:(const void* p)
MallocBlock::InitDeletedBuffer	src/debugallocation.cc	/^  static void InitDeletedBuffer() {$/;"	f	class:MallocBlock	access:public	signature:()
MallocBlock::Initialize	src/debugallocation.cc	/^  void Initialize(size_t size, int type) {$/;"	f	class:MallocBlock	file:	access:private	signature:(size_t size, int type)
MallocBlock::IsMMapped	src/debugallocation.cc	/^  bool IsMMapped() const { return kMagicMMap == magic1_; }$/;"	f	class:MallocBlock	file:	access:private	signature:() const
MallocBlock::IsValidMagicValue	src/debugallocation.cc	/^  bool IsValidMagicValue(size_t value) const {$/;"	f	class:MallocBlock	file:	access:private	signature:(size_t value) const
MallocBlock::MemoryStats	src/debugallocation.cc	/^  static bool MemoryStats(int* blocks, size_t* total,$/;"	f	class:MallocBlock	access:public	signature:(int* blocks, size_t* total, int histogram[kMallocHistogramSize])
MallocBlock::ProcessFreeQueue	src/debugallocation.cc	/^  static void ProcessFreeQueue(MallocBlock* b, size_t size,$/;"	f	class:MallocBlock	access:public	signature:(MallocBlock* b, size_t size, int max_free_queue_size)
MallocBlock::StatsCallback	src/debugallocation.cc	/^  static void StatsCallback(const void* ptr, int* type, int dummy) {$/;"	f	class:MallocBlock	file:	access:private	signature:(const void* ptr, int* type, int dummy)
MallocBlock::alloc_map_	src/debugallocation.cc	/^  static AllocMap* alloc_map_;$/;"	m	class:MallocBlock	file:	access:private
MallocBlock::alloc_map_	src/debugallocation.cc	/^MallocBlock::AllocMap* MallocBlock::alloc_map_ = NULL;$/;"	m	class:MallocBlock	file:
MallocBlock::alloc_map_lock_	src/debugallocation.cc	/^  static SpinLock alloc_map_lock_;$/;"	m	class:MallocBlock	file:	access:private
MallocBlock::alloc_map_lock_	src/debugallocation.cc	/^SpinLock MallocBlock::alloc_map_lock_(SpinLock::LINKER_INITIALIZED);$/;"	p	class:MallocBlock	file:	signature:(SpinLock::LINKER_INITIALIZED)
MallocBlock::alloc_type_	src/debugallocation.cc	/^  size_t alloc_type_;$/;"	m	class:MallocBlock	file:	access:private
MallocBlock::data_addr	src/debugallocation.cc	/^  const void* data_addr() const { return (const void*)&size2_; }$/;"	f	class:MallocBlock	access:public	signature:() const
MallocBlock::data_addr	src/debugallocation.cc	/^  void* data_addr() { return (void*)&size2_; }$/;"	f	class:MallocBlock	access:public	signature:()
MallocBlock::data_offset	src/debugallocation.cc	/^  static size_t data_offset() { return OFFSETOF_MEMBER(MallocBlock, size2_); }$/;"	f	class:MallocBlock	access:public	signature:()
MallocBlock::data_size	src/debugallocation.cc	/^  size_t data_size() const { return size1_; }$/;"	f	class:MallocBlock	access:public	signature:() const
MallocBlock::deleted_buffer_initialized_	src/debugallocation.cc	/^  static pthread_once_t deleted_buffer_initialized_;$/;"	m	class:MallocBlock	file:	access:private
MallocBlock::deleted_buffer_initialized_	src/debugallocation.cc	/^pthread_once_t MallocBlock::deleted_buffer_initialized_ = PTHREAD_ONCE_INIT;$/;"	m	class:MallocBlock	file:
MallocBlock::deleted_buffer_initialized_no_pthreads_	src/debugallocation.cc	/^  static bool deleted_buffer_initialized_no_pthreads_;$/;"	m	class:MallocBlock	file:	access:private
MallocBlock::deleted_buffer_initialized_no_pthreads_	src/debugallocation.cc	/^bool MallocBlock::deleted_buffer_initialized_no_pthreads_ = false;$/;"	m	class:MallocBlock	file:
MallocBlock::free_queue_	src/debugallocation.cc	/^  static FreeQueue<MallocBlockQueueEntry>* free_queue_;$/;"	m	class:MallocBlock	file:	access:private
MallocBlock::free_queue_	src/debugallocation.cc	/^FreeQueue<MallocBlockQueueEntry>* MallocBlock::free_queue_ = NULL;$/;"	m	class:MallocBlock	file:
MallocBlock::free_queue_lock_	src/debugallocation.cc	/^  static SpinLock free_queue_lock_;$/;"	m	class:MallocBlock	file:	access:private
MallocBlock::free_queue_lock_	src/debugallocation.cc	/^SpinLock MallocBlock::free_queue_lock_(SpinLock::LINKER_INITIALIZED);$/;"	p	class:MallocBlock	file:	signature:(SpinLock::LINKER_INITIALIZED)
MallocBlock::free_queue_size_	src/debugallocation.cc	/^  static size_t free_queue_size_;  \/\/ total size of blocks in free_queue_$/;"	m	class:MallocBlock	file:	access:private
MallocBlock::free_queue_size_	src/debugallocation.cc	/^size_t MallocBlock::free_queue_size_ = 0;$/;"	m	class:MallocBlock	file:
MallocBlock::kAllocName	src/debugallocation.cc	/^  static const char* const kAllocName[];$/;"	m	class:MallocBlock	file:	access:private
MallocBlock::kAllocName	src/debugallocation.cc	/^const char* const MallocBlock::kAllocName[] = {$/;"	m	class:MallocBlock	file:
MallocBlock::kAllocTypeMask	src/debugallocation.cc	/^  static const int kAllocTypeMask = 0x3;$/;"	m	class:MallocBlock	file:	access:private
MallocBlock::kArrayNewType	src/debugallocation.cc	/^  static const int kArrayNewType = 0xBCEADF72;$/;"	m	class:MallocBlock	file:	access:public
MallocBlock::kDeallocName	src/debugallocation.cc	/^  static const char* const kDeallocName[];$/;"	m	class:MallocBlock	file:	access:private
MallocBlock::kDeallocName	src/debugallocation.cc	/^const char* const MallocBlock::kDeallocName[] = {$/;"	m	class:MallocBlock	file:
MallocBlock::kDeallocatedTypeBit	src/debugallocation.cc	/^  static const int kDeallocatedTypeBit = 0x4;$/;"	m	class:MallocBlock	file:	access:private
MallocBlock::kMagicDeletedBuffer	src/debugallocation.cc	/^  static unsigned char kMagicDeletedBuffer[1024];$/;"	m	class:MallocBlock	file:	access:private
MallocBlock::kMagicDeletedBuffer	src/debugallocation.cc	/^unsigned char MallocBlock::kMagicDeletedBuffer[1024];$/;"	m	class:MallocBlock	file:
MallocBlock::kMagicDeletedByte	src/debugallocation.cc	/^  static const int kMagicDeletedByte = 0xCD;$/;"	m	class:MallocBlock	file:	access:private
MallocBlock::kMagicDeletedSizeT	src/debugallocation.cc	/^  static const size_t kMagicDeletedSizeT =$/;"	m	class:MallocBlock	file:	access:private
MallocBlock::kMagicMMap	src/debugallocation.cc	/^  static const size_t kMagicMMap = 0xABCDEFAB;$/;"	m	class:MallocBlock	file:	access:private
MallocBlock::kMagicMMap	src/debugallocation.cc	/^const size_t MallocBlock::kMagicMMap;$/;"	m	class:MallocBlock	file:
MallocBlock::kMagicMalloc	src/debugallocation.cc	/^  static const size_t kMagicMalloc = 0xDEADBEEF;$/;"	m	class:MallocBlock	file:	access:private
MallocBlock::kMagicMalloc	src/debugallocation.cc	/^const size_t MallocBlock::kMagicMalloc;$/;"	m	class:MallocBlock	file:
MallocBlock::kMagicUninitializedByte	src/debugallocation.cc	/^  static const int kMagicUninitializedByte = 0xAB;$/;"	m	class:MallocBlock	file:	access:private
MallocBlock::kMallocType	src/debugallocation.cc	/^  static const int kMallocType = 0xEFCDAB90;$/;"	m	class:MallocBlock	file:	access:public
MallocBlock::kNewType	src/debugallocation.cc	/^  static const int kNewType = 0xFEBADC81;$/;"	m	class:MallocBlock	file:	access:public
MallocBlock::magic1_	src/debugallocation.cc	/^  size_t magic1_;$/;"	m	class:MallocBlock	file:	access:private
MallocBlock::magic2_	src/debugallocation.cc	/^  size_t magic2_;$/;"	m	class:MallocBlock	file:	access:private
MallocBlock::magic2_addr	src/debugallocation.cc	/^  const size_t* magic2_addr() const { return (const size_t*)(size2_addr() + 1); }$/;"	f	class:MallocBlock	file:	access:private	signature:() const
MallocBlock::magic2_addr	src/debugallocation.cc	/^  size_t* magic2_addr() { return (size_t*)(size2_addr() + 1); }$/;"	f	class:MallocBlock	file:	access:private	signature:()
MallocBlock::offset_	src/debugallocation.cc	/^  size_t offset_;   \/\/ normally 0 unless memaligned memory$/;"	m	class:MallocBlock	file:	access:private
MallocBlock::real_malloced_size	src/debugallocation.cc	/^  static size_t real_malloced_size(size_t size) {$/;"	f	class:MallocBlock	file:	access:private	signature:(size_t size)
MallocBlock::real_mmapped_size	src/debugallocation.cc	/^  static size_t real_mmapped_size(size_t size) {$/;"	f	class:MallocBlock	file:	access:private	signature:(size_t size)
MallocBlock::real_size	src/debugallocation.cc	/^  size_t real_size() {$/;"	f	class:MallocBlock	file:	access:private	signature:()
MallocBlock::set_offset	src/debugallocation.cc	/^  void set_offset(int offset) { this->offset_ = offset; }$/;"	f	class:MallocBlock	access:public	signature:(int offset)
MallocBlock::size1_	src/debugallocation.cc	/^  size_t size1_;$/;"	m	class:MallocBlock	file:	access:private
MallocBlock::size2_	src/debugallocation.cc	/^  size_t size2_;$/;"	m	class:MallocBlock	file:	access:private
MallocBlock::size2_addr	src/debugallocation.cc	/^  const size_t* size2_addr() const {$/;"	f	class:MallocBlock	file:	access:private	signature:() const
MallocBlock::size2_addr	src/debugallocation.cc	/^  size_t* size2_addr() { return (size_t*)((char*)&size2_ + size1_); }$/;"	f	class:MallocBlock	file:	access:private	signature:()
MallocBlock::stats_blocks_	src/debugallocation.cc	/^  static int stats_blocks_;$/;"	m	class:MallocBlock	file:	access:private
MallocBlock::stats_blocks_	src/debugallocation.cc	/^int MallocBlock::stats_blocks_;$/;"	m	class:MallocBlock	file:
MallocBlock::stats_histogram_	src/debugallocation.cc	/^  static int* stats_histogram_;$/;"	m	class:MallocBlock	file:	access:private
MallocBlock::stats_histogram_	src/debugallocation.cc	/^int* MallocBlock::stats_histogram_;$/;"	m	class:MallocBlock	file:
MallocBlock::stats_total_	src/debugallocation.cc	/^  static size_t stats_total_;$/;"	m	class:MallocBlock	file:	access:private
MallocBlock::stats_total_	src/debugallocation.cc	/^size_t MallocBlock::stats_total_;$/;"	m	class:MallocBlock	file:
MallocBlockQueueEntry	src/debugallocation.cc	/^  MallocBlockQueueEntry() : block(NULL), size(0),$/;"	f	struct:MallocBlockQueueEntry	access:public	signature:()
MallocBlockQueueEntry	src/debugallocation.cc	/^  MallocBlockQueueEntry(MallocBlock* b, size_t s) : block(b), size(s) {$/;"	f	struct:MallocBlockQueueEntry	access:public	signature:(MallocBlock* b, size_t s)
MallocBlockQueueEntry	src/debugallocation.cc	/^struct MallocBlockQueueEntry {$/;"	s	file:
MallocBlockQueueEntry::MallocBlockQueueEntry	src/debugallocation.cc	/^  MallocBlockQueueEntry() : block(NULL), size(0),$/;"	f	struct:MallocBlockQueueEntry	access:public	signature:()
MallocBlockQueueEntry::MallocBlockQueueEntry	src/debugallocation.cc	/^  MallocBlockQueueEntry(MallocBlock* b, size_t s) : block(b), size(s) {$/;"	f	struct:MallocBlockQueueEntry	access:public	signature:(MallocBlock* b, size_t s)
MallocBlockQueueEntry::block	src/debugallocation.cc	/^  MallocBlock* block;$/;"	m	struct:MallocBlockQueueEntry	file:	access:public
MallocBlockQueueEntry::deleter_pcs	src/debugallocation.cc	/^  void* deleter_pcs[16];$/;"	m	struct:MallocBlockQueueEntry	file:	access:public
MallocBlockQueueEntry::deleter_threadid	src/debugallocation.cc	/^  pthread_t deleter_threadid;$/;"	m	struct:MallocBlockQueueEntry	file:	access:public
MallocBlockQueueEntry::num_deleter_pcs	src/debugallocation.cc	/^  int num_deleter_pcs;$/;"	m	struct:MallocBlockQueueEntry	file:	access:public
MallocBlockQueueEntry::size	src/debugallocation.cc	/^  size_t size;$/;"	m	struct:MallocBlockQueueEntry	file:	access:public
MallocExtension	src/gperftools/malloc_extension.h	/^class PERFTOOLS_DLL_DECL MallocExtension {$/;"	c
MallocExtension::FreeListInfo	src/gperftools/malloc_extension.h	/^  struct FreeListInfo {$/;"	s	class:MallocExtension	access:public
MallocExtension::FreeListInfo::max_object_size	src/gperftools/malloc_extension.h	/^    size_t max_object_size;$/;"	m	struct:MallocExtension::FreeListInfo	access:public
MallocExtension::FreeListInfo::min_object_size	src/gperftools/malloc_extension.h	/^    size_t min_object_size;$/;"	m	struct:MallocExtension::FreeListInfo	access:public
MallocExtension::FreeListInfo::total_bytes_free	src/gperftools/malloc_extension.h	/^    size_t total_bytes_free;$/;"	m	struct:MallocExtension::FreeListInfo	access:public
MallocExtension::FreeListInfo::type	src/gperftools/malloc_extension.h	/^    const char* type;$/;"	m	struct:MallocExtension::FreeListInfo	access:public
MallocExtension::GetAllocatedSize	src/gperftools/malloc_extension.h	/^  virtual size_t GetAllocatedSize(const void* p);$/;"	p	class:MallocExtension	access:public	signature:(const void* p)
MallocExtension::GetAllocatedSize	src/malloc_extension.cc	/^size_t MallocExtension::GetAllocatedSize(const void* p) {$/;"	f	class:MallocExtension	signature:(const void* p)
MallocExtension::GetEstimatedAllocatedSize	src/gperftools/malloc_extension.h	/^  virtual size_t GetEstimatedAllocatedSize(size_t size);$/;"	p	class:MallocExtension	access:public	signature:(size_t size)
MallocExtension::GetEstimatedAllocatedSize	src/malloc_extension.cc	/^size_t MallocExtension::GetEstimatedAllocatedSize(size_t size) {$/;"	f	class:MallocExtension	signature:(size_t size)
MallocExtension::GetFreeListSizes	src/gperftools/malloc_extension.h	/^  virtual void GetFreeListSizes(std::vector<FreeListInfo>* v);$/;"	p	class:MallocExtension	access:public	signature:(std::vector<FreeListInfo>* v)
MallocExtension::GetFreeListSizes	src/malloc_extension.cc	/^void MallocExtension::GetFreeListSizes($/;"	f	class:MallocExtension	signature:( vector<MallocExtension::FreeListInfo>* v)
MallocExtension::GetHeapGrowthStacks	src/gperftools/malloc_extension.h	/^  virtual void GetHeapGrowthStacks(MallocExtensionWriter* writer);$/;"	p	class:MallocExtension	access:public	signature:(MallocExtensionWriter* writer)
MallocExtension::GetHeapGrowthStacks	src/malloc_extension.cc	/^void MallocExtension::GetHeapGrowthStacks(MallocExtensionWriter* writer) {$/;"	f	class:MallocExtension	signature:(MallocExtensionWriter* writer)
MallocExtension::GetHeapSample	src/gperftools/malloc_extension.h	/^  virtual void GetHeapSample(MallocExtensionWriter* writer);$/;"	p	class:MallocExtension	access:public	signature:(MallocExtensionWriter* writer)
MallocExtension::GetHeapSample	src/malloc_extension.cc	/^void MallocExtension::GetHeapSample(MallocExtensionWriter* writer) {$/;"	f	class:MallocExtension	signature:(MallocExtensionWriter* writer)
MallocExtension::GetMemoryReleaseRate	src/gperftools/malloc_extension.h	/^  virtual double GetMemoryReleaseRate();$/;"	p	class:MallocExtension	access:public	signature:()
MallocExtension::GetMemoryReleaseRate	src/malloc_extension.cc	/^double MallocExtension::GetMemoryReleaseRate() {$/;"	f	class:MallocExtension	signature:()
MallocExtension::GetNumericProperty	src/gperftools/malloc_extension.h	/^  virtual bool GetNumericProperty(const char* property, size_t* value);$/;"	p	class:MallocExtension	access:public	signature:(const char* property, size_t* value)
MallocExtension::GetNumericProperty	src/malloc_extension.cc	/^bool MallocExtension::GetNumericProperty(const char* property, size_t* value) {$/;"	f	class:MallocExtension	signature:(const char* property, size_t* value)
MallocExtension::GetOwnership	src/gperftools/malloc_extension.h	/^  virtual Ownership GetOwnership(const void* p);$/;"	p	class:MallocExtension	access:public	signature:(const void* p)
MallocExtension::GetOwnership	src/malloc_extension.cc	/^MallocExtension::Ownership MallocExtension::GetOwnership(const void* p) {$/;"	f	class:MallocExtension	signature:(const void* p)
MallocExtension::GetStats	src/gperftools/malloc_extension.h	/^  virtual void GetStats(char* buffer, int buffer_length);$/;"	p	class:MallocExtension	access:public	signature:(char* buffer, int buffer_length)
MallocExtension::GetStats	src/malloc_extension.cc	/^void MallocExtension::GetStats(char* buffer, int length) {$/;"	f	class:MallocExtension	signature:(char* buffer, int length)
MallocExtension::GetSystemAllocator	src/gperftools/malloc_extension.h	/^  virtual SysAllocator* GetSystemAllocator();$/;"	p	class:MallocExtension	access:public	signature:()
MallocExtension::GetSystemAllocator	src/malloc_extension.cc	/^SysAllocator* MallocExtension::GetSystemAllocator() {$/;"	f	class:MallocExtension	signature:()
MallocExtension::GetThreadCacheSize	src/gperftools/malloc_extension.h	/^  virtual size_t GetThreadCacheSize();$/;"	p	class:MallocExtension	access:public	signature:()
MallocExtension::GetThreadCacheSize	src/malloc_extension.cc	/^size_t MallocExtension::GetThreadCacheSize() {$/;"	f	class:MallocExtension	signature:()
MallocExtension::Initialize	src/gperftools/malloc_extension.h	/^  static void Initialize();$/;"	p	class:MallocExtension	access:public	signature:()
MallocExtension::Initialize	src/malloc_extension.cc	/^void MallocExtension::Initialize() {$/;"	f	class:MallocExtension	signature:()
MallocExtension::MallocMemoryStats	src/gperftools/malloc_extension.h	/^  virtual bool MallocMemoryStats(int* blocks, size_t* total,$/;"	p	class:MallocExtension	access:public	signature:(int* blocks, size_t* total, int histogram[kMallocHistogramSize])
MallocExtension::MallocMemoryStats	src/malloc_extension.cc	/^bool MallocExtension::MallocMemoryStats(int* blocks, size_t* total,$/;"	f	class:MallocExtension	signature:(int* blocks, size_t* total, int histogram[kMallocHistogramSize])
MallocExtension::MarkThreadBusy	src/gperftools/malloc_extension.h	/^  virtual void MarkThreadBusy();$/;"	p	class:MallocExtension	access:public	signature:()
MallocExtension::MarkThreadBusy	src/malloc_extension.cc	/^void MallocExtension::MarkThreadBusy() {$/;"	f	class:MallocExtension	signature:()
MallocExtension::MarkThreadIdle	src/gperftools/malloc_extension.h	/^  virtual void MarkThreadIdle();$/;"	p	class:MallocExtension	access:public	signature:()
MallocExtension::MarkThreadIdle	src/malloc_extension.cc	/^void MallocExtension::MarkThreadIdle() {$/;"	f	class:MallocExtension	signature:()
MallocExtension::MarkThreadTemporarilyIdle	src/gperftools/malloc_extension.h	/^  virtual void MarkThreadTemporarilyIdle();$/;"	p	class:MallocExtension	access:public	signature:()
MallocExtension::MarkThreadTemporarilyIdle	src/malloc_extension.cc	/^void MallocExtension::MarkThreadTemporarilyIdle() {$/;"	f	class:MallocExtension	signature:()
MallocExtension::Ownership	src/gperftools/malloc_extension.h	/^  enum Ownership {$/;"	g	class:MallocExtension	access:public
MallocExtension::RangeFunction	src/gperftools/malloc_extension.h	/^  typedef void (RangeFunction)(void*, const base::MallocRange*);$/;"	t	class:MallocExtension	access:public
MallocExtension::Ranges	src/gperftools/malloc_extension.h	/^  virtual void Ranges(void* arg, RangeFunction func);$/;"	p	class:MallocExtension	access:public	signature:(void* arg, RangeFunction func)
MallocExtension::Ranges	src/malloc_extension.cc	/^void MallocExtension::Ranges(void* arg, RangeFunction func) {$/;"	f	class:MallocExtension	signature:(void* arg, RangeFunction func)
MallocExtension::ReadHeapGrowthStackTraces	src/gperftools/malloc_extension.h	/^  virtual void** ReadHeapGrowthStackTraces();$/;"	p	class:MallocExtension	access:public	signature:()
MallocExtension::ReadHeapGrowthStackTraces	src/malloc_extension.cc	/^void** MallocExtension::ReadHeapGrowthStackTraces() {$/;"	f	class:MallocExtension	signature:()
MallocExtension::ReadStackTraces	src/gperftools/malloc_extension.h	/^  virtual void** ReadStackTraces(int* sample_period);$/;"	p	class:MallocExtension	access:public	signature:(int* sample_period)
MallocExtension::ReadStackTraces	src/malloc_extension.cc	/^void** MallocExtension::ReadStackTraces(int* sample_period) {$/;"	f	class:MallocExtension	signature:(int* sample_period)
MallocExtension::Register	src/gperftools/malloc_extension.h	/^  static void Register(MallocExtension* implementation);$/;"	p	class:MallocExtension	access:public	signature:(MallocExtension* implementation)
MallocExtension::Register	src/malloc_extension.cc	/^void MallocExtension::Register(MallocExtension* implementation) {$/;"	f	class:MallocExtension	signature:(MallocExtension* implementation)
MallocExtension::ReleaseFreeMemory	src/gperftools/malloc_extension.h	/^  virtual void ReleaseFreeMemory();$/;"	p	class:MallocExtension	access:public	signature:()
MallocExtension::ReleaseFreeMemory	src/malloc_extension.cc	/^void MallocExtension::ReleaseFreeMemory() {$/;"	f	class:MallocExtension	signature:()
MallocExtension::ReleaseToSystem	src/gperftools/malloc_extension.h	/^  virtual void ReleaseToSystem(size_t num_bytes);$/;"	p	class:MallocExtension	access:public	signature:(size_t num_bytes)
MallocExtension::ReleaseToSystem	src/malloc_extension.cc	/^void MallocExtension::ReleaseToSystem(size_t num_bytes) {$/;"	f	class:MallocExtension	signature:(size_t num_bytes)
MallocExtension::SetMemoryReleaseRate	src/gperftools/malloc_extension.h	/^  virtual void SetMemoryReleaseRate(double rate);$/;"	p	class:MallocExtension	access:public	signature:(double rate)
MallocExtension::SetMemoryReleaseRate	src/malloc_extension.cc	/^void MallocExtension::SetMemoryReleaseRate(double rate) {$/;"	f	class:MallocExtension	signature:(double rate)
MallocExtension::SetNumericProperty	src/gperftools/malloc_extension.h	/^  virtual bool SetNumericProperty(const char* property, size_t value);$/;"	p	class:MallocExtension	access:public	signature:(const char* property, size_t value)
MallocExtension::SetNumericProperty	src/malloc_extension.cc	/^bool MallocExtension::SetNumericProperty(const char* property, size_t value) {$/;"	f	class:MallocExtension	signature:(const char* property, size_t value)
MallocExtension::SetSystemAllocator	src/gperftools/malloc_extension.h	/^  virtual void SetSystemAllocator(SysAllocator *a);$/;"	p	class:MallocExtension	access:public	signature:(SysAllocator *a)
MallocExtension::SetSystemAllocator	src/malloc_extension.cc	/^void MallocExtension::SetSystemAllocator(SysAllocator *a) {$/;"	f	class:MallocExtension	signature:(SysAllocator *a)
MallocExtension::VerifyAllMemory	src/gperftools/malloc_extension.h	/^  virtual bool VerifyAllMemory();$/;"	p	class:MallocExtension	access:public	signature:()
MallocExtension::VerifyAllMemory	src/malloc_extension.cc	/^bool MallocExtension::VerifyAllMemory() { return true; }$/;"	f	class:MallocExtension	signature:()
MallocExtension::VerifyArrayNewMemory	src/gperftools/malloc_extension.h	/^  virtual bool VerifyArrayNewMemory(const void* p);$/;"	p	class:MallocExtension	access:public	signature:(const void* p)
MallocExtension::VerifyArrayNewMemory	src/malloc_extension.cc	/^bool MallocExtension::VerifyArrayNewMemory(const void* p) { return true; }$/;"	f	class:MallocExtension	signature:(const void* p)
MallocExtension::VerifyMallocMemory	src/gperftools/malloc_extension.h	/^  virtual bool VerifyMallocMemory(const void* p);$/;"	p	class:MallocExtension	access:public	signature:(const void* p)
MallocExtension::VerifyMallocMemory	src/malloc_extension.cc	/^bool MallocExtension::VerifyMallocMemory(const void* p) { return true; }$/;"	f	class:MallocExtension	signature:(const void* p)
MallocExtension::VerifyNewMemory	src/gperftools/malloc_extension.h	/^  virtual bool VerifyNewMemory(const void* p);$/;"	p	class:MallocExtension	access:public	signature:(const void* p)
MallocExtension::VerifyNewMemory	src/malloc_extension.cc	/^bool MallocExtension::VerifyNewMemory(const void* p) { return true; }$/;"	f	class:MallocExtension	signature:(const void* p)
MallocExtension::instance	src/gperftools/malloc_extension.h	/^  static MallocExtension* instance();$/;"	p	class:MallocExtension	access:public	signature:()
MallocExtension::instance	src/malloc_extension.cc	/^MallocExtension* MallocExtension::instance() {$/;"	f	class:MallocExtension	signature:()
MallocExtension::kNotOwned	src/gperftools/malloc_extension.h	/^    kNotOwned$/;"	e	enum:MallocExtension::Ownership
MallocExtension::kOwned	src/gperftools/malloc_extension.h	/^    kOwned,$/;"	e	enum:MallocExtension::Ownership
MallocExtension::kUnknownOwnership	src/gperftools/malloc_extension.h	/^    kUnknownOwnership = 0,$/;"	e	enum:MallocExtension::Ownership
MallocExtension::~MallocExtension	src/gperftools/malloc_extension.h	/^  virtual ~MallocExtension();$/;"	p	class:MallocExtension	access:public	signature:()
MallocExtension::~MallocExtension	src/malloc_extension.cc	/^MallocExtension::~MallocExtension() { }$/;"	f	class:MallocExtension	signature:()
MallocExtensionWriter	src/gperftools/malloc_extension.h	/^typedef std::string MallocExtensionWriter;$/;"	t
MallocExtension_GetAllocatedSize	src/gperftools/malloc_extension_c.h	/^PERFTOOLS_DLL_DECL size_t MallocExtension_GetAllocatedSize(const void* p);$/;"	p	signature:(const void* p)
MallocExtension_GetEstimatedAllocatedSize	src/gperftools/malloc_extension_c.h	/^PERFTOOLS_DLL_DECL size_t MallocExtension_GetEstimatedAllocatedSize(size_t size);$/;"	p	signature:(size_t size)
MallocExtension_GetNumericProperty	src/gperftools/malloc_extension_c.h	/^PERFTOOLS_DLL_DECL int MallocExtension_GetNumericProperty(const char* property, size_t* value);$/;"	p	signature:(const char* property, size_t* value)
MallocExtension_GetOwnership	src/gperftools/malloc_extension_c.h	/^PERFTOOLS_DLL_DECL MallocExtension_Ownership MallocExtension_GetOwnership(const void* p);$/;"	p	signature:(const void* p)
MallocExtension_GetOwnership	src/malloc_extension.cc	/^MallocExtension_Ownership MallocExtension_GetOwnership(const void* p) {$/;"	f	signature:(const void* p)
MallocExtension_GetStats	src/gperftools/malloc_extension_c.h	/^PERFTOOLS_DLL_DECL void MallocExtension_GetStats(char* buffer, int buffer_length);$/;"	p	signature:(char* buffer, int buffer_length)
MallocExtension_GetThreadCacheSize	src/gperftools/malloc_extension_c.h	/^PERFTOOLS_DLL_DECL size_t MallocExtension_GetThreadCacheSize(void);$/;"	p	signature:(void)
MallocExtension_MallocMemoryStats	src/gperftools/malloc_extension_c.h	/^PERFTOOLS_DLL_DECL int MallocExtension_MallocMemoryStats(int* blocks, size_t* total,$/;"	p	signature:(int* blocks, size_t* total, int histogram[kMallocExtensionHistogramSize])
MallocExtension_MarkThreadBusy	src/gperftools/malloc_extension_c.h	/^PERFTOOLS_DLL_DECL void MallocExtension_MarkThreadBusy(void);$/;"	p	signature:(void)
MallocExtension_MarkThreadIdle	src/gperftools/malloc_extension_c.h	/^PERFTOOLS_DLL_DECL void MallocExtension_MarkThreadIdle(void);$/;"	p	signature:(void)
MallocExtension_MarkThreadTemporarilyIdle	src/gperftools/malloc_extension_c.h	/^PERFTOOLS_DLL_DECL void MallocExtension_MarkThreadTemporarilyIdle(void);$/;"	p	signature:(void)
MallocExtension_Ownership	src/gperftools/malloc_extension_c.h	/^} MallocExtension_Ownership;$/;"	t	typeref:enum:__anon18
MallocExtension_ReleaseFreeMemory	src/gperftools/malloc_extension_c.h	/^PERFTOOLS_DLL_DECL void MallocExtension_ReleaseFreeMemory(void);$/;"	p	signature:(void)
MallocExtension_ReleaseToSystem	src/gperftools/malloc_extension_c.h	/^PERFTOOLS_DLL_DECL void MallocExtension_ReleaseToSystem(size_t num_bytes);$/;"	p	signature:(size_t num_bytes)
MallocExtension_SetNumericProperty	src/gperftools/malloc_extension_c.h	/^PERFTOOLS_DLL_DECL int MallocExtension_SetNumericProperty(const char* property, size_t value);$/;"	p	signature:(const char* property, size_t value)
MallocExtension_VerifyAllMemory	src/gperftools/malloc_extension_c.h	/^PERFTOOLS_DLL_DECL int MallocExtension_VerifyAllMemory(void);$/;"	p	signature:(void)
MallocExtension_VerifyArrayNewMemory	src/gperftools/malloc_extension_c.h	/^PERFTOOLS_DLL_DECL int MallocExtension_VerifyArrayNewMemory(const void* p);$/;"	p	signature:(const void* p)
MallocExtension_VerifyMallocMemory	src/gperftools/malloc_extension_c.h	/^PERFTOOLS_DLL_DECL int MallocExtension_VerifyMallocMemory(const void* p);$/;"	p	signature:(const void* p)
MallocExtension_VerifyNewMemory	src/gperftools/malloc_extension_c.h	/^PERFTOOLS_DLL_DECL int MallocExtension_VerifyNewMemory(const void* p);$/;"	p	signature:(const void* p)
MallocExtension_kNotOwned	src/gperftools/malloc_extension_c.h	/^  MallocExtension_kNotOwned$/;"	e	enum:__anon18
MallocExtension_kOwned	src/gperftools/malloc_extension_c.h	/^  MallocExtension_kOwned,$/;"	e	enum:__anon18
MallocExtension_kUnknownOwnership	src/gperftools/malloc_extension_c.h	/^  MallocExtension_kUnknownOwnership = 0,$/;"	e	enum:__anon18
MallocHook	src/gperftools/malloc_hook.h	/^class PERFTOOLS_DLL_DECL MallocHook {$/;"	c
MallocHook::AddDeleteHook	src/gperftools/malloc_hook.h	/^  inline static bool AddDeleteHook(DeleteHook hook) {$/;"	f	class:MallocHook	access:public	signature:(DeleteHook hook)
MallocHook::AddMmapHook	src/gperftools/malloc_hook.h	/^  inline static bool AddMmapHook(MmapHook hook) {$/;"	f	class:MallocHook	access:public	signature:(MmapHook hook)
MallocHook::AddMremapHook	src/gperftools/malloc_hook.h	/^  inline static bool AddMremapHook(MremapHook hook) {$/;"	f	class:MallocHook	access:public	signature:(MremapHook hook)
MallocHook::AddMunmapHook	src/gperftools/malloc_hook.h	/^  inline static bool AddMunmapHook(MunmapHook hook) {$/;"	f	class:MallocHook	access:public	signature:(MunmapHook hook)
MallocHook::AddNewHook	src/gperftools/malloc_hook.h	/^  inline static bool AddNewHook(NewHook hook) {$/;"	f	class:MallocHook	access:public	signature:(NewHook hook)
MallocHook::AddPreMmapHook	src/gperftools/malloc_hook.h	/^  inline static bool AddPreMmapHook(PreMmapHook hook) {$/;"	f	class:MallocHook	access:public	signature:(PreMmapHook hook)
MallocHook::AddPreSbrkHook	src/gperftools/malloc_hook.h	/^  inline static bool AddPreSbrkHook(PreSbrkHook hook) {$/;"	f	class:MallocHook	access:public	signature:(PreSbrkHook hook)
MallocHook::AddSbrkHook	src/gperftools/malloc_hook.h	/^  inline static bool AddSbrkHook(SbrkHook hook) {$/;"	f	class:MallocHook	access:public	signature:(SbrkHook hook)
MallocHook::DeleteHook	src/gperftools/malloc_hook.h	/^  typedef MallocHook_DeleteHook DeleteHook;$/;"	t	class:MallocHook	access:public
MallocHook::GetCallerStackTrace	src/gperftools/malloc_hook.h	/^  inline static int GetCallerStackTrace(void** result, int max_depth,$/;"	f	class:MallocHook	access:public	signature:(void** result, int max_depth, int skip_count)
MallocHook::GetDeleteHook	src/gperftools/malloc_hook.h	/^  inline static DeleteHook GetDeleteHook();$/;"	p	class:MallocHook	access:public	signature:()
MallocHook::GetDeleteHook	src/malloc_hook-inl.h	/^inline MallocHook::DeleteHook MallocHook::GetDeleteHook() {$/;"	f	class:MallocHook	signature:()
MallocHook::GetMmapHook	src/gperftools/malloc_hook.h	/^  inline static MmapHook GetMmapHook();$/;"	p	class:MallocHook	access:public	signature:()
MallocHook::GetMmapHook	src/malloc_hook-inl.h	/^inline MallocHook::MmapHook MallocHook::GetMmapHook() {$/;"	f	class:MallocHook	signature:()
MallocHook::GetMremapHook	src/gperftools/malloc_hook.h	/^  inline static MremapHook GetMremapHook();$/;"	p	class:MallocHook	access:public	signature:()
MallocHook::GetMremapHook	src/malloc_hook-inl.h	/^inline MallocHook::MremapHook MallocHook::GetMremapHook() {$/;"	f	class:MallocHook	signature:()
MallocHook::GetMunmapHook	src/gperftools/malloc_hook.h	/^  inline static MunmapHook GetMunmapHook();$/;"	p	class:MallocHook	access:public	signature:()
MallocHook::GetMunmapHook	src/malloc_hook-inl.h	/^inline MallocHook::MunmapHook MallocHook::GetMunmapHook() {$/;"	f	class:MallocHook	signature:()
MallocHook::GetNewHook	src/gperftools/malloc_hook.h	/^  inline static NewHook GetNewHook();$/;"	p	class:MallocHook	access:public	signature:()
MallocHook::GetNewHook	src/malloc_hook-inl.h	/^inline MallocHook::NewHook MallocHook::GetNewHook() {$/;"	f	class:MallocHook	signature:()
MallocHook::GetPreMmapHook	src/gperftools/malloc_hook.h	/^  inline static PreMmapHook GetPreMmapHook();$/;"	p	class:MallocHook	access:public	signature:()
MallocHook::GetPreMmapHook	src/malloc_hook-inl.h	/^inline MallocHook::PreMmapHook MallocHook::GetPreMmapHook() {$/;"	f	class:MallocHook	signature:()
MallocHook::GetPreSbrkHook	src/gperftools/malloc_hook.h	/^  inline static PreSbrkHook GetPreSbrkHook();$/;"	p	class:MallocHook	access:public	signature:()
MallocHook::GetPreSbrkHook	src/malloc_hook-inl.h	/^inline MallocHook::PreSbrkHook MallocHook::GetPreSbrkHook() {$/;"	f	class:MallocHook	signature:()
MallocHook::GetSbrkHook	src/gperftools/malloc_hook.h	/^  inline static SbrkHook GetSbrkHook();$/;"	p	class:MallocHook	access:public	signature:()
MallocHook::GetSbrkHook	src/malloc_hook-inl.h	/^inline MallocHook::SbrkHook MallocHook::GetSbrkHook() {$/;"	f	class:MallocHook	signature:()
MallocHook::InvokeDeleteHook	src/gperftools/malloc_hook.h	/^  inline static void InvokeDeleteHook(const void* p);$/;"	p	class:MallocHook	access:public	signature:(const void* p)
MallocHook::InvokeDeleteHook	src/malloc_hook-inl.h	/^inline void MallocHook::InvokeDeleteHook(const void* p) {$/;"	f	class:MallocHook	signature:(const void* p)
MallocHook::InvokeDeleteHookSlow	src/gperftools/malloc_hook.h	/^  static void InvokeDeleteHookSlow(const void* p);$/;"	p	class:MallocHook	access:private	signature:(const void* p)
MallocHook::InvokeDeleteHookSlow	src/malloc_hook.cc	/^void MallocHook::InvokeDeleteHookSlow(const void* p) {$/;"	f	class:MallocHook	signature:(const void* p)
MallocHook::InvokeMmapHook	src/gperftools/malloc_hook.h	/^  inline static void InvokeMmapHook(const void* result,$/;"	p	class:MallocHook	access:public	signature:(const void* result, const void* start, size_t size, int protection, int flags, int fd, off_t offset)
MallocHook::InvokeMmapHook	src/malloc_hook-inl.h	/^inline void MallocHook::InvokeMmapHook(const void* result,$/;"	f	class:MallocHook	signature:(const void* result, const void* start, size_t size, int protection, int flags, int fd, off_t offset)
MallocHook::InvokeMmapHookSlow	src/gperftools/malloc_hook.h	/^  static void InvokeMmapHookSlow(const void* result,$/;"	p	class:MallocHook	access:private	signature:(const void* result, const void* start, size_t size, int protection, int flags, int fd, off_t offset)
MallocHook::InvokeMmapHookSlow	src/malloc_hook.cc	/^void MallocHook::InvokeMmapHookSlow(const void* result,$/;"	f	class:MallocHook	signature:(const void* result, const void* start, size_t size, int protection, int flags, int fd, off_t offset)
MallocHook::InvokeMmapReplacement	src/gperftools/malloc_hook.h	/^  inline static bool InvokeMmapReplacement(const void* start,$/;"	p	class:MallocHook	access:public	signature:(const void* start, size_t size, int protection, int flags, int fd, off_t offset, void** result)
MallocHook::InvokeMmapReplacement	src/malloc_hook-inl.h	/^inline bool MallocHook::InvokeMmapReplacement(const void* start,$/;"	f	class:MallocHook	signature:(const void* start, size_t size, int protection, int flags, int fd, off_t offset, void** result)
MallocHook::InvokeMmapReplacementSlow	src/gperftools/malloc_hook.h	/^  static bool InvokeMmapReplacementSlow(const void* start,$/;"	p	class:MallocHook	access:private	signature:(const void* start, size_t size, int protection, int flags, int fd, off_t offset, void** result)
MallocHook::InvokeMmapReplacementSlow	src/malloc_hook.cc	/^bool MallocHook::InvokeMmapReplacementSlow(const void* start,$/;"	f	class:MallocHook	signature:(const void* start, size_t size, int protection, int flags, int fd, off_t offset, void** result)
MallocHook::InvokeMremapHook	src/gperftools/malloc_hook.h	/^  inline static void InvokeMremapHook(const void* result,$/;"	p	class:MallocHook	access:public	signature:(const void* result, const void* old_addr, size_t old_size, size_t new_size, int flags, const void* new_addr)
MallocHook::InvokeMremapHook	src/malloc_hook-inl.h	/^inline void MallocHook::InvokeMremapHook(const void* result,$/;"	f	class:MallocHook	signature:(const void* result, const void* old_addr, size_t old_size, size_t new_size, int flags, const void* new_addr)
MallocHook::InvokeMremapHookSlow	src/gperftools/malloc_hook.h	/^  static void InvokeMremapHookSlow(const void* result,$/;"	p	class:MallocHook	access:private	signature:(const void* result, const void* old_addr, size_t old_size, size_t new_size, int flags, const void* new_addr)
MallocHook::InvokeMremapHookSlow	src/malloc_hook.cc	/^void MallocHook::InvokeMremapHookSlow(const void* result,$/;"	f	class:MallocHook	signature:(const void* result, const void* old_addr, size_t old_size, size_t new_size, int flags, const void* new_addr)
MallocHook::InvokeMunmapHook	src/gperftools/malloc_hook.h	/^  inline static void InvokeMunmapHook(const void* p, size_t size);$/;"	p	class:MallocHook	access:public	signature:(const void* p, size_t size)
MallocHook::InvokeMunmapHook	src/malloc_hook-inl.h	/^inline void MallocHook::InvokeMunmapHook(const void* p, size_t size) {$/;"	f	class:MallocHook	signature:(const void* p, size_t size)
MallocHook::InvokeMunmapHookSlow	src/gperftools/malloc_hook.h	/^  static void InvokeMunmapHookSlow(const void* p, size_t size);$/;"	p	class:MallocHook	access:private	signature:(const void* p, size_t size)
MallocHook::InvokeMunmapHookSlow	src/malloc_hook.cc	/^void MallocHook::InvokeMunmapHookSlow(const void* p, size_t s) {$/;"	f	class:MallocHook	signature:(const void* p, size_t s)
MallocHook::InvokeMunmapReplacement	src/gperftools/malloc_hook.h	/^  inline static bool InvokeMunmapReplacement(const void* p,$/;"	p	class:MallocHook	access:public	signature:(const void* p, size_t size, int* result)
MallocHook::InvokeMunmapReplacement	src/malloc_hook-inl.h	/^inline bool MallocHook::InvokeMunmapReplacement($/;"	f	class:MallocHook	signature:( const void* p, size_t size, int* result)
MallocHook::InvokeMunmapReplacementSlow	src/gperftools/malloc_hook.h	/^  static bool InvokeMunmapReplacementSlow(const void* p,$/;"	p	class:MallocHook	access:private	signature:(const void* p, size_t size, int* result)
MallocHook::InvokeMunmapReplacementSlow	src/malloc_hook.cc	/^bool MallocHook::InvokeMunmapReplacementSlow(const void* p,$/;"	f	class:MallocHook	signature:(const void* p, size_t s, int* result)
MallocHook::InvokeNewHook	src/gperftools/malloc_hook.h	/^  inline static void InvokeNewHook(const void* p, size_t s);$/;"	p	class:MallocHook	access:public	signature:(const void* p, size_t s)
MallocHook::InvokeNewHook	src/malloc_hook-inl.h	/^inline void MallocHook::InvokeNewHook(const void* p, size_t s) {$/;"	f	class:MallocHook	signature:(const void* p, size_t s)
MallocHook::InvokeNewHookSlow	src/gperftools/malloc_hook.h	/^  static void InvokeNewHookSlow(const void* p, size_t s);$/;"	p	class:MallocHook	access:private	signature:(const void* p, size_t s)
MallocHook::InvokeNewHookSlow	src/malloc_hook.cc	/^void MallocHook::InvokeNewHookSlow(const void* p, size_t s) {$/;"	f	class:MallocHook	signature:(const void* p, size_t s)
MallocHook::InvokePreMmapHook	src/gperftools/malloc_hook.h	/^  inline static void InvokePreMmapHook(const void* start,$/;"	p	class:MallocHook	access:public	signature:(const void* start, size_t size, int protection, int flags, int fd, off_t offset)
MallocHook::InvokePreMmapHook	src/malloc_hook-inl.h	/^inline void MallocHook::InvokePreMmapHook(const void* start,$/;"	f	class:MallocHook	signature:(const void* start, size_t size, int protection, int flags, int fd, off_t offset)
MallocHook::InvokePreMmapHookSlow	src/gperftools/malloc_hook.h	/^  static void InvokePreMmapHookSlow(const void* start,$/;"	p	class:MallocHook	access:private	signature:(const void* start, size_t size, int protection, int flags, int fd, off_t offset)
MallocHook::InvokePreMmapHookSlow	src/malloc_hook.cc	/^void MallocHook::InvokePreMmapHookSlow(const void* start,$/;"	f	class:MallocHook	signature:(const void* start, size_t size, int protection, int flags, int fd, off_t offset)
MallocHook::InvokePreSbrkHook	src/gperftools/malloc_hook.h	/^  inline static void InvokePreSbrkHook(ptrdiff_t increment);$/;"	p	class:MallocHook	access:public	signature:(ptrdiff_t increment)
MallocHook::InvokePreSbrkHook	src/malloc_hook-inl.h	/^inline void MallocHook::InvokePreSbrkHook(ptrdiff_t increment) {$/;"	f	class:MallocHook	signature:(ptrdiff_t increment)
MallocHook::InvokePreSbrkHookSlow	src/gperftools/malloc_hook.h	/^  static void InvokePreSbrkHookSlow(ptrdiff_t increment);$/;"	p	class:MallocHook	access:private	signature:(ptrdiff_t increment)
MallocHook::InvokePreSbrkHookSlow	src/malloc_hook.cc	/^void MallocHook::InvokePreSbrkHookSlow(ptrdiff_t increment) {$/;"	f	class:MallocHook	signature:(ptrdiff_t increment)
MallocHook::InvokeSbrkHook	src/gperftools/malloc_hook.h	/^  inline static void InvokeSbrkHook(const void* result, ptrdiff_t increment);$/;"	p	class:MallocHook	access:public	signature:(const void* result, ptrdiff_t increment)
MallocHook::InvokeSbrkHook	src/malloc_hook-inl.h	/^inline void MallocHook::InvokeSbrkHook(const void* result,$/;"	f	class:MallocHook	signature:(const void* result, ptrdiff_t increment)
MallocHook::InvokeSbrkHookSlow	src/gperftools/malloc_hook.h	/^  static void InvokeSbrkHookSlow(const void* result, ptrdiff_t increment);$/;"	p	class:MallocHook	access:private	signature:(const void* result, ptrdiff_t increment)
MallocHook::InvokeSbrkHookSlow	src/malloc_hook.cc	/^void MallocHook::InvokeSbrkHookSlow(const void* result, ptrdiff_t increment) {$/;"	f	class:MallocHook	signature:(const void* result, ptrdiff_t increment)
MallocHook::MmapHook	src/gperftools/malloc_hook.h	/^  typedef MallocHook_MmapHook MmapHook;$/;"	t	class:MallocHook	access:public
MallocHook::MmapReplacement	src/gperftools/malloc_hook.h	/^  typedef MallocHook_MmapReplacement MmapReplacement;$/;"	t	class:MallocHook	access:public
MallocHook::MremapHook	src/gperftools/malloc_hook.h	/^  typedef MallocHook_MremapHook MremapHook;$/;"	t	class:MallocHook	access:public
MallocHook::MunmapHook	src/gperftools/malloc_hook.h	/^  typedef MallocHook_MunmapHook MunmapHook;$/;"	t	class:MallocHook	access:public
MallocHook::MunmapReplacement	src/gperftools/malloc_hook.h	/^  typedef MallocHook_MunmapReplacement MunmapReplacement;$/;"	t	class:MallocHook	access:public
MallocHook::NewHook	src/gperftools/malloc_hook.h	/^  typedef MallocHook_NewHook NewHook;$/;"	t	class:MallocHook	access:public
MallocHook::PreMmapHook	src/gperftools/malloc_hook.h	/^  typedef MallocHook_PreMmapHook PreMmapHook;$/;"	t	class:MallocHook	access:public
MallocHook::PreSbrkHook	src/gperftools/malloc_hook.h	/^  typedef MallocHook_PreSbrkHook PreSbrkHook;$/;"	t	class:MallocHook	access:public
MallocHook::RemoveDeleteHook	src/gperftools/malloc_hook.h	/^  inline static bool RemoveDeleteHook(DeleteHook hook) {$/;"	f	class:MallocHook	access:public	signature:(DeleteHook hook)
MallocHook::RemoveMmapHook	src/gperftools/malloc_hook.h	/^  inline static bool RemoveMmapHook(MmapHook hook) {$/;"	f	class:MallocHook	access:public	signature:(MmapHook hook)
MallocHook::RemoveMmapReplacement	src/gperftools/malloc_hook.h	/^  inline static bool RemoveMmapReplacement(MmapReplacement hook) {$/;"	f	class:MallocHook	access:public	signature:(MmapReplacement hook)
MallocHook::RemoveMremapHook	src/gperftools/malloc_hook.h	/^  inline static bool RemoveMremapHook(MremapHook hook) {$/;"	f	class:MallocHook	access:public	signature:(MremapHook hook)
MallocHook::RemoveMunmapHook	src/gperftools/malloc_hook.h	/^  inline static bool RemoveMunmapHook(MunmapHook hook) {$/;"	f	class:MallocHook	access:public	signature:(MunmapHook hook)
MallocHook::RemoveMunmapReplacement	src/gperftools/malloc_hook.h	/^  inline static bool RemoveMunmapReplacement(MunmapReplacement hook) {$/;"	f	class:MallocHook	access:public	signature:(MunmapReplacement hook)
MallocHook::RemoveNewHook	src/gperftools/malloc_hook.h	/^  inline static bool RemoveNewHook(NewHook hook) {$/;"	f	class:MallocHook	access:public	signature:(NewHook hook)
MallocHook::RemovePreMmapHook	src/gperftools/malloc_hook.h	/^  inline static bool RemovePreMmapHook(PreMmapHook hook) {$/;"	f	class:MallocHook	access:public	signature:(PreMmapHook hook)
MallocHook::RemovePreSbrkHook	src/gperftools/malloc_hook.h	/^  inline static bool RemovePreSbrkHook(PreSbrkHook hook) {$/;"	f	class:MallocHook	access:public	signature:(PreSbrkHook hook)
MallocHook::RemoveSbrkHook	src/gperftools/malloc_hook.h	/^  inline static bool RemoveSbrkHook(SbrkHook hook) {$/;"	f	class:MallocHook	access:public	signature:(SbrkHook hook)
MallocHook::SbrkHook	src/gperftools/malloc_hook.h	/^  typedef MallocHook_SbrkHook SbrkHook;$/;"	t	class:MallocHook	access:public
MallocHook::SetDeleteHook	src/gperftools/malloc_hook.h	/^  inline static DeleteHook SetDeleteHook(DeleteHook hook) {$/;"	f	class:MallocHook	access:public	signature:(DeleteHook hook)
MallocHook::SetMmapHook	src/gperftools/malloc_hook.h	/^  inline static MmapHook SetMmapHook(MmapHook hook) {$/;"	f	class:MallocHook	access:public	signature:(MmapHook hook)
MallocHook::SetMmapReplacement	src/gperftools/malloc_hook.h	/^  inline static bool SetMmapReplacement(MmapReplacement hook) {$/;"	f	class:MallocHook	access:public	signature:(MmapReplacement hook)
MallocHook::SetMremapHook	src/gperftools/malloc_hook.h	/^  inline static MremapHook SetMremapHook(MremapHook hook) {$/;"	f	class:MallocHook	access:public	signature:(MremapHook hook)
MallocHook::SetMunmapHook	src/gperftools/malloc_hook.h	/^  inline static MunmapHook SetMunmapHook(MunmapHook hook) {$/;"	f	class:MallocHook	access:public	signature:(MunmapHook hook)
MallocHook::SetMunmapReplacement	src/gperftools/malloc_hook.h	/^  inline static bool SetMunmapReplacement(MunmapReplacement hook) {$/;"	f	class:MallocHook	access:public	signature:(MunmapReplacement hook)
MallocHook::SetNewHook	src/gperftools/malloc_hook.h	/^  inline static NewHook SetNewHook(NewHook hook) {$/;"	f	class:MallocHook	access:public	signature:(NewHook hook)
MallocHook::SetPreMmapHook	src/gperftools/malloc_hook.h	/^  inline static PreMmapHook SetPreMmapHook(PreMmapHook hook) {$/;"	f	class:MallocHook	access:public	signature:(PreMmapHook hook)
MallocHook::SetPreSbrkHook	src/gperftools/malloc_hook.h	/^  inline static PreSbrkHook SetPreSbrkHook(PreSbrkHook hook) {$/;"	f	class:MallocHook	access:public	signature:(PreSbrkHook hook)
MallocHook::SetSbrkHook	src/gperftools/malloc_hook.h	/^  inline static SbrkHook SetSbrkHook(SbrkHook hook) {$/;"	f	class:MallocHook	access:public	signature:(SbrkHook hook)
MallocHook::UnhookedMMap	src/gperftools/malloc_hook.h	/^  static void* UnhookedMMap(void *start, size_t length, int prot, int flags,$/;"	p	class:MallocHook	access:public	signature:(void *start, size_t length, int prot, int flags, int fd, off_t offset)
MallocHook::UnhookedMMap	src/malloc_hook.cc	/^\/*static*\/void* MallocHook::UnhookedMMap(void *start, size_t length, int prot,$/;"	f	class:MallocHook	signature:(void *start, size_t length, int prot, int flags, int fd, off_t offset)
MallocHook::UnhookedMMap	src/malloc_hook_mmap_freebsd.h	/^\/*static*\/void* MallocHook::UnhookedMMap(void *start, size_t length, int prot,$/;"	f	class:MallocHook	signature:(void *start, size_t length, int prot, int flags, int fd, off_t offset)
MallocHook::UnhookedMMap	src/malloc_hook_mmap_linux.h	/^\/*static*\/void* MallocHook::UnhookedMMap(void *start, size_t length, int prot,$/;"	f	class:MallocHook	signature:(void *start, size_t length, int prot, int flags, int fd, off_t offset)
MallocHook::UnhookedMUnmap	src/gperftools/malloc_hook.h	/^  static int UnhookedMUnmap(void *start, size_t length);$/;"	p	class:MallocHook	access:public	signature:(void *start, size_t length)
MallocHook::UnhookedMUnmap	src/malloc_hook.cc	/^\/*static*\/int MallocHook::UnhookedMUnmap(void *start, size_t length) {$/;"	f	class:MallocHook	signature:(void *start, size_t length)
MallocHook::UnhookedMUnmap	src/malloc_hook_mmap_freebsd.h	/^\/*static*\/int MallocHook::UnhookedMUnmap(void *start, size_t length) {$/;"	f	class:MallocHook	signature:(void *start, size_t length)
MallocHook::UnhookedMUnmap	src/malloc_hook_mmap_linux.h	/^\/*static*\/int MallocHook::UnhookedMUnmap(void *start, size_t length) {$/;"	f	class:MallocHook	signature:(void *start, size_t length)
MallocHook_AddDeleteHook	src/gperftools/malloc_hook_c.h	/^int MallocHook_AddDeleteHook(MallocHook_DeleteHook hook);$/;"	p	signature:(MallocHook_DeleteHook hook)
MallocHook_AddDeleteHook	src/malloc_hook.cc	/^int MallocHook_AddDeleteHook(MallocHook_DeleteHook hook) {$/;"	f	signature:(MallocHook_DeleteHook hook)
MallocHook_AddMmapHook	src/gperftools/malloc_hook_c.h	/^int MallocHook_AddMmapHook(MallocHook_MmapHook hook);$/;"	p	signature:(MallocHook_MmapHook hook)
MallocHook_AddMmapHook	src/malloc_hook.cc	/^int MallocHook_AddMmapHook(MallocHook_MmapHook hook) {$/;"	f	signature:(MallocHook_MmapHook hook)
MallocHook_AddMremapHook	src/gperftools/malloc_hook_c.h	/^int MallocHook_AddMremapHook(MallocHook_MremapHook hook);$/;"	p	signature:(MallocHook_MremapHook hook)
MallocHook_AddMremapHook	src/malloc_hook.cc	/^int MallocHook_AddMremapHook(MallocHook_MremapHook hook) {$/;"	f	signature:(MallocHook_MremapHook hook)
MallocHook_AddMunmapHook	src/gperftools/malloc_hook_c.h	/^int MallocHook_AddMunmapHook(MallocHook_MunmapHook hook);$/;"	p	signature:(MallocHook_MunmapHook hook)
MallocHook_AddMunmapHook	src/malloc_hook.cc	/^int MallocHook_AddMunmapHook(MallocHook_MunmapHook hook) {$/;"	f	signature:(MallocHook_MunmapHook hook)
MallocHook_AddNewHook	src/gperftools/malloc_hook_c.h	/^int MallocHook_AddNewHook(MallocHook_NewHook hook);$/;"	p	signature:(MallocHook_NewHook hook)
MallocHook_AddNewHook	src/malloc_hook.cc	/^int MallocHook_AddNewHook(MallocHook_NewHook hook) {$/;"	f	signature:(MallocHook_NewHook hook)
MallocHook_AddPreMmapHook	src/gperftools/malloc_hook_c.h	/^int MallocHook_AddPreMmapHook(MallocHook_PreMmapHook hook);$/;"	p	signature:(MallocHook_PreMmapHook hook)
MallocHook_AddPreMmapHook	src/malloc_hook.cc	/^int MallocHook_AddPreMmapHook(MallocHook_PreMmapHook hook) {$/;"	f	signature:(MallocHook_PreMmapHook hook)
MallocHook_AddPreSbrkHook	src/gperftools/malloc_hook_c.h	/^int MallocHook_AddPreSbrkHook(MallocHook_PreSbrkHook hook);$/;"	p	signature:(MallocHook_PreSbrkHook hook)
MallocHook_AddPreSbrkHook	src/malloc_hook.cc	/^int MallocHook_AddPreSbrkHook(MallocHook_PreSbrkHook hook) {$/;"	f	signature:(MallocHook_PreSbrkHook hook)
MallocHook_AddSbrkHook	src/gperftools/malloc_hook_c.h	/^int MallocHook_AddSbrkHook(MallocHook_SbrkHook hook);$/;"	p	signature:(MallocHook_SbrkHook hook)
MallocHook_AddSbrkHook	src/malloc_hook.cc	/^int MallocHook_AddSbrkHook(MallocHook_SbrkHook hook) {$/;"	f	signature:(MallocHook_SbrkHook hook)
MallocHook_DeleteHook	src/gperftools/malloc_hook_c.h	/^typedef void (*MallocHook_DeleteHook)(const void* ptr);$/;"	t
MallocHook_GetCallerStackTrace	src/gperftools/malloc_hook_c.h	/^int MallocHook_GetCallerStackTrace(void** result, int max_depth,$/;"	p	signature:(void** result, int max_depth, int skip_count)
MallocHook_GetCallerStackTrace	src/malloc_hook.cc	/^extern "C" int MallocHook_GetCallerStackTrace(void** result, int max_depth,$/;"	f	signature:(void** result, int max_depth, int skip_count)
MallocHook_InitAtFirstAllocation_HeapLeakChecker	src/heap-checker.cc	/^extern "C" void MallocHook_InitAtFirstAllocation_HeapLeakChecker() {$/;"	f	signature:()
MallocHook_InitAtFirstAllocation_HeapLeakChecker	src/malloc_hook.cc	/^ATTRIBUTE_WEAK void MallocHook_InitAtFirstAllocation_HeapLeakChecker();$/;"	p	file:	signature:()
MallocHook_InitAtFirstAllocation_HeapLeakChecker	src/malloc_hook.cc	/^extern "C" void MallocHook_InitAtFirstAllocation_HeapLeakChecker() {$/;"	f	signature:()
MallocHook_MmapHook	src/gperftools/malloc_hook_c.h	/^typedef void (*MallocHook_MmapHook)(const void* result,$/;"	t
MallocHook_MmapReplacement	src/gperftools/malloc_hook_c.h	/^typedef int (*MallocHook_MmapReplacement)(const void* start,$/;"	t
MallocHook_MremapHook	src/gperftools/malloc_hook_c.h	/^typedef void (*MallocHook_MremapHook)(const void* result,$/;"	t
MallocHook_MunmapHook	src/gperftools/malloc_hook_c.h	/^typedef void (*MallocHook_MunmapHook)(const void* ptr, size_t size);$/;"	t
MallocHook_MunmapReplacement	src/gperftools/malloc_hook_c.h	/^typedef int (*MallocHook_MunmapReplacement)(const void* ptr,$/;"	t
MallocHook_NewHook	src/gperftools/malloc_hook_c.h	/^typedef void (*MallocHook_NewHook)(const void* ptr, size_t size);$/;"	t
MallocHook_PreMmapHook	src/gperftools/malloc_hook_c.h	/^typedef void (*MallocHook_PreMmapHook)(const void *start,$/;"	t
MallocHook_PreSbrkHook	src/gperftools/malloc_hook_c.h	/^typedef void (*MallocHook_PreSbrkHook)(ptrdiff_t increment);$/;"	t
MallocHook_RemoveDeleteHook	src/gperftools/malloc_hook_c.h	/^int MallocHook_RemoveDeleteHook(MallocHook_DeleteHook hook);$/;"	p	signature:(MallocHook_DeleteHook hook)
MallocHook_RemoveDeleteHook	src/malloc_hook.cc	/^int MallocHook_RemoveDeleteHook(MallocHook_DeleteHook hook) {$/;"	f	signature:(MallocHook_DeleteHook hook)
MallocHook_RemoveMmapHook	src/gperftools/malloc_hook_c.h	/^int MallocHook_RemoveMmapHook(MallocHook_MmapHook hook);$/;"	p	signature:(MallocHook_MmapHook hook)
MallocHook_RemoveMmapHook	src/malloc_hook.cc	/^int MallocHook_RemoveMmapHook(MallocHook_MmapHook hook) {$/;"	f	signature:(MallocHook_MmapHook hook)
MallocHook_RemoveMmapReplacement	src/gperftools/malloc_hook_c.h	/^int MallocHook_RemoveMmapReplacement(MallocHook_MmapReplacement hook);$/;"	p	signature:(MallocHook_MmapReplacement hook)
MallocHook_RemoveMmapReplacement	src/malloc_hook.cc	/^int MallocHook_RemoveMmapReplacement(MallocHook_MmapReplacement hook) {$/;"	f	signature:(MallocHook_MmapReplacement hook)
MallocHook_RemoveMremapHook	src/gperftools/malloc_hook_c.h	/^int MallocHook_RemoveMremapHook(MallocHook_MremapHook hook);$/;"	p	signature:(MallocHook_MremapHook hook)
MallocHook_RemoveMremapHook	src/malloc_hook.cc	/^int MallocHook_RemoveMremapHook(MallocHook_MremapHook hook) {$/;"	f	signature:(MallocHook_MremapHook hook)
MallocHook_RemoveMunmapHook	src/gperftools/malloc_hook_c.h	/^int MallocHook_RemoveMunmapHook(MallocHook_MunmapHook hook);$/;"	p	signature:(MallocHook_MunmapHook hook)
MallocHook_RemoveMunmapHook	src/malloc_hook.cc	/^int MallocHook_RemoveMunmapHook(MallocHook_MunmapHook hook) {$/;"	f	signature:(MallocHook_MunmapHook hook)
MallocHook_RemoveMunmapReplacement	src/gperftools/malloc_hook_c.h	/^int MallocHook_RemoveMunmapReplacement(MallocHook_MunmapReplacement hook);$/;"	p	signature:(MallocHook_MunmapReplacement hook)
MallocHook_RemoveMunmapReplacement	src/malloc_hook.cc	/^int MallocHook_RemoveMunmapReplacement(MallocHook_MunmapReplacement hook) {$/;"	f	signature:(MallocHook_MunmapReplacement hook)
MallocHook_RemoveNewHook	src/gperftools/malloc_hook_c.h	/^int MallocHook_RemoveNewHook(MallocHook_NewHook hook);$/;"	p	signature:(MallocHook_NewHook hook)
MallocHook_RemoveNewHook	src/malloc_hook.cc	/^int MallocHook_RemoveNewHook(MallocHook_NewHook hook) {$/;"	f	signature:(MallocHook_NewHook hook)
MallocHook_RemovePreMmapHook	src/gperftools/malloc_hook_c.h	/^int MallocHook_RemovePreMmapHook(MallocHook_PreMmapHook hook);$/;"	p	signature:(MallocHook_PreMmapHook hook)
MallocHook_RemovePreMmapHook	src/malloc_hook.cc	/^int MallocHook_RemovePreMmapHook(MallocHook_PreMmapHook hook) {$/;"	f	signature:(MallocHook_PreMmapHook hook)
MallocHook_RemovePreSbrkHook	src/gperftools/malloc_hook_c.h	/^int MallocHook_RemovePreSbrkHook(MallocHook_PreSbrkHook hook);$/;"	p	signature:(MallocHook_PreSbrkHook hook)
MallocHook_RemovePreSbrkHook	src/malloc_hook.cc	/^int MallocHook_RemovePreSbrkHook(MallocHook_PreSbrkHook hook) {$/;"	f	signature:(MallocHook_PreSbrkHook hook)
MallocHook_RemoveSbrkHook	src/gperftools/malloc_hook_c.h	/^int MallocHook_RemoveSbrkHook(MallocHook_SbrkHook hook);$/;"	p	signature:(MallocHook_SbrkHook hook)
MallocHook_RemoveSbrkHook	src/malloc_hook.cc	/^int MallocHook_RemoveSbrkHook(MallocHook_SbrkHook hook) {$/;"	f	signature:(MallocHook_SbrkHook hook)
MallocHook_SbrkHook	src/gperftools/malloc_hook_c.h	/^typedef void (*MallocHook_SbrkHook)(const void* result, ptrdiff_t increment);$/;"	t
MallocHook_SetDeleteHook	src/gperftools/malloc_hook_c.h	/^MallocHook_DeleteHook MallocHook_SetDeleteHook(MallocHook_DeleteHook hook);$/;"	p	signature:(MallocHook_DeleteHook hook)
MallocHook_SetDeleteHook	src/malloc_hook.cc	/^MallocHook_DeleteHook MallocHook_SetDeleteHook(MallocHook_DeleteHook hook) {$/;"	f	signature:(MallocHook_DeleteHook hook)
MallocHook_SetMmapHook	src/gperftools/malloc_hook_c.h	/^MallocHook_MmapHook MallocHook_SetMmapHook(MallocHook_MmapHook hook);$/;"	p	signature:(MallocHook_MmapHook hook)
MallocHook_SetMmapHook	src/malloc_hook.cc	/^MallocHook_MmapHook MallocHook_SetMmapHook(MallocHook_MmapHook hook) {$/;"	f	signature:(MallocHook_MmapHook hook)
MallocHook_SetMmapReplacement	src/gperftools/malloc_hook_c.h	/^int MallocHook_SetMmapReplacement(MallocHook_MmapReplacement hook);$/;"	p	signature:(MallocHook_MmapReplacement hook)
MallocHook_SetMmapReplacement	src/malloc_hook.cc	/^int MallocHook_SetMmapReplacement(MallocHook_MmapReplacement hook) {$/;"	f	signature:(MallocHook_MmapReplacement hook)
MallocHook_SetMremapHook	src/gperftools/malloc_hook_c.h	/^MallocHook_MremapHook MallocHook_SetMremapHook(MallocHook_MremapHook hook);$/;"	p	signature:(MallocHook_MremapHook hook)
MallocHook_SetMremapHook	src/malloc_hook.cc	/^MallocHook_MremapHook MallocHook_SetMremapHook(MallocHook_MremapHook hook) {$/;"	f	signature:(MallocHook_MremapHook hook)
MallocHook_SetMunmapHook	src/gperftools/malloc_hook_c.h	/^MallocHook_MunmapHook MallocHook_SetMunmapHook(MallocHook_MunmapHook hook);$/;"	p	signature:(MallocHook_MunmapHook hook)
MallocHook_SetMunmapHook	src/malloc_hook.cc	/^MallocHook_MunmapHook MallocHook_SetMunmapHook(MallocHook_MunmapHook hook) {$/;"	f	signature:(MallocHook_MunmapHook hook)
MallocHook_SetMunmapReplacement	src/gperftools/malloc_hook_c.h	/^int MallocHook_SetMunmapReplacement(MallocHook_MunmapReplacement hook);$/;"	p	signature:(MallocHook_MunmapReplacement hook)
MallocHook_SetMunmapReplacement	src/malloc_hook.cc	/^int MallocHook_SetMunmapReplacement(MallocHook_MunmapReplacement hook) {$/;"	f	signature:(MallocHook_MunmapReplacement hook)
MallocHook_SetNewHook	src/gperftools/malloc_hook_c.h	/^MallocHook_NewHook MallocHook_SetNewHook(MallocHook_NewHook hook);$/;"	p	signature:(MallocHook_NewHook hook)
MallocHook_SetNewHook	src/malloc_hook.cc	/^MallocHook_NewHook MallocHook_SetNewHook(MallocHook_NewHook hook) {$/;"	f	signature:(MallocHook_NewHook hook)
MallocHook_SetPreMmapHook	src/gperftools/malloc_hook_c.h	/^MallocHook_PreMmapHook MallocHook_SetPreMmapHook(MallocHook_PreMmapHook hook);$/;"	p	signature:(MallocHook_PreMmapHook hook)
MallocHook_SetPreMmapHook	src/malloc_hook.cc	/^MallocHook_PreMmapHook MallocHook_SetPreMmapHook(MallocHook_PreMmapHook hook) {$/;"	f	signature:(MallocHook_PreMmapHook hook)
MallocHook_SetPreSbrkHook	src/gperftools/malloc_hook_c.h	/^MallocHook_PreSbrkHook MallocHook_SetPreSbrkHook(MallocHook_PreSbrkHook hook);$/;"	p	signature:(MallocHook_PreSbrkHook hook)
MallocHook_SetPreSbrkHook	src/malloc_hook.cc	/^MallocHook_PreSbrkHook MallocHook_SetPreSbrkHook(MallocHook_PreSbrkHook hook) {$/;"	f	signature:(MallocHook_PreSbrkHook hook)
MallocHook_SetSbrkHook	src/gperftools/malloc_hook_c.h	/^MallocHook_SbrkHook MallocHook_SetSbrkHook(MallocHook_SbrkHook hook);$/;"	p	signature:(MallocHook_SbrkHook hook)
MallocHook_SetSbrkHook	src/malloc_hook.cc	/^MallocHook_SbrkHook MallocHook_SetSbrkHook(MallocHook_SbrkHook hook) {$/;"	f	signature:(MallocHook_SbrkHook hook)
MallocMemoryStats	src/debugallocation.cc	/^  virtual bool MallocMemoryStats(int* blocks, size_t* total,$/;"	f	class:DebugMallocImplementation	access:public	signature:(int* blocks, size_t* total, int histogram[kMallocHistogramSize])
MallocMemoryStats	src/gperftools/malloc_extension.h	/^  virtual bool MallocMemoryStats(int* blocks, size_t* total,$/;"	p	class:MallocExtension	access:public	signature:(int* blocks, size_t* total, int histogram[kMallocHistogramSize])
MallocMemoryStats	src/malloc_extension.cc	/^bool MallocExtension::MallocMemoryStats(int* blocks, size_t* total,$/;"	f	class:MallocExtension	signature:(int* blocks, size_t* total, int histogram[kMallocHistogramSize])
MallocRange	src/gperftools/malloc_extension.h	/^struct MallocRange {$/;"	s	namespace:base
Mallocer	src/tests/heap-checker_unittest.cc	/^static void* Mallocer(uintptr_t* addr_after_malloc_call) {$/;"	f	file:	signature:(uintptr_t* addr_after_malloc_call)
MapArgsAllocIterator	src/heap-profile-table.h	/^  static void MapArgsAllocIterator(const void* ptr, AllocValue* v,$/;"	f	class:HeapProfileTable	access:private	signature:(const void* ptr, AllocValue* v, AllocIterator callback)
MapObjectToSpan	src/central_freelist.cc	/^Span* MapObjectToSpan(void* object) {$/;"	f	namespace:tcmalloc	signature:(void* object)
MapPages	src/base/low_level_alloc.cc	/^    virtual void *MapPages(int32 flags, size_t size);$/;"	p	class:__anon38::DefaultPagesAllocator	file:	access:public	signature:(int32 flags, size_t size)
MapPages	src/base/low_level_alloc.cc	/^void *DefaultPagesAllocator::MapPages(int32 flags, size_t size) {$/;"	f	class:DefaultPagesAllocator	signature:(int32 flags, size_t size)
MapPages	src/base/low_level_alloc.h	/^    virtual void *MapPages(int32 flags, size_t size) = 0;$/;"	p	class:LowLevelAlloc::PagesAllocator	access:public	signature:(int32 flags, size_t size)
MapPages	src/emergency_malloc.cc	/^    void *MapPages(int32 flags, size_t size) {$/;"	f	class:tcmalloc::EmergencyArenaPagesAllocator	file:	access:private	signature:(int32 flags, size_t size)
MapSelector	src/page_heap.h	/^template <> class MapSelector<32> {$/;"	c	namespace:tcmalloc
MapSelector	src/page_heap.h	/^template <> class MapSelector<48> {$/;"	c	namespace:tcmalloc
MapSelector	src/page_heap.h	/^template <int BITS> class MapSelector {$/;"	c	namespace:tcmalloc
MapSize	src/memory_region_map.h	/^  static int64 MapSize() { return map_size_; }$/;"	f	class:MemoryRegionMap	access:public	signature:()
MarkAsIgnored	src/heap-profile-table.cc	/^void HeapProfileTable::MarkAsIgnored(const void* ptr) {$/;"	f	class:HeapProfileTable	signature:(const void* ptr)
MarkAsIgnored	src/heap-profile-table.h	/^  void MarkAsIgnored(const void* ptr);$/;"	p	class:HeapProfileTable	access:public	signature:(const void* ptr)
MarkAsLive	src/heap-profile-table.cc	/^bool HeapProfileTable::MarkAsLive(const void* ptr) {$/;"	f	class:HeapProfileTable	signature:(const void* ptr)
MarkAsLive	src/heap-profile-table.h	/^  bool MarkAsLive(const void* ptr);$/;"	p	class:HeapProfileTable	access:public	signature:(const void* ptr)
MarkThreadBusy	src/gperftools/malloc_extension.h	/^  virtual void MarkThreadBusy();$/;"	p	class:MallocExtension	access:public	signature:()
MarkThreadBusy	src/malloc_extension.cc	/^void MallocExtension::MarkThreadBusy() {$/;"	f	class:MallocExtension	signature:()
MarkThreadBusy	src/tcmalloc.cc	/^  virtual void MarkThreadBusy();  \/\/ Implemented below$/;"	p	class:TCMallocImplementation	file:	access:public	signature:()
MarkThreadBusy	src/tcmalloc.cc	/^void TCMallocImplementation::MarkThreadBusy() {$/;"	f	class:TCMallocImplementation	signature:()
MarkThreadIdle	src/gperftools/malloc_extension.h	/^  virtual void MarkThreadIdle();$/;"	p	class:MallocExtension	access:public	signature:()
MarkThreadIdle	src/malloc_extension.cc	/^void MallocExtension::MarkThreadIdle() {$/;"	f	class:MallocExtension	signature:()
MarkThreadIdle	src/tcmalloc.cc	/^  virtual void MarkThreadIdle() {$/;"	f	class:TCMallocImplementation	access:public	signature:()
MarkThreadTemporarilyIdle	src/gperftools/malloc_extension.h	/^  virtual void MarkThreadTemporarilyIdle();$/;"	p	class:MallocExtension	access:public	signature:()
MarkThreadTemporarilyIdle	src/malloc_extension.cc	/^void MallocExtension::MarkThreadTemporarilyIdle() {$/;"	f	class:MallocExtension	signature:()
MarkThreadTemporarilyIdle	src/tcmalloc.cc	/^  virtual void MarkThreadTemporarilyIdle() {$/;"	f	class:TCMallocImplementation	access:public	signature:()
MaybeDumpProfileLocked	src/heap-profiler.cc	/^static void MaybeDumpProfileLocked() {$/;"	f	file:	signature:()
MaybePrint	src/windows/nm-pdb.c	/^static void MaybePrint(const char* var, const char* description) {$/;"	f	file:	signature:(const char* var, const char* description)
Memalign	src/tests/tcmalloc_unittest.cc	/^static inline void* Memalign(size_t align, size_t size) {$/;"	f	file:	signature:(size_t align, size_t size)
MemoryAligner	src/base/basictypes.h	/^union MemoryAligner {$/;"	u
MemoryAligner::d	src/base/basictypes.h	/^  double d;$/;"	m	union:MemoryAligner	access:public
MemoryAligner::p	src/base/basictypes.h	/^  void*  p;$/;"	m	union:MemoryAligner	access:public
MemoryAligner::s	src/base/basictypes.h	/^  size_t s;$/;"	m	union:MemoryAligner	access:public
MemoryBarrier	src/base/atomicops-internals-arm-generic.h	/^inline void MemoryBarrier() {$/;"	f	namespace:base::subtle	signature:()
MemoryBarrier	src/base/atomicops-internals-arm-v6plus.h	/^inline void MemoryBarrier() {$/;"	f	namespace:base::subtle	signature:()
MemoryBarrier	src/base/atomicops-internals-gcc.h	/^inline void MemoryBarrier() {$/;"	f	namespace:base::subtle	signature:()
MemoryBarrier	src/base/atomicops-internals-linuxppc.h	/^inline void MemoryBarrier() {$/;"	f	namespace:base::subtle	signature:()
MemoryBarrier	src/base/atomicops-internals-macosx.h	/^inline void MemoryBarrier() {$/;"	f	namespace:base::subtle	signature:()
MemoryBarrier	src/base/atomicops-internals-mips.h	/^inline void MemoryBarrier()$/;"	f	namespace:base::subtle	signature:()
MemoryBarrier	src/base/atomicops-internals-windows.h	/^inline void MemoryBarrier() {$/;"	f	namespace:base::subtle	signature:()
MemoryBarrier	src/base/atomicops-internals-windows.h	/^inline void MemoryBarrier() {$/;"	f	signature:()
MemoryBarrier	src/base/atomicops-internals-x86.h	/^inline void MemoryBarrier() {$/;"	f	namespace:base::subtle	signature:()
MemoryRegionMap	src/memory_region_map.h	/^class MemoryRegionMap {$/;"	c
MemoryRegionMap::BeginRegionLocked	src/memory_region_map.cc	/^MemoryRegionMap::RegionIterator MemoryRegionMap::BeginRegionLocked() {$/;"	f	class:MemoryRegionMap	signature:()
MemoryRegionMap::BeginRegionLocked	src/memory_region_map.h	/^  static RegionIterator BeginRegionLocked();$/;"	p	class:MemoryRegionMap	access:public	signature:()
MemoryRegionMap::DISALLOW_COPY_AND_ASSIGN	src/memory_region_map.h	/^  DISALLOW_COPY_AND_ASSIGN(MemoryRegionMap);$/;"	p	class:MemoryRegionMap	access:private	signature:(MemoryRegionMap)
MemoryRegionMap::DoFindRegionLocked	src/memory_region_map.cc	/^MemoryRegionMap::DoFindRegionLocked(uintptr_t addr) {$/;"	f	class:MemoryRegionMap	signature:(uintptr_t addr)
MemoryRegionMap::DoFindRegionLocked	src/memory_region_map.h	/^  static const Region* DoFindRegionLocked(uintptr_t addr);$/;"	p	class:MemoryRegionMap	access:private	signature:(uintptr_t addr)
MemoryRegionMap::DoInsertRegionLocked	src/memory_region_map.cc	/^inline void MemoryRegionMap::DoInsertRegionLocked(const Region& region) {$/;"	f	class:MemoryRegionMap	signature:(const Region& region)
MemoryRegionMap::DoInsertRegionLocked	src/memory_region_map.h	/^  inline static void DoInsertRegionLocked(const Region& region);$/;"	p	class:MemoryRegionMap	access:private	signature:(const Region& region)
MemoryRegionMap::EXCLUSIVE_LOCK_FUNCTION	src/memory_region_map.h	/^  static void Lock() EXCLUSIVE_LOCK_FUNCTION(lock_);$/;"	p	class:MemoryRegionMap	access:public	signature:(lock_)
MemoryRegionMap::EndRegionLocked	src/memory_region_map.cc	/^MemoryRegionMap::RegionIterator MemoryRegionMap::EndRegionLocked() {$/;"	f	class:MemoryRegionMap	signature:()
MemoryRegionMap::EndRegionLocked	src/memory_region_map.h	/^  static RegionIterator EndRegionLocked();$/;"	p	class:MemoryRegionMap	access:public	signature:()
MemoryRegionMap::FindAndMarkStackRegion	src/memory_region_map.cc	/^bool MemoryRegionMap::FindAndMarkStackRegion(uintptr_t stack_top,$/;"	f	class:MemoryRegionMap	signature:(uintptr_t stack_top, Region* result)
MemoryRegionMap::FindAndMarkStackRegion	src/memory_region_map.h	/^  static bool FindAndMarkStackRegion(uintptr_t stack_top, Region* result);$/;"	p	class:MemoryRegionMap	access:public	signature:(uintptr_t stack_top, Region* result)
MemoryRegionMap::FindRegion	src/memory_region_map.cc	/^bool MemoryRegionMap::FindRegion(uintptr_t addr, Region* result) {$/;"	f	class:MemoryRegionMap	signature:(uintptr_t addr, Region* result)
MemoryRegionMap::FindRegion	src/memory_region_map.h	/^  static bool FindRegion(uintptr_t addr, Region* result);$/;"	p	class:MemoryRegionMap	access:public	signature:(uintptr_t addr, Region* result)
MemoryRegionMap::GUARDED_BY	src/memory_region_map.h	/^  static HeapProfileBucket saved_buckets_[20] GUARDED_BY(lock_);$/;"	p	class:MemoryRegionMap	access:private	signature:(lock_)
MemoryRegionMap::GUARDED_BY	src/memory_region_map.h	/^  static HeapProfileBucket** bucket_table_ GUARDED_BY(lock_);$/;"	p	class:MemoryRegionMap	access:private	signature:(lock_)
MemoryRegionMap::GUARDED_BY	src/memory_region_map.h	/^  static const void* saved_buckets_keys_[20][kMaxStackDepth] GUARDED_BY(lock_);$/;"	p	class:MemoryRegionMap	access:private	signature:(lock_)
MemoryRegionMap::GUARDED_BY	src/memory_region_map.h	/^  static int num_buckets_ GUARDED_BY(lock_);$/;"	p	class:MemoryRegionMap	access:private	signature:(lock_)
MemoryRegionMap::GUARDED_BY	src/memory_region_map.h	/^  static int saved_buckets_count_ GUARDED_BY(lock_);$/;"	p	class:MemoryRegionMap	access:private	signature:(lock_)
MemoryRegionMap::GetBucket	src/memory_region_map.cc	/^HeapProfileBucket* MemoryRegionMap::GetBucket(int depth,$/;"	f	class:MemoryRegionMap	signature:(int depth, const void* const key[])
MemoryRegionMap::GetBucket	src/memory_region_map.h	/^  static HeapProfileBucket* GetBucket(int depth, const void* const key[]);$/;"	p	class:MemoryRegionMap	access:public	signature:(int depth, const void* const key[])
MemoryRegionMap::HandleSavedRegionsLocked	src/memory_region_map.cc	/^inline void MemoryRegionMap::HandleSavedRegionsLocked($/;"	f	class:MemoryRegionMap	signature:( void (*insert_func)(const Region& region))
MemoryRegionMap::HandleSavedRegionsLocked	src/memory_region_map.h	/^  inline static void HandleSavedRegionsLocked($/;"	p	class:MemoryRegionMap	access:private	signature:( void (*insert_func)(const Region& region))
MemoryRegionMap::Init	src/memory_region_map.cc	/^void MemoryRegionMap::Init(int max_stack_depth, bool use_buckets) {$/;"	f	class:MemoryRegionMap	signature:(int max_stack_depth, bool use_buckets)
MemoryRegionMap::Init	src/memory_region_map.h	/^  static void Init(int max_stack_depth, bool use_buckets);$/;"	p	class:MemoryRegionMap	access:public	signature:(int max_stack_depth, bool use_buckets)
MemoryRegionMap::InsertRegionLocked	src/memory_region_map.cc	/^inline void MemoryRegionMap::InsertRegionLocked(const Region& region) {$/;"	f	class:MemoryRegionMap	signature:(const Region& region)
MemoryRegionMap::InsertRegionLocked	src/memory_region_map.h	/^  inline static void InsertRegionLocked(const Region& region);$/;"	p	class:MemoryRegionMap	access:private	signature:(const Region& region)
MemoryRegionMap::IsRecordingLocked	src/memory_region_map.cc	/^bool MemoryRegionMap::IsRecordingLocked() {$/;"	f	class:MemoryRegionMap	signature:()
MemoryRegionMap::IsRecordingLocked	src/memory_region_map.h	/^  static bool IsRecordingLocked();$/;"	p	class:MemoryRegionMap	access:public	signature:()
MemoryRegionMap::IterateBuckets	src/memory_region_map.h	/^  static void IterateBuckets(void (*callback)(const HeapProfileBucket*, Type),$/;"	p	class:MemoryRegionMap	access:public	signature:(void (*callback)(const HeapProfileBucket*, Type), Type arg)
MemoryRegionMap::IterateBuckets	src/memory_region_map.h	/^void MemoryRegionMap::IterateBuckets($/;"	f	class:MemoryRegionMap	signature:( void (*callback)(const HeapProfileBucket*, Type), Type callback_arg)
MemoryRegionMap::Lock	src/memory_region_map.cc	/^void MemoryRegionMap::Lock() {$/;"	f	class:MemoryRegionMap	signature:()
MemoryRegionMap::LockHolder	src/memory_region_map.h	/^  class LockHolder {$/;"	c	class:MemoryRegionMap	access:public
MemoryRegionMap::LockHolder::DISALLOW_COPY_AND_ASSIGN	src/memory_region_map.h	/^    DISALLOW_COPY_AND_ASSIGN(LockHolder);$/;"	p	class:MemoryRegionMap::LockHolder	access:private	signature:(LockHolder)
MemoryRegionMap::LockHolder::LockHolder	src/memory_region_map.h	/^    LockHolder() { Lock(); }$/;"	f	class:MemoryRegionMap::LockHolder	access:public	signature:()
MemoryRegionMap::LockHolder::~LockHolder	src/memory_region_map.h	/^    ~LockHolder() { Unlock(); }$/;"	f	class:MemoryRegionMap::LockHolder	access:public	signature:()
MemoryRegionMap::LockIsHeld	src/memory_region_map.cc	/^bool MemoryRegionMap::LockIsHeld() {$/;"	f	class:MemoryRegionMap	signature:()
MemoryRegionMap::LockIsHeld	src/memory_region_map.h	/^  static bool LockIsHeld();$/;"	p	class:MemoryRegionMap	access:public	signature:()
MemoryRegionMap::LogAllLocked	src/memory_region_map.cc	/^void MemoryRegionMap::LogAllLocked() {$/;"	f	class:MemoryRegionMap	signature:()
MemoryRegionMap::LogAllLocked	src/memory_region_map.h	/^  static void LogAllLocked();$/;"	p	class:MemoryRegionMap	access:private	signature:()
MemoryRegionMap::MapSize	src/memory_region_map.h	/^  static int64 MapSize() { return map_size_; }$/;"	f	class:MemoryRegionMap	access:public	signature:()
MemoryRegionMap::MmapHook	src/memory_region_map.cc	/^void MemoryRegionMap::MmapHook(const void* result,$/;"	f	class:MemoryRegionMap	signature:(const void* result, const void* start, size_t size, int prot, int flags, int fd, off_t offset)
MemoryRegionMap::MmapHook	src/memory_region_map.h	/^  static void MmapHook(const void* result,$/;"	p	class:MemoryRegionMap	access:private	signature:(const void* result, const void* start, size_t size, int prot, int flags, int fd, off_t offset)
MemoryRegionMap::MremapHook	src/memory_region_map.cc	/^void MemoryRegionMap::MremapHook(const void* result,$/;"	f	class:MemoryRegionMap	signature:(const void* result, const void* old_addr, size_t old_size, size_t new_size, int flags, const void* new_addr)
MemoryRegionMap::MremapHook	src/memory_region_map.h	/^  static void MremapHook(const void* result, const void* old_addr,$/;"	p	class:MemoryRegionMap	access:private	signature:(const void* result, const void* old_addr, size_t old_size, size_t new_size, int flags, const void* new_addr)
MemoryRegionMap::MunmapHook	src/memory_region_map.cc	/^void MemoryRegionMap::MunmapHook(const void* ptr, size_t size) {$/;"	f	class:MemoryRegionMap	signature:(const void* ptr, size_t size)
MemoryRegionMap::MunmapHook	src/memory_region_map.h	/^  static void MunmapHook(const void* ptr, size_t size);$/;"	p	class:MemoryRegionMap	access:private	signature:(const void* ptr, size_t size)
MemoryRegionMap::MyAllocator	src/memory_region_map.h	/^  struct MyAllocator {$/;"	s	class:MemoryRegionMap	access:private
MemoryRegionMap::MyAllocator::Allocate	src/memory_region_map.h	/^    static void *Allocate(size_t n) {$/;"	f	struct:MemoryRegionMap::MyAllocator	access:public	signature:(size_t n)
MemoryRegionMap::MyAllocator::Free	src/memory_region_map.h	/^    static void Free(const void *p, size_t \/* n *\/) {$/;"	f	struct:MemoryRegionMap::MyAllocator	access:public	signature:(const void *p, size_t )
MemoryRegionMap::RecordRegionAddition	src/memory_region_map.cc	/^void MemoryRegionMap::RecordRegionAddition(const void* start, size_t size) {$/;"	f	class:MemoryRegionMap	signature:(const void* start, size_t size)
MemoryRegionMap::RecordRegionAddition	src/memory_region_map.h	/^  static void RecordRegionAddition(const void* start, size_t size);$/;"	p	class:MemoryRegionMap	access:private	signature:(const void* start, size_t size)
MemoryRegionMap::RecordRegionRemoval	src/memory_region_map.cc	/^void MemoryRegionMap::RecordRegionRemoval(const void* start, size_t size) {$/;"	f	class:MemoryRegionMap	signature:(const void* start, size_t size)
MemoryRegionMap::RecordRegionRemoval	src/memory_region_map.h	/^  static void RecordRegionRemoval(const void* start, size_t size);$/;"	p	class:MemoryRegionMap	access:private	signature:(const void* start, size_t size)
MemoryRegionMap::RecordRegionRemovalInBucket	src/memory_region_map.cc	/^void MemoryRegionMap::RecordRegionRemovalInBucket(int depth,$/;"	f	class:MemoryRegionMap	signature:(int depth, const void* const stack[], size_t size)
MemoryRegionMap::RecordRegionRemovalInBucket	src/memory_region_map.h	/^  static void RecordRegionRemovalInBucket(int depth,$/;"	p	class:MemoryRegionMap	access:private	signature:(int depth, const void* const key[], size_t size)
MemoryRegionMap::Region	src/memory_region_map.h	/^  struct Region {$/;"	s	class:MemoryRegionMap	access:public
MemoryRegionMap::Region::AssertIsConsistent	src/memory_region_map.h	/^    void AssertIsConsistent() const {$/;"	f	struct:MemoryRegionMap::Region	access:private	signature:() const
MemoryRegionMap::Region::Create	src/memory_region_map.h	/^    void Create(const void* start, size_t size) {$/;"	f	struct:MemoryRegionMap::Region	access:private	signature:(const void* start, size_t size)
MemoryRegionMap::Region::Overlaps	src/memory_region_map.h	/^    bool Overlaps(const Region& x) const {$/;"	f	struct:MemoryRegionMap::Region	access:public	signature:(const Region& x) const
MemoryRegionMap::Region::SetRegionSetKey	src/memory_region_map.h	/^    void SetRegionSetKey(uintptr_t addr) {$/;"	f	struct:MemoryRegionMap::Region	access:private	signature:(uintptr_t addr)
MemoryRegionMap::Region::call_stack	src/memory_region_map.h	/^    const void* call_stack[kMaxStackDepth];  \/\/ caller address stack array$/;"	m	struct:MemoryRegionMap::Region	access:public
MemoryRegionMap::Region::call_stack_depth	src/memory_region_map.h	/^    int call_stack_depth;  \/\/ number of caller stack frames that we saved$/;"	m	struct:MemoryRegionMap::Region	access:public
MemoryRegionMap::Region::caller	src/memory_region_map.h	/^    uintptr_t caller() const {$/;"	f	struct:MemoryRegionMap::Region	access:public	signature:() const
MemoryRegionMap::Region::end_addr	src/memory_region_map.h	/^    uintptr_t end_addr;  \/\/ region end address$/;"	m	struct:MemoryRegionMap::Region	access:public
MemoryRegionMap::Region::is_stack	src/memory_region_map.h	/^    bool is_stack;  \/\/ does this region contain a thread's stack:$/;"	m	struct:MemoryRegionMap::Region	access:public
MemoryRegionMap::Region::set_call_stack_depth	src/memory_region_map.h	/^    void set_call_stack_depth(int depth) {$/;"	f	struct:MemoryRegionMap::Region	access:private	signature:(int depth)
MemoryRegionMap::Region::set_end_addr	src/memory_region_map.h	/^    void set_end_addr(uintptr_t addr) {$/;"	f	struct:MemoryRegionMap::Region	access:private	signature:(uintptr_t addr)
MemoryRegionMap::Region::set_is_stack	src/memory_region_map.h	/^    void set_is_stack() { is_stack = true; }$/;"	f	struct:MemoryRegionMap::Region	access:private	signature:()
MemoryRegionMap::Region::set_start_addr	src/memory_region_map.h	/^    void set_start_addr(uintptr_t addr) {$/;"	f	struct:MemoryRegionMap::Region	access:private	signature:(uintptr_t addr)
MemoryRegionMap::Region::start_addr	src/memory_region_map.h	/^    uintptr_t start_addr;  \/\/ region start address$/;"	m	struct:MemoryRegionMap::Region	access:public
MemoryRegionMap::RegionCmp	src/memory_region_map.h	/^  struct RegionCmp {$/;"	s	class:MemoryRegionMap	access:private
MemoryRegionMap::RegionCmp::operator ()	src/memory_region_map.h	/^    bool operator()(const Region& x, const Region& y) const {$/;"	f	struct:MemoryRegionMap::RegionCmp	access:public	signature:(const Region& x, const Region& y) const
MemoryRegionMap::RegionIterator	src/memory_region_map.h	/^  typedef RegionSet::const_iterator RegionIterator;$/;"	t	class:MemoryRegionMap	access:public
MemoryRegionMap::RegionSet	src/memory_region_map.h	/^              STL_Allocator<Region, MyAllocator> > RegionSet;$/;"	t	class:MemoryRegionMap	access:private
MemoryRegionMap::RegionSetRep	src/memory_region_map.cc	/^union MemoryRegionMap::RegionSetRep {$/;"	u	class:MemoryRegionMap	file:
MemoryRegionMap::RegionSetRep::align_it	src/memory_region_map.cc	/^  void* align_it;  \/\/ do not need a better alignment for 'rep' than this$/;"	m	union:MemoryRegionMap::RegionSetRep	file:	access:public
MemoryRegionMap::RegionSetRep::region_set	src/memory_region_map.cc	/^  RegionSet* region_set() { return reinterpret_cast<RegionSet*>(rep); }$/;"	f	union:MemoryRegionMap::RegionSetRep	access:public	signature:()
MemoryRegionMap::RegionSetRep::rep	src/memory_region_map.cc	/^  char rep[sizeof(RegionSet)];$/;"	m	union:MemoryRegionMap::RegionSetRep	file:	access:public
MemoryRegionMap::RestoreSavedBucketsLocked	src/memory_region_map.cc	/^void MemoryRegionMap::RestoreSavedBucketsLocked() {$/;"	f	class:MemoryRegionMap	signature:()
MemoryRegionMap::RestoreSavedBucketsLocked	src/memory_region_map.h	/^  static void RestoreSavedBucketsLocked();$/;"	p	class:MemoryRegionMap	access:private	signature:()
MemoryRegionMap::SbrkHook	src/memory_region_map.cc	/^void MemoryRegionMap::SbrkHook(const void* result, ptrdiff_t increment) {$/;"	f	class:MemoryRegionMap	signature:(const void* result, ptrdiff_t increment)
MemoryRegionMap::SbrkHook	src/memory_region_map.h	/^  static void SbrkHook(const void* result, ptrdiff_t increment);$/;"	p	class:MemoryRegionMap	access:private	signature:(const void* result, ptrdiff_t increment)
MemoryRegionMap::Shutdown	src/memory_region_map.cc	/^bool MemoryRegionMap::Shutdown() {$/;"	f	class:MemoryRegionMap	signature:()
MemoryRegionMap::Shutdown	src/memory_region_map.h	/^  static bool Shutdown();$/;"	p	class:MemoryRegionMap	access:public	signature:()
MemoryRegionMap::UNLOCK_FUNCTION	src/memory_region_map.h	/^  static void Unlock() UNLOCK_FUNCTION(lock_);$/;"	p	class:MemoryRegionMap	access:public	signature:(lock_)
MemoryRegionMap::Unlock	src/memory_region_map.cc	/^void MemoryRegionMap::Unlock() {$/;"	f	class:MemoryRegionMap	signature:()
MemoryRegionMap::UnmapSize	src/memory_region_map.h	/^  static int64 UnmapSize() { return unmap_size_; }$/;"	f	class:MemoryRegionMap	access:public	signature:()
MemoryRegionMap::arena_	src/memory_region_map.cc	/^LowLevelAlloc::Arena* MemoryRegionMap::arena_ = NULL;$/;"	m	class:MemoryRegionMap	file:
MemoryRegionMap::arena_	src/memory_region_map.h	/^  static LowLevelAlloc::Arena* arena_;$/;"	m	class:MemoryRegionMap	access:private
MemoryRegionMap::bucket_table_	src/memory_region_map.cc	/^HeapProfileBucket** MemoryRegionMap::bucket_table_ = NULL;  \/\/ GUARDED_BY(lock_)$/;"	m	class:MemoryRegionMap	file:
MemoryRegionMap::client_count_	src/memory_region_map.cc	/^int MemoryRegionMap::client_count_ = 0;$/;"	m	class:MemoryRegionMap	file:
MemoryRegionMap::client_count_	src/memory_region_map.h	/^  static int client_count_;$/;"	m	class:MemoryRegionMap	access:private
MemoryRegionMap::kHashTableSize	src/memory_region_map.h	/^  static const int kHashTableSize = 179999;$/;"	m	class:MemoryRegionMap	access:private
MemoryRegionMap::kMaxStackDepth	src/memory_region_map.h	/^  static const int kMaxStackDepth = 32;$/;"	m	class:MemoryRegionMap	access:private
MemoryRegionMap::lock_	src/memory_region_map.cc	/^SpinLock MemoryRegionMap::lock_(SpinLock::LINKER_INITIALIZED);$/;"	p	class:MemoryRegionMap	file:	signature:(SpinLock::LINKER_INITIALIZED)
MemoryRegionMap::lock_	src/memory_region_map.h	/^  static SpinLock lock_;$/;"	m	class:MemoryRegionMap	access:private
MemoryRegionMap::lock_owner_tid_	src/memory_region_map.cc	/^pthread_t MemoryRegionMap::lock_owner_tid_;  \/\/ GUARDED_BY(owner_lock_)$/;"	m	class:MemoryRegionMap	file:
MemoryRegionMap::lock_owner_tid_	src/memory_region_map.h	/^  static pthread_t lock_owner_tid_;$/;"	m	class:MemoryRegionMap	access:private
MemoryRegionMap::map_size_	src/memory_region_map.cc	/^int64 MemoryRegionMap::map_size_ = 0;$/;"	m	class:MemoryRegionMap	file:
MemoryRegionMap::map_size_	src/memory_region_map.h	/^  static int64 map_size_;$/;"	m	class:MemoryRegionMap	access:private
MemoryRegionMap::max_stack_depth_	src/memory_region_map.cc	/^int MemoryRegionMap::max_stack_depth_ = 0;$/;"	m	class:MemoryRegionMap	file:
MemoryRegionMap::max_stack_depth_	src/memory_region_map.h	/^  static int max_stack_depth_;$/;"	m	class:MemoryRegionMap	access:private
MemoryRegionMap::num_buckets_	src/memory_region_map.cc	/^int MemoryRegionMap::num_buckets_ = 0;  \/\/ GUARDED_BY(lock_)$/;"	m	class:MemoryRegionMap	file:
MemoryRegionMap::owner_lock_	src/memory_region_map.cc	/^SpinLock MemoryRegionMap::owner_lock_(  \/\/ ACQUIRED_AFTER(lock_)$/;"	p	class:MemoryRegionMap	file:	signature:( SpinLock::LINKER_INITIALIZED)
MemoryRegionMap::owner_lock_	src/memory_region_map.h	/^  static SpinLock owner_lock_;$/;"	m	class:MemoryRegionMap	access:private
MemoryRegionMap::recursion_count_	src/memory_region_map.cc	/^int MemoryRegionMap::recursion_count_ = 0;  \/\/ GUARDED_BY(owner_lock_)$/;"	m	class:MemoryRegionMap	file:
MemoryRegionMap::recursion_count_	src/memory_region_map.h	/^  static int recursion_count_;$/;"	m	class:MemoryRegionMap	access:private
MemoryRegionMap::regions_	src/memory_region_map.cc	/^MemoryRegionMap::RegionSet* MemoryRegionMap::regions_ = NULL;$/;"	m	class:MemoryRegionMap	file:
MemoryRegionMap::regions_	src/memory_region_map.h	/^  static RegionSet* regions_;$/;"	m	class:MemoryRegionMap	access:private
MemoryRegionMap::saved_buckets_	src/memory_region_map.cc	/^HeapProfileBucket MemoryRegionMap::saved_buckets_[20];  \/\/ GUARDED_BY(lock_)$/;"	m	class:MemoryRegionMap	file:
MemoryRegionMap::saved_buckets_count_	src/memory_region_map.cc	/^int MemoryRegionMap::saved_buckets_count_ = 0;  \/\/ GUARDED_BY(lock_)$/;"	m	class:MemoryRegionMap	file:
MemoryRegionMap::saved_buckets_keys_	src/memory_region_map.cc	/^const void* MemoryRegionMap::saved_buckets_keys_[20][kMaxStackDepth];$/;"	m	class:MemoryRegionMap	file:
MemoryRegionMap::unmap_size_	src/memory_region_map.cc	/^int64 MemoryRegionMap::unmap_size_ = 0;$/;"	m	class:MemoryRegionMap	file:
MemoryRegionMap::unmap_size_	src/memory_region_map.h	/^  static int64 unmap_size_;$/;"	m	class:MemoryRegionMap	access:private
MemoryStats	src/debugallocation.cc	/^  static bool MemoryStats(int* blocks, size_t* total,$/;"	f	class:MallocBlock	access:public	signature:(int* blocks, size_t* total, int histogram[kMallocHistogramSize])
MergeIntoFreeList	src/page_heap.cc	/^void PageHeap::MergeIntoFreeList(Span* span) {$/;"	f	class:tcmalloc::PageHeap	signature:(Span* span)
MergeIntoFreeList	src/page_heap.h	/^  void MergeIntoFreeList(Span* span);$/;"	p	class:tcmalloc::PageHeap	access:private	signature:(Span* span)
MetaDataAlloc	src/common.cc	/^void* MetaDataAlloc(size_t bytes) {$/;"	f	namespace:tcmalloc	signature:(size_t bytes)
MetaDataAlloc	src/common.h	/^void* MetaDataAlloc(size_t bytes);$/;"	p	namespace:tcmalloc	signature:(size_t bytes)
MiniDisassembler	src/windows/mini_disassembler.cc	/^MiniDisassembler::MiniDisassembler()$/;"	f	class:sidestep::MiniDisassembler	signature:()
MiniDisassembler	src/windows/mini_disassembler.cc	/^MiniDisassembler::MiniDisassembler(bool operand_default_is_32_bits,$/;"	f	class:sidestep::MiniDisassembler	signature:(bool operand_default_is_32_bits, bool address_default_is_32_bits)
MiniDisassembler	src/windows/mini_disassembler.h	/^  MiniDisassembler();$/;"	p	class:sidestep::MiniDisassembler	access:public	signature:()
MiniDisassembler	src/windows/mini_disassembler.h	/^  MiniDisassembler(bool operand_default_32_bits,$/;"	p	class:sidestep::MiniDisassembler	access:public	signature:(bool operand_default_32_bits, bool address_default_32_bits)
MiniDisassembler	src/windows/mini_disassembler.h	/^class PERFTOOLS_DLL_DECL MiniDisassembler {$/;"	c	namespace:sidestep
MmapHook	src/gperftools/malloc_hook.h	/^  typedef MallocHook_MmapHook MmapHook;$/;"	t	class:MallocHook	access:public
MmapHook	src/heap-profiler.cc	/^static void MmapHook(const void* result, const void* start, size_t size,$/;"	f	file:	signature:(const void* result, const void* start, size_t size, int prot, int flags, int fd, off_t offset)
MmapHook	src/memory_region_map.cc	/^void MemoryRegionMap::MmapHook(const void* result,$/;"	f	class:MemoryRegionMap	signature:(const void* result, const void* start, size_t size, int prot, int flags, int fd, off_t offset)
MmapHook	src/memory_region_map.h	/^  static void MmapHook(const void* result,$/;"	p	class:MemoryRegionMap	access:private	signature:(const void* result, const void* start, size_t size, int prot, int flags, int fd, off_t offset)
MmapReplacement	src/gperftools/malloc_hook.h	/^  typedef MallocHook_MmapReplacement MmapReplacement;$/;"	t	class:MallocHook	access:public
MmapReplacement	src/tests/malloc_hook_test.cc	/^int MmapReplacement(const void* start,$/;"	f	namespace:__anon57	signature:(const void* start, size_t size, int protection, int flags, int fd, off_t offset, void** result)
MmapSysAllocator	src/system-alloc.cc	/^  MmapSysAllocator() : SysAllocator() {$/;"	f	class:MmapSysAllocator	access:public	signature:()
MmapSysAllocator	src/system-alloc.cc	/^class MmapSysAllocator : public SysAllocator {$/;"	c	file:	inherits:SysAllocator
MmapSysAllocator::Alloc	src/system-alloc.cc	/^  void* Alloc(size_t size, size_t *actual_size, size_t alignment);$/;"	p	class:MmapSysAllocator	file:	access:public	signature:(size_t size, size_t *actual_size, size_t alignment)
MmapSysAllocator::Alloc	src/system-alloc.cc	/^void* MmapSysAllocator::Alloc(size_t size, size_t *actual_size,$/;"	f	class:MmapSysAllocator	signature:(size_t size, size_t *actual_size, size_t alignment)
MmapSysAllocator::MmapSysAllocator	src/system-alloc.cc	/^  MmapSysAllocator() : SysAllocator() {$/;"	f	class:MmapSysAllocator	access:public	signature:()
Mmapper	src/tests/heap-checker_unittest.cc	/^static void* Mmapper(uintptr_t* addr_after_mmap_call) {$/;"	f	file:	signature:(uintptr_t* addr_after_mmap_call)
ModrmEntry	src/windows/mini_disassembler_types.h	/^struct ModrmEntry {$/;"	s	namespace:sidestep
Module32First	src/base/sysinfo.cc	72;"	d	file:
Module32Next	src/base/sysinfo.cc	73;"	d	file:
ModuleEntryCopy	src/windows/patch_functions.cc	/^  ModuleEntryCopy() {$/;"	f	struct:__anon13::ModuleEntryCopy	access:public	signature:()
ModuleEntryCopy	src/windows/patch_functions.cc	/^  ModuleEntryCopy(const MODULEINFO& mi) {$/;"	f	struct:__anon13::ModuleEntryCopy	access:public	signature:(const MODULEINFO& mi)
ModuleEntryCopy	src/windows/patch_functions.cc	/^struct ModuleEntryCopy {$/;"	s	namespace:__anon13	file:
MremapHook	src/gperftools/malloc_hook.h	/^  typedef MallocHook_MremapHook MremapHook;$/;"	t	class:MallocHook	access:public
MremapHook	src/heap-profiler.cc	/^static void MremapHook(const void* result, const void* old_addr,$/;"	f	file:	signature:(const void* result, const void* old_addr, size_t old_size, size_t new_size, int flags, const void* new_addr)
MremapHook	src/memory_region_map.cc	/^void MemoryRegionMap::MremapHook(const void* result,$/;"	f	class:MemoryRegionMap	signature:(const void* result, const void* old_addr, size_t old_size, size_t new_size, int flags, const void* new_addr)
MremapHook	src/memory_region_map.h	/^  static void MremapHook(const void* result, const void* old_addr,$/;"	p	class:MemoryRegionMap	access:private	signature:(const void* result, const void* old_addr, size_t old_size, size_t new_size, int flags, const void* new_addr)
MultipleCallbacks	src/tests/profile-handler_unittest.cc	/^  void MultipleCallbacks();$/;"	p	class:__anon56::ProfileHandlerTest	file:	access:private	signature:()
MultipleIdleCalls	src/tests/markidle_unittest.cc	/^static void MultipleIdleCalls() {$/;"	f	file:	signature:()
MultipleIdleNonIdlePhases	src/tests/markidle_unittest.cc	/^static void MultipleIdleNonIdlePhases() {$/;"	f	file:	signature:()
MultithreadedTestThread	src/tests/malloc_hook_test.cc	/^void MultithreadedTestThread(TestHookList* list, int shift,$/;"	f	namespace:__anon57	signature:(TestHookList* list, int shift, int thread_num)
MultithreadedTestThreadRunner	src/tests/malloc_hook_test.cc	/^void MultithreadedTestThreadRunner(int thread_num) {$/;"	f	namespace:__anon57	signature:(int thread_num)
MunmapHook	src/gperftools/malloc_hook.h	/^  typedef MallocHook_MunmapHook MunmapHook;$/;"	t	class:MallocHook	access:public
MunmapHook	src/heap-profiler.cc	/^static void MunmapHook(const void* ptr, size_t size) {$/;"	f	file:	signature:(const void* ptr, size_t size)
MunmapHook	src/memory_region_map.cc	/^void MemoryRegionMap::MunmapHook(const void* ptr, size_t size) {$/;"	f	class:MemoryRegionMap	signature:(const void* ptr, size_t size)
MunmapHook	src/memory_region_map.h	/^  static void MunmapHook(const void* ptr, size_t size);$/;"	p	class:MemoryRegionMap	access:private	signature:(const void* ptr, size_t size)
MunmapReplacement	src/gperftools/malloc_hook.h	/^  typedef MallocHook_MunmapReplacement MunmapReplacement;$/;"	t	class:MallocHook	access:public
MunmapReplacement	src/tests/malloc_hook_test.cc	/^int MunmapReplacement(const void* ptr, size_t size, int* result) {$/;"	f	namespace:__anon57	signature:(const void* ptr, size_t size, int* result)
MustGet	src/tests/packed-cache_test.cc	/^static size_t MustGet(const PackedCache<kKeybits>& cache, uintptr_t key) {$/;"	f	file:	signature:(const PackedCache<kKeybits>& cache, uintptr_t key)
Mutex	src/base/simple_mutex.h	/^  Mutex(Mutex* \/*ignored*\/) {}$/;"	f	class:MUTEX_NAMESPACE::Mutex	access:private	signature:(Mutex* )
Mutex	src/base/simple_mutex.h	/^  Mutex(const Mutex&);$/;"	p	class:MUTEX_NAMESPACE::Mutex	access:private	signature:(const Mutex&)
Mutex	src/base/simple_mutex.h	/^  inline Mutex();$/;"	p	class:MUTEX_NAMESPACE::Mutex	access:public	signature:()
Mutex	src/base/simple_mutex.h	/^  inline Mutex(LinkerInitialized);$/;"	p	class:MUTEX_NAMESPACE::Mutex	access:public	signature:(LinkerInitialized)
Mutex	src/base/simple_mutex.h	/^Mutex::Mutex() : destroy_(true) {$/;"	f	class:MUTEX_NAMESPACE::Mutex	signature:()
Mutex	src/base/simple_mutex.h	/^Mutex::Mutex() : mutex_(0) { }$/;"	f	class:MUTEX_NAMESPACE::Mutex	signature:()
Mutex	src/base/simple_mutex.h	/^Mutex::Mutex(LinkerInitialized) : destroy_(false) {$/;"	f	class:MUTEX_NAMESPACE::Mutex	signature:(LinkerInitialized)
Mutex	src/base/simple_mutex.h	/^Mutex::Mutex(Mutex::LinkerInitialized) : destroy_(false) {$/;"	f	class:MUTEX_NAMESPACE::Mutex	signature:(Mutex::LinkerInitialized)
Mutex	src/base/simple_mutex.h	/^Mutex::Mutex(Mutex::LinkerInitialized) : mutex_(0) { }$/;"	f	class:MUTEX_NAMESPACE::Mutex	signature:(Mutex::LinkerInitialized)
Mutex	src/base/simple_mutex.h	/^class Mutex {$/;"	c	namespace:MUTEX_NAMESPACE
MutexLock	src/base/simple_mutex.h	/^  MutexLock(const MutexLock&);$/;"	p	class:MUTEX_NAMESPACE::MutexLock	access:private	signature:(const MutexLock&)
MutexLock	src/base/simple_mutex.h	/^  explicit MutexLock(Mutex *mu) : mu_(mu) { mu_->Lock(); }$/;"	f	class:MUTEX_NAMESPACE::MutexLock	access:public	signature:(Mutex *mu)
MutexLock	src/base/simple_mutex.h	/^class MutexLock {$/;"	c	namespace:MUTEX_NAMESPACE
MutexLock	src/base/simple_mutex.h	322;"	d
MutexType	src/base/simple_mutex.h	/^  typedef CRITICAL_SECTION MutexType;$/;"	t
MutexType	src/base/simple_mutex.h	/^  typedef int MutexType;      \/\/ to keep a lock-count$/;"	t
MutexType	src/base/simple_mutex.h	/^  typedef pthread_mutex_t MutexType;$/;"	t
MutexType	src/base/simple_mutex.h	/^  typedef pthread_rwlock_t MutexType;$/;"	t
MyAllocator	src/memory_region_map.h	/^  struct MyAllocator {$/;"	s	class:MemoryRegionMap	access:private
N	benchmark/unwind_bench-getcontext_light.o	/^/;"	v
N	src/.libs/libtcmalloc_internal_la-page_heap.o	/^/;"	v
N	src/.libs/libtcmalloc_minimal_internal_la-page_heap.o	/^/;"	v
N	src/libtcmalloc_internal_la-page_heap.o	/^/;"	v
N	src/libtcmalloc_minimal_internal_la-page_heap.o	/^/;"	v
N12_GLOBAL__N_16ThreadE	src/tests/profile_handler_unittest-profile-handler_unittest.o	/^/;"	v
N6	src/tests/current_allocated_bytes_test-current_allocated_bytes_test.o	/^&/;"	v
NM	m4/libtool.m4	/^    NM="$DUMPBIN"$/;"	v
NM	m4/libtool.m4	/^  NM="$lt_cv_path_NM"$/;"	v
NOMINMAX	src/base/logging.h	245;"	d
NOMINMAX	src/windows/port.cc	39;"	d	file:
NOT	src/windows/shortproc.asm	/^; "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT$/;"	v
NO_HEAP_CHECK	src/windows/config.h	315;"	d
NO_INTR	src/base/linuxthreads.cc	145;"	d	file:
NO_INTR	src/base/logging.cc	88;"	d	file:
NO_INTR	src/base/sysinfo.cc	84;"	d	file:
NO_INTR	src/profiledata.cc	137;"	d	file:
NO_INTR	src/tests/profiledata_unittest.cc	70;"	d	file:
NO_LEAKS	src/tests/heap-checker_unittest.cc	/^enum CheckType { SAME_HEAP, NO_LEAKS };$/;"	e	enum:CheckType	file:
NO_MINUS_C_MINUS_O	src/config.h.in	224;"	d	file:
NO_MINUS_C_MINUS_O	src/windows/config.h	227;"	d
NO_SHARED_LIBS_IN_PROC_MAPS	src/gperftools/heap-checker.h	/^    NO_SHARED_LIBS_IN_PROC_MAPS$/;"	e	enum:HeapLeakChecker::ProcMapsResult
NO_THREAD_SAFETY_ANALYSIS	src/base/thread_annotations.h	131;"	d
NO_THREAD_SAFETY_ANALYSIS	src/profile-handler.cc	/^      NO_THREAD_SAFETY_ANALYSIS;$/;"	m	class:ProfileHandler	file:	access:public
NULLCMD	binary_trees_shared	/^  NULLCMD=:$/;"	v
NULLCMD	config.status	/^  NULLCMD=:$/;"	v
NULLCMD	configure	/^  NULLCMD=:$/;"	v
NULLCMD	current_allocated_bytes_test	/^  NULLCMD=:$/;"	v
NULLCMD	debugallocation_test	/^  NULLCMD=:$/;"	v
NULLCMD	frag_unittest	/^  NULLCMD=:$/;"	v
NULLCMD	heap-checker_debug_unittest	/^  NULLCMD=:$/;"	v
NULLCMD	heap-checker_unittest	/^  NULLCMD=:$/;"	v
NULLCMD	heap-profiler_debug_unittest	/^  NULLCMD=:$/;"	v
NULLCMD	heap-profiler_unittest	/^  NULLCMD=:$/;"	v
NULLCMD	libtool	/^  NULLCMD=:$/;"	v
NULLCMD	ltmain.sh	/^  NULLCMD=:$/;"	v
NULLCMD	malloc_bench_shared	/^  NULLCMD=:$/;"	v
NULLCMD	malloc_bench_shared_full	/^  NULLCMD=:$/;"	v
NULLCMD	malloc_extension_c_test	/^  NULLCMD=:$/;"	v
NULLCMD	malloc_extension_debug_test	/^  NULLCMD=:$/;"	v
NULLCMD	malloc_extension_test	/^  NULLCMD=:$/;"	v
NULLCMD	malloc_hook_test	/^  NULLCMD=:$/;"	v
NULLCMD	markidle_unittest	/^  NULLCMD=:$/;"	v
NULLCMD	memalign_debug_unittest	/^  NULLCMD=:$/;"	v
NULLCMD	memalign_unittest	/^  NULLCMD=:$/;"	v
NULLCMD	packed_cache_test	/^  NULLCMD=:$/;"	v
NULLCMD	page_heap_test	/^  NULLCMD=:$/;"	v
NULLCMD	pagemap_unittest	/^  NULLCMD=:$/;"	v
NULLCMD	profile_handler_unittest	/^  NULLCMD=:$/;"	v
NULLCMD	profiledata_unittest	/^  NULLCMD=:$/;"	v
NULLCMD	profiler1_unittest	/^  NULLCMD=:$/;"	v
NULLCMD	profiler2_unittest	/^  NULLCMD=:$/;"	v
NULLCMD	profiler3_unittest	/^  NULLCMD=:$/;"	v
NULLCMD	profiler4_unittest	/^  NULLCMD=:$/;"	v
NULLCMD	raw_printer_test	/^  NULLCMD=:$/;"	v
NULLCMD	realloc_debug_unittest	/^  NULLCMD=:$/;"	v
NULLCMD	realloc_unittest	/^  NULLCMD=:$/;"	v
NULLCMD	sampler_debug_test	/^  NULLCMD=:$/;"	v
NULLCMD	sampler_test	/^  NULLCMD=:$/;"	v
NULLCMD	sampling_debug_test	/^  NULLCMD=:$/;"	v
NULLCMD	sampling_test	/^  NULLCMD=:$/;"	v
NULLCMD	simple_compat_test	/^  NULLCMD=:$/;"	v
NULLCMD	stack_trace_table_test	/^  NULLCMD=:$/;"	v
NULLCMD	system_alloc_unittest	/^  NULLCMD=:$/;"	v
NULLCMD	tags	/^NULLCMD	configure	\/^  NULLCMD=:$\/;"	v$/;"	v
NULLCMD	tcmalloc_and_profiler_unittest	/^  NULLCMD=:$/;"	v
NULLCMD	tcmalloc_both_unittest	/^  NULLCMD=:$/;"	v
NULLCMD	tcmalloc_debug_unittest	/^  NULLCMD=:$/;"	v
NULLCMD	tcmalloc_large_heap_fragmentation_unittest	/^  NULLCMD=:$/;"	v
NULLCMD	tcmalloc_large_unittest	/^  NULLCMD=:$/;"	v
NULLCMD	tcmalloc_minimal_debug_unittest	/^  NULLCMD=:$/;"	v
NULLCMD	tcmalloc_minimal_large_heap_fragmentation_unittest	/^  NULLCMD=:$/;"	v
NULLCMD	tcmalloc_minimal_large_unittest	/^  NULLCMD=:$/;"	v
NULLCMD	tcmalloc_minimal_unittest	/^  NULLCMD=:$/;"	v
NULLCMD	tcmalloc_unittest	/^  NULLCMD=:$/;"	v
NULLCMD	thread_dealloc_unittest	/^  NULLCMD=:$/;"	v
NULLCMD	unwind_bench	/^  NULLCMD=:$/;"	v
NUM_BITS	src/tests/atomicops_unittest.cc	42;"	d	file:
NVALGRIND	src/third_party/valgrind.h	116;"	d
N_ONES_	src/packed-cache-inl.h	126;"	d
N_ONES_	src/packed-cache-inl.h	214;"	d
NamedTwoDisabledLeaks	src/gperftools/heap-checker.h	/^  friend void NamedTwoDisabledLeaks();$/;"	p	class:HeapLeakChecker	access:friend	signature:()
Nesting	src/tests/heap-checker_unittest.cc	/^  Nesting() : i0(this), i1(this), i2(this), i3(this) {}$/;"	f	struct:Nesting	access:public	signature:()
Nesting	src/tests/heap-checker_unittest.cc	/^struct Nesting {$/;"	s	file:
Nesting::Inner	src/tests/heap-checker_unittest.cc	/^  struct Inner {$/;"	s	struct:Nesting	file:	access:public
Nesting::Inner::Inner	src/tests/heap-checker_unittest.cc	/^    Inner(Nesting* p) : parent(p) {}$/;"	f	struct:Nesting::Inner	access:public	signature:(Nesting* p)
Nesting::Inner::parent	src/tests/heap-checker_unittest.cc	/^    Nesting* parent;$/;"	m	struct:Nesting::Inner	file:	access:public
Nesting::Nesting	src/tests/heap-checker_unittest.cc	/^  Nesting() : i0(this), i1(this), i2(this), i3(this) {}$/;"	f	struct:Nesting	access:public	signature:()
Nesting::i0	src/tests/heap-checker_unittest.cc	/^  Inner i0;$/;"	m	struct:Nesting	file:	access:public
Nesting::i1	src/tests/heap-checker_unittest.cc	/^  Inner i1;$/;"	m	struct:Nesting	file:	access:public
Nesting::i2	src/tests/heap-checker_unittest.cc	/^  Inner i2;$/;"	m	struct:Nesting	file:	access:public
Nesting::i3	src/tests/heap-checker_unittest.cc	/^  Inner i3;$/;"	m	struct:Nesting	file:	access:public
Nesting::n1	src/tests/heap-checker_unittest.cc	/^  char n1[5];$/;"	m	struct:Nesting	file:	access:public
Nesting::n2	src/tests/heap-checker_unittest.cc	/^  char n2[11];$/;"	m	struct:Nesting	file:	access:public
Nesting::n3	src/tests/heap-checker_unittest.cc	/^  char n3[27];$/;"	m	struct:Nesting	file:	access:public
New	src/addressmap-inl.h	/^  template <class T> T* New(int num) {$/;"	f	class:AddressMap	access:private	signature:(int num)
New	src/page_heap.cc	/^Span* PageHeap::New(Length n) {$/;"	f	class:tcmalloc::PageHeap	signature:(Length n)
New	src/page_heap.h	/^  Span* New(Length n);$/;"	p	class:tcmalloc::PageHeap	access:public	signature:(Length n)
New	src/page_heap_allocator.h	/^  T* New() {$/;"	f	class:tcmalloc::PageHeapAllocator	access:public	signature:()
NewArena	src/base/low_level_alloc.cc	/^LowLevelAlloc::Arena *LowLevelAlloc::NewArena(int32 flags,$/;"	f	class:LowLevelAlloc	signature:(int32 flags, Arena *meta_data_arena)
NewArena	src/base/low_level_alloc.h	/^  static Arena *NewArena(int32 flags, Arena *meta_data_arena);$/;"	p	class:LowLevelAlloc	access:public	signature:(int32 flags, Arena *meta_data_arena)
NewArenaWithCustomAlloc	src/base/low_level_alloc.cc	/^LowLevelAlloc::Arena *LowLevelAlloc::NewArenaWithCustomAlloc(int32 flags,$/;"	f	class:LowLevelAlloc	signature:(int32 flags, Arena *meta_data_arena, PagesAllocator *allocator)
NewArenaWithCustomAlloc	src/base/low_level_alloc.h	/^  static Arena *NewArenaWithCustomAlloc(int32 flags, Arena *meta_data_arena, PagesAllocator *allocator);$/;"	p	class:LowLevelAlloc	access:public	signature:(int32 flags, Arena *meta_data_arena, PagesAllocator *allocator)
NewCallback	src/tests/heap-checker_unittest.cc	/^inline Callback0* NewCallback(void (*function)()) {$/;"	f	signature:(void (*function)())
NewCallback	src/tests/heap-checker_unittest.cc	/^inline Callback1<P1>* NewCallback(void (*function)(P1), P1 p1) {$/;"	f	signature:(void (*function)(P1), P1 p1)
NewCallback	src/tests/heap-checker_unittest.cc	/^inline Callback2<P1,P2>* NewCallback(void (*function)(P1,P2), P1 p1, P2 p2) {$/;"	f	signature:(void (*function)(P1,P2), P1 p1, P2 p2)
NewHeap	src/thread_cache.cc	/^ThreadCache* ThreadCache::NewHeap(pthread_t tid) {$/;"	f	class:tcmalloc::ThreadCache	signature:(pthread_t tid)
NewHeap	src/thread_cache.h	/^  static ThreadCache* NewHeap(pthread_t tid);$/;"	p	class:tcmalloc::ThreadCache	access:private	signature:(pthread_t tid)
NewHook	src/gperftools/malloc_hook.h	/^  typedef MallocHook_NewHook NewHook;$/;"	t	class:MallocHook	access:public
NewHook	src/heap-checker.cc	/^static void NewHook(const void* ptr, size_t size) {$/;"	f	file:	signature:(const void* ptr, size_t size)
NewHook	src/heap-profiler.cc	/^static void NewHook(const void* ptr, size_t size);$/;"	p	file:	signature:(const void* ptr, size_t size)
NewHook	src/heap-profiler.cc	/^void NewHook(const void* ptr, size_t size) {$/;"	f	signature:(const void* ptr, size_t size)
NewNode	src/pagemap.h	/^  Node* NewNode() {$/;"	f	class:TCMalloc_PageMap3	access:private	signature:()
NewSpan	src/span.cc	/^Span* NewSpan(PageID p, Length len) {$/;"	f	namespace:tcmalloc	signature:(PageID p, Length len)
NewSpan	src/span.h	/^Span* NewSpan(PageID p, Length len);$/;"	p	namespace:tcmalloc	signature:(PageID p, Length len)
Next	src/base/low_level_alloc.cc	/^static AllocList *Next(int i, AllocList *prev, LowLevelAlloc::Arena *arena) {$/;"	f	file:	signature:(int i, AllocList *prev, LowLevelAlloc::Arena *arena)
Next	src/base/sysinfo.cc	/^bool ProcMapsIterator::Next(uint64 *start, uint64 *end, char **flags,$/;"	f	class:ProcMapsIterator	signature:(uint64 *start, uint64 *end, char **flags, uint64 *offset, int64 *inode, char **filename)
Next	src/base/sysinfo.h	/^  bool Next(uint64 *start, uint64 *end, char **flags,$/;"	p	class:ProcMapsIterator	access:public	signature:(uint64 *start, uint64 *end, char **flags, uint64 *offset, int64 *inode, char **filename)
Next	src/pagemap.h	/^  void* Next(Number k) const {$/;"	f	class:TCMalloc_PageMap1	access:public	signature:(Number k) const
Next	src/pagemap.h	/^  void* Next(Number k) const {$/;"	f	class:TCMalloc_PageMap2	access:public	signature:(Number k) const
Next	src/pagemap.h	/^  void* Next(Number k) const {$/;"	f	class:TCMalloc_PageMap3	access:public	signature:(Number k) const
Next	src/tests/tcmalloc_unittest.cc	/^    int32 Next() {$/;"	f	class:testing::TesterThread::ACMRandom	access:public	signature:()
Next	src/thread_cache.h	/^    void* Next() {$/;"	f	class:tcmalloc::ThreadCache::FreeList	access:public	signature:()
NextExt	src/base/sysinfo.cc	/^bool ProcMapsIterator::NextExt(uint64 *start, uint64 *end, char **flags,$/;"	f	class:ProcMapsIterator	signature:(uint64 *start, uint64 *end, char **flags, uint64 *offset, int64 *inode, char **filename, uint64 *file_mapping, uint64 *file_pages, uint64 *anon_mapping, uint64 *anon_pages, dev_t *dev)
NextExt	src/base/sysinfo.h	/^  bool NextExt(uint64 *start, uint64 *end, char **flags,$/;"	p	class:ProcMapsIterator	access:public	signature:(uint64 *start, uint64 *end, char **flags, uint64 *offset, int64 *inode, char **filename, uint64 *file_mapping, uint64 *file_pages, uint64 *anon_mapping, uint64 *anon_pages, dev_t *dev)
NextExtMachHelper	src/base/sysinfo.cc	/^static bool NextExtMachHelper(const mach_header* hdr,$/;"	f	file:	signature:(const mach_header* hdr, int current_image, int current_load_cmd, uint64 *start, uint64 *end, char **flags, uint64 *offset, int64 *inode, char **filename, uint64 *file_mapping, uint64 *file_pages, uint64 *anon_mapping, uint64 *anon_pages, dev_t *dev)
NextRandom	src/sampler.h	/^  static uint64_t NextRandom(uint64_t rnd_);  \/\/ Returns the next prng value$/;"	p	class:tcmalloc::Sampler	access:public	signature:(uint64_t rnd_)
NextRandom	src/sampler.h	/^inline uint64_t Sampler::NextRandom(uint64_t rnd) {$/;"	f	class:tcmalloc::Sampler	signature:(uint64_t rnd)
NextSize	src/tests/memalign_unittest.cc	/^static int NextSize(int size) {$/;"	f	file:	signature:(int size)
NextSize	src/tests/realloc_unittest.cc	/^static int NextSize(int size) {$/;"	f	file:	signature:(int size)
NextStackFrame	src/stacktrace_arm-inl.h	/^static void **NextStackFrame(void **old_sp) {$/;"	f	signature:(void **old_sp)
NextStackFrame	src/stacktrace_powerpc-darwin-inl.h	/^static void **NextStackFrame(void **old_sp) {$/;"	f	signature:(void **old_sp)
NextStackFrame	src/stacktrace_powerpc-inl.h	/^static layout_ppc *NextStackFrame(layout_ppc *current) {$/;"	f	signature:(layout_ppc *current)
NextStackFrame	src/stacktrace_powerpc-linux-inl.h	/^static layout_ppc *NextStackFrame(layout_ppc *current) {$/;"	f	signature:(layout_ppc *current)
NextStackFrame	src/stacktrace_x86-inl.h	/^static void **NextStackFrame(void **old_sp, const void *uc) {$/;"	f	signature:(void **old_sp, const void *uc)
NoBarrier_AtomicExchange	src/base/atomicops-internals-arm-generic.h	/^inline Atomic32 NoBarrier_AtomicExchange(volatile Atomic32* ptr,$/;"	f	namespace:base::subtle	signature:(volatile Atomic32* ptr, Atomic32 new_value)
NoBarrier_AtomicExchange	src/base/atomicops-internals-arm-generic.h	/^inline Atomic64 NoBarrier_AtomicExchange(volatile Atomic64* ptr,$/;"	f	namespace:base::subtle	signature:(volatile Atomic64* ptr, Atomic64 new_value)
NoBarrier_AtomicExchange	src/base/atomicops-internals-arm-v6plus.h	/^inline Atomic32 NoBarrier_AtomicExchange(volatile Atomic32* ptr,$/;"	f	namespace:base::subtle	signature:(volatile Atomic32* ptr, Atomic32 new_value)
NoBarrier_AtomicExchange	src/base/atomicops-internals-arm-v6plus.h	/^inline Atomic64 NoBarrier_AtomicExchange(volatile Atomic64* ptr,$/;"	f	namespace:base::subtle	signature:(volatile Atomic64* ptr, Atomic64 new_value)
NoBarrier_AtomicExchange	src/base/atomicops-internals-gcc.h	/^inline Atomic32 NoBarrier_AtomicExchange(volatile Atomic32* ptr,$/;"	f	namespace:base::subtle	signature:(volatile Atomic32* ptr, Atomic32 new_value)
NoBarrier_AtomicExchange	src/base/atomicops-internals-gcc.h	/^inline Atomic64 NoBarrier_AtomicExchange(volatile Atomic64* ptr,$/;"	f	namespace:base::subtle	signature:(volatile Atomic64* ptr, Atomic64 new_value)
NoBarrier_AtomicExchange	src/base/atomicops-internals-linuxppc.h	/^inline Atomic32 NoBarrier_AtomicExchange(volatile Atomic32 *ptr,$/;"	f	namespace:base::subtle	signature:(volatile Atomic32 *ptr, Atomic32 new_value)
NoBarrier_AtomicExchange	src/base/atomicops-internals-linuxppc.h	/^inline Atomic64 NoBarrier_AtomicExchange(volatile Atomic64 *ptr,$/;"	f	namespace:base::subtle	signature:(volatile Atomic64 *ptr, Atomic64 new_value)
NoBarrier_AtomicExchange	src/base/atomicops-internals-macosx.h	/^inline Atomic32 NoBarrier_AtomicExchange(volatile Atomic32 *ptr,$/;"	f	namespace:base::subtle	signature:(volatile Atomic32 *ptr, Atomic32 new_value)
NoBarrier_AtomicExchange	src/base/atomicops-internals-macosx.h	/^inline Atomic64 NoBarrier_AtomicExchange(volatile Atomic64 *ptr,$/;"	f	namespace:base::subtle	signature:(volatile Atomic64 *ptr, Atomic64 new_value)
NoBarrier_AtomicExchange	src/base/atomicops-internals-mips.h	/^inline Atomic32 NoBarrier_AtomicExchange(volatile Atomic32* ptr,$/;"	f	namespace:base::subtle	signature:(volatile Atomic32* ptr, Atomic32 new_value)
NoBarrier_AtomicExchange	src/base/atomicops-internals-mips.h	/^inline Atomic64 NoBarrier_AtomicExchange(volatile Atomic64* ptr,$/;"	f	namespace:base::subtle	signature:(volatile Atomic64* ptr, Atomic64 new_value)
NoBarrier_AtomicExchange	src/base/atomicops-internals-windows.h	/^inline Atomic32 NoBarrier_AtomicExchange(volatile Atomic32* ptr,$/;"	f	namespace:base::subtle	signature:(volatile Atomic32* ptr, Atomic32 new_value)
NoBarrier_AtomicExchange	src/base/atomicops-internals-windows.h	/^inline Atomic64 NoBarrier_AtomicExchange(volatile Atomic64* ptr,$/;"	f	namespace:base::subtle	signature:(volatile Atomic64* ptr, Atomic64 new_value)
NoBarrier_AtomicExchange	src/base/atomicops-internals-x86.h	/^inline Atomic32 NoBarrier_AtomicExchange(volatile Atomic32* ptr,$/;"	f	namespace:base::subtle	signature:(volatile Atomic32* ptr, Atomic32 new_value)
NoBarrier_AtomicExchange	src/base/atomicops-internals-x86.h	/^inline Atomic64 NoBarrier_AtomicExchange(volatile Atomic64* ptr,$/;"	f	namespace:base::subtle	signature:(volatile Atomic64* ptr, Atomic64 new_val)
NoBarrier_AtomicExchange	src/base/atomicops-internals-x86.h	/^inline Atomic64 NoBarrier_AtomicExchange(volatile Atomic64* ptr,$/;"	f	namespace:base::subtle	signature:(volatile Atomic64* ptr, Atomic64 new_value)
NoBarrier_AtomicExchange	src/base/atomicops.h	/^inline AtomicWord NoBarrier_AtomicExchange(volatile AtomicWord* ptr,$/;"	f	namespace:base::subtle	signature:(volatile AtomicWord* ptr, AtomicWord new_value)
NoBarrier_CompareAndSwap	src/base/atomicops-internals-arm-generic.h	/^inline Atomic32 NoBarrier_CompareAndSwap(volatile Atomic32* ptr,$/;"	f	namespace:base::subtle	signature:(volatile Atomic32* ptr, Atomic32 old_value, Atomic32 new_value)
NoBarrier_CompareAndSwap	src/base/atomicops-internals-arm-generic.h	/^inline Atomic64 NoBarrier_CompareAndSwap(volatile Atomic64* ptr,$/;"	f	namespace:base::subtle	signature:(volatile Atomic64* ptr, Atomic64 old_value, Atomic64 new_value)
NoBarrier_CompareAndSwap	src/base/atomicops-internals-arm-v6plus.h	/^inline Atomic32 NoBarrier_CompareAndSwap(volatile Atomic32* ptr,$/;"	f	namespace:base::subtle	signature:(volatile Atomic32* ptr, Atomic32 old_value, Atomic32 new_value)
NoBarrier_CompareAndSwap	src/base/atomicops-internals-arm-v6plus.h	/^inline Atomic64 NoBarrier_CompareAndSwap(volatile Atomic64* ptr,$/;"	f	namespace:base::subtle	signature:(volatile Atomic64* ptr, Atomic64 old_value, Atomic64 new_value)
NoBarrier_CompareAndSwap	src/base/atomicops-internals-gcc.h	/^inline Atomic32 NoBarrier_CompareAndSwap(volatile Atomic32* ptr,$/;"	f	namespace:base::subtle	signature:(volatile Atomic32* ptr, Atomic32 old_value, Atomic32 new_value)
NoBarrier_CompareAndSwap	src/base/atomicops-internals-gcc.h	/^inline Atomic64 NoBarrier_CompareAndSwap(volatile Atomic64* ptr,$/;"	f	namespace:base::subtle	signature:(volatile Atomic64* ptr, Atomic64 old_value, Atomic64 new_value)
NoBarrier_CompareAndSwap	src/base/atomicops-internals-linuxppc.h	/^inline Atomic32 NoBarrier_CompareAndSwap(volatile Atomic32 *ptr,$/;"	f	namespace:base::subtle	signature:(volatile Atomic32 *ptr, Atomic32 old_value, Atomic32 new_value)
NoBarrier_CompareAndSwap	src/base/atomicops-internals-linuxppc.h	/^inline Atomic64 NoBarrier_CompareAndSwap(volatile Atomic64 *ptr,$/;"	f	namespace:base::subtle	signature:(volatile Atomic64 *ptr, Atomic64 old_value, Atomic64 new_value)
NoBarrier_CompareAndSwap	src/base/atomicops-internals-macosx.h	/^inline Atomic32 NoBarrier_CompareAndSwap(volatile Atomic32 *ptr,$/;"	f	namespace:base::subtle	signature:(volatile Atomic32 *ptr, Atomic32 old_value, Atomic32 new_value)
NoBarrier_CompareAndSwap	src/base/atomicops-internals-macosx.h	/^inline Atomic64 NoBarrier_CompareAndSwap(volatile Atomic64 *ptr,$/;"	f	namespace:base::subtle	signature:(volatile Atomic64 *ptr, Atomic64 old_value, Atomic64 new_value)
NoBarrier_CompareAndSwap	src/base/atomicops-internals-mips.h	/^inline Atomic32 NoBarrier_CompareAndSwap(volatile Atomic32* ptr,$/;"	f	namespace:base::subtle	signature:(volatile Atomic32* ptr, Atomic32 old_value, Atomic32 new_value)
NoBarrier_CompareAndSwap	src/base/atomicops-internals-mips.h	/^inline Atomic64 NoBarrier_CompareAndSwap(volatile Atomic64* ptr,$/;"	f	namespace:base::subtle	signature:(volatile Atomic64* ptr, Atomic64 old_value, Atomic64 new_value)
NoBarrier_CompareAndSwap	src/base/atomicops-internals-windows.h	/^inline Atomic32 NoBarrier_CompareAndSwap(volatile Atomic32* ptr,$/;"	f	namespace:base::subtle	signature:(volatile Atomic32* ptr, Atomic32 old_value, Atomic32 new_value)
NoBarrier_CompareAndSwap	src/base/atomicops-internals-windows.h	/^inline Atomic64 NoBarrier_CompareAndSwap(volatile Atomic64* ptr,$/;"	f	namespace:base::subtle	signature:(volatile Atomic64* ptr, Atomic64 old_value, Atomic64 new_value)
NoBarrier_CompareAndSwap	src/base/atomicops-internals-x86.h	/^inline Atomic32 NoBarrier_CompareAndSwap(volatile Atomic32* ptr,$/;"	f	namespace:base::subtle	signature:(volatile Atomic32* ptr, Atomic32 old_value, Atomic32 new_value)
NoBarrier_CompareAndSwap	src/base/atomicops-internals-x86.h	/^inline Atomic64 NoBarrier_CompareAndSwap(volatile Atomic64* ptr,$/;"	f	namespace:base::subtle	signature:(volatile Atomic64* ptr, Atomic64 old_val, Atomic64 new_val)
NoBarrier_CompareAndSwap	src/base/atomicops-internals-x86.h	/^inline Atomic64 NoBarrier_CompareAndSwap(volatile Atomic64* ptr,$/;"	f	namespace:base::subtle	signature:(volatile Atomic64* ptr, Atomic64 old_value, Atomic64 new_value)
NoBarrier_CompareAndSwap	src/base/atomicops.h	/^inline AtomicWord NoBarrier_CompareAndSwap(volatile AtomicWord* ptr,$/;"	f	namespace:base::subtle	signature:(volatile AtomicWord* ptr, AtomicWord old_value, AtomicWord new_value)
NoBarrier_Load	src/base/atomicops-internals-arm-generic.h	/^inline Atomic32 NoBarrier_Load(volatile const Atomic32* ptr) {$/;"	f	namespace:base::subtle	signature:(volatile const Atomic32* ptr)
NoBarrier_Load	src/base/atomicops-internals-arm-generic.h	/^inline Atomic64 NoBarrier_Load(volatile const Atomic64* ptr) {$/;"	f	namespace:base::subtle	signature:(volatile const Atomic64* ptr)
NoBarrier_Load	src/base/atomicops-internals-arm-v6plus.h	/^inline Atomic32 NoBarrier_Load(volatile const Atomic32* ptr) {$/;"	f	namespace:base::subtle	signature:(volatile const Atomic32* ptr)
NoBarrier_Load	src/base/atomicops-internals-arm-v6plus.h	/^inline Atomic64 NoBarrier_Load(volatile const Atomic64* ptr) {$/;"	f	namespace:base::subtle	signature:(volatile const Atomic64* ptr)
NoBarrier_Load	src/base/atomicops-internals-gcc.h	/^inline Atomic32 NoBarrier_Load(volatile const Atomic32* ptr) {$/;"	f	namespace:base::subtle	signature:(volatile const Atomic32* ptr)
NoBarrier_Load	src/base/atomicops-internals-gcc.h	/^inline Atomic64 NoBarrier_Load(volatile const Atomic64* ptr) {$/;"	f	namespace:base::subtle	signature:(volatile const Atomic64* ptr)
NoBarrier_Load	src/base/atomicops-internals-linuxppc.h	/^inline Atomic32 NoBarrier_Load(volatile const Atomic32 *ptr) {$/;"	f	namespace:base::subtle	signature:(volatile const Atomic32 *ptr)
NoBarrier_Load	src/base/atomicops-internals-linuxppc.h	/^inline Atomic64 NoBarrier_Load(volatile const Atomic64 *ptr) {$/;"	f	namespace:base::subtle	signature:(volatile const Atomic64 *ptr)
NoBarrier_Load	src/base/atomicops-internals-macosx.h	/^inline Atomic32 NoBarrier_Load(volatile const Atomic32* ptr) {$/;"	f	namespace:base::subtle	signature:(volatile const Atomic32* ptr)
NoBarrier_Load	src/base/atomicops-internals-macosx.h	/^inline Atomic64 NoBarrier_Load(volatile const Atomic64* ptr) {$/;"	f	namespace:base::subtle	signature:(volatile const Atomic64* ptr)
NoBarrier_Load	src/base/atomicops-internals-mips.h	/^inline Atomic32 NoBarrier_Load(volatile const Atomic32* ptr)$/;"	f	namespace:base::subtle	signature:(volatile const Atomic32* ptr)
NoBarrier_Load	src/base/atomicops-internals-mips.h	/^inline Atomic64 NoBarrier_Load(volatile const Atomic64* ptr)$/;"	f	namespace:base::subtle	signature:(volatile const Atomic64* ptr)
NoBarrier_Load	src/base/atomicops-internals-windows.h	/^inline Atomic32 NoBarrier_Load(volatile const Atomic32* ptr) {$/;"	f	namespace:base::subtle	signature:(volatile const Atomic32* ptr)
NoBarrier_Load	src/base/atomicops-internals-windows.h	/^inline Atomic64 NoBarrier_Load(volatile const Atomic64* ptr) {$/;"	f	namespace:base::subtle	signature:(volatile const Atomic64* ptr)
NoBarrier_Load	src/base/atomicops-internals-windows.h	/^inline Atomic64 NoBarrier_Load(volatile const Atomic64* ptrValue)$/;"	f	namespace:base::subtle	signature:(volatile const Atomic64* ptrValue)
NoBarrier_Load	src/base/atomicops-internals-x86.h	/^inline Atomic32 NoBarrier_Load(volatile const Atomic32* ptr) {$/;"	f	namespace:base::subtle	signature:(volatile const Atomic32* ptr)
NoBarrier_Load	src/base/atomicops-internals-x86.h	/^inline Atomic64 NoBarrier_Load(volatile const Atomic64* ptr) {$/;"	f	namespace:base::subtle	signature:(volatile const Atomic64* ptr)
NoBarrier_Load	src/base/atomicops.h	/^inline AtomicWord NoBarrier_Load(volatile const AtomicWord *ptr) {$/;"	f	namespace:base::subtle	signature:(volatile const AtomicWord *ptr)
NoBarrier_Store	src/base/atomicops-internals-arm-generic.h	/^inline void NoBarrier_Store(volatile Atomic32* ptr, Atomic32 value) {$/;"	f	namespace:base::subtle	signature:(volatile Atomic32* ptr, Atomic32 value)
NoBarrier_Store	src/base/atomicops-internals-arm-generic.h	/^inline void NoBarrier_Store(volatile Atomic64* ptr, Atomic64 value) {$/;"	f	namespace:base::subtle	signature:(volatile Atomic64* ptr, Atomic64 value)
NoBarrier_Store	src/base/atomicops-internals-arm-v6plus.h	/^inline void NoBarrier_Store(volatile Atomic32* ptr, Atomic32 value) {$/;"	f	namespace:base::subtle	signature:(volatile Atomic32* ptr, Atomic32 value)
NoBarrier_Store	src/base/atomicops-internals-arm-v6plus.h	/^inline void NoBarrier_Store(volatile Atomic64* ptr, Atomic64 value) {$/;"	f	namespace:base::subtle	signature:(volatile Atomic64* ptr, Atomic64 value)
NoBarrier_Store	src/base/atomicops-internals-gcc.h	/^inline void NoBarrier_Store(volatile Atomic32* ptr, Atomic32 value) {$/;"	f	namespace:base::subtle	signature:(volatile Atomic32* ptr, Atomic32 value)
NoBarrier_Store	src/base/atomicops-internals-gcc.h	/^inline void NoBarrier_Store(volatile Atomic64* ptr, Atomic64 value) {$/;"	f	namespace:base::subtle	signature:(volatile Atomic64* ptr, Atomic64 value)
NoBarrier_Store	src/base/atomicops-internals-linuxppc.h	/^inline void NoBarrier_Store(volatile Atomic32 *ptr, Atomic32 value) {$/;"	f	namespace:base::subtle	signature:(volatile Atomic32 *ptr, Atomic32 value)
NoBarrier_Store	src/base/atomicops-internals-linuxppc.h	/^inline void NoBarrier_Store(volatile Atomic64 *ptr, Atomic64 value) {$/;"	f	namespace:base::subtle	signature:(volatile Atomic64 *ptr, Atomic64 value)
NoBarrier_Store	src/base/atomicops-internals-macosx.h	/^inline void NoBarrier_Store(volatile Atomic32* ptr, Atomic32 value) {$/;"	f	namespace:base::subtle	signature:(volatile Atomic32* ptr, Atomic32 value)
NoBarrier_Store	src/base/atomicops-internals-macosx.h	/^inline void NoBarrier_Store(volatile Atomic64* ptr, Atomic64 value) {$/;"	f	namespace:base::subtle	signature:(volatile Atomic64* ptr, Atomic64 value)
NoBarrier_Store	src/base/atomicops-internals-mips.h	/^inline void NoBarrier_Store(volatile Atomic32* ptr, Atomic32 value)$/;"	f	namespace:base::subtle	signature:(volatile Atomic32* ptr, Atomic32 value)
NoBarrier_Store	src/base/atomicops-internals-mips.h	/^inline void NoBarrier_Store(volatile Atomic64* ptr, Atomic64 value)$/;"	f	namespace:base::subtle	signature:(volatile Atomic64* ptr, Atomic64 value)
NoBarrier_Store	src/base/atomicops-internals-windows.h	/^inline void NoBarrier_Store(volatile Atomic32* ptr, Atomic32 value) {$/;"	f	namespace:base::subtle	signature:(volatile Atomic32* ptr, Atomic32 value)
NoBarrier_Store	src/base/atomicops-internals-windows.h	/^inline void NoBarrier_Store(volatile Atomic64* ptr, Atomic64 value) {$/;"	f	namespace:base::subtle	signature:(volatile Atomic64* ptr, Atomic64 value)
NoBarrier_Store	src/base/atomicops-internals-windows.h	/^inline void NoBarrier_Store(volatile Atomic64* ptrValue, Atomic64 value)$/;"	f	namespace:base::subtle	signature:(volatile Atomic64* ptrValue, Atomic64 value)
NoBarrier_Store	src/base/atomicops-internals-x86.h	/^inline void NoBarrier_Store(volatile Atomic32* ptr, Atomic32 value) {$/;"	f	namespace:base::subtle	signature:(volatile Atomic32* ptr, Atomic32 value)
NoBarrier_Store	src/base/atomicops-internals-x86.h	/^inline void NoBarrier_Store(volatile Atomic64* ptr, Atomic64 value) {$/;"	f	namespace:base::subtle	signature:(volatile Atomic64* ptr, Atomic64 value)
NoBarrier_Store	src/base/atomicops.h	/^inline void NoBarrier_Store(volatile AtomicWord *ptr, AtomicWord value) {$/;"	f	namespace:base::subtle	signature:(volatile AtomicWord *ptr, AtomicWord value)
NoGlobalLeaks	src/gperftools/heap-checker.h	/^  static bool NoGlobalLeaks();$/;"	p	class:HeapLeakChecker	access:public	signature:()
NoGlobalLeaks	src/heap-checker.cc	/^bool HeapLeakChecker::NoGlobalLeaks() {$/;"	f	class:HeapLeakChecker	signature:()
NoGlobalLeaksMaybeSymbolize	src/gperftools/heap-checker.h	/^  static bool NoGlobalLeaksMaybeSymbolize(ShouldSymbolize should_symbolize);$/;"	p	class:HeapLeakChecker	access:private	signature:(ShouldSymbolize should_symbolize)
NoGlobalLeaksMaybeSymbolize	src/heap-checker.cc	/^bool HeapLeakChecker::NoGlobalLeaksMaybeSymbolize($/;"	f	class:HeapLeakChecker	signature:( ShouldSymbolize should_symbolize)
NoLeaks	src/gperftools/heap-checker.h	/^  bool NoLeaks() { return DoNoLeaks(DO_NOT_SYMBOLIZE); }$/;"	f	class:HeapLeakChecker	access:public	signature:()
Node	benchmark/binary_trees.cc	/^  Node(Node *l2, int i2, Node *r2) : l(l2), r(r2), i(i2) {}$/;"	f	struct:Node	access:public	signature:(Node *l2, int i2, Node *r2)
Node	benchmark/binary_trees.cc	/^  Node(int i2) : l(0), r(0), i(i2) {}$/;"	f	struct:Node	access:public	signature:(int i2)
Node	benchmark/binary_trees.cc	/^struct Node {$/;"	s	file:
Node	src/pagemap.h	/^  struct Node {$/;"	s	class:TCMalloc_PageMap3	access:private
Node::Node	benchmark/binary_trees.cc	/^  Node(Node *l2, int i2, Node *r2) : l(l2), r(r2), i(i2) {}$/;"	f	struct:Node	access:public	signature:(Node *l2, int i2, Node *r2)
Node::Node	benchmark/binary_trees.cc	/^  Node(int i2) : l(0), r(0), i(i2) {}$/;"	f	struct:Node	access:public	signature:(int i2)
Node::check	benchmark/binary_trees.cc	/^  int check() const {$/;"	f	struct:Node	access:public	signature:() const
Node::i	benchmark/binary_trees.cc	/^  int i;$/;"	m	struct:Node	file:	access:public
Node::l	benchmark/binary_trees.cc	/^  Node *l, *r;$/;"	m	struct:Node	file:	access:public
Node::r	benchmark/binary_trees.cc	/^  Node *l, *r;$/;"	m	struct:Node	file:	access:public
Node::~Node	benchmark/binary_trees.cc	/^  ~Node() { delete l; delete r; }$/;"	f	struct:Node	access:public	signature:()
NonLiveSnapshot	src/heap-profile-table.cc	/^HeapProfileTable::Snapshot* HeapProfileTable::NonLiveSnapshot($/;"	f	class:HeapProfileTable	signature:( Snapshot* base)
NonLiveSnapshot	src/heap-profile-table.h	/^  Snapshot* NonLiveSnapshot(Snapshot* base);$/;"	p	class:HeapProfileTable	access:public	signature:(Snapshot* base)
NotImplementedFatalError	src/base/atomicops-internals-arm-generic.h	/^inline void NotImplementedFatalError(const char *function_name) {$/;"	f	namespace:base::subtle	signature:(const char *function_name)
NotImplementedFatalError	src/base/atomicops-internals-arm-v6plus.h	/^inline void NotImplementedFatalError(const char *function_name) {$/;"	f	namespace:base::subtle	signature:(const char *function_name)
NotImplementedFatalError	src/base/atomicops-internals-windows.h	/^inline void NotImplementedFatalError(const char *function_name) {$/;"	f	namespace:base::subtle	signature:(const char *function_name)
NullThread	src/tests/profile-handler_unittest.cc	/^class NullThread : public Thread {$/;"	c	namespace:__anon56	file:	inherits:Thread
NumMoveSize	src/common.cc	/^int SizeMap::NumMoveSize(size_t size) {$/;"	f	class:tcmalloc::SizeMap	signature:(size_t size)
NumMoveSize	src/common.h	/^  int NumMoveSize(size_t size);$/;"	p	class:tcmalloc::SizeMap	access:private	signature:(size_t size)
Number	src/addressmap-inl.h	/^  typedef uintptr_t Number;$/;"	t	class:AddressMap	access:private
Number	src/pagemap.h	/^  typedef uintptr_t Number;$/;"	t	class:TCMalloc_PageMap1	access:public
Number	src/pagemap.h	/^  typedef uintptr_t Number;$/;"	t	class:TCMalloc_PageMap2	access:public
Number	src/pagemap.h	/^  typedef uintptr_t Number;$/;"	t	class:TCMalloc_PageMap3	access:public
Number	src/tests/memalign_unittest.cc	/^static uintptr_t Number(void* p) {$/;"	f	file:	signature:(void* p)
OFFSETOF_MEMBER	src/base/basictypes.h	214;"	d
ON_NORMAL_FREELIST	src/span.h	/^  enum { IN_USE, ON_NORMAL_FREELIST, ON_RETURNED_FREELIST };$/;"	e	enum:tcmalloc::Span::__anon6
ON_RETURNED_FREELIST	src/span.h	/^  enum { IN_USE, ON_NORMAL_FREELIST, ON_RETURNED_FREELIST };$/;"	e	enum:tcmalloc::Span::__anon6
OOMAbleSysAlloc	src/tests/tcmalloc_unittest.cc	/^struct OOMAbleSysAlloc : public SysAllocator {$/;"	s	file:	inherits:SysAllocator
OOMAbleSysAlloc::Alloc	src/tests/tcmalloc_unittest.cc	/^  void* Alloc(size_t size, size_t* actual_size, size_t alignment) {$/;"	f	struct:OOMAbleSysAlloc	access:public	signature:(size_t size, size_t* actual_size, size_t alignment)
OOMAbleSysAlloc::child	src/tests/tcmalloc_unittest.cc	/^  SysAllocator *child;$/;"	m	struct:OOMAbleSysAlloc	file:	access:public
OOMAbleSysAlloc::simulate_oom	src/tests/tcmalloc_unittest.cc	/^  int simulate_oom;$/;"	m	struct:OOMAbleSysAlloc	file:	access:public
OS	docs/tcmalloc.html	/^    OS, typically do not count towards physical memory usage.$/;"	m	class:object::structure	file:	access:private
OS	docs/tcmalloc.html	/^    swapped out by the OS, they also count towards physical memory$/;"	m	class:object::structure	file:	access:private
OSAtomicAdd32	src/base/atomicops-internals-linuxppc.h	/^static inline Atomic32 OSAtomicAdd32(Atomic32 amount, Atomic32 *value) {$/;"	f	namespace:base::subtle	signature:(Atomic32 amount, Atomic32 *value)
OSAtomicAdd32Barrier	src/base/atomicops-internals-linuxppc.h	/^static inline Atomic32 OSAtomicAdd32Barrier(Atomic32 amount, Atomic32 *value) {$/;"	f	namespace:base::subtle	signature:(Atomic32 amount, Atomic32 *value)
OSAtomicAdd64	src/base/atomicops-internals-linuxppc.h	/^static inline Atomic64 OSAtomicAdd64(Atomic64 amount, Atomic64 *value) {$/;"	f	namespace:base::subtle	signature:(Atomic64 amount, Atomic64 *value)
OSAtomicAdd64	src/base/atomicops-internals-macosx.h	/^inline int64_t OSAtomicAdd64(int64_t theAmount, int64_t *theValue) {$/;"	f	namespace:base::subtle	signature:(int64_t theAmount, int64_t *theValue)
OSAtomicAdd64Barrier	src/base/atomicops-internals-linuxppc.h	/^static inline Atomic64 OSAtomicAdd64Barrier(Atomic64 amount, Atomic64 *value) {$/;"	f	namespace:base::subtle	signature:(Atomic64 amount, Atomic64 *value)
OSAtomicAdd64Barrier	src/base/atomicops-internals-macosx.h	/^inline int64_t OSAtomicAdd64Barrier($/;"	f	namespace:base::subtle	signature:( int64_t theAmount, int64_t *theValue)
OSAtomicCompareAndSwap32	src/base/atomicops-internals-linuxppc.h	/^static inline bool OSAtomicCompareAndSwap32(Atomic32 old_value,$/;"	f	namespace:base::subtle	signature:(Atomic32 old_value, Atomic32 new_value, Atomic32 *value)
OSAtomicCompareAndSwap32Acquire	src/base/atomicops-internals-linuxppc.h	/^static inline Atomic32 OSAtomicCompareAndSwap32Acquire(Atomic32 old_value,$/;"	f	namespace:base::subtle	signature:(Atomic32 old_value, Atomic32 new_value, Atomic32 *value)
OSAtomicCompareAndSwap32Release	src/base/atomicops-internals-linuxppc.h	/^static inline Atomic32 OSAtomicCompareAndSwap32Release(Atomic32 old_value,$/;"	f	namespace:base::subtle	signature:(Atomic32 old_value, Atomic32 new_value, Atomic32 *value)
OSAtomicCompareAndSwap64	src/base/atomicops-internals-linuxppc.h	/^static inline bool OSAtomicCompareAndSwap64(Atomic64 old_value,$/;"	f	namespace:base::subtle	signature:(Atomic64 old_value, Atomic64 new_value, Atomic64 *value)
OSAtomicCompareAndSwap64	src/base/atomicops-internals-macosx.h	/^inline int64_t OSAtomicCompareAndSwap64($/;"	f	namespace:base::subtle	signature:( int64_t oldValue, int64_t newValue, int64_t *theValue)
OSAtomicCompareAndSwap64Acquire	src/base/atomicops-internals-linuxppc.h	/^static inline Atomic64 OSAtomicCompareAndSwap64Acquire(Atomic64 old_value,$/;"	f	namespace:base::subtle	signature:(Atomic64 old_value, Atomic64 new_value, Atomic64 *value)
OSAtomicCompareAndSwap64Barrier	src/base/atomicops-internals-macosx.h	/^inline int64_t OSAtomicCompareAndSwap64Barrier($/;"	f	namespace:base::subtle	signature:( int64_t oldValue, int64_t newValue, int64_t *theValue)
OSAtomicCompareAndSwap64Release	src/base/atomicops-internals-linuxppc.h	/^static inline Atomic64 OSAtomicCompareAndSwap64Release(Atomic64 old_value,$/;"	f	namespace:base::subtle	signature:(Atomic64 old_value, Atomic64 new_value, Atomic64 *value)
OS_128_BIT_PACKED_SINGLE_PRECISION_FLOATING	src/windows/mini_disassembler_types.h	/^  OS_128_BIT_PACKED_SINGLE_PRECISION_FLOATING = 128\/8,$/;"	e	enum:sidestep::OperandSize
OS_32_BIT_POINTER	src/windows/mini_disassembler_types.h	/^  OS_32_BIT_POINTER = 32\/8,$/;"	e	enum:sidestep::OperandSize
OS_48_BIT_POINTER	src/windows/mini_disassembler_types.h	/^  OS_48_BIT_POINTER = 48\/8,$/;"	e	enum:sidestep::OperandSize
OS_BYTE	src/windows/mini_disassembler_types.h	/^  OS_BYTE = 1,$/;"	e	enum:sidestep::OperandSize
OS_DOUBLE_EXTENDED_PRECISION_FLOATING	src/windows/mini_disassembler_types.h	/^  OS_DOUBLE_EXTENDED_PRECISION_FLOATING = 80\/8,$/;"	e	enum:sidestep::OperandSize
OS_DOUBLE_PRECISION_FLOATING	src/windows/mini_disassembler_types.h	/^  OS_DOUBLE_PRECISION_FLOATING = 64\/8,$/;"	e	enum:sidestep::OperandSize
OS_DOUBLE_QUAD_WORD	src/windows/mini_disassembler_types.h	/^  OS_DOUBLE_QUAD_WORD = 16,$/;"	e	enum:sidestep::OperandSize
OS_DOUBLE_WORD	src/windows/mini_disassembler_types.h	/^  OS_DOUBLE_WORD = 4,$/;"	e	enum:sidestep::OperandSize
OS_PSEUDO_DESCRIPTOR	src/windows/mini_disassembler_types.h	/^  OS_PSEUDO_DESCRIPTOR = 6$/;"	e	enum:sidestep::OperandSize
OS_QUAD_WORD	src/windows/mini_disassembler_types.h	/^  OS_QUAD_WORD = 8,$/;"	e	enum:sidestep::OperandSize
OS_SINGLE_PRECISION_FLOATING	src/windows/mini_disassembler_types.h	/^  OS_SINGLE_PRECISION_FLOATING = 32\/8,$/;"	e	enum:sidestep::OperandSize
OS_WORD	src/windows/mini_disassembler_types.h	/^  OS_WORD = 2,$/;"	e	enum:sidestep::OperandSize
OS_ZERO	src/windows/mini_disassembler_types.h	/^  OS_ZERO = 0,$/;"	e	enum:sidestep::OperandSize
OT_A	src/windows/mini_disassembler_types.h	/^  OT_A = 0x01000000,$/;"	e	enum:sidestep::OperandType
OT_ADDRESS_MODE_M	src/windows/mini_disassembler_types.h	/^  OT_ADDRESS_MODE_M = 0x80000000$/;"	e	enum:sidestep::OperandType
OT_B	src/windows/mini_disassembler_types.h	/^  OT_B = 0x02000000,$/;"	e	enum:sidestep::OperandType
OT_C	src/windows/mini_disassembler_types.h	/^  OT_C = 0x03000000,$/;"	e	enum:sidestep::OperandType
OT_D	src/windows/mini_disassembler_types.h	/^  OT_D = 0x04000000,$/;"	e	enum:sidestep::OperandType
OT_DQ	src/windows/mini_disassembler_types.h	/^  OT_DQ = 0x05000000,$/;"	e	enum:sidestep::OperandType
OT_MASK	src/windows/mini_disassembler_types.h	/^  OT_MASK = 0xFF000000,$/;"	e	enum:sidestep::OperandType
OT_P	src/windows/mini_disassembler_types.h	/^  OT_P = 0x06000000,$/;"	e	enum:sidestep::OperandType
OT_PD	src/windows/mini_disassembler_types.h	/^  OT_PD = 0x10000000,  \/\/ double-precision floating point$/;"	e	enum:sidestep::OperandType
OT_PI	src/windows/mini_disassembler_types.h	/^  OT_PI = 0x07000000,$/;"	e	enum:sidestep::OperandType
OT_PS	src/windows/mini_disassembler_types.h	/^  OT_PS = 0x08000000,  \/\/ actually unsupported for (we don't know its size)$/;"	e	enum:sidestep::OperandType
OT_Q	src/windows/mini_disassembler_types.h	/^  OT_Q = 0x09000000,$/;"	e	enum:sidestep::OperandType
OT_S	src/windows/mini_disassembler_types.h	/^  OT_S = 0x0A000000,$/;"	e	enum:sidestep::OperandType
OT_SD	src/windows/mini_disassembler_types.h	/^  OT_SD = 0x0F000000,  \/\/ scalar double-precision floating-point value$/;"	e	enum:sidestep::OperandType
OT_SI	src/windows/mini_disassembler_types.h	/^  OT_SI = 0x0C000000,$/;"	e	enum:sidestep::OperandType
OT_SS	src/windows/mini_disassembler_types.h	/^  OT_SS = 0x0B000000,$/;"	e	enum:sidestep::OperandType
OT_V	src/windows/mini_disassembler_types.h	/^  OT_V = 0x0D000000,$/;"	e	enum:sidestep::OperandType
OT_W	src/windows/mini_disassembler_types.h	/^  OT_W = 0x0E000000,$/;"	e	enum:sidestep::OperandType
OVERALIGNMENT	src/tests/tcmalloc_unittest.cc	149;"	d	file:
O_DIRECTORY	src/base/linux_syscall_support.h	550;"	d
O_DIRECTORY	src/base/linux_syscall_support.h	552;"	d
O_RDONLY	src/windows/port.h	365;"	d
ObjMakerFunc	src/tests/heap-checker_unittest.cc	/^typedef void* (*ObjMakerFunc)();$/;"	t	file:
ObjMakerRegistrar	src/tests/heap-checker_unittest.cc	/^  ObjMakerRegistrar(ObjMakerFunc obj_maker) { obj_makers.push_back(obj_maker); }$/;"	f	struct:ObjMakerRegistrar	access:public	signature:(ObjMakerFunc obj_maker)
ObjMakerRegistrar	src/tests/heap-checker_unittest.cc	/^struct ObjMakerRegistrar {$/;"	s	file:
ObjMakerRegistrar::ObjMakerRegistrar	src/tests/heap-checker_unittest.cc	/^  ObjMakerRegistrar(ObjMakerFunc obj_maker) { obj_makers.push_back(obj_maker); }$/;"	f	struct:ObjMakerRegistrar	access:public	signature:(ObjMakerFunc obj_maker)
Object	src/addressmap-inl.h	/^  struct Object {$/;"	s	class:AddressMap	access:private
Object	src/tests/tcmalloc_unittest.cc	/^  struct Object {$/;"	s	class:testing::TesterThread	file:	access:private
ObjectPlacement	src/heap-checker.cc	/^enum ObjectPlacement {$/;"	g	file:
ObjectsLeaked	src/gperftools/heap-checker.h	/^  ssize_t ObjectsLeaked() const;$/;"	p	class:HeapLeakChecker	access:public	signature:() const
ObjectsLeaked	src/heap-checker.cc	/^ssize_t HeapLeakChecker::ObjectsLeaked() const {$/;"	f	class:HeapLeakChecker	signature:() const
OldSampler	src/tests/sampler_test.cc	/^class OldSampler {$/;"	c	file:
OldSampler::Cleanup	src/tests/sampler_test.cc	/^  void Cleanup() {}$/;"	f	class:OldSampler	access:public	signature:()
OldSampler::Init	src/tests/sampler_test.cc	/^  void Init(uint32_t seed);$/;"	p	class:OldSampler	file:	access:public	signature:(uint32_t seed)
OldSampler::Init	src/tests/sampler_test.cc	/^void OldSampler::Init(uint32_t seed) {$/;"	f	class:OldSampler	signature:(uint32_t seed)
OldSampler::InitStatics	src/tests/sampler_test.cc	/^  static void InitStatics() {$/;"	f	class:OldSampler	access:public	signature:()
OldSampler::PickNextSample	src/tests/sampler_test.cc	/^  void PickNextSample(size_t k);$/;"	p	class:OldSampler	file:	access:public	signature:(size_t k)
OldSampler::PickNextSample	src/tests/sampler_test.cc	/^void OldSampler::PickNextSample(size_t k) {$/;"	f	class:OldSampler	signature:(size_t k)
OldSampler::SampleAllocation	src/tests/sampler_test.cc	/^  bool SampleAllocation(size_t k);$/;"	p	class:OldSampler	file:	access:public	signature:(size_t k)
OldSampler::SampleAllocation	src/tests/sampler_test.cc	/^inline bool OldSampler::SampleAllocation(size_t k) {$/;"	f	class:OldSampler	signature:(size_t k)
OldSampler::bytes_until_sample_	src/tests/sampler_test.cc	/^  size_t bytes_until_sample_;$/;"	m	class:OldSampler	file:	access:public
OldSampler::rnd_	src/tests/sampler_test.cc	/^  uint32_t rnd_;                   \/\/ Cheap random number generator$/;"	m	class:OldSampler	file:	access:private
OldSampler::sample_period	src/tests/sampler_test.cc	/^  static uint64_t sample_period;$/;"	m	class:OldSampler	file:	access:private
OldSampler::sample_period	src/tests/sampler_test.cc	/^uint64_t OldSampler::sample_period;$/;"	m	class:OldSampler	file:
OnNoMemory	src/tests/tcmalloc_unittest.cc	/^static void OnNoMemory() {$/;"	f	namespace:testing	signature:()
Opcode	src/windows/mini_disassembler_types.h	/^struct Opcode {$/;"	s	namespace:sidestep
OpcodeTable	src/windows/mini_disassembler_types.h	/^struct OpcodeTable {$/;"	s	namespace:sidestep
OperandSize	src/windows/mini_disassembler_types.h	/^enum OperandSize {$/;"	g	namespace:sidestep
OperandType	src/windows/mini_disassembler_types.h	/^enum OperandType {$/;"	g	namespace:sidestep
OpsWhenStopped	src/tests/profiledata_unittest.cc	/^  void OpsWhenStopped();$/;"	p	class:__anon53::ProfileDataTest	file:	access:private	signature:()
Options	src/profiledata.cc	/^ProfileData::Options::Options()$/;"	f	class:ProfileData::Options	signature:()
Options	src/profiledata.h	/^    Options();$/;"	p	class:ProfileData::Options	access:public	signature:()
Options	src/profiledata.h	/^  class Options {$/;"	c	class:ProfileData	access:public
OrigFn	src/third_party/valgrind.h	/^   OrigFn;$/;"	t	typeref:struct:__anon22
OrigFn	src/third_party/valgrind.h	/^   OrigFn;$/;"	t	typeref:struct:__anon23
OrigFn	src/third_party/valgrind.h	/^   OrigFn;$/;"	t	typeref:struct:__anon24
OrigFn	src/third_party/valgrind.h	/^   OrigFn;$/;"	t	typeref:struct:__anon25
OrigFn	src/third_party/valgrind.h	/^   OrigFn;$/;"	t	typeref:struct:__anon26
OrigFn	src/third_party/valgrind.h	/^   OrigFn;$/;"	t	typeref:struct:__anon27
OutputSequence	src/tests/sampler_test.cc	/^void OutputSequence(int sequence_length) {$/;"	f	signature:(int sequence_length)
OverheadBytes	src/central_freelist.cc	/^size_t CentralFreeList::OverheadBytes() {$/;"	f	class:tcmalloc::CentralFreeList	signature:()
OverheadBytes	src/central_freelist.h	/^  size_t OverheadBytes();$/;"	p	class:tcmalloc::CentralFreeList	access:public	signature:()
Overlaps	src/memory_region_map.h	/^    bool Overlaps(const Region& x) const {$/;"	f	struct:MemoryRegionMap::Region	access:public	signature:(const Region& x) const
Ownership	src/gperftools/malloc_extension.h	/^  enum Ownership {$/;"	g	class:MallocExtension	access:public
P	docs/tcmalloc-opspercpusec.vs.threads.1024.bytes.png	/^/;"	v
P	docs/tcmalloc-opspercpusec.vs.threads.16384.bytes.png	/^/;"	v
P	docs/tcmalloc-opspercpusec.vs.threads.256.bytes.png	/^/;"	v
P	docs/tcmalloc-opspercpusec.vs.threads.8192.bytes.png	/^/;"	v
P	docs/tcmalloc-opspersec.vs.size.12.threads.png	/^/;"	v
P	docs/tcmalloc-opspersec.vs.size.3.threads.png	/^/;"	v
P	src/.libs/libtcmalloc_internal_la-internal_logging.o	/^/;"	v
PACKAGE	src/config.h	228;"	d
PACKAGE	src/config.h.in	227;"	d	file:
PACKAGE	src/windows/config.h	230;"	d
PACKAGE_BUGREPORT	src/config.h	231;"	d
PACKAGE_BUGREPORT	src/config.h.in	230;"	d	file:
PACKAGE_BUGREPORT	src/windows/config.h	233;"	d
PACKAGE_NAME	src/config.h	234;"	d
PACKAGE_NAME	src/config.h.in	233;"	d	file:
PACKAGE_NAME	src/windows/config.h	236;"	d
PACKAGE_STRING	src/config.h	237;"	d
PACKAGE_STRING	src/config.h.in	236;"	d	file:
PACKAGE_STRING	src/windows/config.h	239;"	d
PACKAGE_TARNAME	src/config.h	240;"	d
PACKAGE_TARNAME	src/config.h.in	239;"	d	file:
PACKAGE_TARNAME	src/windows/config.h	242;"	d
PACKAGE_URL	src/windows/config.h	245;"	d
PACKAGE_VERSION	src/config.h	243;"	d
PACKAGE_VERSION	src/config.h.in	242;"	d	file:
PACKAGE_VERSION	src/windows/config.h	248;"	d
PASS	src/tests/tcmalloc_unittest.cc	/^  enum Type { ALLOC, FREE, UPDATE, PASS };$/;"	e	enum:testing::TesterThread::Type	file:
PATH	config.guess	/^	PATH=$PATH:\/.attbin ; export PATH$/;"	v
PATH_MAX	src/heap-profiler.cc	79;"	d	file:
PATH_MAX	src/heap-profiler.cc	81;"	d	file:
PATH_MAX	src/windows/port.h	359;"	d
PATH_SEPARATOR	config.status	/^  PATH_SEPARATOR=:$/;"	v
PATH_SEPARATOR	configure	/^  PATH_SEPARATOR=:$/;"	v
PC	src/malloc_extension.cc	/^void* PC(void** entry, int i) {$/;"	f	namespace:__anon21	signature:(void** entry, int i)
PCHECK	src/base/logging.h	114;"	d
PC_FROM_UCONTEXT	src/config.h	246;"	d
PC_FROM_UCONTEXT	src/config.h.in	245;"	d	file:
PC_FROM_UCONTEXT	src/windows/config.h	251;"	d
PERFTOOLS_DLL_DECL	src/config.h	253;"	d
PERFTOOLS_DLL_DECL	src/config.h.in	252;"	d	file:
PERFTOOLS_DLL_DECL	src/config_for_unittests.h	60;"	d
PERFTOOLS_DLL_DECL	src/config_for_unittests.h	62;"	d
PERFTOOLS_DLL_DECL	src/config_for_unittests.h	64;"	d
PERFTOOLS_DLL_DECL	src/gperftools/heap-checker.h	69;"	d
PERFTOOLS_DLL_DECL	src/gperftools/heap-checker.h	71;"	d
PERFTOOLS_DLL_DECL	src/gperftools/heap-profiler.h	59;"	d
PERFTOOLS_DLL_DECL	src/gperftools/heap-profiler.h	61;"	d
PERFTOOLS_DLL_DECL	src/gperftools/malloc_extension.h	59;"	d
PERFTOOLS_DLL_DECL	src/gperftools/malloc_extension.h	61;"	d
PERFTOOLS_DLL_DECL	src/gperftools/malloc_extension_c.h	48;"	d
PERFTOOLS_DLL_DECL	src/gperftools/malloc_extension_c.h	50;"	d
PERFTOOLS_DLL_DECL	src/gperftools/malloc_hook.h	79;"	d
PERFTOOLS_DLL_DECL	src/gperftools/malloc_hook.h	81;"	d
PERFTOOLS_DLL_DECL	src/gperftools/malloc_hook_c.h	46;"	d
PERFTOOLS_DLL_DECL	src/gperftools/malloc_hook_c.h	48;"	d
PERFTOOLS_DLL_DECL	src/gperftools/nallocx.h	7;"	d
PERFTOOLS_DLL_DECL	src/gperftools/nallocx.h	9;"	d
PERFTOOLS_DLL_DECL	src/gperftools/profiler.h	68;"	d
PERFTOOLS_DLL_DECL	src/gperftools/profiler.h	70;"	d
PERFTOOLS_DLL_DECL	src/gperftools/stacktrace.h	43;"	d
PERFTOOLS_DLL_DECL	src/gperftools/stacktrace.h	45;"	d
PERFTOOLS_DLL_DECL	src/gperftools/tcmalloc.h	73;"	d
PERFTOOLS_DLL_DECL	src/gperftools/tcmalloc.h	75;"	d
PERFTOOLS_DLL_DECL	src/gperftools/tcmalloc.h.in	73;"	d	file:
PERFTOOLS_DLL_DECL	src/gperftools/tcmalloc.h.in	75;"	d	file:
PERFTOOLS_DLL_DECL	src/windows/config.h	260;"	d
PERFTOOLS_DLL_DECL	src/windows/gperftools/tcmalloc.h	68;"	d
PERFTOOLS_DLL_DECL	src/windows/gperftools/tcmalloc.h	70;"	d
PERFTOOLS_DLL_DECL	src/windows/gperftools/tcmalloc.h.in	68;"	d	file:
PERFTOOLS_DLL_DECL	src/windows/gperftools/tcmalloc.h.in	70;"	d	file:
PERFTOOLS_DLL_DECL_FOR_UNITTESTS	src/windows/config.h	261;"	d
PERFTOOLS_IS_A_DLL	src/windows/config.h	259;"	d
PERFTOOLS_NOTHROW	src/gperftools/tcmalloc.h	159;"	d
PERFTOOLS_NOTHROW	src/gperftools/tcmalloc.h	58;"	d
PERFTOOLS_NOTHROW	src/gperftools/tcmalloc.h	60;"	d
PERFTOOLS_NOTHROW	src/gperftools/tcmalloc.h	63;"	d
PERFTOOLS_NOTHROW	src/gperftools/tcmalloc.h	65;"	d
PERFTOOLS_NOTHROW	src/gperftools/tcmalloc.h.in	159;"	d	file:
PERFTOOLS_NOTHROW	src/gperftools/tcmalloc.h.in	58;"	d	file:
PERFTOOLS_NOTHROW	src/gperftools/tcmalloc.h.in	60;"	d	file:
PERFTOOLS_NOTHROW	src/gperftools/tcmalloc.h.in	63;"	d	file:
PERFTOOLS_NOTHROW	src/gperftools/tcmalloc.h.in	65;"	d	file:
PERFTOOLS_NOTHROW	src/tcmalloc.cc	93;"	d	file:
PERFTOOLS_NOTHROW	src/windows/gperftools/tcmalloc.h	151;"	d
PERFTOOLS_NOTHROW	src/windows/gperftools/tcmalloc.h	53;"	d
PERFTOOLS_NOTHROW	src/windows/gperftools/tcmalloc.h	55;"	d
PERFTOOLS_NOTHROW	src/windows/gperftools/tcmalloc.h	58;"	d
PERFTOOLS_NOTHROW	src/windows/gperftools/tcmalloc.h	60;"	d
PERFTOOLS_NOTHROW	src/windows/gperftools/tcmalloc.h.in	151;"	d	file:
PERFTOOLS_NOTHROW	src/windows/gperftools/tcmalloc.h.in	53;"	d	file:
PERFTOOLS_NOTHROW	src/windows/gperftools/tcmalloc.h.in	55;"	d	file:
PERFTOOLS_NOTHROW	src/windows/gperftools/tcmalloc.h.in	58;"	d	file:
PERFTOOLS_NOTHROW	src/windows/gperftools/tcmalloc.h.in	60;"	d	file:
PERFTOOLS_NO_ALIGNED_MALLOC	src/windows/mingw.h	46;"	d
PLATFORM_WINDOWS	src/base/sysinfo.cc	33;"	d	file:
PLAT_amd64_linux	src/third_party/valgrind.h	3918;"	d
PLAT_amd64_linux	src/third_party/valgrind.h	89;"	d
PLAT_amd64_linux	src/third_party/valgrind.h	98;"	d
PLAT_ppc32_aix5	src/third_party/valgrind.h	106;"	d
PLAT_ppc32_aix5	src/third_party/valgrind.h	3921;"	d
PLAT_ppc32_aix5	src/third_party/valgrind.h	92;"	d
PLAT_ppc32_linux	src/third_party/valgrind.h	100;"	d
PLAT_ppc32_linux	src/third_party/valgrind.h	3919;"	d
PLAT_ppc32_linux	src/third_party/valgrind.h	90;"	d
PLAT_ppc64_aix5	src/third_party/valgrind.h	104;"	d
PLAT_ppc64_aix5	src/third_party/valgrind.h	3922;"	d
PLAT_ppc64_aix5	src/third_party/valgrind.h	93;"	d
PLAT_ppc64_linux	src/third_party/valgrind.h	102;"	d
PLAT_ppc64_linux	src/third_party/valgrind.h	3920;"	d
PLAT_ppc64_linux	src/third_party/valgrind.h	91;"	d
PLAT_x86_linux	src/third_party/valgrind.h	3917;"	d
PLAT_x86_linux	src/third_party/valgrind.h	88;"	d
PLAT_x86_linux	src/third_party/valgrind.h	96;"	d
PMODULEENTRY32	src/base/sysinfo.cc	74;"	d	file:
POSIX	src/pprof	/^use POSIX;$/;"	v
PREDICT_FALSE	src/base/basictypes.h	122;"	d
PREDICT_FALSE	src/base/basictypes.h	125;"	d
PREDICT_TRUE	src/base/basictypes.h	121;"	d
PREDICT_TRUE	src/base/basictypes.h	124;"	d
PRINTABLE_PTHREAD	src/base/basictypes.h	115;"	d
PRINTABLE_PTHREAD	src/base/basictypes.h	117;"	d
PRId64	src/base/basictypes.h	99;"	d
PRId64	src/windows/port.h	345;"	d
PRIdS	src/config.h	256;"	d
PRIdS	src/config.h.in	255;"	d	file:
PRIdS	src/windows/config.h	265;"	d
PRIu64	src/base/basictypes.h	105;"	d
PRIu64	src/windows/port.h	347;"	d
PRIuPTR	src/windows/port.h	349;"	d
PRIuPTR	src/windows/port.h	352;"	d
PRIuS	src/config.h	259;"	d
PRIuS	src/config.h.in	258;"	d	file:
PRIuS	src/windows/config.h	268;"	d
PRIx64	src/base/basictypes.h	93;"	d
PRIx64	src/windows/port.h	343;"	d
PRIxPTR	src/base/basictypes.h	108;"	d
PRIxPTR	src/windows/port.h	350;"	d
PRIxPTR	src/windows/port.h	353;"	d
PRIxS	src/config.h	262;"	d
PRIxS	src/config.h.in	261;"	d	file:
PRIxS	src/windows/config.h	271;"	d
PROC_MAPS_USED	src/gperftools/heap-checker.h	/^    PROC_MAPS_USED,$/;"	e	enum:HeapLeakChecker::ProcMapsResult
PROT_READ	src/windows/port.h	276;"	d
PROT_WRITE	src/windows/port.h	277;"	d
PR_GET_DUMPABLE	src/base/linux_syscall_support.h	556;"	d
PR_SET_DUMPABLE	src/base/linux_syscall_support.h	559;"	d
PS1	config.status	/^PS1='$ '$/;"	v
PS1	configure	/^PS1='$ '$/;"	v
PS2PDF	src/pprof	/^my @PS2PDF = ("ps2pdf");$/;"	v
PSAPI_VERSION	src/windows/patch_functions.cc	82;"	d	file:
PTHREADS_CRASHES_IF_RUN_TOO_EARLY	configure.ac	609;"	d	file:
PTHREADS_CRASHES_IF_RUN_TOO_EARLY	src/config.h	267;"	d
PTHREADS_CRASHES_IF_RUN_TOO_EARLY	src/config.h.in	266;"	d	file:
PTHREADS_CRASHES_IF_RUN_TOO_EARLY	src/windows/config.h	276;"	d
PTHREAD_CFLAGS	m4/acx_pthread.m4	/^		PTHREAD_CFLAGS="`pthread-config --cflags`"$/;"	v
PTHREAD_CFLAGS	m4/acx_pthread.m4	/^            PTHREAD_CFLAGS="$flag $PTHREAD_CFLAGS"$/;"	v
PTHREAD_CREATE_JOINABLE	m4/acx_pthread.m4	/^        if test "$attr_name" != PTHREAD_CREATE_JOINABLE; then$/;"	v
PTHREAD_CREATE_JOINABLE	src/config.h.in	271;"	d	file:
PTHREAD_CREATE_JOINABLE	src/windows/config.h	281;"	d
PTHREAD_LIBS	m4/acx_pthread.m4	/^                PTHREAD_LIBS=""$/;"	v
PTHREAD_LIBS	m4/acx_pthread.m4	/^        PTHREAD_LIBS=""$/;"	v
PTHREAD_ONCE_INIT	src/windows/port.h	/^enum { PTHREAD_ONCE_INIT = 0 };   \/* important that this be 0! for SpinLock *\/$/;"	e	enum:__anon16
PT_GUARDED_BY	src/base/thread_annotations.h	74;"	d
PT_GUARDED_VAR	src/base/thread_annotations.h	76;"	d
PackedCache	src/packed-cache-inl.h	/^  explicit PackedCache() {$/;"	f	class:PackedCache	access:public	signature:()
PackedCache	src/packed-cache-inl.h	/^class PackedCache {$/;"	c
PackedCache::Clear	src/packed-cache-inl.h	/^  void Clear() {$/;"	f	class:PackedCache	access:public	signature:()
PackedCache::Hash	src/packed-cache-inl.h	/^  static T Hash(K key) {$/;"	f	class:PackedCache	access:private	signature:(K key)
PackedCache::Invalidate	src/packed-cache-inl.h	/^  void Invalidate(K key) {$/;"	f	class:PackedCache	access:public	signature:(K key)
PackedCache::K	src/packed-cache-inl.h	/^  typedef uintptr_t K;$/;"	t	class:PackedCache	access:public
PackedCache::KeyToUpper	src/packed-cache-inl.h	/^  static T KeyToUpper(K k) {$/;"	f	class:PackedCache	access:private	signature:(K k)
PackedCache::PackedCache	src/packed-cache-inl.h	/^  explicit PackedCache() {$/;"	f	class:PackedCache	access:public	signature:()
PackedCache::Put	src/packed-cache-inl.h	/^  void Put(K key, V value) {$/;"	f	class:PackedCache	access:public	signature:(K key, V value)
PackedCache::T	src/packed-cache-inl.h	/^  typedef uintptr_t T;$/;"	t	class:PackedCache	access:public
PackedCache::TryGet	src/packed-cache-inl.h	/^  bool TryGet(K key, V* out) const {$/;"	f	class:PackedCache	access:public	signature:(K key, V* out) const
PackedCache::V	src/packed-cache-inl.h	/^  typedef uint32 V;$/;"	t	class:PackedCache	access:public
PackedCache::array_	src/packed-cache-inl.h	/^  volatile T array_[1 << kHashbits];$/;"	m	class:PackedCache	access:private
PackedCache::kHashbits	src/packed-cache-inl.h	/^  static const int kHashbits = 12;$/;"	m	class:PackedCache	access:public
PackedCache::kHashbits	src/packed-cache-inl.h	/^  static const int kHashbits = 16;$/;"	m	class:PackedCache	access:public
PackedCache::kInvalidMask	src/packed-cache-inl.h	/^  static const int kInvalidMask = 0x80;$/;"	m	class:PackedCache	access:public
PackedCache::kKeyMask	src/packed-cache-inl.h	/^  static const K kKeyMask = N_ONES_(K, kKeybits);$/;"	m	class:PackedCache	access:private
PackedCache::kValueMask	src/packed-cache-inl.h	/^  static const V kValueMask = N_ONES_(V, kValuebits);$/;"	m	class:PackedCache	access:private
PackedCache::kValuebits	src/packed-cache-inl.h	/^  static const int kValuebits = 7;$/;"	m	class:PackedCache	access:public
PackedCacheTest_basic	src/tests/packed-cache_test.cc	/^void PackedCacheTest_basic() {$/;"	f	signature:()
PageHeap	src/page_heap.cc	/^PageHeap::PageHeap()$/;"	f	class:tcmalloc::PageHeap	signature:()
PageHeap	src/page_heap.h	/^  PageHeap();$/;"	p	class:tcmalloc::PageHeap	access:public	signature:()
PageHeap	src/page_heap.h	/^class PERFTOOLS_DLL_DECL PageHeap {$/;"	c	namespace:tcmalloc
PageHeapAllocator	src/page_heap_allocator.h	/^class PageHeapAllocator {$/;"	c	namespace:tcmalloc
PageHeapStorage	src/static_vars.h	/^  union PageHeapStorage {$/;"	u	class:tcmalloc::Static	access:private
PageID	src/common.h	/^typedef uintptr_t PageID;$/;"	t
PageMap	src/page_heap.h	/^  typedef MapSelector<kAddressBits>::Type PageMap;$/;"	t	class:tcmalloc::PageHeap	access:private
PageMapCache	src/page_heap.h	/^  typedef PackedCache<kAddressBits - kPageShift> PageMapCache;$/;"	t	class:tcmalloc::PageHeap	access:private
PagesAllocator	src/base/low_level_alloc.h	/^  class PagesAllocator {$/;"	c	class:LowLevelAlloc	access:public
PagesToMiB	src/tcmalloc.cc	/^static double PagesToMiB(uint64_t pages) {$/;"	f	file:	signature:(uint64_t pages)
ParseProcMapsLine	src/base/sysinfo.cc	/^static bool ParseProcMapsLine(char *text, uint64 *start, uint64 *end,$/;"	f	file:	signature:(char *text, uint64 *start, uint64 *end, char *flags, uint64 *offset, int *major, int *minor, int64 *inode, unsigned *filename_offset)
Pass	src/tests/heap-checker_unittest.cc	/^static int Pass() {$/;"	f	file:	signature:()
PassObject	src/tests/tcmalloc_unittest.cc	/^  void PassObject() {$/;"	f	class:testing::TesterThread	access:public	signature:()
Patch	src/windows/patch_functions.cc	/^  bool Patch(const LibcInfo& me_info);$/;"	p	class:__anon13::LibcInfoWithPatchFunctions	file:	access:public	signature:(const LibcInfo& me_info)
Patch	src/windows/patch_functions.cc	/^  void Patch();$/;"	p	class:__anon13::WindowsInfo	file:	access:public	signature:()
Patch	src/windows/patch_functions.cc	/^bool LibcInfoWithPatchFunctions<T>::Patch(const LibcInfo& me_info) {$/;"	f	class:__anon13::LibcInfoWithPatchFunctions	signature:(const LibcInfo& me_info)
Patch	src/windows/patch_functions.cc	/^void WindowsInfo::Patch() {$/;"	f	class:__anon13::WindowsInfo	signature:()
Patch	src/windows/preamble_patcher.h	/^  static SideStepError Patch(LPCTSTR module_name,$/;"	f	class:sidestep::PreamblePatcher	access:public	signature:(LPCTSTR module_name, LPCSTR function_name, T replacement_function, T* original_function_stub)
Patch	src/windows/preamble_patcher.h	/^  static SideStepError Patch(T target_function,$/;"	f	class:sidestep::PreamblePatcher	access:public	signature:(T target_function, T replacement_function, T* original_function_stub)
PatchAllModules	src/windows/patch_functions.cc	/^bool PatchAllModules() {$/;"	f	namespace:__anon13	signature:()
PatchMainExecutableLocked	src/windows/patch_functions.cc	/^void PatchMainExecutableLocked() {$/;"	f	namespace:__anon13	signature:()
PatchMovWithDisplacement	src/windows/preamble_patcher.cc	/^SideStepError PreamblePatcher::PatchMovWithDisplacement($/;"	f	class:sidestep::PreamblePatcher	signature:( unsigned char* source, unsigned int instruction_size, unsigned char* target, unsigned int* target_bytes, unsigned int target_size)
PatchMovWithDisplacement	src/windows/preamble_patcher.h	/^  static SideStepError PatchMovWithDisplacement(unsigned char* source,$/;"	p	class:sidestep::PreamblePatcher	access:private	signature:(unsigned char* source, unsigned int instruction_size, unsigned char* target, unsigned int* target_bytes, unsigned int target_size)
PatchNearJumpOrCall	src/windows/preamble_patcher.cc	/^SideStepError PreamblePatcher::PatchNearJumpOrCall($/;"	f	class:sidestep::PreamblePatcher	signature:( unsigned char* source, unsigned int instruction_size, unsigned char* target, unsigned int* target_bytes, unsigned int target_size)
PatchNearJumpOrCall	src/windows/preamble_patcher.h	/^  static SideStepError PatchNearJumpOrCall(unsigned char* source,$/;"	p	class:sidestep::PreamblePatcher	access:private	signature:(unsigned char* source, unsigned int instruction_size, unsigned char* target, unsigned int* target_bytes, unsigned int target_size)
PatchOneModuleLocked	src/windows/patch_functions.cc	/^void PatchOneModuleLocked(const LibcInfo& me_info) {$/;"	f	namespace:__anon13	signature:(const LibcInfo& me_info)
PatchShortConditionalJump	src/windows/preamble_patcher.cc	/^SideStepError PreamblePatcher::PatchShortConditionalJump($/;"	f	class:sidestep::PreamblePatcher	signature:( unsigned char* source, unsigned int instruction_size, unsigned char* target, unsigned int* target_bytes, unsigned int target_size)
PatchShortConditionalJump	src/windows/preamble_patcher.h	/^  static SideStepError PatchShortConditionalJump(unsigned char* source,$/;"	p	class:sidestep::PreamblePatcher	access:private	signature:(unsigned char* source, unsigned int instruction_size, unsigned char* target, unsigned int* target_bytes, unsigned int target_size)
PatchShortJump	src/windows/preamble_patcher.cc	/^SideStepError PreamblePatcher::PatchShortJump($/;"	f	class:sidestep::PreamblePatcher	signature:( unsigned char* source, unsigned int instruction_size, unsigned char* target, unsigned int* target_bytes, unsigned int target_size)
PatchShortJump	src/windows/preamble_patcher.h	/^  static SideStepError PatchShortJump(unsigned char* source,$/;"	p	class:sidestep::PreamblePatcher	access:private	signature:(unsigned char* source, unsigned int instruction_size, unsigned char* target, unsigned int* target_bytes, unsigned int target_size)
PatchThenUnpatch	src/windows/preamble_patcher_test.cc	/^bool PatchThenUnpatch() {$/;"	f	namespace:sidestep	signature:()
PatchWindowsFunctions	src/libc_override.h	/^void PatchWindowsFunctions();   \/\/ in src\/windows\/patch_function.cc$/;"	p	signature:()
PatchWindowsFunctions	src/windows/patch_functions.cc	/^void PatchWindowsFunctions() {$/;"	f	signature:()
PatchWindowsFunctions	src/windows/port.h	/^extern void PatchWindowsFunctions();$/;"	p	signature:()
Pause	src/tests/heap-checker_unittest.cc	/^static void Pause() {$/;"	f	file:	signature:()
Perftools_FreeLibrary	src/windows/patch_functions.cc	/^  static BOOL WINAPI Perftools_FreeLibrary(HMODULE hLibModule);$/;"	p	class:__anon13::WindowsInfo	file:	access:private	signature:(HMODULE hLibModule)
Perftools_FreeLibrary	src/windows/patch_functions.cc	/^BOOL WINAPI WindowsInfo::Perftools_FreeLibrary(HMODULE hLibModule) {$/;"	f	class:WindowsInfo	signature:(HMODULE hLibModule)
Perftools_HeapAlloc	src/windows/patch_functions.cc	/^  static LPVOID WINAPI Perftools_HeapAlloc(HANDLE hHeap, DWORD dwFlags,$/;"	p	class:__anon13::WindowsInfo	file:	access:private	signature:(HANDLE hHeap, DWORD dwFlags, DWORD_PTR dwBytes)
Perftools_HeapAlloc	src/windows/patch_functions.cc	/^LPVOID WINAPI WindowsInfo::Perftools_HeapAlloc(HANDLE hHeap, DWORD dwFlags,$/;"	f	class:WindowsInfo	signature:(HANDLE hHeap, DWORD dwFlags, DWORD_PTR dwBytes)
Perftools_HeapFree	src/windows/patch_functions.cc	/^  static BOOL WINAPI Perftools_HeapFree(HANDLE hHeap, DWORD dwFlags,$/;"	p	class:__anon13::WindowsInfo	file:	access:private	signature:(HANDLE hHeap, DWORD dwFlags, LPVOID lpMem)
Perftools_HeapFree	src/windows/patch_functions.cc	/^BOOL WINAPI WindowsInfo::Perftools_HeapFree(HANDLE hHeap, DWORD dwFlags,$/;"	f	class:WindowsInfo	signature:(HANDLE hHeap, DWORD dwFlags, LPVOID lpMem)
Perftools_LoadLibraryExW	src/windows/patch_functions.cc	/^  static HMODULE WINAPI Perftools_LoadLibraryExW(LPCWSTR lpFileName,$/;"	p	class:__anon13::WindowsInfo	file:	access:private	signature:(LPCWSTR lpFileName, HANDLE hFile, DWORD dwFlags)
Perftools_LoadLibraryExW	src/windows/patch_functions.cc	/^HMODULE WINAPI WindowsInfo::Perftools_LoadLibraryExW(LPCWSTR lpFileName,$/;"	f	class:WindowsInfo	signature:(LPCWSTR lpFileName, HANDLE hFile, DWORD dwFlags)
Perftools_MapViewOfFileEx	src/windows/patch_functions.cc	/^  static LPVOID WINAPI Perftools_MapViewOfFileEx(HANDLE hFileMappingObject,$/;"	p	class:__anon13::WindowsInfo	file:	access:private	signature:(HANDLE hFileMappingObject, DWORD dwDesiredAccess, DWORD dwFileOffsetHigh, DWORD dwFileOffsetLow, SIZE_T dwNumberOfBytesToMap, LPVOID lpBaseAddress)
Perftools_MapViewOfFileEx	src/windows/patch_functions.cc	/^LPVOID WINAPI WindowsInfo::Perftools_MapViewOfFileEx($/;"	f	class:WindowsInfo	signature:( HANDLE hFileMappingObject, DWORD dwDesiredAccess, DWORD dwFileOffsetHigh, DWORD dwFileOffsetLow, SIZE_T dwNumberOfBytesToMap, LPVOID lpBaseAddress)
Perftools_UnmapViewOfFile	src/windows/patch_functions.cc	/^  static BOOL WINAPI Perftools_UnmapViewOfFile(LPCVOID lpBaseAddress);$/;"	p	class:__anon13::WindowsInfo	file:	access:private	signature:(LPCVOID lpBaseAddress)
Perftools_UnmapViewOfFile	src/windows/patch_functions.cc	/^BOOL WINAPI WindowsInfo::Perftools_UnmapViewOfFile(LPCVOID lpBaseAddress) {$/;"	f	class:WindowsInfo	signature:(LPCVOID lpBaseAddress)
Perftools_VirtualAllocEx	src/windows/patch_functions.cc	/^  static LPVOID WINAPI Perftools_VirtualAllocEx(HANDLE process, LPVOID address,$/;"	p	class:__anon13::WindowsInfo	file:	access:private	signature:(HANDLE process, LPVOID address, SIZE_T size, DWORD type, DWORD protect)
Perftools_VirtualAllocEx	src/windows/patch_functions.cc	/^LPVOID WINAPI WindowsInfo::Perftools_VirtualAllocEx(HANDLE process,$/;"	f	class:WindowsInfo	signature:(HANDLE process, LPVOID address, SIZE_T size, DWORD type, DWORD protect)
Perftools_VirtualFreeEx	src/windows/patch_functions.cc	/^  static BOOL WINAPI Perftools_VirtualFreeEx(HANDLE process, LPVOID address,$/;"	p	class:__anon13::WindowsInfo	file:	access:private	signature:(HANDLE process, LPVOID address, SIZE_T size, DWORD type)
Perftools_VirtualFreeEx	src/windows/patch_functions.cc	/^BOOL WINAPI WindowsInfo::Perftools_VirtualFreeEx(HANDLE process, LPVOID address,$/;"	f	class:WindowsInfo	signature:(HANDLE process, LPVOID address, SIZE_T size, DWORD type)
Perftools_delete	src/windows/patch_functions.cc	/^  static void Perftools_delete(void *ptr);$/;"	p	class:__anon13::LibcInfoWithPatchFunctions	file:	access:private	signature:(void *ptr)
Perftools_delete	src/windows/patch_functions.cc	/^void LibcInfoWithPatchFunctions<T>::Perftools_delete(void *p) {$/;"	f	class:LibcInfoWithPatchFunctions	signature:(void *p)
Perftools_deletearray	src/windows/patch_functions.cc	/^  static void Perftools_deletearray(void *ptr);$/;"	p	class:__anon13::LibcInfoWithPatchFunctions	file:	access:private	signature:(void *ptr)
Perftools_deletearray	src/windows/patch_functions.cc	/^void LibcInfoWithPatchFunctions<T>::Perftools_deletearray(void *p) {$/;"	f	class:LibcInfoWithPatchFunctions	signature:(void *p)
Perftools_new	src/windows/patch_functions.cc	/^  static void* Perftools_new(size_t size);$/;"	p	class:__anon13::LibcInfoWithPatchFunctions	file:	access:private	signature:(size_t size)
Perftools_new	src/windows/patch_functions.cc	/^void* LibcInfoWithPatchFunctions<T>::Perftools_new(size_t size) {$/;"	f	class:LibcInfoWithPatchFunctions	signature:(size_t size)
Perftools_newarray	src/windows/patch_functions.cc	/^  static void* Perftools_newarray(size_t size);$/;"	p	class:__anon13::LibcInfoWithPatchFunctions	file:	access:private	signature:(size_t size)
Perftools_newarray	src/windows/patch_functions.cc	/^void* LibcInfoWithPatchFunctions<T>::Perftools_newarray(size_t size) {$/;"	f	class:LibcInfoWithPatchFunctions	signature:(size_t size)
Permute	src/tests/pagemap_unittest.cc	/^static void Permute(vector<intptr_t>* elements) {$/;"	f	file:	signature:(vector<intptr_t>* elements)
PickNextSample	src/tests/sampler_test.cc	/^  void PickNextSample(size_t k);$/;"	p	class:OldSampler	file:	access:public	signature:(size_t k)
PickNextSample	src/tests/sampler_test.cc	/^void OldSampler::PickNextSample(size_t k) {$/;"	f	class:OldSampler	signature:(size_t k)
PickNextSamplingPoint	src/sampler.cc	/^ssize_t Sampler::PickNextSamplingPoint() {$/;"	f	class:tcmalloc::Sampler	signature:()
PickNextSamplingPoint	src/sampler.h	/^  ssize_t PickNextSamplingPoint();$/;"	p	class:tcmalloc::Sampler	access:public	signature:()
PickType	src/tests/tcmalloc_unittest.cc	/^  int PickType();$/;"	p	class:testing::TestHarness	file:	access:public	signature:()
PickType	src/tests/tcmalloc_unittest.cc	/^int TestHarness::PickType() {$/;"	f	class:testing::TestHarness	signature:()
Pop	src/debugallocation.cc	/^  QueueEntry Pop() {$/;"	f	class:FreeQueue	access:public	signature:()
Pop	src/thread_cache.h	/^    void* Pop() {$/;"	f	class:tcmalloc::ThreadCache::FreeList	access:public	signature:()
PopRange	src/thread_cache.h	/^    void PopRange(int N, void **start, void **end) {$/;"	f	class:tcmalloc::ThreadCache::FreeList	access:public	signature:(int N, void **start, void **end)
Populate	src/central_freelist.cc	/^void CentralFreeList::Populate() {$/;"	f	class:tcmalloc::CentralFreeList	signature:()
PopulateWindowsFn	src/windows/patch_functions.cc	/^  bool PopulateWindowsFn(const ModuleEntryCopy& module_entry);$/;"	p	class:__anon13::LibcInfo	file:	access:public	signature:(const ModuleEntryCopy& module_entry)
PopulateWindowsFn	src/windows/patch_functions.cc	/^bool LibcInfo::PopulateWindowsFn(const ModuleEntryCopy& module_entry) {$/;"	f	class:__anon13::LibcInfo	signature:(const ModuleEntryCopy& module_entry)
PosixMemalign	src/tests/tcmalloc_unittest.cc	/^static inline int PosixMemalign(void** ptr, size_t align, size_t size) {$/;"	f	file:	signature:(void** ptr, size_t align, size_t size)
PreMmapHook	src/gperftools/malloc_hook.h	/^  typedef MallocHook_PreMmapHook PreMmapHook;$/;"	t	class:MallocHook	access:public
PreSbrkHook	src/gperftools/malloc_hook.h	/^  typedef MallocHook_PreSbrkHook PreSbrkHook;$/;"	t	class:MallocHook	access:public
PreallocateMoreMemory	src/pagemap.h	/^  void PreallocateMoreMemory() {$/;"	f	class:TCMalloc_PageMap2	access:public	signature:()
PreallocateMoreMemory	src/pagemap.h	/^  void PreallocateMoreMemory() {$/;"	f	class:TCMalloc_PageMap3	access:public	signature:()
PreallocateMoreMemory	src/pagemap.h	/^  void PreallocateMoreMemory() {}$/;"	f	class:TCMalloc_PageMap1	access:public	signature:()
PreamblePage	src/windows/preamble_patcher.h	/^  struct PreamblePage {$/;"	s	class:sidestep::PreamblePatcher	access:private
PreamblePatcher	src/windows/preamble_patcher.h	/^class PERFTOOLS_DLL_DECL PreamblePatcher {$/;"	c	namespace:sidestep
PrependToFreeList	src/page_heap.cc	/^void PageHeap::PrependToFreeList(Span* span) {$/;"	f	class:tcmalloc::PageHeap	signature:(Span* span)
PrependToFreeList	src/page_heap.h	/^  void PrependToFreeList(Span* span);$/;"	p	class:tcmalloc::PageHeap	access:private	signature:(Span* span)
PreventHeapReclaiming	src/tests/heap-checker_unittest.cc	/^void PreventHeapReclaiming(size_t size) {$/;"	f	signature:(size_t size)
PrintAvailability	src/windows/nm-pdb.c	/^static void PrintAvailability(BOOL var, const char *description) {$/;"	f	file:	signature:(BOOL var, const char *description)
PrintCountAndSize	src/malloc_extension.cc	/^void PrintCountAndSize(MallocExtensionWriter* writer,$/;"	f	namespace:__anon21	signature:(MallocExtensionWriter* writer, uintptr_t count, uintptr_t size)
PrintError	src/symbolize.cc	/^static void PrintError(const char* reason) {$/;"	f	file:	signature:(const char* reason)
PrintHeader	src/malloc_extension.cc	/^void PrintHeader(MallocExtensionWriter* writer,$/;"	f	namespace:__anon21	signature:(MallocExtensionWriter* writer, const char* label, void** entries)
PrintStackEntry	src/malloc_extension.cc	/^void PrintStackEntry(MallocExtensionWriter* writer, void** entry) {$/;"	f	namespace:__anon21	signature:(MallocExtensionWriter* writer, void** entry)
PrintStats	src/tcmalloc.cc	/^static void PrintStats(int level) {$/;"	f	file:	signature:(int level)
Printf	src/raw_printer.cc	/^void RawPrinter::Printf(const char* format, ...) {$/;"	f	class:base::RawPrinter	signature:(const char* format, ...)
Printf	src/raw_printer.h	/^  void Printf(const char* format, ...)$/;"	p	class:base::RawPrinter	access:public	signature:(const char* format, ...)
ProcMapsIterator	src/base/sysinfo.cc	/^ProcMapsIterator::ProcMapsIterator(pid_t pid) {$/;"	f	class:ProcMapsIterator	signature:(pid_t pid)
ProcMapsIterator	src/base/sysinfo.cc	/^ProcMapsIterator::ProcMapsIterator(pid_t pid, Buffer *buffer) {$/;"	f	class:ProcMapsIterator	signature:(pid_t pid, Buffer *buffer)
ProcMapsIterator	src/base/sysinfo.cc	/^ProcMapsIterator::ProcMapsIterator(pid_t pid, Buffer *buffer,$/;"	f	class:ProcMapsIterator	signature:(pid_t pid, Buffer *buffer, bool use_maps_backing)
ProcMapsIterator	src/base/sysinfo.h	/^  ProcMapsIterator(pid_t pid, Buffer *buffer);$/;"	p	class:ProcMapsIterator	access:public	signature:(pid_t pid, Buffer *buffer)
ProcMapsIterator	src/base/sysinfo.h	/^  ProcMapsIterator(pid_t pid, Buffer *buffer,$/;"	p	class:ProcMapsIterator	access:public	signature:(pid_t pid, Buffer *buffer, bool use_maps_backing)
ProcMapsIterator	src/base/sysinfo.h	/^  explicit ProcMapsIterator(pid_t pid);$/;"	p	class:ProcMapsIterator	access:public	signature:(pid_t pid)
ProcMapsIterator	src/base/sysinfo.h	/^class ProcMapsIterator {$/;"	c
ProcMapsIterator::Buffer	src/base/sysinfo.h	/^  struct Buffer {$/;"	s	class:ProcMapsIterator	access:public
ProcMapsIterator::Buffer::buf_	src/base/sysinfo.h	/^    char buf_[kBufSize];$/;"	m	struct:ProcMapsIterator::Buffer	access:public
ProcMapsIterator::Buffer::kBufSize	src/base/sysinfo.h	/^    static const size_t kBufSize = 102400;$/;"	m	struct:ProcMapsIterator::Buffer	access:public
ProcMapsIterator::CurrentLine	src/base/sysinfo.h	/^  const char *CurrentLine() const { return stext_; }$/;"	f	class:ProcMapsIterator	access:public	signature:() const
ProcMapsIterator::FormatLine	src/base/sysinfo.cc	/^int ProcMapsIterator::FormatLine(char* buffer, int bufsize,$/;"	f	class:ProcMapsIterator	signature:(char* buffer, int bufsize, uint64 start, uint64 end, const char *flags, uint64 offset, int64 inode, const char *filename, dev_t dev)
ProcMapsIterator::FormatLine	src/base/sysinfo.h	/^  static int FormatLine(char* buffer, int bufsize,$/;"	p	class:ProcMapsIterator	access:public	signature:(char* buffer, int bufsize, uint64 start, uint64 end, const char *flags, uint64 offset, int64 inode, const char *filename, dev_t dev)
ProcMapsIterator::Init	src/base/sysinfo.cc	/^void ProcMapsIterator::Init(pid_t pid, Buffer *buffer,$/;"	f	class:ProcMapsIterator	signature:(pid_t pid, Buffer *buffer, bool use_maps_backing)
ProcMapsIterator::Init	src/base/sysinfo.h	/^  void Init(pid_t pid, Buffer *buffer, bool use_maps_backing);$/;"	p	class:ProcMapsIterator	access:private	signature:(pid_t pid, Buffer *buffer, bool use_maps_backing)
ProcMapsIterator::Next	src/base/sysinfo.cc	/^bool ProcMapsIterator::Next(uint64 *start, uint64 *end, char **flags,$/;"	f	class:ProcMapsIterator	signature:(uint64 *start, uint64 *end, char **flags, uint64 *offset, int64 *inode, char **filename)
ProcMapsIterator::Next	src/base/sysinfo.h	/^  bool Next(uint64 *start, uint64 *end, char **flags,$/;"	p	class:ProcMapsIterator	access:public	signature:(uint64 *start, uint64 *end, char **flags, uint64 *offset, int64 *inode, char **filename)
ProcMapsIterator::NextExt	src/base/sysinfo.cc	/^bool ProcMapsIterator::NextExt(uint64 *start, uint64 *end, char **flags,$/;"	f	class:ProcMapsIterator	signature:(uint64 *start, uint64 *end, char **flags, uint64 *offset, int64 *inode, char **filename, uint64 *file_mapping, uint64 *file_pages, uint64 *anon_mapping, uint64 *anon_pages, dev_t *dev)
ProcMapsIterator::NextExt	src/base/sysinfo.h	/^  bool NextExt(uint64 *start, uint64 *end, char **flags,$/;"	p	class:ProcMapsIterator	access:public	signature:(uint64 *start, uint64 *end, char **flags, uint64 *offset, int64 *inode, char **filename, uint64 *file_mapping, uint64 *file_pages, uint64 *anon_mapping, uint64 *anon_pages, dev_t *dev)
ProcMapsIterator::ProcMapsIterator	src/base/sysinfo.cc	/^ProcMapsIterator::ProcMapsIterator(pid_t pid) {$/;"	f	class:ProcMapsIterator	signature:(pid_t pid)
ProcMapsIterator::ProcMapsIterator	src/base/sysinfo.cc	/^ProcMapsIterator::ProcMapsIterator(pid_t pid, Buffer *buffer) {$/;"	f	class:ProcMapsIterator	signature:(pid_t pid, Buffer *buffer)
ProcMapsIterator::ProcMapsIterator	src/base/sysinfo.cc	/^ProcMapsIterator::ProcMapsIterator(pid_t pid, Buffer *buffer,$/;"	f	class:ProcMapsIterator	signature:(pid_t pid, Buffer *buffer, bool use_maps_backing)
ProcMapsIterator::ProcMapsIterator	src/base/sysinfo.h	/^  ProcMapsIterator(pid_t pid, Buffer *buffer);$/;"	p	class:ProcMapsIterator	access:public	signature:(pid_t pid, Buffer *buffer)
ProcMapsIterator::ProcMapsIterator	src/base/sysinfo.h	/^  ProcMapsIterator(pid_t pid, Buffer *buffer,$/;"	p	class:ProcMapsIterator	access:public	signature:(pid_t pid, Buffer *buffer, bool use_maps_backing)
ProcMapsIterator::ProcMapsIterator	src/base/sysinfo.h	/^  explicit ProcMapsIterator(pid_t pid);$/;"	p	class:ProcMapsIterator	access:public	signature:(pid_t pid)
ProcMapsIterator::Valid	src/base/sysinfo.cc	/^bool ProcMapsIterator::Valid() const {$/;"	f	class:ProcMapsIterator	signature:() const
ProcMapsIterator::Valid	src/base/sysinfo.h	/^  bool Valid() const;$/;"	p	class:ProcMapsIterator	access:public	signature:() const
ProcMapsIterator::current_filename_	src/base/sysinfo.h	/^  char current_filename_[PATH_MAX];$/;"	m	class:ProcMapsIterator	access:private
ProcMapsIterator::current_image_	src/base/sysinfo.h	/^  int current_image_; \/\/ dll's are called "images" in macos parlance$/;"	m	class:ProcMapsIterator	access:private
ProcMapsIterator::current_load_cmd_	src/base/sysinfo.h	/^  int current_load_cmd_;   \/\/ the segment of this dll we're examining$/;"	m	class:ProcMapsIterator	access:private
ProcMapsIterator::dynamic_buffer_	src/base/sysinfo.h	/^  Buffer* dynamic_buffer_;  \/\/ dynamically-allocated Buffer$/;"	m	class:ProcMapsIterator	access:private
ProcMapsIterator::ebuf_	src/base/sysinfo.h	/^  char *ebuf_;        \/\/ end of buffer (1 char for a nul)$/;"	m	class:ProcMapsIterator	access:private
ProcMapsIterator::etext_	src/base/sysinfo.h	/^  char *etext_;       \/\/ end of text$/;"	m	class:ProcMapsIterator	access:private
ProcMapsIterator::fd_	src/base/sysinfo.h	/^  int fd_;            \/\/ filehandle on \/proc\/*\/maps$/;"	m	class:ProcMapsIterator	access:private
ProcMapsIterator::fd_	src/base/sysinfo.h	/^  int fd_;$/;"	m	class:ProcMapsIterator	access:private
ProcMapsIterator::flags_	src/base/sysinfo.h	/^  char flags_[10];$/;"	m	class:ProcMapsIterator	access:private
ProcMapsIterator::ibuf_	src/base/sysinfo.h	/^  char *ibuf_;        \/\/ input buffer$/;"	m	class:ProcMapsIterator	access:private
ProcMapsIterator::module_	src/base/sysinfo.h	/^  MODULEENTRY32 module_;   \/\/ info about current dll (and dll iterator)$/;"	m	class:ProcMapsIterator	access:private
ProcMapsIterator::nextline_	src/base/sysinfo.h	/^  char *nextline_;    \/\/ start of next line$/;"	m	class:ProcMapsIterator	access:private
ProcMapsIterator::pid_	src/base/sysinfo.h	/^  pid_t pid_;$/;"	m	class:ProcMapsIterator	access:private
ProcMapsIterator::snapshot_	src/base/sysinfo.h	/^  HANDLE snapshot_;   \/\/ filehandle on dll info$/;"	m	class:ProcMapsIterator	access:private
ProcMapsIterator::stext_	src/base/sysinfo.h	/^  char *stext_;       \/\/ start of text$/;"	m	class:ProcMapsIterator	access:private
ProcMapsIterator::using_maps_backing_	src/base/sysinfo.h	/^  bool using_maps_backing_; \/\/ true if we are looking at maps_backing instead of maps.$/;"	m	class:ProcMapsIterator	access:private
ProcMapsIterator::~ProcMapsIterator	src/base/sysinfo.cc	/^ProcMapsIterator::~ProcMapsIterator() {$/;"	f	class:ProcMapsIterator	signature:()
ProcMapsIterator::~ProcMapsIterator	src/base/sysinfo.h	/^  ~ProcMapsIterator();$/;"	p	class:ProcMapsIterator	access:public	signature:()
ProcMapsResult	src/gperftools/heap-checker.h	/^  enum ProcMapsResult {$/;"	g	class:HeapLeakChecker	access:private
ProcMapsTask	src/gperftools/heap-checker.h	/^  enum ProcMapsTask {$/;"	g	class:HeapLeakChecker	access:private
ProcessFreeQueue	src/debugallocation.cc	/^  static void ProcessFreeQueue(MallocBlock* b, size_t size,$/;"	f	class:MallocBlock	access:public	signature:(MallocBlock* b, size_t size, int max_free_queue_size)
ProcessModrm	src/windows/mini_disassembler.cc	/^bool MiniDisassembler::ProcessModrm(unsigned char* start_byte,$/;"	f	class:sidestep::MiniDisassembler	signature:(unsigned char* start_byte, unsigned int& size)
ProcessModrm	src/windows/mini_disassembler.h	/^  bool ProcessModrm(unsigned char* start, unsigned int& size);$/;"	p	class:sidestep::MiniDisassembler	access:private	signature:(unsigned char* start, unsigned int& size)
ProcessOpcode	src/windows/mini_disassembler.cc	/^InstructionType MiniDisassembler::ProcessOpcode(unsigned char* start_byte,$/;"	f	class:sidestep::MiniDisassembler	signature:(unsigned char* start_byte, unsigned int table_index, unsigned int& size)
ProcessOpcode	src/windows/mini_disassembler.h	/^  InstructionType ProcessOpcode(unsigned char* start,$/;"	p	class:sidestep::MiniDisassembler	access:private	signature:(unsigned char* start, unsigned int table, unsigned int& size)
ProcessOperand	src/windows/mini_disassembler.cc	/^bool MiniDisassembler::ProcessOperand(int flag_operand) {$/;"	f	class:sidestep::MiniDisassembler	signature:(int flag_operand)
ProcessOperand	src/windows/mini_disassembler.h	/^  bool ProcessOperand(int flag_operand);$/;"	p	class:sidestep::MiniDisassembler	access:private	signature:(int flag_operand)
ProcessPrefixes	src/windows/mini_disassembler.cc	/^InstructionType MiniDisassembler::ProcessPrefixes(unsigned char* start_byte,$/;"	f	class:sidestep::MiniDisassembler	signature:(unsigned char* start_byte, unsigned int& size)
ProcessPrefixes	src/windows/mini_disassembler.h	/^  InstructionType ProcessPrefixes(unsigned char* start, unsigned int& size);$/;"	p	class:sidestep::MiniDisassembler	access:private	signature:(unsigned char* start, unsigned int& size)
ProcessSib	src/windows/mini_disassembler.cc	/^bool MiniDisassembler::ProcessSib(unsigned char* start_byte,$/;"	f	class:sidestep::MiniDisassembler	signature:(unsigned char* start_byte, unsigned char mod, unsigned int& size)
ProcessSib	src/windows/mini_disassembler.h	/^  bool ProcessSib(unsigned char* start, unsigned char mod, unsigned int& size);$/;"	p	class:sidestep::MiniDisassembler	access:private	signature:(unsigned char* start, unsigned char mod, unsigned int& size)
ProfileData	src/profiledata.cc	/^ProfileData::ProfileData()$/;"	f	class:ProfileData	signature:()
ProfileData	src/profiledata.h	/^  ProfileData();$/;"	p	class:ProfileData	access:public	signature:()
ProfileData	src/profiledata.h	/^class ProfileData {$/;"	c
ProfileData::Add	src/profiledata.cc	/^void ProfileData::Add(int depth, const void* const* stack) {$/;"	f	class:ProfileData	signature:(int depth, const void* const* stack)
ProfileData::Add	src/profiledata.h	/^  void Add(int depth, const void* const* stack);$/;"	p	class:ProfileData	access:public	signature:(int depth, const void* const* stack)
ProfileData::Bucket	src/profiledata.h	/^  struct Bucket {$/;"	s	class:ProfileData	access:private
ProfileData::Bucket::entry	src/profiledata.h	/^    Entry entry[kAssociativity];$/;"	m	struct:ProfileData::Bucket	access:public
ProfileData::DISALLOW_COPY_AND_ASSIGN	src/profiledata.h	/^  DISALLOW_COPY_AND_ASSIGN(ProfileData);$/;"	p	class:ProfileData	access:private	signature:(ProfileData)
ProfileData::Entry	src/profiledata.h	/^  struct Entry {$/;"	s	class:ProfileData	access:private
ProfileData::Entry::count	src/profiledata.h	/^    Slot count;                  \/\/ Number of hits$/;"	m	struct:ProfileData::Entry	access:public
ProfileData::Entry::depth	src/profiledata.h	/^    Slot depth;                  \/\/ Stack depth$/;"	m	struct:ProfileData::Entry	access:public
ProfileData::Entry::stack	src/profiledata.h	/^    Slot stack[kMaxStackDepth];  \/\/ Stack contents$/;"	m	struct:ProfileData::Entry	access:public
ProfileData::Evict	src/profiledata.cc	/^void ProfileData::Evict(const Entry& entry) {$/;"	f	class:ProfileData	signature:(const Entry& entry)
ProfileData::Evict	src/profiledata.h	/^  void Evict(const Entry& entry);$/;"	p	class:ProfileData	access:private	signature:(const Entry& entry)
ProfileData::FlushEvicted	src/profiledata.cc	/^void ProfileData::FlushEvicted() {$/;"	f	class:ProfileData	signature:()
ProfileData::FlushEvicted	src/profiledata.h	/^  void FlushEvicted();$/;"	p	class:ProfileData	access:private	signature:()
ProfileData::FlushTable	src/profiledata.cc	/^void ProfileData::FlushTable() {$/;"	f	class:ProfileData	signature:()
ProfileData::FlushTable	src/profiledata.h	/^  void FlushTable();$/;"	p	class:ProfileData	access:public	signature:()
ProfileData::GetCurrentState	src/profiledata.cc	/^void ProfileData::GetCurrentState(State* state) const {$/;"	f	class:ProfileData	signature:(State* state) const
ProfileData::GetCurrentState	src/profiledata.h	/^  void GetCurrentState(State* state) const;$/;"	p	class:ProfileData	access:public	signature:(State* state) const
ProfileData::Options	src/profiledata.h	/^  class Options {$/;"	c	class:ProfileData	access:public
ProfileData::Options::Options	src/profiledata.cc	/^ProfileData::Options::Options()$/;"	f	class:ProfileData::Options	signature:()
ProfileData::Options::Options	src/profiledata.h	/^    Options();$/;"	p	class:ProfileData::Options	access:public	signature:()
ProfileData::Options::frequency	src/profiledata.h	/^    int frequency() const {$/;"	f	class:ProfileData::Options	access:public	signature:() const
ProfileData::Options::frequency_	src/profiledata.h	/^    int      frequency_;                  \/\/ Sample frequency.$/;"	m	class:ProfileData::Options	access:private
ProfileData::Options::set_frequency	src/profiledata.h	/^    void set_frequency(int frequency) {$/;"	f	class:ProfileData::Options	access:public	signature:(int frequency)
ProfileData::ProfileData	src/profiledata.cc	/^ProfileData::ProfileData()$/;"	f	class:ProfileData	signature:()
ProfileData::ProfileData	src/profiledata.h	/^  ProfileData();$/;"	p	class:ProfileData	access:public	signature:()
ProfileData::Reset	src/profiledata.cc	/^void ProfileData::Reset() {$/;"	f	class:ProfileData	signature:()
ProfileData::Reset	src/profiledata.h	/^  void Reset();$/;"	p	class:ProfileData	access:public	signature:()
ProfileData::Slot	src/profiledata.h	/^  typedef uintptr_t Slot;$/;"	t	class:ProfileData	access:private
ProfileData::Start	src/profiledata.cc	/^bool ProfileData::Start(const char* fname,$/;"	f	class:ProfileData	signature:(const char* fname, const ProfileData::Options& options)
ProfileData::Start	src/profiledata.h	/^  bool Start(const char *fname, const Options& options);$/;"	p	class:ProfileData	access:public	signature:(const char *fname, const Options& options)
ProfileData::State	src/profiledata.h	/^  struct State {$/;"	s	class:ProfileData	access:public
ProfileData::State::enabled	src/profiledata.h	/^    bool     enabled;             \/\/ Is profiling currently enabled?$/;"	m	struct:ProfileData::State	access:public
ProfileData::State::profile_name	src/profiledata.h	/^    char     profile_name[1024];  \/\/ Name of file being written, or '\\0'$/;"	m	struct:ProfileData::State	access:public
ProfileData::State::samples_gathered	src/profiledata.h	/^    int      samples_gathered;    \/\/ Number of samples gathered to far (or 0)$/;"	m	struct:ProfileData::State	access:public
ProfileData::State::start_time	src/profiledata.h	/^    time_t   start_time;          \/\/ If enabled, when was profiling started?$/;"	m	struct:ProfileData::State	access:public
ProfileData::Stop	src/profiledata.cc	/^void ProfileData::Stop() {$/;"	f	class:ProfileData	signature:()
ProfileData::Stop	src/profiledata.h	/^  void Stop();$/;"	p	class:ProfileData	access:public	signature:()
ProfileData::count_	src/profiledata.h	/^  int           count_;         \/\/ How many samples recorded$/;"	m	class:ProfileData	access:private
ProfileData::enabled	src/profiledata.h	/^  bool enabled() const { return out_ >= 0; }$/;"	f	class:ProfileData	access:public	signature:() const
ProfileData::evict_	src/profiledata.h	/^  Slot*         evict_;         \/\/ evicted entries$/;"	m	class:ProfileData	access:private
ProfileData::evictions_	src/profiledata.h	/^  int           evictions_;     \/\/ How many evictions$/;"	m	class:ProfileData	access:private
ProfileData::fname_	src/profiledata.h	/^  char*         fname_;         \/\/ Profile file name$/;"	m	class:ProfileData	access:private
ProfileData::hash_	src/profiledata.h	/^  Bucket*       hash_;          \/\/ hash table$/;"	m	class:ProfileData	access:private
ProfileData::kAssociativity	src/profiledata.cc	/^const int ProfileData::kAssociativity;$/;"	m	class:ProfileData	file:
ProfileData::kAssociativity	src/profiledata.h	/^  static const int kAssociativity = 4;          \/\/ For hashtable$/;"	m	class:ProfileData	access:private
ProfileData::kBuckets	src/profiledata.cc	/^const int ProfileData::kBuckets;$/;"	m	class:ProfileData	file:
ProfileData::kBuckets	src/profiledata.h	/^  static const int kBuckets = 1 << 10;          \/\/ For hashtable$/;"	m	class:ProfileData	access:private
ProfileData::kBufferLength	src/profiledata.cc	/^const int ProfileData::kBufferLength;$/;"	m	class:ProfileData	file:
ProfileData::kBufferLength	src/profiledata.h	/^  static const int kBufferLength = 1 << 18;     \/\/ For eviction buffer$/;"	m	class:ProfileData	access:private
ProfileData::kMaxStackDepth	src/profiledata.cc	/^const int ProfileData::kMaxStackDepth;$/;"	m	class:ProfileData	file:
ProfileData::kMaxStackDepth	src/profiledata.h	/^  static const int kMaxStackDepth = 64;  \/\/ Max stack depth stored in profile$/;"	m	class:ProfileData	access:public
ProfileData::num_evicted_	src/profiledata.h	/^  int           num_evicted_;   \/\/ how many evicted entries?$/;"	m	class:ProfileData	access:private
ProfileData::out_	src/profiledata.h	/^  int           out_;           \/\/ fd for output file.$/;"	m	class:ProfileData	access:private
ProfileData::start_time_	src/profiledata.h	/^  time_t        start_time_;    \/\/ Start time, or 0$/;"	m	class:ProfileData	access:private
ProfileData::total_bytes_	src/profiledata.h	/^  size_t        total_bytes_;   \/\/ How much output$/;"	m	class:ProfileData	access:private
ProfileData::~ProfileData	src/profiledata.cc	/^ProfileData::~ProfileData() {$/;"	f	class:ProfileData	signature:()
ProfileData::~ProfileData	src/profiledata.h	/^  ~ProfileData();$/;"	p	class:ProfileData	access:public	signature:()
ProfileDataChecker	src/tests/profiledata_unittest.cc	/^  ProfileDataChecker() {$/;"	f	class:__anon53::ProfileDataChecker	access:public	signature:()
ProfileDataChecker	src/tests/profiledata_unittest.cc	/^class ProfileDataChecker {$/;"	c	namespace:__anon53	file:
ProfileDataSlot	src/tests/profiledata_unittest.cc	/^typedef uintptr_t ProfileDataSlot;$/;"	t	namespace:__anon53	file:
ProfileDataTest	src/tests/profiledata_unittest.cc	/^class ProfileDataTest {$/;"	c	namespace:__anon53	file:
ProfileHandler	src/profile-handler.cc	/^  ProfileHandler();$/;"	p	class:ProfileHandler	file:	access:private	signature:()
ProfileHandler	src/profile-handler.cc	/^ProfileHandler::ProfileHandler()$/;"	f	class:ProfileHandler	signature:()
ProfileHandler	src/profile-handler.cc	/^class ProfileHandler {$/;"	c	file:
ProfileHandler::ACQUIRED_BEFORE	src/profile-handler.cc	/^  SpinLock control_lock_ ACQUIRED_BEFORE(signal_lock_);$/;"	p	class:ProfileHandler	file:	access:private	signature:(signal_lock_)
ProfileHandler::CallbackIterator	src/profile-handler.cc	/^  typedef CallbackList::iterator CallbackIterator;$/;"	t	class:ProfileHandler	file:	access:private
ProfileHandler::CallbackList	src/profile-handler.cc	/^  typedef list<ProfileHandlerToken*> CallbackList;$/;"	t	class:ProfileHandler	file:	access:private
ProfileHandler::DISALLOW_COPY_AND_ASSIGN	src/profile-handler.cc	/^  DISALLOW_COPY_AND_ASSIGN(ProfileHandler);$/;"	p	class:ProfileHandler	file:	access:private	signature:(ProfileHandler)
ProfileHandler::EXCLUSIVE_LOCKS_REQUIRED	src/profile-handler.cc	/^  void UpdateTimer(bool enable) EXCLUSIVE_LOCKS_REQUIRED(signal_lock_);$/;"	p	class:ProfileHandler	file:	access:private	signature:(signal_lock_)
ProfileHandler::GUARDED_BY	src/profile-handler.cc	/^  CallbackList callbacks_ GUARDED_BY(signal_lock_);$/;"	p	class:ProfileHandler	file:	access:private	signature:(signal_lock_)
ProfileHandler::GUARDED_BY	src/profile-handler.cc	/^  int32 callback_count_ GUARDED_BY(control_lock_);$/;"	p	class:ProfileHandler	file:	access:private	signature:(control_lock_)
ProfileHandler::GUARDED_BY	src/profile-handler.cc	/^  int64 interrupts_ GUARDED_BY(signal_lock_);$/;"	p	class:ProfileHandler	file:	access:private	signature:(signal_lock_)
ProfileHandler::GetState	src/profile-handler.cc	/^  void GetState(ProfileHandlerState* state);$/;"	p	class:ProfileHandler	file:	access:public	signature:(ProfileHandlerState* state)
ProfileHandler::GetState	src/profile-handler.cc	/^void ProfileHandler::GetState(ProfileHandlerState* state) {$/;"	f	class:ProfileHandler	signature:(ProfileHandlerState* state)
ProfileHandler::Init	src/profile-handler.cc	/^  static void Init();$/;"	p	class:ProfileHandler	file:	access:private	signature:()
ProfileHandler::Init	src/profile-handler.cc	/^void ProfileHandler::Init() {$/;"	f	class:ProfileHandler	signature:()
ProfileHandler::Instance	src/profile-handler.cc	/^  static ProfileHandler* Instance();$/;"	p	class:ProfileHandler	file:	access:public	signature:()
ProfileHandler::Instance	src/profile-handler.cc	/^ProfileHandler* ProfileHandler::Instance() {$/;"	f	class:ProfileHandler	signature:()
ProfileHandler::IsSignalHandlerAvailable	src/profile-handler.cc	/^  bool IsSignalHandlerAvailable();$/;"	p	class:ProfileHandler	file:	access:private	signature:()
ProfileHandler::IsSignalHandlerAvailable	src/profile-handler.cc	/^bool ProfileHandler::IsSignalHandlerAvailable() {$/;"	f	class:ProfileHandler	signature:()
ProfileHandler::NO_THREAD_SAFETY_ANALYSIS	src/profile-handler.cc	/^      NO_THREAD_SAFETY_ANALYSIS;$/;"	m	class:ProfileHandler	file:	access:public
ProfileHandler::ProfileHandler	src/profile-handler.cc	/^  ProfileHandler();$/;"	p	class:ProfileHandler	file:	access:private	signature:()
ProfileHandler::ProfileHandler	src/profile-handler.cc	/^ProfileHandler::ProfileHandler()$/;"	f	class:ProfileHandler	signature:()
ProfileHandler::RegisterCallback	src/profile-handler.cc	/^  ProfileHandlerToken* RegisterCallback(ProfileHandlerCallback callback,$/;"	p	class:ProfileHandler	file:	access:public	signature:(ProfileHandlerCallback callback, void* callback_arg)
ProfileHandler::RegisterCallback	src/profile-handler.cc	/^ProfileHandlerToken* ProfileHandler::RegisterCallback($/;"	f	class:ProfileHandler	signature:( ProfileHandlerCallback callback, void* callback_arg)
ProfileHandler::RegisterThread	src/profile-handler.cc	/^  void RegisterThread();$/;"	p	class:ProfileHandler	file:	access:public	signature:()
ProfileHandler::RegisterThread	src/profile-handler.cc	/^void ProfileHandler::RegisterThread() {$/;"	f	class:ProfileHandler	signature:()
ProfileHandler::Reset	src/profile-handler.cc	/^  void Reset();$/;"	p	class:ProfileHandler	file:	access:public	signature:()
ProfileHandler::Reset	src/profile-handler.cc	/^void ProfileHandler::Reset() {$/;"	f	class:ProfileHandler	signature:()
ProfileHandler::SignalHandler	src/profile-handler.cc	/^  static void SignalHandler(int sig, siginfo_t* sinfo, void* ucontext);$/;"	p	class:ProfileHandler	file:	access:private	signature:(int sig, siginfo_t* sinfo, void* ucontext)
ProfileHandler::SignalHandler	src/profile-handler.cc	/^void ProfileHandler::SignalHandler(int sig, siginfo_t* sinfo, void* ucontext) {$/;"	f	class:ProfileHandler	signature:(int sig, siginfo_t* sinfo, void* ucontext)
ProfileHandler::UnregisterCallback	src/profile-handler.cc	/^void ProfileHandler::UnregisterCallback(ProfileHandlerToken* token) {$/;"	f	class:ProfileHandler	signature:(ProfileHandlerToken* token)
ProfileHandler::UpdateTimer	src/profile-handler.cc	/^void ProfileHandler::UpdateTimer(bool enable) {$/;"	f	class:ProfileHandler	signature:(bool enable)
ProfileHandler::allowed_	src/profile-handler.cc	/^  bool allowed_;$/;"	m	class:ProfileHandler	file:	access:private
ProfileHandler::frequency_	src/profile-handler.cc	/^  int32 frequency_;$/;"	m	class:ProfileHandler	file:	access:private
ProfileHandler::instance_	src/profile-handler.cc	/^  static ProfileHandler* instance_;$/;"	m	class:ProfileHandler	file:	access:private
ProfileHandler::instance_	src/profile-handler.cc	/^ProfileHandler* ProfileHandler::instance_ = NULL;$/;"	m	class:ProfileHandler	file:
ProfileHandler::kDefaultFrequency	src/profile-handler.cc	/^  static const int32 kDefaultFrequency = 100;$/;"	m	class:ProfileHandler	file:	access:private
ProfileHandler::kDefaultFrequency	src/profile-handler.cc	/^const int32 ProfileHandler::kDefaultFrequency;$/;"	m	class:ProfileHandler	file:
ProfileHandler::kMaxFrequency	src/profile-handler.cc	/^  static const int32 kMaxFrequency = 4000;$/;"	m	class:ProfileHandler	file:	access:private
ProfileHandler::kMaxFrequency	src/profile-handler.cc	/^const int32 ProfileHandler::kMaxFrequency;$/;"	m	class:ProfileHandler	file:
ProfileHandler::once_	src/profile-handler.cc	/^  static pthread_once_t once_;$/;"	m	class:ProfileHandler	file:	access:private
ProfileHandler::once_	src/profile-handler.cc	/^pthread_once_t ProfileHandler::once_ = PTHREAD_ONCE_INIT;$/;"	m	class:ProfileHandler	file:
ProfileHandler::per_thread_timer_enabled_	src/profile-handler.cc	/^  bool per_thread_timer_enabled_;$/;"	m	class:ProfileHandler	file:	access:private
ProfileHandler::signal_lock_	src/profile-handler.cc	/^  SpinLock signal_lock_;$/;"	m	class:ProfileHandler	file:	access:private
ProfileHandler::signal_number_	src/profile-handler.cc	/^  int signal_number_;$/;"	m	class:ProfileHandler	file:	access:private
ProfileHandler::thread_timer_key	src/profile-handler.cc	/^  pthread_key_t thread_timer_key;$/;"	m	class:ProfileHandler	file:	access:private
ProfileHandler::timer_running_	src/profile-handler.cc	/^  bool timer_running_;$/;"	m	class:ProfileHandler	file:	access:private
ProfileHandler::timer_type_	src/profile-handler.cc	/^  int timer_type_;$/;"	m	class:ProfileHandler	file:	access:private
ProfileHandler::~ProfileHandler	src/profile-handler.cc	/^  ~ProfileHandler();$/;"	p	class:ProfileHandler	file:	access:private	signature:()
ProfileHandler::~ProfileHandler	src/profile-handler.cc	/^ProfileHandler::~ProfileHandler() {$/;"	f	class:ProfileHandler	signature:()
ProfileHandlerCallback	src/profile-handler.h	/^typedef void (*ProfileHandlerCallback)(int sig, siginfo_t* sig_info,$/;"	t
ProfileHandlerGetState	src/profile-handler.cc	/^void ProfileHandlerGetState(ProfileHandlerState* state) {$/;"	f	signature:(ProfileHandlerState* state)
ProfileHandlerGetState	src/profile-handler.h	/^void ProfileHandlerGetState(struct ProfileHandlerState* state);$/;"	p	signature:(struct ProfileHandlerState* state)
ProfileHandlerRegisterCallback	src/profile-handler.cc	/^ProfileHandlerToken* ProfileHandlerRegisterCallback($/;"	f	signature:( ProfileHandlerCallback callback, void* callback_arg)
ProfileHandlerRegisterCallback	src/profile-handler.h	/^ProfileHandlerToken* ProfileHandlerRegisterCallback($/;"	p	signature:( ProfileHandlerCallback callback, void* callback_arg)
ProfileHandlerRegisterThread	src/profile-handler.cc	/^void ProfileHandlerRegisterThread() {$/;"	f	signature:()
ProfileHandlerRegisterThread	src/profile-handler.h	/^void ProfileHandlerRegisterThread();$/;"	p	signature:()
ProfileHandlerReset	src/profile-handler.cc	/^void ProfileHandlerReset() {$/;"	f	signature:()
ProfileHandlerReset	src/profile-handler.h	/^void ProfileHandlerReset();$/;"	p	signature:()
ProfileHandlerState	src/profile-handler.h	/^struct ProfileHandlerState {$/;"	s
ProfileHandlerState::allowed	src/profile-handler.h	/^  bool allowed; \/* Profiling is allowed *\/$/;"	m	struct:ProfileHandlerState	access:public
ProfileHandlerState::callback_count	src/profile-handler.h	/^  int32 callback_count;  \/* Number of callbacks registered *\/$/;"	m	struct:ProfileHandlerState	access:public
ProfileHandlerState::frequency	src/profile-handler.h	/^  int32 frequency;  \/* Profiling frequency *\/$/;"	m	struct:ProfileHandlerState	access:public
ProfileHandlerState::interrupts	src/profile-handler.h	/^  int64 interrupts;  \/* Number of interrupts received *\/$/;"	m	struct:ProfileHandlerState	access:public
ProfileHandlerTest	src/tests/profile-handler_unittest.cc	/^class ProfileHandlerTest {$/;"	c	namespace:__anon56	file:
ProfileHandlerToken	src/profile-handler.cc	/^  ProfileHandlerToken(ProfileHandlerCallback cb, void* cb_arg)$/;"	f	struct:ProfileHandlerToken	access:public	signature:(ProfileHandlerCallback cb, void* cb_arg)
ProfileHandlerToken	src/profile-handler.cc	/^struct ProfileHandlerToken {$/;"	s	file:
ProfileHandlerToken::ProfileHandlerToken	src/profile-handler.cc	/^  ProfileHandlerToken(ProfileHandlerCallback cb, void* cb_arg)$/;"	f	struct:ProfileHandlerToken	access:public	signature:(ProfileHandlerCallback cb, void* cb_arg)
ProfileHandlerToken::callback	src/profile-handler.cc	/^  ProfileHandlerCallback callback;$/;"	m	struct:ProfileHandlerToken	file:	access:public
ProfileHandlerToken::callback_arg	src/profile-handler.cc	/^  void* callback_arg;$/;"	m	struct:ProfileHandlerToken	file:	access:public
ProfileHandlerUnregisterCallback	src/profile-handler.cc	/^void ProfileHandlerUnregisterCallback(ProfileHandlerToken* token) {$/;"	f	signature:(ProfileHandlerToken* token)
ProfileHandlerUnregisterCallback	src/profile-handler.h	/^void ProfileHandlerUnregisterCallback(ProfileHandlerToken* token);$/;"	p	signature:(ProfileHandlerToken* token)
ProfilerDisable	src/gperftools/profiler.h	/^PERFTOOLS_DLL_DECL void ProfilerDisable(void);$/;"	p	signature:(void)
ProfilerDisable	src/profiler.cc	/^extern "C" PERFTOOLS_DLL_DECL void ProfilerDisable() { }$/;"	f	signature:()
ProfilerEnable	src/gperftools/profiler.h	/^PERFTOOLS_DLL_DECL void ProfilerEnable(void);$/;"	p	signature:(void)
ProfilerEnable	src/profiler.cc	/^extern "C" PERFTOOLS_DLL_DECL void ProfilerEnable() { }$/;"	f	signature:()
ProfilerFlush	src/gperftools/profiler.h	/^PERFTOOLS_DLL_DECL void ProfilerFlush(void);$/;"	p	signature:(void)
ProfilerFlush	src/profiler.cc	/^extern "C" PERFTOOLS_DLL_DECL void ProfilerFlush() {$/;"	f	signature:()
ProfilerFlush	src/profiler.cc	/^extern "C" void ProfilerFlush() { }$/;"	f	signature:()
ProfilerFree	src/heap-profiler.cc	/^static void ProfilerFree(void* p) {$/;"	f	file:	signature:(void* p)
ProfilerGetCurrentState	src/gperftools/profiler.h	/^PERFTOOLS_DLL_DECL void ProfilerGetCurrentState(struct ProfilerState* state);$/;"	p	signature:(struct ProfilerState* state)
ProfilerGetCurrentState	src/profiler.cc	/^extern "C" PERFTOOLS_DLL_DECL void ProfilerGetCurrentState($/;"	f	signature:( ProfilerState* state)
ProfilerGetCurrentState	src/profiler.cc	/^extern "C" void ProfilerGetCurrentState(ProfilerState* state) {$/;"	f	signature:(ProfilerState* state)
ProfilerMalloc	src/heap-profiler.cc	/^static void* ProfilerMalloc(size_t bytes) {$/;"	f	file:	signature:(size_t bytes)
ProfilerOptions	src/gperftools/profiler.h	/^struct ProfilerOptions {$/;"	s
ProfilerOptions::filter_in_thread	src/gperftools/profiler.h	/^  int (*filter_in_thread)(void *arg);$/;"	m	struct:ProfilerOptions	access:public
ProfilerOptions::filter_in_thread_arg	src/gperftools/profiler.h	/^  void *filter_in_thread_arg;$/;"	m	struct:ProfilerOptions	access:public
ProfilerRegisterThread	src/gperftools/profiler.h	/^PERFTOOLS_DLL_DECL void ProfilerRegisterThread(void);$/;"	p	signature:(void)
ProfilerRegisterThread	src/profiler.cc	/^extern "C" PERFTOOLS_DLL_DECL void ProfilerRegisterThread() {$/;"	f	signature:()
ProfilerRegisterThread	src/profiler.cc	/^extern "C" void ProfilerRegisterThread() { }$/;"	f	signature:()
ProfilerStart	src/gperftools/profiler.h	/^PERFTOOLS_DLL_DECL int ProfilerStart(const char* fname);$/;"	p	signature:(const char* fname)
ProfilerStart	src/profiler.cc	/^extern "C" PERFTOOLS_DLL_DECL int ProfilerStart(const char* fname) {$/;"	f	signature:(const char* fname)
ProfilerStart	src/profiler.cc	/^extern "C" int ProfilerStart(const char* fname) { return 0; }$/;"	f	signature:(const char* fname)
ProfilerStartWithOptions	src/gperftools/profiler.h	/^PERFTOOLS_DLL_DECL int ProfilerStartWithOptions($/;"	p	signature:( const char *fname, const struct ProfilerOptions *options)
ProfilerStartWithOptions	src/profiler.cc	/^extern "C" PERFTOOLS_DLL_DECL int ProfilerStartWithOptions($/;"	f	signature:( const char *fname, const ProfilerOptions *options)
ProfilerStartWithOptions	src/profiler.cc	/^extern "C" int ProfilerStartWithOptions(const char *fname,$/;"	f	signature:(const char *fname, const ProfilerOptions *options)
ProfilerState	src/gperftools/profiler.h	/^struct ProfilerState {$/;"	s
ProfilerState::enabled	src/gperftools/profiler.h	/^  int    enabled;             \/* Is profiling currently enabled? *\/$/;"	m	struct:ProfilerState	access:public
ProfilerState::profile_name	src/gperftools/profiler.h	/^  char   profile_name[1024];  \/* Name of profile file being written, or '\\0' *\/$/;"	m	struct:ProfilerState	access:public
ProfilerState::samples_gathered	src/gperftools/profiler.h	/^  int    samples_gathered;    \/* Number of samples gathered so far (or 0) *\/$/;"	m	struct:ProfilerState	access:public
ProfilerState::start_time	src/gperftools/profiler.h	/^  time_t start_time;          \/* If enabled, when was profiling started? *\/$/;"	m	struct:ProfilerState	access:public
ProfilerStop	src/gperftools/profiler.h	/^PERFTOOLS_DLL_DECL void ProfilerStop(void);$/;"	p	signature:(void)
ProfilerStop	src/profiler.cc	/^extern "C" PERFTOOLS_DLL_DECL void ProfilerStop() {$/;"	f	signature:()
ProfilerStop	src/profiler.cc	/^extern "C" void ProfilerStop() { }$/;"	f	signature:()
ProfilingIsEnabledForAllThreads	src/gperftools/profiler.h	/^PERFTOOLS_DLL_DECL int ProfilingIsEnabledForAllThreads(void);$/;"	p	signature:(void)
ProfilingIsEnabledForAllThreads	src/heap-checker.cc	/^ATTRIBUTE_WEAK PERFTOOLS_DLL_DECL int ProfilingIsEnabledForAllThreads();$/;"	p	file:	signature:()
ProfilingIsEnabledForAllThreads	src/heap-checker.cc	/^int ProfilingIsEnabledForAllThreads() { return false; }$/;"	f	signature:()
ProfilingIsEnabledForAllThreads	src/profiler.cc	/^extern "C" PERFTOOLS_DLL_DECL int ProfilingIsEnabledForAllThreads() {$/;"	f	signature:()
ProfilingIsEnabledForAllThreads	src/profiler.cc	/^extern "C" int ProfilingIsEnabledForAllThreads() { return 0; }$/;"	f	signature:()
ProjectDependencies	gperftools.sln	/^	ProjectSection(ProjectDependencies) = postProject$/;"	v
PthreadKeyCreate	src/windows/port.cc	/^extern "C" pthread_key_t PthreadKeyCreate(void (*destr_fn)(void*)) {$/;"	f	signature:(void (*destr_fn)(void*))
PthreadKeyCreate	src/windows/port.h	/^EXTERN_C pthread_key_t PthreadKeyCreate(void (*destr_fn)(void*));  \/* port.cc *\/$/;"	p	signature:(void (*destr_fn)(void*))
PtrAndSize	src/tests/addressmap_unittest.cc	/^  PtrAndSize(char* p, size_t s) : ptr(p), size(s) {}$/;"	f	struct:PtrAndSize	access:public	signature:(char* p, size_t s)
PtrAndSize	src/tests/addressmap_unittest.cc	/^struct PtrAndSize {$/;"	s	file:
PtrAndSize::PtrAndSize	src/tests/addressmap_unittest.cc	/^  PtrAndSize(char* p, size_t s) : ptr(p), size(s) {}$/;"	f	struct:PtrAndSize	access:public	signature:(char* p, size_t s)
PtrAndSize::ptr	src/tests/addressmap_unittest.cc	/^  char* ptr;$/;"	m	struct:PtrAndSize	file:	access:public
PtrAndSize::size	src/tests/addressmap_unittest.cc	/^  size_t size;$/;"	m	struct:PtrAndSize	file:	access:public
Push	src/debugallocation.cc	/^  void Push(const QueueEntry& block) {$/;"	f	class:FreeQueue	access:public	signature:(const QueueEntry& block)
Push	src/thread_cache.h	/^    uint32_t Push(void* ptr) {$/;"	f	class:tcmalloc::ThreadCache::FreeList	access:public	signature:(void* ptr)
PushRange	src/thread_cache.h	/^    void PushRange(int N, void *start, void *end) {$/;"	f	class:tcmalloc::ThreadCache::FreeList	access:public	signature:(int N, void *start, void *end)
Put	src/packed-cache-inl.h	/^  void Put(K key, V value) {$/;"	f	class:PackedCache	access:public	signature:(K key, V value)
Q7	src/libtcmalloc_internal_la-malloc_extension.o	/^/;"	v
QYE	src/.libs/libtcmalloc_minimal_internal_la-malloc_hook.o	/^h/;"	v
QuickNoLeaks	src/gperftools/heap-checker.h	/^  bool QuickNoLeaks()  { return NoLeaks(); }$/;"	f	class:HeapLeakChecker	access:public	signature:()
QuickSameHeap	src/gperftools/heap-checker.h	/^  bool QuickSameHeap() { return NoLeaks(); }$/;"	f	class:HeapLeakChecker	access:public	signature:()
R	benchmark/getcontext_light.cc	9;"	d	file:
R	src/.libs/libtcmalloc_internal_la-internal_logging.o	/^/;"	v
R	src/.libs/libtcmalloc_minimal_internal_la-internal_logging.o	/^/;"	v
RAW_CHECK	src/base/logging.h	94;"	d
RAW_DCHECK	src/base/logging.h	106;"	d
RAW_DCHECK	src/base/logging.h	109;"	d
RAW_LOG	src/base/logging.h	/^inline void RAW_LOG(int lvl, const char* pat, ...)  { LOG_PRINTF(lvl, pat); }$/;"	f	signature:(int lvl, const char* pat, ...)
RAW_VLOG	src/base/logging.h	/^inline void RAW_VLOG(int lvl, const char* pat, ...) { LOG_PRINTF(lvl, pat); }$/;"	f	signature:(int lvl, const char* pat, ...)
RECORD_GLOBAL_DATA	src/gperftools/heap-checker.h	/^    RECORD_GLOBAL_DATA,$/;"	e	enum:HeapLeakChecker::ProcMapsTask
REGISTER_HEAPCHECK_CLEANUP	docs/heap_checker.html	/^    <code>REGISTER_HEAPCHECK_CLEANUP<\/code>, typically much earlier in$/;"	v
REGISTER_HEAPCHECK_CLEANUP	src/gperftools/heap-checker.h	416;"	d
REGISTER_MODULE_DESTRUCTOR	src/base/googleinit.h	66;"	d
REGISTER_MODULE_INITIALIZER	src/base/googleinit.h	59;"	d
REGISTER_OBJ_MAKER	src/tests/heap-checker_unittest.cc	981;"	d	file:
ROOT_BITS	src/pagemap.h	/^  static const int ROOT_BITS = BITS - LEAF_BITS;$/;"	m	class:TCMalloc_PageMap2	access:private
ROOT_LENGTH	src/pagemap.h	/^  static const int ROOT_LENGTH = 1 << ROOT_BITS;$/;"	m	class:TCMalloc_PageMap2	access:private
RUN	src/tests/profile-handler_unittest.cc	289;"	d	file:
RUN	src/tests/profiledata_unittest.cc	354;"	d	file:
RUNNING_ON_VALGRIND	src/third_party/valgrind.h	3639;"	d
RUN_ALL_TESTS	src/tests/debugallocation_test.cc	/^static int RUN_ALL_TESTS() {$/;"	f	file:	signature:()
RUN_ALL_TESTS	src/tests/malloc_hook_test.cc	/^static int RUN_ALL_TESTS() {$/;"	f	namespace:__anon57	signature:()
RUN_ALL_TESTS	src/tests/profile-handler_unittest.cc	/^  static int RUN_ALL_TESTS() {$/;"	f	class:__anon56::ProfileHandlerTest	access:public	signature:()
RUN_ALL_TESTS	src/tests/profiledata_unittest.cc	/^  static int RUN_ALL_TESTS() {$/;"	f	class:__anon53::ProfileDataTest	access:public	signature:()
RUN_ALL_TESTS	src/tests/sampler_test.cc	/^static int RUN_ALL_TESTS() {$/;"	f	file:	signature:()
RUN_SILENT	src/tests/heap-checker_unittest.cc	421;"	d	file:
RUN_TEST	src/tests/raw_printer_test.cc	16;"	d	file:
Random	src/base/low_level_alloc.cc	/^static int Random() {$/;"	f	file:	signature:()
RandomizeBlockDesc	src/tests/low_level_alloc_unittest.cc	/^static void RandomizeBlockDesc(BlockDesc *d) {$/;"	f	file:	signature:(BlockDesc *d)
RangeCallback	src/tests/tcmalloc_unittest.cc	/^static void RangeCallback(void* arg, const base::MallocRange* r) {$/;"	f	namespace:testing::__anon59	signature:(void* arg, const base::MallocRange* r)
RangeCallbackState	src/tests/tcmalloc_unittest.cc	/^struct RangeCallbackState {$/;"	s	namespace:testing::__anon59	file:
RangeDisabledLeaks	src/gperftools/heap-checker.h	/^  friend void RangeDisabledLeaks();$/;"	p	class:HeapLeakChecker	access:friend	signature:()
RangeFunction	src/gperftools/malloc_extension.h	/^  typedef void (RangeFunction)(void*, const base::MallocRange*);$/;"	t	class:MallocExtension	access:public
RangeValue	src/heap-checker.cc	/^struct HeapLeakChecker::RangeValue {$/;"	s	class:HeapLeakChecker	file:
Ranges	src/gperftools/malloc_extension.h	/^  virtual void Ranges(void* arg, RangeFunction func);$/;"	p	class:MallocExtension	access:public	signature:(void* arg, RangeFunction func)
Ranges	src/malloc_extension.cc	/^void MallocExtension::Ranges(void* arg, RangeFunction func) {$/;"	f	class:MallocExtension	signature:(void* arg, RangeFunction func)
Ranges	src/tcmalloc.cc	/^  virtual void Ranges(void* arg, RangeFunction func) {$/;"	f	class:TCMallocImplementation	access:public	signature:(void* arg, RangeFunction func)
RawClose	src/base/logging.cc	/^void RawClose(RawFD fd) {$/;"	f	signature:(RawFD fd)
RawClose	src/base/logging.cc	/^void RawClose(RawFD handle) {$/;"	f	signature:(RawFD handle)
RawClose	src/base/logging.h	/^void RawClose(RawFD fd);$/;"	p	signature:(RawFD fd)
RawFD	src/base/logging.h	/^typedef HANDLE RawFD;$/;"	t
RawFD	src/base/logging.h	/^typedef int RawFD;$/;"	t
RawInfoStackDumper	src/heap-profiler.cc	/^static void RawInfoStackDumper(const char* message, void*) {$/;"	f	file:	signature:(const char* message, void*)
RawOpenForWriting	src/base/logging.cc	/^RawFD RawOpenForWriting(const char* filename) {$/;"	f	signature:(const char* filename)
RawOpenForWriting	src/base/logging.h	/^RawFD RawOpenForWriting(const char* filename);   \/\/ uses default permissions$/;"	p	signature:(const char* filename)
RawPatch	src/windows/preamble_patcher.cc	/^SideStepError PreamblePatcher::RawPatch(void* target_function,$/;"	f	class:sidestep::PreamblePatcher	signature:(void* target_function, void* replacement_function, void** original_function_stub)
RawPatch	src/windows/preamble_patcher.h	/^  static SideStepError RawPatch(void* target_function,$/;"	p	class:sidestep::PreamblePatcher	access:public	signature:(void* target_function, void* replacement_function, void** original_function_stub)
RawPatchWithStub	src/windows/preamble_patcher.h	/^  static SideStepError RawPatchWithStub(void* target_function,$/;"	p	class:sidestep::PreamblePatcher	access:private	signature:(void* target_function, void* replacement_function, unsigned char* preamble_stub, unsigned long stub_size, unsigned long* bytes_needed)
RawPatchWithStub	src/windows/preamble_patcher_with_stub.cc	/^SideStepError PreamblePatcher::RawPatchWithStub($/;"	f	class:sidestep::PreamblePatcher	signature:( void* target_function, void* replacement_function, unsigned char* preamble_stub, unsigned long stub_size, unsigned long* bytes_needed)
RawPatchWithStubAndProtections	src/windows/preamble_patcher.cc	/^SideStepError PreamblePatcher::RawPatchWithStubAndProtections($/;"	f	class:sidestep::PreamblePatcher	signature:( void* target_function, void *replacement_function, unsigned char* preamble_stub, unsigned long stub_size, unsigned long* bytes_needed)
RawPatchWithStubAndProtections	src/windows/preamble_patcher.h	/^  static SideStepError RawPatchWithStubAndProtections($/;"	p	class:sidestep::PreamblePatcher	access:private	signature:( void* target_function, void* replacement_function, unsigned char* preamble_stub, unsigned long stub_size, unsigned long* bytes_needed)
RawPrinter	src/raw_printer.cc	/^RawPrinter::RawPrinter(char* buf, int length)$/;"	f	class:base::RawPrinter	signature:(char* buf, int length)
RawPrinter	src/raw_printer.h	/^  RawPrinter(char* buf, int length);$/;"	p	class:base::RawPrinter	access:public	signature:(char* buf, int length)
RawPrinter	src/raw_printer.h	/^class RawPrinter {$/;"	c	namespace:base
RawWrite	src/base/logging.cc	/^void RawWrite(RawFD fd, const char* buf, size_t len) {$/;"	f	signature:(RawFD fd, const char* buf, size_t len)
RawWrite	src/base/logging.cc	/^void RawWrite(RawFD handle, const char* buf, size_t len) {$/;"	f	signature:(RawFD handle, const char* buf, size_t len)
RawWrite	src/base/logging.h	/^void RawWrite(RawFD fd, const char* buf, size_t len);$/;"	p	signature:(RawFD fd, const char* buf, size_t len)
ReadHeapGrowthStackTraces	src/gperftools/malloc_extension.h	/^  virtual void** ReadHeapGrowthStackTraces();$/;"	p	class:MallocExtension	access:public	signature:()
ReadHeapGrowthStackTraces	src/malloc_extension.cc	/^void** MallocExtension::ReadHeapGrowthStackTraces() {$/;"	f	class:MallocExtension	signature:()
ReadHeapGrowthStackTraces	src/tcmalloc.cc	/^  virtual void** ReadHeapGrowthStackTraces() {$/;"	f	class:TCMallocImplementation	access:public	signature:()
ReadPersistent	src/tests/profiledata_unittest.cc	/^static ssize_t ReadPersistent(const int fd, void *buf, const size_t count) {$/;"	f	namespace:__anon53	signature:(const int fd, void *buf, const size_t count)
ReadStackTraces	src/gperftools/malloc_extension.h	/^  virtual void** ReadStackTraces(int* sample_period);$/;"	p	class:MallocExtension	access:public	signature:(int* sample_period)
ReadStackTraces	src/malloc_extension.cc	/^void** MallocExtension::ReadStackTraces(int* sample_period) {$/;"	f	class:MallocExtension	signature:(int* sample_period)
ReadStackTraces	src/tcmalloc.cc	/^  virtual void** ReadStackTraces(int* sample_period) {$/;"	f	class:TCMallocImplementation	access:public	signature:(int* sample_period)
ReadStackTracesAndClear	src/stack_trace_table.cc	/^void** StackTraceTable::ReadStackTracesAndClear() {$/;"	f	class:tcmalloc::StackTraceTable	signature:()
ReadStackTracesAndClear	src/stack_trace_table.h	/^  void** ReadStackTracesAndClear();$/;"	p	class:tcmalloc::StackTraceTable	access:public	signature:()
ReaderLock	src/base/simple_mutex.h	/^  inline void ReaderLock();   \/\/ Block until free or shared then acquire a share$/;"	p	class:MUTEX_NAMESPACE::Mutex	access:public	signature:()
ReaderLock	src/base/simple_mutex.h	/^void Mutex::ReaderLock()   { Lock(); }      \/\/ we don't have read-write locks$/;"	f	class:MUTEX_NAMESPACE::Mutex	signature:()
ReaderLock	src/base/simple_mutex.h	/^void Mutex::ReaderLock()   { Lock(); }$/;"	f	class:MUTEX_NAMESPACE::Mutex	signature:()
ReaderLock	src/base/simple_mutex.h	/^void Mutex::ReaderLock()   { SAFE_PTHREAD(pthread_rwlock_rdlock); }$/;"	f	class:MUTEX_NAMESPACE::Mutex	signature:()
ReaderLock	src/base/simple_mutex.h	/^void Mutex::ReaderLock()   { assert(++mutex_ > 0); }$/;"	f	class:MUTEX_NAMESPACE::Mutex	signature:()
ReaderMutexLock	src/base/simple_mutex.h	/^  ReaderMutexLock(const ReaderMutexLock&);$/;"	p	class:MUTEX_NAMESPACE::ReaderMutexLock	access:private	signature:(const ReaderMutexLock&)
ReaderMutexLock	src/base/simple_mutex.h	/^  explicit ReaderMutexLock(Mutex *mu) : mu_(mu) { mu_->ReaderLock(); }$/;"	f	class:MUTEX_NAMESPACE::ReaderMutexLock	access:public	signature:(Mutex *mu)
ReaderMutexLock	src/base/simple_mutex.h	/^class ReaderMutexLock {$/;"	c	namespace:MUTEX_NAMESPACE
ReaderMutexLock	src/base/simple_mutex.h	323;"	d
ReaderUnlock	src/base/simple_mutex.h	/^  inline void ReaderUnlock(); \/\/ Release a read share of this Mutex$/;"	p	class:MUTEX_NAMESPACE::Mutex	access:public	signature:()
ReaderUnlock	src/base/simple_mutex.h	/^void Mutex::ReaderUnlock() { SAFE_PTHREAD(pthread_rwlock_unlock); }$/;"	f	class:MUTEX_NAMESPACE::Mutex	signature:()
ReaderUnlock	src/base/simple_mutex.h	/^void Mutex::ReaderUnlock() { Unlock(); }$/;"	f	class:MUTEX_NAMESPACE::Mutex	signature:()
ReaderUnlock	src/base/simple_mutex.h	/^void Mutex::ReaderUnlock() { assert(mutex_-- > 0); }$/;"	f	class:MUTEX_NAMESPACE::Mutex	signature:()
RecomputePerThreadCacheSize	src/thread_cache.cc	/^void ThreadCache::RecomputePerThreadCacheSize() {$/;"	f	class:tcmalloc::ThreadCache	signature:()
RecomputePerThreadCacheSize	src/thread_cache.h	/^  static void RecomputePerThreadCacheSize();$/;"	p	class:tcmalloc::ThreadCache	access:private	signature:()
RecordAlloc	src/heap-profile-table.cc	/^void HeapProfileTable::RecordAlloc($/;"	f	class:HeapProfileTable	signature:( const void* ptr, size_t bytes, int stack_depth, const void* const call_stack[])
RecordAlloc	src/heap-profile-table.h	/^  void RecordAlloc(const void* ptr, size_t bytes,$/;"	p	class:HeapProfileTable	access:public	signature:(const void* ptr, size_t bytes, int stack_depth, const void* const call_stack[])
RecordAlloc	src/heap-profiler.cc	/^static void RecordAlloc(const void* ptr, size_t bytes, int skip_count) {$/;"	f	file:	signature:(const void* ptr, size_t bytes, int skip_count)
RecordAllocation	src/sampler.h	/^  bool RecordAllocation(size_t k);$/;"	p	class:tcmalloc::Sampler	access:public	signature:(size_t k)
RecordAllocation	src/sampler.h	/^inline bool Sampler::RecordAllocation(size_t k) {$/;"	f	class:tcmalloc::Sampler	signature:(size_t k)
RecordAllocationSlow	src/sampler.cc	/^bool Sampler::RecordAllocationSlow(size_t k) {$/;"	f	class:tcmalloc::Sampler	signature:(size_t k)
RecordAllocationSlow	src/sampler.h	/^  bool RecordAllocationSlow(size_t k);$/;"	p	class:tcmalloc::Sampler	access:private	signature:(size_t k)
RecordFree	src/heap-profile-table.cc	/^void HeapProfileTable::RecordFree(const void* ptr) {$/;"	f	class:HeapProfileTable	signature:(const void* ptr)
RecordFree	src/heap-profile-table.h	/^  void RecordFree(const void* ptr);$/;"	p	class:HeapProfileTable	access:public	signature:(const void* ptr)
RecordFree	src/heap-profiler.cc	/^static void RecordFree(const void* ptr) {$/;"	f	file:	signature:(const void* ptr)
RecordGlobalDataLocked	src/heap-checker.cc	/^static void RecordGlobalDataLocked(uintptr_t start_address,$/;"	f	file:	signature:(uintptr_t start_address, uintptr_t end_address, const char* permissions, const char* filename)
RecordGrowth	src/page_heap.cc	/^static void RecordGrowth(size_t growth) {$/;"	f	namespace:tcmalloc	signature:(size_t growth)
RecordRegionAddition	src/memory_region_map.cc	/^void MemoryRegionMap::RecordRegionAddition(const void* start, size_t size) {$/;"	f	class:MemoryRegionMap	signature:(const void* start, size_t size)
RecordRegionAddition	src/memory_region_map.h	/^  static void RecordRegionAddition(const void* start, size_t size);$/;"	p	class:MemoryRegionMap	access:private	signature:(const void* start, size_t size)
RecordRegionRemoval	src/memory_region_map.cc	/^void MemoryRegionMap::RecordRegionRemoval(const void* start, size_t size) {$/;"	f	class:MemoryRegionMap	signature:(const void* start, size_t size)
RecordRegionRemoval	src/memory_region_map.h	/^  static void RecordRegionRemoval(const void* start, size_t size);$/;"	p	class:MemoryRegionMap	access:private	signature:(const void* start, size_t size)
RecordRegionRemovalInBucket	src/memory_region_map.cc	/^void MemoryRegionMap::RecordRegionRemovalInBucket(int depth,$/;"	f	class:MemoryRegionMap	signature:(int depth, const void* const stack[], size_t size)
RecordRegionRemovalInBucket	src/memory_region_map.h	/^  static void RecordRegionRemovalInBucket(int depth,$/;"	p	class:MemoryRegionMap	access:private	signature:(int depth, const void* const key[], size_t size)
RecordSpan	src/page_heap.h	/^  void RecordSpan(Span* span) {$/;"	f	class:tcmalloc::PageHeap	access:private	signature:(Span* span)
Region	src/memory_region_map.h	/^  struct Region {$/;"	s	class:MemoryRegionMap	access:public
RegionCmp	src/memory_region_map.h	/^  struct RegionCmp {$/;"	s	class:MemoryRegionMap	access:private
RegionIterator	src/memory_region_map.h	/^  typedef RegionSet::const_iterator RegionIterator;$/;"	t	class:MemoryRegionMap	access:public
RegionSet	src/memory_region_map.h	/^              STL_Allocator<Region, MyAllocator> > RegionSet;$/;"	t	class:MemoryRegionMap	access:private
RegionSetRep	src/memory_region_map.cc	/^union MemoryRegionMap::RegionSetRep {$/;"	u	class:MemoryRegionMap	file:
Register	src/gperftools/malloc_extension.h	/^  static void Register(MallocExtension* implementation);$/;"	p	class:MallocExtension	access:public	signature:(MallocExtension* implementation)
Register	src/malloc_extension.cc	/^void MallocExtension::Register(MallocExtension* implementation) {$/;"	f	class:MallocExtension	signature:(MallocExtension* implementation)
RegisterCallback	src/profile-handler.cc	/^  ProfileHandlerToken* RegisterCallback(ProfileHandlerCallback callback,$/;"	p	class:ProfileHandler	file:	access:public	signature:(ProfileHandlerCallback callback, void* callback_arg)
RegisterCallback	src/profile-handler.cc	/^ProfileHandlerToken* ProfileHandler::RegisterCallback($/;"	f	class:ProfileHandler	signature:( ProfileHandlerCallback callback, void* callback_arg)
RegisterCallback	src/tests/profile-handler_unittest.cc	/^  ProfileHandlerToken* RegisterCallback(void* callback_arg) {$/;"	f	class:__anon56::ProfileHandlerTest	access:protected	signature:(void* callback_arg)
RegisterCallbackBeforeThread	src/tests/profile-handler_unittest.cc	/^  void RegisterCallbackBeforeThread();$/;"	p	class:__anon56::ProfileHandlerTest	file:	access:private	signature:()
RegisterSizeClass	src/page_heap.cc	/^void PageHeap::RegisterSizeClass(Span* span, uint32 sc) {$/;"	f	class:tcmalloc::PageHeap	signature:(Span* span, uint32 sc)
RegisterSizeClass	src/page_heap.h	/^  void RegisterSizeClass(Span* span, uint32 sc);$/;"	p	class:tcmalloc::PageHeap	access:public	signature:(Span* span, uint32 sc)
RegisterStackLocked	src/heap-checker.cc	/^static void RegisterStackLocked(const void* top_ptr) {$/;"	f	file:	signature:(const void* top_ptr)
RegisterSystemAllocator	src/windows/system-alloc.cc	/^bool RegisterSystemAllocator(SysAllocator *allocator, int priority) {$/;"	f	signature:(SysAllocator *allocator, int priority)
RegisterThread	src/profile-handler.cc	/^  void RegisterThread();$/;"	p	class:ProfileHandler	file:	access:public	signature:()
RegisterThread	src/profile-handler.cc	/^void ProfileHandler::RegisterThread() {$/;"	f	class:ProfileHandler	signature:()
RegisterUnregisterCallback	src/tests/profile-handler_unittest.cc	/^  void RegisterUnregisterCallback();$/;"	p	class:__anon56::ProfileHandlerTest	file:	access:private	signature:()
Release	src/windows/preamble_patcher.cc	/^  unsigned char* Release() {$/;"	f	class:sidestep::DeleteUnsignedCharArray	access:public	signature:()
ReleaseAtLeastNPages	src/page_heap.cc	/^Length PageHeap::ReleaseAtLeastNPages(Length num_pages) {$/;"	f	class:tcmalloc::PageHeap	signature:(Length num_pages)
ReleaseAtLeastNPages	src/page_heap.h	/^  Length ReleaseAtLeastNPages(Length num_pages);$/;"	p	class:tcmalloc::PageHeap	access:public	signature:(Length num_pages)
ReleaseFreeMemory	src/gperftools/malloc_extension.h	/^  virtual void ReleaseFreeMemory();$/;"	p	class:MallocExtension	access:public	signature:()
ReleaseFreeMemory	src/malloc_extension.cc	/^void MallocExtension::ReleaseFreeMemory() {$/;"	f	class:MallocExtension	signature:()
ReleaseLastNormalSpan	src/page_heap.cc	/^Length PageHeap::ReleaseLastNormalSpan(SpanList* slist) {$/;"	f	class:tcmalloc::PageHeap	signature:(SpanList* slist)
ReleaseLastNormalSpan	src/page_heap.h	/^  Length ReleaseLastNormalSpan(SpanList* slist);$/;"	p	class:tcmalloc::PageHeap	access:private	signature:(SpanList* slist)
ReleaseListToSpans	src/central_freelist.cc	/^void CentralFreeList::ReleaseListToSpans(void* start) {$/;"	f	class:tcmalloc::CentralFreeList	signature:(void* start)
ReleaseSnapshot	src/heap-profile-table.cc	/^void HeapProfileTable::ReleaseSnapshot(Snapshot* s) {$/;"	f	class:HeapProfileTable	signature:(Snapshot* s)
ReleaseSnapshot	src/heap-profile-table.h	/^  void ReleaseSnapshot(Snapshot* snapshot);$/;"	p	class:HeapProfileTable	access:public	signature:(Snapshot* snapshot)
ReleaseToCentralCache	src/thread_cache.cc	/^void ThreadCache::ReleaseToCentralCache(FreeList* src, uint32 cl, int N) {$/;"	f	class:tcmalloc::ThreadCache	signature:(FreeList* src, uint32 cl, int N)
ReleaseToCentralCache	src/thread_cache.h	/^  void ReleaseToCentralCache(FreeList* src, uint32 cl, int N);$/;"	p	class:tcmalloc::ThreadCache	access:private	signature:(FreeList* src, uint32 cl, int N)
ReleaseToSpans	src/central_freelist.cc	/^void CentralFreeList::ReleaseToSpans(void* object) {$/;"	f	class:tcmalloc::CentralFreeList	signature:(void* object)
ReleaseToSystem	src/gperftools/malloc_extension.h	/^  virtual void ReleaseToSystem(size_t num_bytes);$/;"	p	class:MallocExtension	access:public	signature:(size_t num_bytes)
ReleaseToSystem	src/malloc_extension.cc	/^void MallocExtension::ReleaseToSystem(size_t num_bytes) {$/;"	f	class:MallocExtension	signature:(size_t num_bytes)
ReleaseToSystem	src/tcmalloc.cc	/^  virtual void ReleaseToSystem(size_t num_bytes) {$/;"	f	class:TCMallocImplementation	access:public	signature:(size_t num_bytes)
Release_AtomicExchange	src/base/atomicops-internals-arm-generic.h	/^inline Atomic32 Release_AtomicExchange(volatile Atomic32* ptr,$/;"	f	namespace:base::subtle	signature:(volatile Atomic32* ptr, Atomic32 new_value)
Release_AtomicExchange	src/base/atomicops-internals-arm-generic.h	/^inline Atomic64 Release_AtomicExchange(volatile Atomic64* ptr,$/;"	f	namespace:base::subtle	signature:(volatile Atomic64* ptr, Atomic64 new_value)
Release_AtomicExchange	src/base/atomicops-internals-arm-v6plus.h	/^inline Atomic32 Release_AtomicExchange(volatile Atomic32* ptr,$/;"	f	namespace:base::subtle	signature:(volatile Atomic32* ptr, Atomic32 new_value)
Release_AtomicExchange	src/base/atomicops-internals-arm-v6plus.h	/^inline Atomic64 Release_AtomicExchange(volatile Atomic64* ptr,$/;"	f	namespace:base::subtle	signature:(volatile Atomic64* ptr, Atomic64 new_value)
Release_AtomicExchange	src/base/atomicops-internals-gcc.h	/^inline Atomic32 Release_AtomicExchange(volatile Atomic32* ptr,$/;"	f	namespace:base::subtle	signature:(volatile Atomic32* ptr, Atomic32 new_value)
Release_AtomicExchange	src/base/atomicops-internals-gcc.h	/^inline Atomic64 Release_AtomicExchange(volatile Atomic64* ptr,$/;"	f	namespace:base::subtle	signature:(volatile Atomic64* ptr, Atomic64 new_value)
Release_AtomicExchange	src/base/atomicops-internals-linuxppc.h	/^inline Atomic32 Release_AtomicExchange(volatile Atomic32 *ptr,$/;"	f	namespace:base::subtle	signature:(volatile Atomic32 *ptr, Atomic32 new_value)
Release_AtomicExchange	src/base/atomicops-internals-linuxppc.h	/^inline Atomic64 Release_AtomicExchange(volatile Atomic64 *ptr,$/;"	f	namespace:base::subtle	signature:(volatile Atomic64 *ptr, Atomic64 new_value)
Release_AtomicExchange	src/base/atomicops-internals-macosx.h	/^inline Atomic32 Release_AtomicExchange(volatile Atomic32 *ptr,$/;"	f	namespace:base::subtle	signature:(volatile Atomic32 *ptr, Atomic32 new_value)
Release_AtomicExchange	src/base/atomicops-internals-macosx.h	/^inline Atomic64 Release_AtomicExchange(volatile Atomic64 *ptr,$/;"	f	namespace:base::subtle	signature:(volatile Atomic64 *ptr, Atomic64 new_value)
Release_AtomicExchange	src/base/atomicops-internals-mips.h	/^inline Atomic32 Release_AtomicExchange(volatile Atomic32* ptr,$/;"	f	namespace:base::subtle	signature:(volatile Atomic32* ptr, Atomic32 new_value)
Release_AtomicExchange	src/base/atomicops-internals-mips.h	/^inline Atomic64 Release_AtomicExchange(volatile Atomic64* ptr,$/;"	f	namespace:base::subtle	signature:(volatile Atomic64* ptr, Atomic64 new_value)
Release_AtomicExchange	src/base/atomicops-internals-windows.h	/^inline Atomic32 Release_AtomicExchange(volatile Atomic32* ptr,$/;"	f	namespace:base::subtle	signature:(volatile Atomic32* ptr, Atomic32 new_value)
Release_AtomicExchange	src/base/atomicops-internals-windows.h	/^inline Atomic64 Release_AtomicExchange(volatile Atomic64* ptr,$/;"	f	namespace:base::subtle	signature:(volatile Atomic64* ptr, Atomic64 new_value)
Release_AtomicExchange	src/base/atomicops-internals-x86.h	/^inline Atomic32 Release_AtomicExchange(volatile Atomic32* ptr,$/;"	f	namespace:base::subtle	signature:(volatile Atomic32* ptr, Atomic32 new_value)
Release_AtomicExchange	src/base/atomicops-internals-x86.h	/^inline Atomic64 Release_AtomicExchange(volatile Atomic64* ptr,$/;"	f	namespace:base::subtle	signature:(volatile Atomic64* ptr, Atomic64 new_val)
Release_AtomicExchange	src/base/atomicops-internals-x86.h	/^inline Atomic64 Release_AtomicExchange(volatile Atomic64* ptr,$/;"	f	namespace:base::subtle	signature:(volatile Atomic64* ptr, Atomic64 new_value)
Release_AtomicExchange	src/base/atomicops.h	/^inline AtomicWord Release_AtomicExchange(volatile AtomicWord* ptr,$/;"	f	namespace:base::subtle	signature:(volatile AtomicWord* ptr, AtomicWord new_value)
Release_CompareAndSwap	src/base/atomicops-internals-arm-generic.h	/^inline Atomic32 Release_CompareAndSwap(volatile Atomic32* ptr,$/;"	f	namespace:base::subtle	signature:(volatile Atomic32* ptr, Atomic32 old_value, Atomic32 new_value)
Release_CompareAndSwap	src/base/atomicops-internals-arm-generic.h	/^inline Atomic64 Release_CompareAndSwap(volatile Atomic64* ptr,$/;"	f	namespace:base::subtle	signature:(volatile Atomic64* ptr, Atomic64 old_value, Atomic64 new_value)
Release_CompareAndSwap	src/base/atomicops-internals-arm-v6plus.h	/^inline Atomic32 Release_CompareAndSwap(volatile Atomic32* ptr,$/;"	f	namespace:base::subtle	signature:(volatile Atomic32* ptr, Atomic32 old_value, Atomic32 new_value)
Release_CompareAndSwap	src/base/atomicops-internals-arm-v6plus.h	/^inline Atomic64 Release_CompareAndSwap(volatile Atomic64* ptr,$/;"	f	namespace:base::subtle	signature:(volatile Atomic64* ptr, Atomic64 old_value, Atomic64 new_value)
Release_CompareAndSwap	src/base/atomicops-internals-gcc.h	/^inline Atomic32 Release_CompareAndSwap(volatile Atomic32* ptr,$/;"	f	namespace:base::subtle	signature:(volatile Atomic32* ptr, Atomic32 old_value, Atomic32 new_value)
Release_CompareAndSwap	src/base/atomicops-internals-gcc.h	/^inline Atomic64 Release_CompareAndSwap(volatile Atomic64* ptr,$/;"	f	namespace:base::subtle	signature:(volatile Atomic64* ptr, Atomic64 old_value, Atomic64 new_value)
Release_CompareAndSwap	src/base/atomicops-internals-linuxppc.h	/^inline Atomic32 Release_CompareAndSwap(volatile Atomic32 *ptr,$/;"	f	namespace:base::subtle	signature:(volatile Atomic32 *ptr, Atomic32 old_value, Atomic32 new_value)
Release_CompareAndSwap	src/base/atomicops-internals-linuxppc.h	/^inline Atomic64 Release_CompareAndSwap(volatile Atomic64 *ptr,$/;"	f	namespace:base::subtle	signature:(volatile Atomic64 *ptr, Atomic64 old_value, Atomic64 new_value)
Release_CompareAndSwap	src/base/atomicops-internals-macosx.h	/^inline Atomic32 Release_CompareAndSwap(volatile Atomic32 *ptr,$/;"	f	namespace:base::subtle	signature:(volatile Atomic32 *ptr, Atomic32 old_value, Atomic32 new_value)
Release_CompareAndSwap	src/base/atomicops-internals-macosx.h	/^inline Atomic64 Release_CompareAndSwap(volatile Atomic64 *ptr,$/;"	f	namespace:base::subtle	signature:(volatile Atomic64 *ptr, Atomic64 old_value, Atomic64 new_value)
Release_CompareAndSwap	src/base/atomicops-internals-mips.h	/^inline Atomic32 Release_CompareAndSwap(volatile Atomic32* ptr,$/;"	f	namespace:base::subtle	signature:(volatile Atomic32* ptr, Atomic32 old_value, Atomic32 new_value)
Release_CompareAndSwap	src/base/atomicops-internals-mips.h	/^inline Atomic64 Release_CompareAndSwap(volatile Atomic64* ptr,$/;"	f	namespace:base::subtle	signature:(volatile Atomic64* ptr, Atomic64 old_value, Atomic64 new_value)
Release_CompareAndSwap	src/base/atomicops-internals-windows.h	/^inline Atomic32 Release_CompareAndSwap(volatile Atomic32* ptr,$/;"	f	namespace:base::subtle	signature:(volatile Atomic32* ptr, Atomic32 old_value, Atomic32 new_value)
Release_CompareAndSwap	src/base/atomicops-internals-windows.h	/^inline Atomic64 Release_CompareAndSwap(volatile Atomic64* ptr,$/;"	f	namespace:base::subtle	signature:(volatile Atomic64* ptr, Atomic64 old_value, Atomic64 new_value)
Release_CompareAndSwap	src/base/atomicops-internals-x86.h	/^inline Atomic32 Release_CompareAndSwap(volatile Atomic32* ptr,$/;"	f	namespace:base::subtle	signature:(volatile Atomic32* ptr, Atomic32 old_value, Atomic32 new_value)
Release_CompareAndSwap	src/base/atomicops-internals-x86.h	/^inline Atomic64 Release_CompareAndSwap(volatile Atomic64* ptr,$/;"	f	namespace:base::subtle	signature:(volatile Atomic64* ptr, Atomic64 old_value, Atomic64 new_value)
Release_CompareAndSwap	src/base/atomicops.h	/^inline Atomic32 Release_CompareAndSwap(volatile Atomic32* ptr,$/;"	f	signature:(volatile Atomic32* ptr, Atomic32 old_value, Atomic32 new_value)
Release_CompareAndSwap	src/base/atomicops.h	/^inline AtomicWord Release_CompareAndSwap(volatile AtomicWord* ptr,$/;"	f	namespace:base::subtle	signature:(volatile AtomicWord* ptr, AtomicWord old_value, AtomicWord new_value)
Release_CompareAndSwap	src/base/atomicops.h	/^inline AtomicWord Release_CompareAndSwap(volatile AtomicWord* ptr,$/;"	f	signature:(volatile AtomicWord* ptr, AtomicWord old_value, AtomicWord new_value)
Release_CompareAndSwap	src/base/atomicops.h	/^inline base::subtle::Atomic64 Release_CompareAndSwap($/;"	f	signature:( volatile base::subtle::Atomic64* ptr, base::subtle::Atomic64 old_value, base::subtle::Atomic64 new_value)
Release_Load	src/base/atomicops-internals-arm-generic.h	/^inline Atomic32 Release_Load(volatile const Atomic32* ptr) {$/;"	f	namespace:base::subtle	signature:(volatile const Atomic32* ptr)
Release_Load	src/base/atomicops-internals-arm-generic.h	/^inline Atomic64 Release_Load(volatile const Atomic64* ptr) {$/;"	f	namespace:base::subtle	signature:(volatile const Atomic64* ptr)
Release_Load	src/base/atomicops-internals-arm-v6plus.h	/^inline Atomic32 Release_Load(volatile const Atomic32* ptr) {$/;"	f	namespace:base::subtle	signature:(volatile const Atomic32* ptr)
Release_Load	src/base/atomicops-internals-arm-v6plus.h	/^inline Atomic64 Release_Load(volatile const Atomic64* ptr) {$/;"	f	namespace:base::subtle	signature:(volatile const Atomic64* ptr)
Release_Load	src/base/atomicops-internals-gcc.h	/^inline Atomic32 Release_Load(volatile const Atomic32* ptr) {$/;"	f	namespace:base::subtle	signature:(volatile const Atomic32* ptr)
Release_Load	src/base/atomicops-internals-gcc.h	/^inline Atomic64 Release_Load(volatile const Atomic64* ptr) {$/;"	f	namespace:base::subtle	signature:(volatile const Atomic64* ptr)
Release_Load	src/base/atomicops-internals-linuxppc.h	/^inline Atomic32 Release_Load(volatile const Atomic32 *ptr) {$/;"	f	namespace:base::subtle	signature:(volatile const Atomic32 *ptr)
Release_Load	src/base/atomicops-internals-linuxppc.h	/^inline Atomic64 Release_Load(volatile const Atomic64 *ptr) {$/;"	f	namespace:base::subtle	signature:(volatile const Atomic64 *ptr)
Release_Load	src/base/atomicops-internals-macosx.h	/^inline Atomic32 Release_Load(volatile const Atomic32 *ptr) {$/;"	f	namespace:base::subtle	signature:(volatile const Atomic32 *ptr)
Release_Load	src/base/atomicops-internals-macosx.h	/^inline Atomic64 Release_Load(volatile const Atomic64 *ptr) {$/;"	f	namespace:base::subtle	signature:(volatile const Atomic64 *ptr)
Release_Load	src/base/atomicops-internals-mips.h	/^inline Atomic32 Release_Load(volatile const Atomic32* ptr)$/;"	f	namespace:base::subtle	signature:(volatile const Atomic32* ptr)
Release_Load	src/base/atomicops-internals-mips.h	/^inline Atomic64 Release_Load(volatile const Atomic64* ptr)$/;"	f	namespace:base::subtle	signature:(volatile const Atomic64* ptr)
Release_Load	src/base/atomicops-internals-windows.h	/^inline Atomic32 Release_Load(volatile const Atomic32* ptr) {$/;"	f	namespace:base::subtle	signature:(volatile const Atomic32* ptr)
Release_Load	src/base/atomicops-internals-windows.h	/^inline Atomic64 Release_Load(volatile const Atomic64* ptr) {$/;"	f	namespace:base::subtle	signature:(volatile const Atomic64* ptr)
Release_Load	src/base/atomicops-internals-x86.h	/^inline Atomic32 Release_Load(volatile const Atomic32* ptr) {$/;"	f	namespace:base::subtle	signature:(volatile const Atomic32* ptr)
Release_Load	src/base/atomicops-internals-x86.h	/^inline Atomic64 Release_Load(volatile const Atomic64* ptr) {$/;"	f	namespace:base::subtle	signature:(volatile const Atomic64* ptr)
Release_Load	src/base/atomicops.h	/^inline Atomic32 Release_Load(volatile const Atomic32* ptr) {$/;"	f	signature:(volatile const Atomic32* ptr)
Release_Load	src/base/atomicops.h	/^inline AtomicWord Release_Load(volatile const AtomicWord* ptr) {$/;"	f	namespace:base::subtle	signature:(volatile const AtomicWord* ptr)
Release_Load	src/base/atomicops.h	/^inline AtomicWord Release_Load(volatile const AtomicWord* ptr) {$/;"	f	signature:(volatile const AtomicWord* ptr)
Release_Load	src/base/atomicops.h	/^inline base::subtle::Atomic64 Release_Load($/;"	f	signature:( volatile const base::subtle::Atomic64* ptr)
Release_Store	src/base/atomicops-internals-arm-generic.h	/^inline void Release_Store(volatile Atomic32* ptr, Atomic32 value) {$/;"	f	namespace:base::subtle	signature:(volatile Atomic32* ptr, Atomic32 value)
Release_Store	src/base/atomicops-internals-arm-generic.h	/^inline void Release_Store(volatile Atomic64* ptr, Atomic64 value) {$/;"	f	namespace:base::subtle	signature:(volatile Atomic64* ptr, Atomic64 value)
Release_Store	src/base/atomicops-internals-arm-v6plus.h	/^inline void Release_Store(volatile Atomic32* ptr, Atomic32 value) {$/;"	f	namespace:base::subtle	signature:(volatile Atomic32* ptr, Atomic32 value)
Release_Store	src/base/atomicops-internals-arm-v6plus.h	/^inline void Release_Store(volatile Atomic64* ptr, Atomic64 value) {$/;"	f	namespace:base::subtle	signature:(volatile Atomic64* ptr, Atomic64 value)
Release_Store	src/base/atomicops-internals-gcc.h	/^inline void Release_Store(volatile Atomic32* ptr, Atomic32 value) {$/;"	f	namespace:base::subtle	signature:(volatile Atomic32* ptr, Atomic32 value)
Release_Store	src/base/atomicops-internals-gcc.h	/^inline void Release_Store(volatile Atomic64* ptr, Atomic64 value) {$/;"	f	namespace:base::subtle	signature:(volatile Atomic64* ptr, Atomic64 value)
Release_Store	src/base/atomicops-internals-linuxppc.h	/^inline void Release_Store(volatile Atomic32 *ptr, Atomic32 value) {$/;"	f	namespace:base::subtle	signature:(volatile Atomic32 *ptr, Atomic32 value)
Release_Store	src/base/atomicops-internals-linuxppc.h	/^inline void Release_Store(volatile Atomic64 *ptr, Atomic64 value) {$/;"	f	namespace:base::subtle	signature:(volatile Atomic64 *ptr, Atomic64 value)
Release_Store	src/base/atomicops-internals-macosx.h	/^inline void Release_Store(volatile Atomic32 *ptr, Atomic32 value) {$/;"	f	namespace:base::subtle	signature:(volatile Atomic32 *ptr, Atomic32 value)
Release_Store	src/base/atomicops-internals-macosx.h	/^inline void Release_Store(volatile Atomic64 *ptr, Atomic64 value) {$/;"	f	namespace:base::subtle	signature:(volatile Atomic64 *ptr, Atomic64 value)
Release_Store	src/base/atomicops-internals-mips.h	/^inline void Release_Store(volatile Atomic32* ptr, Atomic32 value)$/;"	f	namespace:base::subtle	signature:(volatile Atomic32* ptr, Atomic32 value)
Release_Store	src/base/atomicops-internals-mips.h	/^inline void Release_Store(volatile Atomic64* ptr, Atomic64 value)$/;"	f	namespace:base::subtle	signature:(volatile Atomic64* ptr, Atomic64 value)
Release_Store	src/base/atomicops-internals-windows.h	/^inline void Release_Store(volatile Atomic32* ptr, Atomic32 value) {$/;"	f	namespace:base::subtle	signature:(volatile Atomic32* ptr, Atomic32 value)
Release_Store	src/base/atomicops-internals-windows.h	/^inline void Release_Store(volatile Atomic64* ptr, Atomic64 value) {$/;"	f	namespace:base::subtle	signature:(volatile Atomic64* ptr, Atomic64 value)
Release_Store	src/base/atomicops-internals-x86.h	/^inline void Release_Store(volatile Atomic32* ptr, Atomic32 value) {$/;"	f	namespace:base::subtle	signature:(volatile Atomic32* ptr, Atomic32 value)
Release_Store	src/base/atomicops-internals-x86.h	/^inline void Release_Store(volatile Atomic64* ptr, Atomic64 value) {$/;"	f	namespace:base::subtle	signature:(volatile Atomic64* ptr, Atomic64 value)
Release_Store	src/base/atomicops.h	/^inline void Release_Store($/;"	f	signature:( volatile base::subtle::Atomic64* ptr, base::subtle::Atomic64 value)
Release_Store	src/base/atomicops.h	/^inline void Release_Store(volatile Atomic32* ptr, Atomic32 value) {$/;"	f	signature:(volatile Atomic32* ptr, Atomic32 value)
Release_Store	src/base/atomicops.h	/^inline void Release_Store(volatile AtomicWord* ptr, AtomicWord value) {$/;"	f	namespace:base::subtle	signature:(volatile AtomicWord* ptr, AtomicWord value)
Release_Store	src/base/atomicops.h	/^inline void Release_Store(volatile AtomicWord* ptr, AtomicWord value) {$/;"	f	signature:(volatile AtomicWord* ptr, AtomicWord value)
Remove	src/malloc_hook-inl.h	/^  bool Remove(T value);$/;"	p	struct:base::internal::HookList	access:public	signature:(T value)
Remove	src/malloc_hook.cc	/^bool HookList<T>::Remove(T value_as_t) {$/;"	f	class:base::internal::HookList	signature:(T value_as_t)
RemoveDeleteHook	src/gperftools/malloc_hook.h	/^  inline static bool RemoveDeleteHook(DeleteHook hook) {$/;"	f	class:MallocHook	access:public	signature:(DeleteHook hook)
RemoveFromFreeList	src/page_heap.cc	/^void PageHeap::RemoveFromFreeList(Span* span) {$/;"	f	class:tcmalloc::PageHeap	signature:(Span* span)
RemoveFromFreeList	src/page_heap.h	/^  void RemoveFromFreeList(Span* span);$/;"	p	class:tcmalloc::PageHeap	access:private	signature:(Span* span)
RemoveInitialHooksAndCallInitializers	src/malloc_hook.cc	/^void RemoveInitialHooksAndCallInitializers() {$/;"	f	namespace:__anon51	signature:()
RemoveInitialHooksAndCallInitializers	src/malloc_hook.cc	/^void RemoveInitialHooksAndCallInitializers();  \/\/ below.$/;"	p	namespace:__anon51	file:	signature:()
RemoveMmapHook	src/gperftools/malloc_hook.h	/^  inline static bool RemoveMmapHook(MmapHook hook) {$/;"	f	class:MallocHook	access:public	signature:(MmapHook hook)
RemoveMmapReplacement	src/gperftools/malloc_hook.h	/^  inline static bool RemoveMmapReplacement(MmapReplacement hook) {$/;"	f	class:MallocHook	access:public	signature:(MmapReplacement hook)
RemoveMremapHook	src/gperftools/malloc_hook.h	/^  inline static bool RemoveMremapHook(MremapHook hook) {$/;"	f	class:MallocHook	access:public	signature:(MremapHook hook)
RemoveMunmapHook	src/gperftools/malloc_hook.h	/^  inline static bool RemoveMunmapHook(MunmapHook hook) {$/;"	f	class:MallocHook	access:public	signature:(MunmapHook hook)
RemoveMunmapReplacement	src/gperftools/malloc_hook.h	/^  inline static bool RemoveMunmapReplacement(MunmapReplacement hook) {$/;"	f	class:MallocHook	access:public	signature:(MunmapReplacement hook)
RemoveNewHook	src/gperftools/malloc_hook.h	/^  inline static bool RemoveNewHook(NewHook hook) {$/;"	f	class:MallocHook	access:public	signature:(NewHook hook)
RemovePreMmapHook	src/gperftools/malloc_hook.h	/^  inline static bool RemovePreMmapHook(PreMmapHook hook) {$/;"	f	class:MallocHook	access:public	signature:(PreMmapHook hook)
RemovePreSbrkHook	src/gperftools/malloc_hook.h	/^  inline static bool RemovePreSbrkHook(PreSbrkHook hook) {$/;"	f	class:MallocHook	access:public	signature:(PreSbrkHook hook)
RemoveRange	src/central_freelist.cc	/^int CentralFreeList::RemoveRange(void **start, void **end, int N) {$/;"	f	class:tcmalloc::CentralFreeList	signature:(void **start, void **end, int N)
RemoveRange	src/central_freelist.h	/^  int RemoveRange(void **start, void **end, int N);$/;"	p	class:tcmalloc::CentralFreeList	access:public	signature:(void **start, void **end, int N)
RemoveSbrkHook	src/gperftools/malloc_hook.h	/^  inline static bool RemoveSbrkHook(SbrkHook hook) {$/;"	f	class:MallocHook	access:public	signature:(SbrkHook hook)
ReplaceSystemAlloc	src/libc_override.h	/^static void ReplaceSystemAlloc() { PatchWindowsFunctions(); }$/;"	f	signature:()
ReplaceSystemAlloc	src/libc_override.h	/^static void ReplaceSystemAlloc();  \/\/ defined in the .h files below$/;"	p	signature:()
ReplaceSystemAlloc	src/libc_override_gcc_and_weak.h	/^static void ReplaceSystemAlloc() { }$/;"	f	signature:()
ReplaceSystemAlloc	src/libc_override_osx.h	/^static void ReplaceSystemAlloc() {$/;"	f	signature:()
ReplaceSystemAlloc	src/libc_override_redefine.h	/^static void ReplaceSystemAlloc() { }$/;"	f	signature:()
ReportCallback	src/heap-profile-table.cc	/^void HeapProfileTable::Snapshot::ReportCallback(const void* ptr,$/;"	f	class:HeapProfileTable::Snapshot	signature:(const void* ptr, AllocValue* v, ReportState* state)
ReportCallback	src/heap-profile-table.h	/^  static void ReportCallback(const void* ptr, AllocValue* v, ReportState*);$/;"	p	class:HeapProfileTable::Snapshot	access:private	signature:(const void* ptr, AllocValue* v, ReportState*)
ReportIndividualObjects	src/heap-profile-table.cc	/^void HeapProfileTable::Snapshot::ReportIndividualObjects() {$/;"	f	class:HeapProfileTable::Snapshot	signature:()
ReportIndividualObjects	src/heap-profile-table.h	/^  void ReportIndividualObjects();$/;"	p	class:HeapProfileTable::Snapshot	access:public	signature:()
ReportLargeAlloc	src/tcmalloc.cc	/^static void ReportLargeAlloc(Length num_pages, void* result) {$/;"	f	namespace:__anon3	signature:(Length num_pages, void* result)
ReportLeaks	src/heap-profile-table.cc	/^void HeapProfileTable::Snapshot::ReportLeaks(const char* checker_name,$/;"	f	class:HeapProfileTable::Snapshot	signature:(const char* checker_name, const char* filename, bool should_symbolize)
ReportLeaks	src/heap-profile-table.h	/^  void ReportLeaks(const char* checker_name, const char* filename,$/;"	p	class:HeapProfileTable::Snapshot	access:public	signature:(const char* checker_name, const char* filename, bool should_symbolize)
ReportObject	src/heap-profile-table.cc	/^void HeapProfileTable::Snapshot::ReportObject(const void* ptr,$/;"	f	class:HeapProfileTable::Snapshot	signature:(const void* ptr, AllocValue* v, char* unused)
ReportObject	src/heap-profile-table.h	/^  static void ReportObject(const void* ptr, AllocValue* v, char*);$/;"	p	class:HeapProfileTable::Snapshot	access:private	signature:(const void* ptr, AllocValue* v, char*)
ReportState	src/heap-profile-table.cc	/^struct HeapProfileTable::Snapshot::ReportState {$/;"	s	class:HeapProfileTable::Snapshot	file:
Reset	src/profile-handler.cc	/^  void Reset();$/;"	p	class:ProfileHandler	file:	access:public	signature:()
Reset	src/profile-handler.cc	/^void ProfileHandler::Reset() {$/;"	f	class:ProfileHandler	signature:()
Reset	src/profiledata.cc	/^void ProfileData::Reset() {$/;"	f	class:ProfileData	signature:()
Reset	src/profiledata.h	/^  void Reset();$/;"	p	class:ProfileData	access:public	signature:()
Reset	src/tests/profile-handler_unittest.cc	/^  void Reset();$/;"	p	class:__anon56::ProfileHandlerTest	file:	access:private	signature:()
ResetUseEmergencyMalloc	src/thread_cache.h	/^  static void         ResetUseEmergencyMalloc();$/;"	p	class:tcmalloc::ThreadCache	access:public	signature:()
ResetUseEmergencyMalloc	src/thread_cache.h	/^inline void ThreadCache::ResetUseEmergencyMalloc() {$/;"	f	class:tcmalloc::ThreadCache	signature:()
ResolveTarget	src/windows/preamble_patcher.h	/^  static T ResolveTarget(T target_function) {$/;"	f	class:sidestep::PreamblePatcher	access:public	signature:(T target_function)
ResolveTargetImpl	src/windows/preamble_patcher.cc	/^void* PreamblePatcher::ResolveTargetImpl(unsigned char* target,$/;"	f	class:sidestep::PreamblePatcher	signature:(unsigned char* target, unsigned char* stop_before, bool stop_before_trampoline)
ResolveTargetImpl	src/windows/preamble_patcher.h	/^  static void* ResolveTargetImpl(unsigned char* target_function,$/;"	p	class:sidestep::PreamblePatcher	access:private	signature:(unsigned char* target_function, unsigned char* stop_before, bool stop_before_trampoline = false)
RestoreSavedBucketsLocked	src/memory_region_map.cc	/^void MemoryRegionMap::RestoreSavedBucketsLocked() {$/;"	f	class:MemoryRegionMap	signature:()
RestoreSavedBucketsLocked	src/memory_region_map.h	/^  static void RestoreSavedBucketsLocked();$/;"	p	class:MemoryRegionMap	access:private	signature:()
RoundUp	src/base/low_level_alloc.cc	/^static intptr_t RoundUp(intptr_t addr, intptr_t align) {$/;"	f	file:	signature:(intptr_t addr, intptr_t align)
RoundUp	src/debugallocation.cc	/^static intptr_t RoundUp(intptr_t value, intptr_t alignment) {$/;"	f	file:	signature:(intptr_t value, intptr_t alignment)
RoutineCallingTheSignal	src/tests/getpc_test.cc	/^static void RoutineCallingTheSignal() {$/;"	f	file:	signature:()
Rt	src/libtcmalloc_internal_la-malloc_extension.o	/^*R/;"	v
RtlCaptureStackBackTrace_Function	src/stacktrace_win32-inl.h	/^typedef USHORT NTAPI RtlCaptureStackBackTrace_Function($/;"	t
RtlCaptureStackBackTrace_fn	src/stacktrace_win32-inl.h	/^static RtlCaptureStackBackTrace_Function* const RtlCaptureStackBackTrace_fn =$/;"	v
Run	src/tests/heap-checker_unittest.cc	/^  virtual void Run() = 0;$/;"	p	class:Closure	file:	access:public	signature:()
Run	src/tests/heap-checker_unittest.cc	/^  virtual void Run() { (*f_)(); delete this; }$/;"	f	class:Callback0	access:public	signature:()
Run	src/tests/heap-checker_unittest.cc	/^  virtual void Run() { (*f_)(p1_); delete this; }$/;"	f	class:Callback1	access:public	signature:()
Run	src/tests/heap-checker_unittest.cc	/^  virtual void Run() { (*f_)(p1_, p2_); delete this; }$/;"	f	class:Callback2	access:public	signature:()
Run	src/tests/profile-handler_unittest.cc	/^  virtual void Run() = 0;$/;"	p	class:__anon56::Thread	file:	access:public	signature:()
Run	src/tests/profile-handler_unittest.cc	/^  void Run() {$/;"	f	class:__anon56::BusyThread	file:	access:private	signature:()
Run	src/tests/profile-handler_unittest.cc	/^  void Run() {$/;"	f	class:__anon56::NullThread	file:	access:private	signature:()
Run	src/tests/tcmalloc_unittest.cc	/^  virtual void Run() {$/;"	f	class:testing::TesterThread	access:public	signature:()
RunAllTests	src/tests/tcmalloc_unittest.cc	/^static int RunAllTests(int argc, char** argv) {$/;"	f	namespace:testing	signature:(int argc, char** argv)
RunDisabledLeaks	src/tests/heap-checker_unittest.cc	/^static void* RunDisabledLeaks(void* a) {$/;"	f	file:	signature:(void* a)
RunFunctionInThread	src/tests/testutil.cc	/^  DWORD WINAPI RunFunctionInThread(LPVOID ptr_to_ptr_to_fn) {$/;"	f	signature:(LPVOID ptr_to_ptr_to_fn)
RunFunctionInThread	src/tests/testutil.cc	/^  static void* RunFunctionInThread(void *ptr_to_ptr_to_fn) {$/;"	f	file:	signature:(void *ptr_to_ptr_to_fn)
RunFunctionInThreadWithId	src/tests/testutil.cc	/^  DWORD WINAPI RunFunctionInThreadWithId(LPVOID ptr_to_fnid) {$/;"	f	signature:(LPVOID ptr_to_fnid)
RunFunctionInThreadWithId	src/tests/testutil.cc	/^  static void* RunFunctionInThreadWithId(void *ptr_to_fnid) {$/;"	f	file:	signature:(void *ptr_to_fnid)
RunHeapBusyThreads	src/tests/heap-checker_unittest.cc	/^static void RunHeapBusyThreads() {$/;"	f	file:	signature:()
RunHeapBusyThreads	src/tests/heap-checker_unittest.cc	/^static void RunHeapBusyThreads();  \/\/ below$/;"	p	file:	signature:()
RunHeapCleanups	src/gperftools/heap-checker.h	/^  static void RunHeapCleanups();$/;"	p	class:HeapCleaner	access:public	signature:()
RunHeapCleanups	src/heap-checker.cc	/^void HeapCleaner::RunHeapCleanups() {$/;"	f	class:HeapCleaner	signature:()
RunHidden	src/tests/heap-checker_unittest.cc	/^static void RunHidden(Closure* c) {$/;"	f	file:	signature:(Closure* c)
RunManyThreads	src/tests/testutil.cc	/^  void RunManyThreads(void (*fn)(), int count) {$/;"	f	signature:(void (*fn)(), int count)
RunManyThreads	src/tests/testutil.cc	/^extern "C" void RunManyThreads(void (*fn)(), int count) {$/;"	f	signature:(void (*fn)(), int count)
RunManyThreads	src/tests/testutil.h	/^extern "C" void RunManyThreads(void (*fn)(), int count);$/;"	p	signature:(void (*fn)(), int count)
RunManyThreadsWithId	src/tests/testutil.cc	/^  void RunManyThreadsWithId(void (*fn)(int), int count, int stacksize) {$/;"	f	signature:(void (*fn)(int), int count, int stacksize)
RunManyThreadsWithId	src/tests/testutil.cc	/^extern "C" void RunManyThreadsWithId(void (*fn)(int), int count, int) {$/;"	f	signature:(void (*fn)(int), int count, int)
RunManyThreadsWithId	src/tests/testutil.h	/^extern "C" void RunManyThreadsWithId(void (*fn)(int), int count, int stacksize);$/;"	p	signature:(void (*fn)(int), int count, int stacksize)
RunNamedDisabledLeaks	src/gperftools/heap-checker.h	/^  friend void* RunNamedDisabledLeaks(void*);$/;"	p	class:HeapLeakChecker	access:friend	signature:(void*)
RunSilent	src/tests/heap-checker_unittest.cc	/^static bool RunSilent(HeapLeakChecker* check,$/;"	f	file:	signature:(HeapLeakChecker* check, bool (HeapLeakChecker::* func)())
RunThread	src/tests/tcmalloc_unittest.cc	/^static void RunThread(int thread_id) {$/;"	f	namespace:testing	signature:(int thread_id)
RunThread	src/tests/testutil.cc	/^  void RunThread(void (*fn)()) {$/;"	f	signature:(void (*fn)())
RunThread	src/tests/testutil.cc	/^extern "C" void RunThread(void (*fn)()) {$/;"	f	signature:(void (*fn)())
RunThread	src/tests/testutil.h	/^extern "C" void RunThread(void (*fn)());$/;"	p	signature:(void (*fn)())
RunningOnValgrind	src/base/dynamic_annotations.c	/^int RunningOnValgrind(void) {$/;"	f	signature:(void)
RunningOnValgrind	src/base/dynamic_annotations.h	/^int RunningOnValgrind(void);$/;"	p	signature:(void)
S	src/.libs/libtcmalloc_internal_la-internal_logging.o	/^/;"	v
S	src/tests/atomicops_unittest.o	/^/;"	v
SAFE_PTHREAD	src/base/simple_mutex.h	237;"	d
SAFE_PTHREAD	src/base/simple_mutex.h	256;"	d
SAFE_PTHREAD	src/base/simple_mutex.h	260;"	d
SAFE_PTHREAD	src/base/simple_mutex.h	279;"	d
SAFE_PTHREAD	src/tests/testutil.cc	163;"	d	file:
SAME_HEAP	src/tests/heap-checker_unittest.cc	/^enum CheckType { SAME_HEAP, NO_LEAKS };$/;"	e	enum:CheckType	file:
SAMPLING_TEST	sampling_debug_test.sh	/^SAMPLING_TEST="${1:-$BINDIR\/sampling_test}"$/;"	v
SAMPLING_TEST	sampling_test.sh	/^SAMPLING_TEST="${1:-$BINDIR\/sampling_test}"$/;"	v
SAMPLING_TEST	src/tests/sampling_test.sh	/^SAMPLING_TEST="${1:-$BINDIR\/sampling_test}"$/;"	v
SA_RESTORER	src/base/linux_syscall_support.h	574;"	d
SCNd64	src/base/basictypes.h	102;"	d
SCNd64	src/windows/port.h	346;"	d
SCNx64	src/base/basictypes.h	96;"	d
SCNx64	src/windows/port.h	344;"	d
SCOPED_LOCKABLE	src/base/thread_annotations.h	112;"	d
SEARCH_CAP	src/windows/addr2line-pdb.c	48;"	d	file:
SEARCH_CAP	src/windows/nm-pdb.c	59;"	d	file:
SET_FRAME	src/base/elfcore.h	180;"	d
SET_FRAME	src/base/elfcore.h	241;"	d
SET_FRAME	src/base/elfcore.h	271;"	d
SET_FRAME	src/base/elfcore.h	334;"	d
SET_FRAME	src/base/elfcore.h	352;"	d
SHARED_LOCKS_REQUIRED	src/base/thread_annotations.h	96;"	d
SHARED_LOCK_FUNCTION	src/base/thread_annotations.h	118;"	d
SHARED_TRYLOCK_FUNCTION	src/base/thread_annotations.h	124;"	d
SIDESTEP_ACCESS_DENIED	src/windows/preamble_patcher.h	/^  SIDESTEP_ACCESS_DENIED,$/;"	e	enum:sidestep::SideStepError
SIDESTEP_ASSERT	src/windows/mini_disassembler.h	46;"	d
SIDESTEP_ASSERT	src/windows/preamble_patcher.h	46;"	d
SIDESTEP_CHK	src/windows/auto_testing_hook.h	39;"	d
SIDESTEP_EXPECT_TRUE	src/windows/auto_testing_hook.h	40;"	d
SIDESTEP_FUNCTION_TOO_SMALL	src/windows/preamble_patcher.h	/^  SIDESTEP_FUNCTION_TOO_SMALL,$/;"	e	enum:sidestep::SideStepError
SIDESTEP_INSUFFICIENT_BUFFER	src/windows/preamble_patcher.h	/^  SIDESTEP_INSUFFICIENT_BUFFER,$/;"	e	enum:sidestep::SideStepError
SIDESTEP_INVALID_PARAMETER	src/windows/preamble_patcher.h	/^  SIDESTEP_INVALID_PARAMETER,$/;"	e	enum:sidestep::SideStepError
SIDESTEP_JUMP_INSTRUCTION	src/windows/preamble_patcher.h	/^  SIDESTEP_JUMP_INSTRUCTION,$/;"	e	enum:sidestep::SideStepError
SIDESTEP_LOG	src/windows/mini_disassembler.h	47;"	d
SIDESTEP_LOG	src/windows/preamble_patcher.h	47;"	d
SIDESTEP_NO_SUCH_FUNCTION	src/windows/preamble_patcher.h	/^  SIDESTEP_NO_SUCH_FUNCTION,$/;"	e	enum:sidestep::SideStepError
SIDESTEP_NO_SUCH_MODULE	src/windows/preamble_patcher.h	/^  SIDESTEP_NO_SUCH_MODULE,$/;"	e	enum:sidestep::SideStepError
SIDESTEP_SUCCESS	src/windows/preamble_patcher.h	/^  SIDESTEP_SUCCESS = 0,$/;"	e	enum:sidestep::SideStepError
SIDESTEP_TO_HRESULT	src/windows/preamble_patcher.h	89;"	d
SIDESTEP_UNEXPECTED	src/windows/preamble_patcher.h	/^  SIDESTEP_UNEXPECTED,$/;"	e	enum:sidestep::SideStepError
SIDESTEP_UNSUPPORTED_INSTRUCTION	src/windows/preamble_patcher.h	/^  SIDESTEP_UNSUPPORTED_INSTRUCTION,$/;"	e	enum:sidestep::SideStepError
SIS_CONCAT	src/stacktrace_impl_setup-inl.h	/^static GetStackImplementation SIS_CONCAT(impl__,GST_SUFFIX) = {$/;"	p	signature:(impl__,GST_SUFFIX)
SIS_CONCAT	src/stacktrace_impl_setup-inl.h	42;"	d
SIS_CONCAT	src/stacktrace_impl_setup-inl.h	94;"	d
SIS_CONCAT2	src/stacktrace_impl_setup-inl.h	41;"	d
SIS_CONCAT2	src/stacktrace_impl_setup-inl.h	93;"	d
SIS_STRINGIFY	src/stacktrace_impl_setup-inl.h	44;"	d
SIS_STRINGIFY2	src/stacktrace_impl_setup-inl.h	45;"	d
SLL_Next	src/linked_list.h	/^inline void *SLL_Next(void *t) {$/;"	f	namespace:tcmalloc	signature:(void *t)
SLL_Pop	src/linked_list.h	/^inline void *SLL_Pop(void **list) {$/;"	f	namespace:tcmalloc	signature:(void **list)
SLL_PopRange	src/linked_list.h	/^inline void SLL_PopRange(void **head, int N, void **start, void **end) {$/;"	f	namespace:tcmalloc	signature:(void **head, int N, void **start, void **end)
SLL_Push	src/linked_list.h	/^inline void SLL_Push(void **list, void *element) {$/;"	f	namespace:tcmalloc	signature:(void **list, void *element)
SLL_PushRange	src/linked_list.h	/^inline void SLL_PushRange(void **head, void *start, void *end) {$/;"	f	namespace:tcmalloc	signature:(void **head, void *start, void *end)
SLL_SetNext	src/linked_list.h	/^inline void SLL_SetNext(void *t, void *n) {$/;"	f	namespace:tcmalloc	signature:(void *t, void *n)
SLL_Size	src/linked_list.h	/^inline size_t SLL_Size(void *head) {$/;"	f	namespace:tcmalloc	signature:(void *head)
SLL_TryPop	src/linked_list.h	/^inline bool SLL_TryPop(void **list, void **rv) {$/;"	f	namespace:tcmalloc	signature:(void **list, void **rv)
SOFTWARE	COPYING	/^OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.$/;"	v
SOFTWARE	packages/deb/copyright	/^OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.$/;"	v
SOFTWARE	src/windows/shortproc.asm	/^; OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.$/;"	v
SP	src/base/elfcore.h	114;"	d
SP	src/base/elfcore.h	71;"	d
SP	src/base/elfcore.h	95;"	d
SPAN_HISTORY	src/span.h	56;"	d
SPECIAL	COPYING	/^SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT$/;"	v
SPECIAL	packages/deb/copyright	/^SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT$/;"	v
STACKSZ	benchmark/malloc_bench.cc	137;"	d	file:
STACKTRACE_INL_HEADER	src/stacktrace.cc	106;"	d	file:
STACKTRACE_INL_HEADER	src/stacktrace.cc	110;"	d	file:
STACKTRACE_INL_HEADER	src/stacktrace.cc	115;"	d	file:
STACKTRACE_INL_HEADER	src/stacktrace.cc	119;"	d	file:
STACKTRACE_INL_HEADER	src/stacktrace.cc	125;"	d	file:
STACKTRACE_INL_HEADER	src/stacktrace.cc	127;"	d	file:
STACKTRACE_INL_HEADER	src/stacktrace.cc	132;"	d	file:
STACKTRACE_INL_HEADER	src/stacktrace.cc	137;"	d	file:
STACKTRACE_INL_HEADER	src/stacktrace.cc	141;"	d	file:
STACKTRACE_INL_HEADER	src/stacktrace.cc	146;"	d	file:
STACKTRACE_INL_HEADER	src/stacktrace.cc	150;"	d	file:
STACKTRACE_INL_HEADER	src/stacktrace.cc	157;"	d	file:
STACKTRACE_INL_HEADER	src/stacktrace.cc	161;"	d	file:
STACKTRACE_INL_HEADER	src/stacktrace.cc	86;"	d	file:
STACKTRACE_INL_HEADER	src/stacktrace.cc	90;"	d	file:
STACKTRACE_INL_HEADER	src/stacktrace.cc	95;"	d	file:
STACKTRACE_INL_HEADER	src/stacktrace.cc	99;"	d	file:
STDC_HEADERS	src/config.h	275;"	d
STDC_HEADERS	src/config.h.in	274;"	d	file:
STDC_HEADERS	src/windows/config.h	284;"	d
STDERR_FILENO	src/windows/port.h	/^enum { STDIN_FILENO = 0, STDOUT_FILENO = 1, STDERR_FILENO = 2 };$/;"	e	enum:__anon17
STDIN_FILENO	src/windows/port.h	/^enum { STDIN_FILENO = 0, STDOUT_FILENO = 1, STDERR_FILENO = 2 };$/;"	e	enum:__anon17
STDOUT_FILENO	src/windows/port.h	/^enum { STDIN_FILENO = 0, STDOUT_FILENO = 1, STDERR_FILENO = 2 };$/;"	e	enum:__anon17
STL_Allocator	src/base/stl_allocator.h	/^  STL_Allocator() { }$/;"	f	class:STL_Allocator	access:public	signature:()
STL_Allocator	src/base/stl_allocator.h	/^  STL_Allocator(const STL_Allocator&) { }$/;"	f	class:STL_Allocator	access:public	signature:(const STL_Allocator&)
STL_Allocator	src/base/stl_allocator.h	/^  template <class T1> STL_Allocator(const STL_Allocator<T1, Alloc>&) { }$/;"	f	class:STL_Allocator	access:public	signature:(const STL_Allocator<T1, Alloc>&)
STL_Allocator	src/base/stl_allocator.h	/^class STL_Allocator {$/;"	c
STL_Allocator::STL_Allocator	src/base/stl_allocator.h	/^  STL_Allocator() { }$/;"	f	class:STL_Allocator	access:public	signature:()
STL_Allocator::STL_Allocator	src/base/stl_allocator.h	/^  STL_Allocator(const STL_Allocator&) { }$/;"	f	class:STL_Allocator	access:public	signature:(const STL_Allocator&)
STL_Allocator::STL_Allocator	src/base/stl_allocator.h	/^  template <class T1> STL_Allocator(const STL_Allocator<T1, Alloc>&) { }$/;"	f	class:STL_Allocator	access:public	signature:(const STL_Allocator<T1, Alloc>&)
STL_Allocator::address	src/base/stl_allocator.h	/^  const_pointer address(const_reference x) const { return &x; }$/;"	f	class:STL_Allocator	access:public	signature:(const_reference x) const
STL_Allocator::address	src/base/stl_allocator.h	/^  pointer address(reference x) const { return &x; }$/;"	f	class:STL_Allocator	access:public	signature:(reference x) const
STL_Allocator::allocate	src/base/stl_allocator.h	/^  pointer allocate(size_type n, const void* = 0) {$/;"	f	class:STL_Allocator	access:public	signature:(size_type n, const void* = 0)
STL_Allocator::const_pointer	src/base/stl_allocator.h	/^  typedef const T*   const_pointer;$/;"	t	class:STL_Allocator	access:public
STL_Allocator::const_reference	src/base/stl_allocator.h	/^  typedef const T&   const_reference;$/;"	t	class:STL_Allocator	access:public
STL_Allocator::construct	src/base/stl_allocator.h	/^  void construct(pointer p) { ::new(p) T(); }$/;"	f	class:STL_Allocator	access:public	signature:(pointer p)
STL_Allocator::construct	src/base/stl_allocator.h	/^  void construct(pointer p, const T& val) { ::new(p) T(val); }$/;"	f	class:STL_Allocator	access:public	signature:(pointer p, const T& val)
STL_Allocator::deallocate	src/base/stl_allocator.h	/^  void deallocate(pointer p, size_type n) { Alloc::Free(p, n * sizeof(T)); }$/;"	f	class:STL_Allocator	access:public	signature:(pointer p, size_type n)
STL_Allocator::destroy	src/base/stl_allocator.h	/^  void destroy(pointer p) { p->~T(); }$/;"	f	class:STL_Allocator	access:public	signature:(pointer p)
STL_Allocator::difference_type	src/base/stl_allocator.h	/^  typedef ptrdiff_t  difference_type;$/;"	t	class:STL_Allocator	access:public
STL_Allocator::max_size	src/base/stl_allocator.h	/^  size_type max_size() const { return size_t(-1) \/ sizeof(T); }$/;"	f	class:STL_Allocator	access:public	signature:() const
STL_Allocator::operator ==	src/base/stl_allocator.h	/^  bool operator==(const STL_Allocator&) const { return true; }$/;"	f	class:STL_Allocator	access:public	signature:(const STL_Allocator&) const
STL_Allocator::pointer	src/base/stl_allocator.h	/^  typedef T*         pointer;$/;"	t	class:STL_Allocator	access:public
STL_Allocator::rebind	src/base/stl_allocator.h	/^  template <class T1> struct rebind {$/;"	s	class:STL_Allocator	access:public
STL_Allocator::rebind::other	src/base/stl_allocator.h	/^    typedef STL_Allocator<T1, Alloc> other;$/;"	t	struct:STL_Allocator::rebind	access:public
STL_Allocator::reference	src/base/stl_allocator.h	/^  typedef T&         reference;$/;"	t	class:STL_Allocator	access:public
STL_Allocator::size_type	src/base/stl_allocator.h	/^  typedef size_t     size_type;$/;"	t	class:STL_Allocator	access:public
STL_Allocator::value_type	src/base/stl_allocator.h	/^  typedef T          value_type;$/;"	t	class:STL_Allocator	access:public
STL_Allocator::~STL_Allocator	src/base/stl_allocator.h	/^  ~STL_Allocator() { }$/;"	f	class:STL_Allocator	access:public	signature:()
STL_NAMESPACE	src/config.h	278;"	d
STL_NAMESPACE	src/config.h.in	277;"	d	file:
STL_NAMESPACE	src/windows/config.h	287;"	d
SUN_ARCH	config.guess	/^		SUN_ARCH="x86_64"$/;"	v
SYM	src/windows/nm-pdb.c	/^} SYM;$/;"	t	typeref:struct:__anon10	file:
SYMBOLIZE	src/gperftools/heap-checker.h	/^  enum ShouldSymbolize { SYMBOLIZE, DO_NOT_SYMBOLIZE };$/;"	e	enum:HeapLeakChecker::ShouldSymbolize
SYM_CONTEXT	src/windows/nm-pdb.c	/^} SYM_CONTEXT;$/;"	t	typeref:struct:__anon11	file:
SYS_CPLUSPLUS	src/base/linuxthreads.cc	157;"	d	file:
SYS_ERRNO	src/base/linuxthreads.cc	158;"	d	file:
SYS_INLINE	src/base/linuxthreads.cc	159;"	d	file:
SYS_LINUX_SYSCALL_SUPPORT_H	src/base/linux_syscall_support.h	131;"	d
SYS_LINUX_SYSCALL_SUPPORT_H	src/base/linuxthreads.cc	161;"	d	file:
SYS_PREFIX	src/base/linuxthreads.cc	160;"	d	file:
SameHeap	src/gperftools/heap-checker.h	/^  bool SameHeap()      { return NoLeaks(); }$/;"	f	class:HeapLeakChecker	access:public	signature:()
SampleAllocation	src/tests/sampler_test.cc	/^  bool SampleAllocation(size_t k);$/;"	p	class:OldSampler	file:	access:public	signature:(size_t k)
SampleAllocation	src/tests/sampler_test.cc	/^inline bool OldSampler::SampleAllocation(size_t k) {$/;"	f	class:OldSampler	signature:(size_t k)
SampleAllocation	src/thread_cache.h	/^  bool SampleAllocation(size_t k);$/;"	p	class:tcmalloc::ThreadCache	access:public	signature:(size_t k)
SampleAllocation	src/thread_cache.h	/^inline bool ThreadCache::SampleAllocation(size_t k) {$/;"	f	class:tcmalloc::ThreadCache	signature:(size_t k)
Sampler	src/sampler.h	/^class PERFTOOLS_DLL_DECL Sampler {$/;"	c	namespace:tcmalloc
Sat	packages/deb/copyright	/^on Sat, 20 Jul 2013 14:21:10 -0700.$/;"	v
SbrkHook	src/gperftools/malloc_hook.h	/^  typedef MallocHook_SbrkHook SbrkHook;$/;"	t	class:MallocHook	access:public
SbrkHook	src/heap-profiler.cc	/^static void SbrkHook(const void* result, ptrdiff_t increment) {$/;"	f	file:	signature:(const void* result, ptrdiff_t increment)
SbrkHook	src/memory_region_map.cc	/^void MemoryRegionMap::SbrkHook(const void* result, ptrdiff_t increment) {$/;"	f	class:MemoryRegionMap	signature:(const void* result, ptrdiff_t increment)
SbrkHook	src/memory_region_map.h	/^  static void SbrkHook(const void* result, ptrdiff_t increment);$/;"	p	class:MemoryRegionMap	access:private	signature:(const void* result, ptrdiff_t increment)
SbrkSysAllocator	src/system-alloc.cc	/^  SbrkSysAllocator() : SysAllocator() {$/;"	f	class:SbrkSysAllocator	access:public	signature:()
SbrkSysAllocator	src/system-alloc.cc	/^class SbrkSysAllocator : public SysAllocator {$/;"	c	file:	inherits:SysAllocator
SbrkSysAllocator::Alloc	src/system-alloc.cc	/^  void* Alloc(size_t size, size_t *actual_size, size_t alignment);$/;"	p	class:SbrkSysAllocator	file:	access:public	signature:(size_t size, size_t *actual_size, size_t alignment)
SbrkSysAllocator::Alloc	src/system-alloc.cc	/^void* SbrkSysAllocator::Alloc(size_t size, size_t *actual_size,$/;"	f	class:SbrkSysAllocator	signature:(size_t size, size_t *actual_size, size_t alignment)
SbrkSysAllocator::SbrkSysAllocator	src/system-alloc.cc	/^  SbrkSysAllocator() : SysAllocator() {$/;"	f	class:SbrkSysAllocator	access:public	signature:()
Scavenge	src/thread_cache.cc	/^void ThreadCache::Scavenge() {$/;"	f	class:tcmalloc::ThreadCache	signature:()
Scavenge	src/thread_cache.h	/^  void Scavenge();$/;"	p	class:tcmalloc::ThreadCache	access:public	signature:()
ScopedDisabledLeaks	src/tests/heap-checker_unittest.cc	/^static void ScopedDisabledLeaks() {$/;"	f	file:	signature:()
ScopedSignalBlocker	src/profile-handler.cc	/^  ScopedSignalBlocker(int signo) {$/;"	f	class:ScopedSignalBlocker	access:public	signature:(int signo)
ScopedSignalBlocker	src/profile-handler.cc	/^class ScopedSignalBlocker {$/;"	c	file:
ScopedSignalBlocker::ScopedSignalBlocker	src/profile-handler.cc	/^  ScopedSignalBlocker(int signo) {$/;"	f	class:ScopedSignalBlocker	access:public	signature:(int signo)
ScopedSignalBlocker::sig_set_	src/profile-handler.cc	/^  sigset_t sig_set_;$/;"	m	class:ScopedSignalBlocker	file:	access:private
ScopedSignalBlocker::~ScopedSignalBlocker	src/profile-handler.cc	/^  ~ScopedSignalBlocker() {$/;"	f	class:ScopedSignalBlocker	access:public	signature:()
SearchFreeAndLargeLists	src/page_heap.cc	/^Span* PageHeap::SearchFreeAndLargeLists(Length n) {$/;"	f	class:tcmalloc::PageHeap	signature:(Length n)
SearchFreeAndLargeLists	src/page_heap.h	/^  Span* SearchFreeAndLargeLists(Length n);$/;"	p	class:tcmalloc::PageHeap	access:private	signature:(Length n)
SetAggressiveDecommit	src/page_heap.h	/^  void SetAggressiveDecommit(bool aggressive_decommit) {$/;"	f	class:tcmalloc::PageHeap	access:public	signature:(bool aggressive_decommit)
SetBase	src/base/vdso_support.cc	/^const void *VDSOSupport::SetBase(const void *base) {$/;"	f	class:base::VDSOSupport	signature:(const void *base)
SetBase	src/base/vdso_support.h	/^  const void *SetBase(const void *s);$/;"	p	class:base::VDSOSupport	access:public	signature:(const void *s)
SetCachedSizeClass	src/page_heap.h	/^  void SetCachedSizeClass(PageID p, uint32 cl) {$/;"	f	class:tcmalloc::PageHeap	access:public	signature:(PageID p, uint32 cl)
SetCheckCallback	src/tests/addressmap_unittest.cc	/^static void SetCheckCallback(const void* ptr, ValueT* val,$/;"	f	file:	signature:(const void* ptr, ValueT* val, set<pair<const void*, int> >* check_set)
SetChildAllocator	src/system-alloc.cc	/^  void SetChildAllocator(SysAllocator* alloc, unsigned int index,$/;"	f	class:DefaultSysAllocator	access:public	signature:(SysAllocator* alloc, unsigned int index, const char* name)
SetDeleteHook	src/gperftools/malloc_hook.h	/^  inline static DeleteHook SetDeleteHook(DeleteHook hook) {$/;"	f	class:MallocHook	access:public	signature:(DeleteHook hook)
SetIsSafe	src/base/simple_mutex.h	/^  inline void SetIsSafe() { is_safe_ = true; }$/;"	f	class:MUTEX_NAMESPACE::Mutex	access:private	signature:()
SetJoinable	src/tests/profile-handler_unittest.cc	/^  void SetJoinable(bool value) { joinable_ = value; }$/;"	f	class:__anon56::Thread	access:public	signature:(bool value)
SetMaxSize	src/thread_cache.h	/^  void SetMaxSize(int32 new_max_size);$/;"	p	class:tcmalloc::ThreadCache	access:private	signature:(int32 new_max_size)
SetMaxSize	src/thread_cache.h	/^inline void ThreadCache::SetMaxSize(int32 new_max_size) {$/;"	f	class:tcmalloc::ThreadCache	signature:(int32 new_max_size)
SetMemoryReleaseRate	src/gperftools/malloc_extension.h	/^  virtual void SetMemoryReleaseRate(double rate);$/;"	p	class:MallocExtension	access:public	signature:(double rate)
SetMemoryReleaseRate	src/malloc_extension.cc	/^void MallocExtension::SetMemoryReleaseRate(double rate) {$/;"	f	class:MallocExtension	signature:(double rate)
SetMemoryReleaseRate	src/tcmalloc.cc	/^  virtual void SetMemoryReleaseRate(double rate) {$/;"	f	class:TCMallocImplementation	access:public	signature:(double rate)
SetMmapHook	src/gperftools/malloc_hook.h	/^  inline static MmapHook SetMmapHook(MmapHook hook) {$/;"	f	class:MallocHook	access:public	signature:(MmapHook hook)
SetMmapReplacement	src/gperftools/malloc_hook.h	/^  inline static bool SetMmapReplacement(MmapReplacement hook) {$/;"	f	class:MallocHook	access:public	signature:(MmapReplacement hook)
SetMremapHook	src/gperftools/malloc_hook.h	/^  inline static MremapHook SetMremapHook(MremapHook hook) {$/;"	f	class:MallocHook	access:public	signature:(MremapHook hook)
SetMunmapHook	src/gperftools/malloc_hook.h	/^  inline static MunmapHook SetMunmapHook(MunmapHook hook) {$/;"	f	class:MallocHook	access:public	signature:(MunmapHook hook)
SetMunmapReplacement	src/gperftools/malloc_hook.h	/^  inline static bool SetMunmapReplacement(MunmapReplacement hook) {$/;"	f	class:MallocHook	access:public	signature:(MunmapReplacement hook)
SetNewHook	src/gperftools/malloc_hook.h	/^  inline static NewHook SetNewHook(NewHook hook) {$/;"	f	class:MallocHook	access:public	signature:(NewHook hook)
SetNumericProperty	docs/tcmalloc.html	/^   MallocExtension::instance()->SetNumericProperty(property_name, value);$/;"	p	class:object::structure	file:	access:private	signature:(property_name, value)
SetNumericProperty	src/gperftools/malloc_extension.h	/^  virtual bool SetNumericProperty(const char* property, size_t value);$/;"	p	class:MallocExtension	access:public	signature:(const char* property, size_t value)
SetNumericProperty	src/malloc_extension.cc	/^bool MallocExtension::SetNumericProperty(const char* property, size_t value) {$/;"	f	class:MallocExtension	signature:(const char* property, size_t value)
SetNumericProperty	src/tcmalloc.cc	/^  virtual bool SetNumericProperty(const char* name, size_t value) {$/;"	f	class:TCMallocImplementation	access:public	signature:(const char* name, size_t value)
SetPreMmapHook	src/gperftools/malloc_hook.h	/^  inline static PreMmapHook SetPreMmapHook(PreMmapHook hook) {$/;"	f	class:MallocHook	access:public	signature:(PreMmapHook hook)
SetPreSbrkHook	src/gperftools/malloc_hook.h	/^  inline static PreSbrkHook SetPreSbrkHook(PreSbrkHook hook) {$/;"	f	class:MallocHook	access:public	signature:(PreSbrkHook hook)
SetRegionSetKey	src/memory_region_map.h	/^    void SetRegionSetKey(uintptr_t addr) {$/;"	f	struct:MemoryRegionMap::Region	access:private	signature:(uintptr_t addr)
SetSbrkHook	src/gperftools/malloc_hook.h	/^  inline static SbrkHook SetSbrkHook(SbrkHook hook) {$/;"	f	class:MallocHook	access:public	signature:(SbrkHook hook)
SetSystemAllocator	src/gperftools/malloc_extension.h	/^  virtual void SetSystemAllocator(SysAllocator *a);$/;"	p	class:MallocExtension	access:public	signature:(SysAllocator *a)
SetSystemAllocator	src/malloc_extension.cc	/^void MallocExtension::SetSystemAllocator(SysAllocator *a) {$/;"	f	class:MallocExtension	signature:(SysAllocator *a)
SetSystemAllocator	src/tcmalloc.cc	/^  virtual void SetSystemAllocator(SysAllocator* alloc) {$/;"	f	class:TCMallocImplementation	access:public	signature:(SysAllocator* alloc)
SetTestResourceLimit	src/tests/testutil.cc	/^void SetTestResourceLimit() {$/;"	f	signature:()
SetTestResourceLimit	src/tests/testutil.h	/^void SetTestResourceLimit();$/;"	p	signature:()
SetUp	src/tests/profile-handler_unittest.cc	/^  virtual void SetUp() {$/;"	f	class:__anon56::ProfileHandlerTest	access:protected	signature:()
SetUpTestCase	src/tests/profile-handler_unittest.cc	/^  static void SetUpTestCase() {$/;"	f	class:__anon56::ProfileHandlerTest	access:protected	signature:()
SetUseEmergencyMalloc	src/thread_cache.h	/^  static void         SetUseEmergencyMalloc();$/;"	p	class:tcmalloc::ThreadCache	access:public	signature:()
SetUseEmergencyMalloc	src/thread_cache.h	/^inline void ThreadCache::SetUseEmergencyMalloc() {$/;"	f	class:tcmalloc::ThreadCache	signature:()
ShouldSymbolize	src/gperftools/heap-checker.h	/^  enum ShouldSymbolize { SYMBOLIZE, DO_NOT_SYMBOLIZE };$/;"	g	class:HeapLeakChecker	access:private
ShowSymbolInfo	src/windows/nm-pdb.c	/^static void ShowSymbolInfo(HANDLE process, ULONG64 module_base) {$/;"	f	file:	signature:(HANDLE process, ULONG64 module_base)
ShrinkHeap	src/tests/tcmalloc_unittest.cc	/^  void ShrinkHeap() {$/;"	f	class:testing::TesterThread	access:public	signature:()
Shutdown	src/heap-checker.cc	/^  static void Shutdown() {$/;"	f	class:HeapLeakChecker::Allocator	access:public	signature:()
Shutdown	src/memory_region_map.cc	/^bool MemoryRegionMap::Shutdown() {$/;"	f	class:MemoryRegionMap	signature:()
Shutdown	src/memory_region_map.h	/^  static bool Shutdown();$/;"	p	class:MemoryRegionMap	access:public	signature:()
SideStepError	src/windows/preamble_patcher.h	/^enum SideStepError {$/;"	g	namespace:sidestep
SignalHandler	src/base/linuxthreads.cc	/^static void SignalHandler(int signum, siginfo_t *si, void *data) {$/;"	f	file:	signature:(int signum, siginfo_t *si, void *data)
SignalHandler	src/profile-handler.cc	/^  static void SignalHandler(int sig, siginfo_t* sinfo, void* ucontext);$/;"	p	class:ProfileHandler	file:	access:private	signature:(int sig, siginfo_t* sinfo, void* ucontext)
SignalHandler	src/profile-handler.cc	/^void ProfileHandler::SignalHandler(int sig, siginfo_t* sinfo, void* ucontext) {$/;"	f	class:ProfileHandler	signature:(int sig, siginfo_t* sinfo, void* ucontext)
Size	src/malloc_extension.cc	/^uintptr_t Size(void** entry) {$/;"	f	namespace:__anon21	signature:(void** entry)
Size	src/thread_cache.h	/^  size_t Size() const { return size_; }$/;"	f	class:tcmalloc::ThreadCache	access:public	signature:() const
SizeClass	src/common.h	/^  inline int SizeClass(size_t size) {$/;"	f	class:tcmalloc::SizeMap	access:public	signature:(size_t size)
SizeFunc	src/tests/addressmap_unittest.cc	/^size_t SizeFunc(const ValueT& v) { return v.second; }$/;"	f	signature:(const ValueT& v)
SizeMap	src/common.h	/^  SizeMap() { }$/;"	f	class:tcmalloc::SizeMap	access:public	signature:()
SizeMap	src/common.h	/^class SizeMap {$/;"	c	namespace:tcmalloc
Skewed	src/tests/tcmalloc_unittest.cc	/^  int Skewed(int max_log) {$/;"	f	class:testing::TestHarness	access:public	signature:(int max_log)
SkipWhileWhitespace	src/base/sysinfo.cc	/^static void SkipWhileWhitespace(char **text_pointer, int c) {$/;"	f	file:	signature:(char **text_pointer, int c)
Sleep	src/tests/malloc_hook_test.cc	/^void Sleep(int seconds) {$/;"	f	namespace:__anon57	signature:(int seconds)
SleepForMilliseconds	src/base/sysinfo.cc	/^void SleepForMilliseconds(int milliseconds) {$/;"	f	signature:(int milliseconds)
SleepForMilliseconds	src/base/sysinfo.h	/^void SleepForMilliseconds(int milliseconds);$/;"	p	signature:(int milliseconds)
Slot	src/profiledata.h	/^  typedef uintptr_t Slot;$/;"	t	class:ProfileData	access:private
SlowLock	src/base/spinlock.cc	/^void SpinLock::SlowLock() {$/;"	f	class:SpinLock	signature:()
SlowLock	src/base/spinlock.h	/^  void SlowLock();$/;"	p	class:SpinLock	access:private	signature:()
SlowUnlock	src/base/spinlock.cc	/^void SpinLock::SlowUnlock() {$/;"	f	class:SpinLock	signature:()
SlowUnlock	src/base/spinlock.h	/^  void SlowUnlock();$/;"	p	class:SpinLock	access:private	signature:()
SmallSizeClass	src/common.h	/^  static inline size_t SmallSizeClass(size_t s) {$/;"	f	class:tcmalloc::SizeMap	access:private	signature:(size_t s)
SmallSpanStats	src/page_heap.h	/^  struct SmallSpanStats {$/;"	s	class:tcmalloc::PageHeap	access:public
Snapshot	src/heap-profile-table.h	/^  Snapshot(Allocator alloc, DeAllocator dealloc) : map_(alloc, dealloc) {$/;"	f	class:HeapProfileTable::Snapshot	access:private	signature:(Allocator alloc, DeAllocator dealloc)
Snapshot	src/heap-profile-table.h	/^class HeapProfileTable::Snapshot {$/;"	c	class:HeapProfileTable
Span	src/span.h	/^struct Span {$/;"	s	namespace:tcmalloc
SpanList	src/page_heap.h	/^  struct SpanList {$/;"	s	class:tcmalloc::PageHeap	access:private
SpanToMallocResult	src/tcmalloc.cc	/^static inline ATTRIBUTE_ALWAYS_INLINE void* SpanToMallocResult(Span *span) {$/;"	f	file:	signature:(Span *span)
SpecificOpcode	src/windows/mini_disassembler_types.h	/^struct SpecificOpcode {$/;"	s	namespace:sidestep
SpinLock	src/base/spinlock.h	/^  SpinLock() : lockword_(kSpinLockFree) { }$/;"	f	class:SpinLock	access:public	signature:()
SpinLock	src/base/spinlock.h	/^  explicit SpinLock(base::LinkerInitialized \/*x*\/) {$/;"	f	class:SpinLock	access:public	signature:(base::LinkerInitialized )
SpinLock	src/base/spinlock.h	/^class LOCKABLE SpinLock {$/;"	c
SpinLock::DISALLOW_COPY_AND_ASSIGN	src/base/spinlock.h	/^  DISALLOW_COPY_AND_ASSIGN(SpinLock);$/;"	p	class:SpinLock	access:private	signature:(SpinLock)
SpinLock::EXCLUSIVE_TRYLOCK_FUNCTION	src/base/spinlock.h	/^  inline bool TryLock() EXCLUSIVE_TRYLOCK_FUNCTION(true) {$/;"	f	class:SpinLock	access:public	signature:(true)
SpinLock::IsHeld	src/base/spinlock.h	/^  inline bool IsHeld() const {$/;"	f	class:SpinLock	access:public	signature:() const
SpinLock::LINKER_INITIALIZED	src/base/spinlock.cc	/^const base::LinkerInitialized SpinLock::LINKER_INITIALIZED =$/;"	m	class:SpinLock	file:
SpinLock::LINKER_INITIALIZED	src/base/spinlock.h	/^  static const base::LinkerInitialized LINKER_INITIALIZED;  \/\/ backwards compat$/;"	m	class:SpinLock	access:public
SpinLock::Lock	src/base/spinlock.h	/^  inline void Lock() \/*EXCLUSIVE_LOCK_FUNCTION()*\/ {$/;"	f	class:SpinLock	access:public	signature:()
SpinLock::SlowLock	src/base/spinlock.cc	/^void SpinLock::SlowLock() {$/;"	f	class:SpinLock	signature:()
SpinLock::SlowLock	src/base/spinlock.h	/^  void SlowLock();$/;"	p	class:SpinLock	access:private	signature:()
SpinLock::SlowUnlock	src/base/spinlock.cc	/^void SpinLock::SlowUnlock() {$/;"	f	class:SpinLock	signature:()
SpinLock::SlowUnlock	src/base/spinlock.h	/^  void SlowUnlock();$/;"	p	class:SpinLock	access:private	signature:()
SpinLock::SpinLock	src/base/spinlock.h	/^  SpinLock() : lockword_(kSpinLockFree) { }$/;"	f	class:SpinLock	access:public	signature:()
SpinLock::SpinLock	src/base/spinlock.h	/^  explicit SpinLock(base::LinkerInitialized \/*x*\/) {$/;"	f	class:SpinLock	access:public	signature:(base::LinkerInitialized )
SpinLock::SpinLoop	src/base/spinlock.cc	/^Atomic32 SpinLock::SpinLoop() {$/;"	f	class:SpinLock	signature:()
SpinLock::SpinLoop	src/base/spinlock.h	/^  Atomic32 SpinLoop();$/;"	p	class:SpinLock	access:private	signature:()
SpinLock::Unlock	src/base/spinlock.h	/^  inline void Unlock() \/*UNLOCK_FUNCTION()*\/ {$/;"	f	class:SpinLock	access:public	signature:()
SpinLock::kSpinLockFree	src/base/spinlock.h	/^  enum { kSpinLockFree = 0 };$/;"	e	enum:SpinLock::__anon41
SpinLock::kSpinLockHeld	src/base/spinlock.h	/^  enum { kSpinLockHeld = 1 };$/;"	e	enum:SpinLock::__anon42
SpinLock::kSpinLockSleeper	src/base/spinlock.h	/^  enum { kSpinLockSleeper = 2 };$/;"	e	enum:SpinLock::__anon43
SpinLock::lockword_	src/base/spinlock.h	/^  volatile Atomic32 lockword_;$/;"	m	class:SpinLock	access:private
SpinLockDelay	src/base/spinlock_internal.h	/^void SpinLockDelay(volatile Atomic32 *w, int32 value, int loop);$/;"	p	namespace:base::internal	signature:(volatile Atomic32 *w, int32 value, int loop)
SpinLockDelay	src/base/spinlock_linux-inl.h	/^void SpinLockDelay(volatile Atomic32 *w, int32 value, int loop) {$/;"	f	namespace:base::internal	signature:(volatile Atomic32 *w, int32 value, int loop)
SpinLockDelay	src/base/spinlock_posix-inl.h	/^void SpinLockDelay(volatile Atomic32 *w, int32 value, int loop) {$/;"	f	namespace:base::internal	signature:(volatile Atomic32 *w, int32 value, int loop)
SpinLockDelay	src/base/spinlock_win32-inl.h	/^void SpinLockDelay(volatile Atomic32 *w, int32 value, int loop) {$/;"	f	namespace:base::internal	signature:(volatile Atomic32 *w, int32 value, int loop)
SpinLockHolder	src/base/spinlock.h	/^class SCOPED_LOCKABLE SpinLockHolder {$/;"	c
SpinLockHolder	src/base/spinlock.h	140;"	d
SpinLockHolder::EXCLUSIVE_LOCK_FUNCTION	src/base/spinlock.h	/^  inline explicit SpinLockHolder(SpinLock* l) EXCLUSIVE_LOCK_FUNCTION(l)$/;"	f	class:SpinLockHolder	access:public	signature:(l)
SpinLockHolder::lock_	src/base/spinlock.h	/^  SpinLock* lock_;$/;"	m	class:SpinLockHolder	access:private
SpinLockHolder::~SpinLockHolder	src/base/spinlock.h	/^  inline ~SpinLockHolder() \/*UNLOCK_FUNCTION()*\/ { lock_->Unlock(); }$/;"	f	class:SpinLockHolder	access:public	signature:()
SpinLockWake	src/base/spinlock_internal.h	/^void SpinLockWake(volatile Atomic32 *w, bool all);$/;"	p	namespace:base::internal	signature:(volatile Atomic32 *w, bool all)
SpinLockWake	src/base/spinlock_linux-inl.h	/^void SpinLockWake(volatile Atomic32 *w, bool all) {$/;"	f	namespace:base::internal	signature:(volatile Atomic32 *w, bool all)
SpinLockWake	src/base/spinlock_posix-inl.h	/^void SpinLockWake(volatile Atomic32 *w, bool all) {$/;"	f	namespace:base::internal	signature:(volatile Atomic32 *w, bool all)
SpinLockWake	src/base/spinlock_win32-inl.h	/^void SpinLockWake(volatile Atomic32 *w, bool all) {$/;"	f	namespace:base::internal	signature:(volatile Atomic32 *w, bool all)
SpinLock_InitHelper	src/base/spinlock.cc	/^  SpinLock_InitHelper() {$/;"	f	struct:__anon37::SpinLock_InitHelper	access:public	signature:()
SpinLock_InitHelper	src/base/spinlock.cc	/^struct SpinLock_InitHelper {$/;"	s	namespace:__anon37	file:
SpinLoop	src/base/spinlock.cc	/^Atomic32 SpinLock::SpinLoop() {$/;"	f	class:SpinLock	signature:()
SpinLoop	src/base/spinlock.h	/^  Atomic32 SpinLoop();$/;"	p	class:SpinLock	access:private	signature:()
SpinlockPause	src/base/spinlock.cc	/^inline void SpinlockPause(void) {$/;"	f	namespace:__anon37	signature:(void)
Split	src/page_heap.cc	/^Span* PageHeap::Split(Span* span, Length n) {$/;"	f	class:tcmalloc::PageHeap	signature:(Span* span, Length n)
Split	src/page_heap.h	/^  Span* Split(Span* span, Length n);$/;"	p	class:tcmalloc::PageHeap	access:public	signature:(Span* span, Length n)
StackDirection	src/heap-checker.cc	/^enum StackDirection {$/;"	g	file:
StackTopSet	src/heap-checker.cc	/^           > StackTopSet;$/;"	t	file:
StackTrace	src/common.h	/^struct StackTrace {$/;"	s	namespace:tcmalloc
StackTraceTable	src/stack_trace_table.cc	/^StackTraceTable::StackTraceTable()$/;"	f	class:tcmalloc::StackTraceTable	signature:()
StackTraceTable	src/stack_trace_table.h	/^  StackTraceTable();$/;"	p	class:tcmalloc::StackTraceTable	access:public	signature:()
StackTraceTable	src/stack_trace_table.h	/^class PERFTOOLS_DLL_DECL StackTraceTable {$/;"	c	namespace:tcmalloc
StacktraceArmDummyFunction	src/stacktrace_arm-inl.h	/^void StacktraceArmDummyFunction() __attribute__((noinline));$/;"	p	signature:()
StacktraceArmDummyFunction	src/stacktrace_arm-inl.h	/^void StacktraceArmDummyFunction() { __asm__ volatile(""); }$/;"	f	signature:()
StacktracePowerPCDummyFunction	src/stacktrace_powerpc-darwin-inl.h	/^void StacktracePowerPCDummyFunction() __attribute__((noinline));$/;"	p	signature:()
StacktracePowerPCDummyFunction	src/stacktrace_powerpc-darwin-inl.h	/^void StacktracePowerPCDummyFunction() { __asm__ volatile(""); }$/;"	f	signature:()
StacktracePowerPCDummyFunction	src/stacktrace_powerpc-inl.h	/^void StacktracePowerPCDummyFunction() __attribute__((noinline));$/;"	p	signature:()
StacktracePowerPCDummyFunction	src/stacktrace_powerpc-inl.h	/^void StacktracePowerPCDummyFunction() { __asm__ volatile(""); }$/;"	f	signature:()
StacktracePowerPCDummyFunction	src/stacktrace_powerpc-linux-inl.h	/^void StacktracePowerPCDummyFunction() __attribute__((noinline));$/;"	p	signature:()
StacktracePowerPCDummyFunction	src/stacktrace_powerpc-linux-inl.h	/^void StacktracePowerPCDummyFunction() { __asm__ volatile(""); }$/;"	f	signature:()
StacktraceScope	src/stacktrace.cc	/^    StacktraceScope() {$/;"	f	class:__anon20::StacktraceScope	access:public	signature:()
StacktraceScope	src/stacktrace.cc	/^  class StacktraceScope {$/;"	c	namespace:__anon20	file:
StandardDeviationsErrorInSample	src/tests/sampler_test.cc	/^double StandardDeviationsErrorInSample($/;"	f	signature:( int total_samples, int picked_samples, int alloc_size, int sampling_interval)
Start	src/profiledata.cc	/^bool ProfileData::Start(const char* fname,$/;"	f	class:ProfileData	signature:(const char* fname, const ProfileData::Options& options)
Start	src/profiledata.h	/^  bool Start(const char *fname, const Options& options);$/;"	p	class:ProfileData	access:public	signature:(const char *fname, const Options& options)
Start	src/profiler.cc	/^  bool Start(const char* fname, const ProfilerOptions* options);$/;"	p	class:CpuProfiler	file:	access:public	signature:(const char* fname, const ProfilerOptions* options)
Start	src/profiler.cc	/^bool CpuProfiler::Start(const char* fname, const ProfilerOptions* options) {$/;"	f	class:CpuProfiler	signature:(const char* fname, const ProfilerOptions* options)
Start	src/tests/profile-handler_unittest.cc	/^  void Start() {$/;"	f	class:__anon56::Thread	access:public	signature:()
StartLinuxThreadTimer	src/profile-handler.cc	/^static void StartLinuxThreadTimer(int timer_type, int signal_number,$/;"	f	file:	signature:(int timer_type, int signal_number, int32 frequency, pthread_key_t timer_key)
StartResetRestart	src/tests/profiledata_unittest.cc	/^  void StartResetRestart();$/;"	p	class:__anon53::ProfileDataTest	file:	access:private	signature:()
StartStopEmpty	src/tests/profiledata_unittest.cc	/^  void StartStopEmpty();$/;"	p	class:__anon53::ProfileDataTest	file:	access:private	signature:()
StartStopEmpty2	src/tests/profiledata_unittest.cc	/^  void StartStopEmpty2();$/;"	p	class:__anon53::ProfileDataTest	file:	access:private	signature:()
StartStopNoOptionsEmpty	src/tests/profiledata_unittest.cc	/^  void StartStopNoOptionsEmpty();$/;"	p	class:__anon53::ProfileDataTest	file:	access:private	signature:()
StartWhenStarted	src/tests/profiledata_unittest.cc	/^  void StartWhenStarted();$/;"	p	class:__anon53::ProfileDataTest	file:	access:private	signature:()
StartWorker	src/tests/profile-handler_unittest.cc	/^  void StartWorker() {$/;"	f	class:__anon56::ProfileHandlerTest	access:protected	signature:()
State	src/profiledata.h	/^  struct State {$/;"	s	class:ProfileData	access:public
Static	src/static_vars.h	/^class Static {$/;"	c	namespace:tcmalloc
Stats	src/heap-profile-table.h	/^  typedef HeapProfileStats Stats;$/;"	t	class:HeapProfileTable	access:public
Stats	src/page_heap.h	/^    Stats() : system_bytes(0), free_bytes(0), unmapped_bytes(0), committed_bytes(0),$/;"	f	struct:tcmalloc::PageHeap::Stats	access:public	signature:()
Stats	src/page_heap.h	/^  struct Stats {$/;"	s	class:tcmalloc::PageHeap	access:public
StatsCallback	src/debugallocation.cc	/^  static void StatsCallback(const void* ptr, int* type, int dummy) {$/;"	f	class:MallocBlock	file:	access:private	signature:(const void* ptr, int* type, int dummy)
Stop	src/profiledata.cc	/^void ProfileData::Stop() {$/;"	f	class:ProfileData	signature:()
Stop	src/profiledata.h	/^  void Stop();$/;"	p	class:ProfileData	access:public	signature:()
Stop	src/profiler.cc	/^  void Stop();$/;"	p	class:CpuProfiler	file:	access:public	signature:()
Stop	src/profiler.cc	/^void CpuProfiler::Stop() {$/;"	f	class:CpuProfiler	signature:()
StopWorker	src/tests/profile-handler_unittest.cc	/^  void StopWorker() {$/;"	f	class:__anon56::ProfileHandlerTest	access:protected	signature:()
StringPrintf	src/tests/sampler_test.cc	/^static std::string StringPrintf(const char* format, ...) {$/;"	f	file:	signature:(const char* format, ...)
StringToBool	src/base/commandlineflags.h	/^    inline bool StringToBool(const char *value, bool def) {$/;"	f	namespace:tcmalloc::commandlineflags	signature:(const char *value, bool def)
StringToDouble	src/base/commandlineflags.h	/^    inline double StringToDouble(const char *value, double def) {$/;"	f	namespace:tcmalloc::commandlineflags	signature:(const char *value, double def)
StringToInt	src/base/commandlineflags.h	/^    inline int StringToInt(const char *value, int def) {$/;"	f	namespace:tcmalloc::commandlineflags	signature:(const char *value, int def)
StringToInteger	src/base/sysinfo.cc	/^int StringToInteger<int>(char *text, char **endptr, int base) {$/;"	f	signature:(char *text, char **endptr, int base)
StringToInteger	src/base/sysinfo.cc	/^int64 StringToInteger<int64>(char *text, char **endptr, int base) {$/;"	f	signature:(char *text, char **endptr, int base)
StringToInteger	src/base/sysinfo.cc	/^static T StringToInteger(char *text, char **endptr, int base) {$/;"	f	file:	signature:(char *text, char **endptr, int base)
StringToInteger	src/base/sysinfo.cc	/^uint64 StringToInteger<uint64>(char *text, char **endptr, int base) {$/;"	f	signature:(char *text, char **endptr, int base)
StringToIntegerUntilChar	src/base/sysinfo.cc	/^static T StringToIntegerUntilChar($/;"	f	file:	signature:( char *text, int base, int c, char **endptr_result)
StringToIntegerUntilCharWithCheck	src/base/sysinfo.cc	/^static bool StringToIntegerUntilCharWithCheck($/;"	f	file:	signature:( T *outptr, char *text, int base, int c, char **endptr)
StringToLongLong	src/base/commandlineflags.h	/^    inline long long StringToLongLong(const char *value, long long def) {$/;"	f	namespace:tcmalloc::commandlineflags	signature:(const char *value, long long def)
SuggestPprofCommand	src/heap-checker.cc	/^static void SuggestPprofCommand(const char* pprof_file_arg) {$/;"	f	file:	signature:(const char* pprof_file_arg)
SuggestedDelayNS	src/base/spinlock_internal.cc	/^namespace base { namespace internal { static int SuggestedDelayNS(int loop); }}$/;"	p	namespace:base::internal	file:	signature:(int loop)
SuggestedDelayNS	src/base/spinlock_internal.cc	/^static int SuggestedDelayNS(int loop) {$/;"	f	namespace:base::internal	signature:(int loop)
SymbolInfo	src/base/elf_mem_image.h	/^  struct SymbolInfo {$/;"	s	class:base::ElfMemImage	access:public
SymbolInfo	src/base/vdso_support.h	/^  typedef ElfMemImage::SymbolInfo SymbolInfo;$/;"	t	class:base::VDSOSupport	access:public
SymbolIterator	src/base/elf_mem_image.cc	/^ElfMemImage::SymbolIterator::SymbolIterator(const void *const image, int index)$/;"	f	class:base::ElfMemImage::SymbolIterator	signature:(const void *const image, int index)
SymbolIterator	src/base/elf_mem_image.h	/^    SymbolIterator(const void *const image, int index);$/;"	p	class:base::ElfMemImage::SymbolIterator	access:private	signature:(const void *const image, int index)
SymbolIterator	src/base/elf_mem_image.h	/^  class SymbolIterator {$/;"	c	class:base::ElfMemImage	access:public
SymbolIterator	src/base/vdso_support.h	/^  typedef ElfMemImage::SymbolIterator SymbolIterator;$/;"	t	class:base::VDSOSupport	access:public
SymbolMap	src/symbolize.h	/^  typedef map<const void*, const char*> SymbolMap;$/;"	t	class:SymbolTable	access:private
SymbolTable	src/symbolize.h	/^  SymbolTable()$/;"	f	class:SymbolTable	access:public	signature:()
SymbolTable	src/symbolize.h	/^class SymbolTable {$/;"	c
SymbolTable::Add	src/symbolize.cc	/^void SymbolTable::Add(const void* addr) {$/;"	f	class:SymbolTable	signature:(const void* addr)
SymbolTable::Add	src/symbolize.h	/^  void Add(const void* addr);$/;"	p	class:SymbolTable	access:public	signature:(const void* addr)
SymbolTable::GetSymbol	src/symbolize.cc	/^const char* SymbolTable::GetSymbol(const void* addr) {$/;"	f	class:SymbolTable	signature:(const void* addr)
SymbolTable::GetSymbol	src/symbolize.h	/^  const char* GetSymbol(const void* addr);$/;"	p	class:SymbolTable	access:public	signature:(const void* addr)
SymbolTable::SymbolMap	src/symbolize.h	/^  typedef map<const void*, const char*> SymbolMap;$/;"	t	class:SymbolTable	access:private
SymbolTable::SymbolTable	src/symbolize.h	/^  SymbolTable()$/;"	f	class:SymbolTable	access:public	signature:()
SymbolTable::Symbolize	src/symbolize.cc	/^int SymbolTable::Symbolize() {$/;"	f	class:SymbolTable	signature:()
SymbolTable::Symbolize	src/symbolize.h	/^  int Symbolize();$/;"	p	class:SymbolTable	access:public	signature:()
SymbolTable::kSymbolSize	src/symbolize.h	/^  static const int kSymbolSize = 1024;$/;"	m	class:SymbolTable	access:private
SymbolTable::symbol_buffer_	src/symbolize.h	/^  char *symbol_buffer_;$/;"	m	class:SymbolTable	access:private
SymbolTable::symbolization_table_	src/symbolize.h	/^  SymbolMap symbolization_table_;$/;"	m	class:SymbolTable	access:private
SymbolTable::~SymbolTable	src/symbolize.h	/^  ~SymbolTable() {$/;"	f	class:SymbolTable	access:public	signature:()
Symbolize	src/symbolize.cc	/^int SymbolTable::Symbolize() {$/;"	f	class:SymbolTable	signature:()
Symbolize	src/symbolize.h	/^  int Symbolize();$/;"	p	class:SymbolTable	access:public	signature:()
SysAllocator	src/gperftools/malloc_extension.h	/^  SysAllocator() {$/;"	f	class:SysAllocator	access:public	signature:()
SysAllocator	src/gperftools/malloc_extension.h	/^class PERFTOOLS_DLL_DECL SysAllocator {$/;"	c
SysAllocator::Alloc	src/gperftools/malloc_extension.h	/^  virtual void* Alloc(size_t size, size_t *actual_size, size_t alignment) = 0;$/;"	p	class:SysAllocator	access:public	signature:(size_t size, size_t *actual_size, size_t alignment)
SysAllocator::SysAllocator	src/gperftools/malloc_extension.h	/^  SysAllocator() {$/;"	f	class:SysAllocator	access:public	signature:()
SysAllocator::~SysAllocator	src/gperftools/malloc_extension.h	/^  virtual ~SysAllocator();$/;"	p	class:SysAllocator	access:public	signature:()
SysAllocator::~SysAllocator	src/malloc_extension.cc	/^SysAllocator::~SysAllocator() {}$/;"	f	class:SysAllocator	signature:()
SysCalls	src/base/linuxthreads.cc	/^    SysCalls() : my_errno(0) { }$/;"	f	class:__anon36::SysCalls	access:public	signature:()
SysCalls	src/base/linuxthreads.cc	/^  class SysCalls {$/;"	c	namespace:__anon36	file:
T	m4/libtool.m4	/^      if sort "$nlist" | uniq > "$nlist"T; then$/;"	v
T	src/packed-cache-inl.h	/^  typedef uintptr_t T;$/;"	t	class:PackedCache	access:public
T	src/tests/packed_cache_test-packed-cache_test.o	/^/;"	v
TARGET_NSEC	benchmark/run_benchmark.c	72;"	d	file:
TCEntry	src/central_freelist.h	/^  struct TCEntry {$/;"	s	class:tcmalloc::CentralFreeList	access:private
TCMALLOC_32K_PAGES	src/config.h.in	280;"	d	file:
TCMALLOC_64K_PAGES	src/config.h.in	283;"	d	file:
TCMALLOC_ALIGN_8BYTES	src/config.h.in	286;"	d	file:
TCMALLOC_CENTRAL_FREELIST_H_	src/central_freelist.h	35;"	d
TCMALLOC_COMMON_H_	src/common.h	37;"	d
TCMALLOC_DONT_PREFER_LIBUNWIND	src/stacktrace.cc	197;"	d	file:
TCMALLOC_INTERNAL_LOGGING_H_	src/internal_logging.h	37;"	d
TCMALLOC_LIBC_OVERRIDE_GCC_AND_WEAK_INL_H_	src/libc_override_gcc_and_weak.h	40;"	d
TCMALLOC_LIBC_OVERRIDE_GLIBC_INL_H_	src/libc_override_glibc.h	37;"	d
TCMALLOC_LIBC_OVERRIDE_INL_H_	src/libc_override.h	53;"	d
TCMALLOC_LIBC_OVERRIDE_OSX_INL_H_	src/libc_override_osx.h	73;"	d
TCMALLOC_LIBC_OVERRIDE_REDEFINE_H_	src/libc_override_redefine.h	43;"	d
TCMALLOC_LINKED_LIST_H_	src/linked_list.h	38;"	d
TCMALLOC_NO_ALIASES	src/tcmalloc.cc	180;"	d	file:
TCMALLOC_NO_ALIASES	src/tcmalloc.cc	181;"	d	file:
TCMALLOC_PACKED_CACHE_INL_H_	src/packed-cache-inl.h	113;"	d
TCMALLOC_PAGEMAP_H_	src/pagemap.h	47;"	d
TCMALLOC_PAGE_HEAP_ALLOCATOR_H_	src/page_heap_allocator.h	35;"	d
TCMALLOC_PAGE_HEAP_H_	src/page_heap.h	35;"	d
TCMALLOC_SAMPLER_H_	src/sampler.h	37;"	d
TCMALLOC_SPAN_H_	src/span.h	37;"	d
TCMALLOC_STACK_TRACE_TABLE_H_	src/stack_trace_table.h	37;"	d
TCMALLOC_STATIC_VARS_H_	src/static_vars.h	37;"	d
TCMALLOC_SYMBOLIZE_H_	src/symbolize.h	35;"	d
TCMALLOC_SYSTEM_ALLOC_H_	src/system-alloc.h	38;"	d
TCMALLOC_TCMALLOC_GUARD_H_	src/tcmalloc_guard.h	41;"	d
TCMALLOC_TCMALLOC_H_	src/gperftools/tcmalloc.h	37;"	d
TCMALLOC_TCMALLOC_H_	src/gperftools/tcmalloc.h.in	37;"	d	file:
TCMALLOC_TCMALLOC_H_	src/windows/gperftools/tcmalloc.h	37;"	d
TCMALLOC_TCMALLOC_H_	src/windows/gperftools/tcmalloc.h.in	37;"	d	file:
TCMALLOC_THREAD_CACHE_H_	src/thread_cache.h	35;"	d
TCMALLOC_TOOLS_TESTUTIL_H_	src/tests/testutil.h	35;"	d
TCMALLOC_USING_DEBUGALLOCATION	src/debugallocation.cc	84;"	d	file:
TCMallocGetenvSafe	src/base/sysinfo.cc	/^  const char* TCMallocGetenvSafe(const char* name) {$/;"	f	signature:(const char* name)
TCMallocGetenvSafe	src/getenv_safe.h	/^const char* TCMallocGetenvSafe(const char* name);$/;"	p	signature:(const char* name)
TCMallocGuard	src/tcmalloc.cc	/^TCMallocGuard::TCMallocGuard() {$/;"	f	class:TCMallocGuard	signature:()
TCMallocGuard	src/tcmalloc_guard.h	/^  TCMallocGuard();$/;"	p	class:TCMallocGuard	access:public	signature:()
TCMallocGuard	src/tcmalloc_guard.h	/^class TCMallocGuard {$/;"	c
TCMallocGuard::TCMallocGuard	src/tcmalloc.cc	/^TCMallocGuard::TCMallocGuard() {$/;"	f	class:TCMallocGuard	signature:()
TCMallocGuard::TCMallocGuard	src/tcmalloc_guard.h	/^  TCMallocGuard();$/;"	p	class:TCMallocGuard	access:public	signature:()
TCMallocGuard::~TCMallocGuard	src/tcmalloc.cc	/^TCMallocGuard::~TCMallocGuard() {$/;"	f	class:TCMallocGuard	signature:()
TCMallocGuard::~TCMallocGuard	src/tcmalloc_guard.h	/^  ~TCMallocGuard();$/;"	p	class:TCMallocGuard	access:public	signature:()
TCMallocImplementation	src/tcmalloc.cc	/^  TCMallocImplementation()$/;"	f	class:TCMallocImplementation	access:public	signature:()
TCMallocImplementation	src/tcmalloc.cc	/^class TCMallocImplementation : public MallocExtension {$/;"	c	file:	inherits:MallocExtension
TCMallocImplementation::GetAllocatedSize	src/tcmalloc.cc	/^  virtual size_t GetAllocatedSize(const void* ptr);$/;"	p	class:TCMallocImplementation	file:	access:public	signature:(const void* ptr)
TCMallocImplementation::GetAllocatedSize	src/tcmalloc.cc	/^size_t TCMallocImplementation::GetAllocatedSize(const void* ptr) {$/;"	f	class:TCMallocImplementation	signature:(const void* ptr)
TCMallocImplementation::GetEstimatedAllocatedSize	src/tcmalloc.cc	/^  virtual size_t GetEstimatedAllocatedSize(size_t size);$/;"	p	class:TCMallocImplementation	file:	access:public	signature:(size_t size)
TCMallocImplementation::GetEstimatedAllocatedSize	src/tcmalloc.cc	/^size_t TCMallocImplementation::GetEstimatedAllocatedSize(size_t size) {$/;"	f	class:TCMallocImplementation	signature:(size_t size)
TCMallocImplementation::GetFreeListSizes	src/tcmalloc.cc	/^  virtual void GetFreeListSizes(vector<MallocExtension::FreeListInfo>* v) {$/;"	f	class:TCMallocImplementation	access:public	signature:(vector<MallocExtension::FreeListInfo>* v)
TCMallocImplementation::GetHeapSample	src/tcmalloc.cc	/^  virtual void GetHeapSample(MallocExtensionWriter* writer) {$/;"	f	class:TCMallocImplementation	access:public	signature:(MallocExtensionWriter* writer)
TCMallocImplementation::GetMemoryReleaseRate	src/tcmalloc.cc	/^  virtual double GetMemoryReleaseRate() {$/;"	f	class:TCMallocImplementation	access:public	signature:()
TCMallocImplementation::GetNumericProperty	src/tcmalloc.cc	/^  virtual bool GetNumericProperty(const char* name, size_t* value) {$/;"	f	class:TCMallocImplementation	access:public	signature:(const char* name, size_t* value)
TCMallocImplementation::GetOwnership	src/tcmalloc.cc	/^  virtual Ownership GetOwnership(const void* ptr) {$/;"	f	class:TCMallocImplementation	access:public	signature:(const void* ptr)
TCMallocImplementation::GetStats	src/tcmalloc.cc	/^  virtual void GetStats(char* buffer, int buffer_length) {$/;"	f	class:TCMallocImplementation	access:public	signature:(char* buffer, int buffer_length)
TCMallocImplementation::GetSystemAllocator	src/tcmalloc.cc	/^  virtual SysAllocator* GetSystemAllocator() {$/;"	f	class:TCMallocImplementation	access:public	signature:()
TCMallocImplementation::GetThreadCacheSize	src/tcmalloc.cc	/^  virtual size_t GetThreadCacheSize() {$/;"	f	class:TCMallocImplementation	access:public	signature:()
TCMallocImplementation::MarkThreadBusy	src/tcmalloc.cc	/^  virtual void MarkThreadBusy();  \/\/ Implemented below$/;"	p	class:TCMallocImplementation	file:	access:public	signature:()
TCMallocImplementation::MarkThreadBusy	src/tcmalloc.cc	/^void TCMallocImplementation::MarkThreadBusy() {$/;"	f	class:TCMallocImplementation	signature:()
TCMallocImplementation::MarkThreadIdle	src/tcmalloc.cc	/^  virtual void MarkThreadIdle() {$/;"	f	class:TCMallocImplementation	access:public	signature:()
TCMallocImplementation::MarkThreadTemporarilyIdle	src/tcmalloc.cc	/^  virtual void MarkThreadTemporarilyIdle() {$/;"	f	class:TCMallocImplementation	access:public	signature:()
TCMallocImplementation::Ranges	src/tcmalloc.cc	/^  virtual void Ranges(void* arg, RangeFunction func) {$/;"	f	class:TCMallocImplementation	access:public	signature:(void* arg, RangeFunction func)
TCMallocImplementation::ReadHeapGrowthStackTraces	src/tcmalloc.cc	/^  virtual void** ReadHeapGrowthStackTraces() {$/;"	f	class:TCMallocImplementation	access:public	signature:()
TCMallocImplementation::ReadStackTraces	src/tcmalloc.cc	/^  virtual void** ReadStackTraces(int* sample_period) {$/;"	f	class:TCMallocImplementation	access:public	signature:(int* sample_period)
TCMallocImplementation::ReleaseToSystem	src/tcmalloc.cc	/^  virtual void ReleaseToSystem(size_t num_bytes) {$/;"	f	class:TCMallocImplementation	access:public	signature:(size_t num_bytes)
TCMallocImplementation::SetMemoryReleaseRate	src/tcmalloc.cc	/^  virtual void SetMemoryReleaseRate(double rate) {$/;"	f	class:TCMallocImplementation	access:public	signature:(double rate)
TCMallocImplementation::SetNumericProperty	src/tcmalloc.cc	/^  virtual bool SetNumericProperty(const char* name, size_t value) {$/;"	f	class:TCMallocImplementation	access:public	signature:(const char* name, size_t value)
TCMallocImplementation::SetSystemAllocator	src/tcmalloc.cc	/^  virtual void SetSystemAllocator(SysAllocator* alloc) {$/;"	f	class:TCMallocImplementation	access:public	signature:(SysAllocator* alloc)
TCMallocImplementation::TCMallocImplementation	src/tcmalloc.cc	/^  TCMallocImplementation()$/;"	f	class:TCMallocImplementation	access:public	signature:()
TCMallocImplementation::extra_bytes_released_	src/tcmalloc.cc	/^  size_t extra_bytes_released_;$/;"	m	class:TCMallocImplementation	file:	access:private
TCMallocStats	src/tcmalloc.cc	/^struct TCMallocStats {$/;"	s	file:
TCMallocStats::central_bytes	src/tcmalloc.cc	/^  uint64_t central_bytes;     \/\/ Bytes in central cache$/;"	m	struct:TCMallocStats	file:	access:public
TCMallocStats::metadata_bytes	src/tcmalloc.cc	/^  uint64_t metadata_bytes;    \/\/ Bytes alloced for metadata$/;"	m	struct:TCMallocStats	file:	access:public
TCMallocStats::pageheap	src/tcmalloc.cc	/^  PageHeap::Stats pageheap;   \/\/ Stats from page heap$/;"	m	struct:TCMallocStats	file:	access:public
TCMallocStats::thread_bytes	src/tcmalloc.cc	/^  uint64_t thread_bytes;      \/\/ Bytes in thread caches$/;"	m	struct:TCMallocStats	file:	access:public
TCMallocStats::transfer_bytes	src/tcmalloc.cc	/^  uint64_t transfer_bytes;    \/\/ Bytes in central transfer cache$/;"	m	struct:TCMallocStats	file:	access:public
TCMalloc_ListAllProcessThreads	src/base/linuxthreads.cc	/^int TCMalloc_ListAllProcessThreads(void *parameter,$/;"	f	signature:(void *parameter, ListAllProcessThreadsCallBack callback, ...)
TCMalloc_ListAllProcessThreads	src/base/thread_lister.c	/^int TCMalloc_ListAllProcessThreads(void *parameter,$/;"	f	signature:(void *parameter, ListAllProcessThreadsCallBack callback, ...)
TCMalloc_ListAllProcessThreads	src/base/thread_lister.h	/^int TCMalloc_ListAllProcessThreads(void *parameter,$/;"	p	signature:(void *parameter, ListAllProcessThreadsCallBack callback, ...)
TCMalloc_PageMap1	src/pagemap.h	/^  explicit TCMalloc_PageMap1(void* (*allocator)(size_t)) {$/;"	f	class:TCMalloc_PageMap1	access:public	signature:(void* (*allocator)(size_t))
TCMalloc_PageMap1	src/pagemap.h	/^class TCMalloc_PageMap1 {$/;"	c
TCMalloc_PageMap1::Ensure	src/pagemap.h	/^  bool Ensure(Number x, size_t n) {$/;"	f	class:TCMalloc_PageMap1	access:public	signature:(Number x, size_t n)
TCMalloc_PageMap1::LENGTH	src/pagemap.h	/^  static const int LENGTH = 1 << BITS;$/;"	m	class:TCMalloc_PageMap1	access:private
TCMalloc_PageMap1::Next	src/pagemap.h	/^  void* Next(Number k) const {$/;"	f	class:TCMalloc_PageMap1	access:public	signature:(Number k) const
TCMalloc_PageMap1::Number	src/pagemap.h	/^  typedef uintptr_t Number;$/;"	t	class:TCMalloc_PageMap1	access:public
TCMalloc_PageMap1::PreallocateMoreMemory	src/pagemap.h	/^  void PreallocateMoreMemory() {}$/;"	f	class:TCMalloc_PageMap1	access:public	signature:()
TCMalloc_PageMap1::TCMalloc_PageMap1	src/pagemap.h	/^  explicit TCMalloc_PageMap1(void* (*allocator)(size_t)) {$/;"	f	class:TCMalloc_PageMap1	access:public	signature:(void* (*allocator)(size_t))
TCMalloc_PageMap1::array_	src/pagemap.h	/^  void** array_;$/;"	m	class:TCMalloc_PageMap1	access:private
TCMalloc_PageMap1::get	src/pagemap.h	/^  void* get(Number k) const {$/;"	f	class:TCMalloc_PageMap1	access:public	signature:(Number k) const
TCMalloc_PageMap1::set	src/pagemap.h	/^  void set(Number k, void* v) {$/;"	f	class:TCMalloc_PageMap1	access:public	signature:(Number k, void* v)
TCMalloc_PageMap2	src/pagemap.h	/^  explicit TCMalloc_PageMap2(void* (*allocator)(size_t)) {$/;"	f	class:TCMalloc_PageMap2	access:public	signature:(void* (*allocator)(size_t))
TCMalloc_PageMap2	src/pagemap.h	/^class TCMalloc_PageMap2 {$/;"	c
TCMalloc_PageMap2::Ensure	src/pagemap.h	/^  bool Ensure(Number start, size_t n) {$/;"	f	class:TCMalloc_PageMap2	access:public	signature:(Number start, size_t n)
TCMalloc_PageMap2::LEAF_BITS	src/pagemap.h	/^  static const int LEAF_BITS = (BITS + 1) \/ 2;$/;"	m	class:TCMalloc_PageMap2	access:private
TCMalloc_PageMap2::LEAF_LENGTH	src/pagemap.h	/^  static const int LEAF_LENGTH = 1 << LEAF_BITS;$/;"	m	class:TCMalloc_PageMap2	access:private
TCMalloc_PageMap2::Leaf	src/pagemap.h	/^  struct Leaf {$/;"	s	class:TCMalloc_PageMap2	access:private
TCMalloc_PageMap2::Leaf::values	src/pagemap.h	/^    void* values[LEAF_LENGTH];$/;"	m	struct:TCMalloc_PageMap2::Leaf	access:public
TCMalloc_PageMap2::Next	src/pagemap.h	/^  void* Next(Number k) const {$/;"	f	class:TCMalloc_PageMap2	access:public	signature:(Number k) const
TCMalloc_PageMap2::Number	src/pagemap.h	/^  typedef uintptr_t Number;$/;"	t	class:TCMalloc_PageMap2	access:public
TCMalloc_PageMap2::PreallocateMoreMemory	src/pagemap.h	/^  void PreallocateMoreMemory() {$/;"	f	class:TCMalloc_PageMap2	access:public	signature:()
TCMalloc_PageMap2::ROOT_BITS	src/pagemap.h	/^  static const int ROOT_BITS = BITS - LEAF_BITS;$/;"	m	class:TCMalloc_PageMap2	access:private
TCMalloc_PageMap2::ROOT_LENGTH	src/pagemap.h	/^  static const int ROOT_LENGTH = 1 << ROOT_BITS;$/;"	m	class:TCMalloc_PageMap2	access:private
TCMalloc_PageMap2::TCMalloc_PageMap2	src/pagemap.h	/^  explicit TCMalloc_PageMap2(void* (*allocator)(size_t)) {$/;"	f	class:TCMalloc_PageMap2	access:public	signature:(void* (*allocator)(size_t))
TCMalloc_PageMap2::allocator_	src/pagemap.h	/^  void* (*allocator_)(size_t);          \/\/ Memory allocator$/;"	m	class:TCMalloc_PageMap2	access:private
TCMalloc_PageMap2::get	src/pagemap.h	/^  void* get(Number k) const {$/;"	f	class:TCMalloc_PageMap2	access:public	signature:(Number k) const
TCMalloc_PageMap2::root_	src/pagemap.h	/^  Leaf* root_[ROOT_LENGTH];             \/\/ Pointers to child nodes$/;"	m	class:TCMalloc_PageMap2	access:private
TCMalloc_PageMap2::set	src/pagemap.h	/^  void set(Number k, void* v) {$/;"	f	class:TCMalloc_PageMap2	access:public	signature:(Number k, void* v)
TCMalloc_PageMap3	src/pagemap.h	/^  explicit TCMalloc_PageMap3(void* (*allocator)(size_t)) {$/;"	f	class:TCMalloc_PageMap3	access:public	signature:(void* (*allocator)(size_t))
TCMalloc_PageMap3	src/pagemap.h	/^class TCMalloc_PageMap3 {$/;"	c
TCMalloc_PageMap3::Ensure	src/pagemap.h	/^  bool Ensure(Number start, size_t n) {$/;"	f	class:TCMalloc_PageMap3	access:public	signature:(Number start, size_t n)
TCMalloc_PageMap3::INTERIOR_BITS	src/pagemap.h	/^  static const int INTERIOR_BITS = (BITS + 2) \/ 3; \/\/ Round-up$/;"	m	class:TCMalloc_PageMap3	access:private
TCMalloc_PageMap3::INTERIOR_LENGTH	src/pagemap.h	/^  static const int INTERIOR_LENGTH = 1 << INTERIOR_BITS;$/;"	m	class:TCMalloc_PageMap3	access:private
TCMalloc_PageMap3::LEAF_BITS	src/pagemap.h	/^  static const int LEAF_BITS = BITS - 2*INTERIOR_BITS;$/;"	m	class:TCMalloc_PageMap3	access:private
TCMalloc_PageMap3::LEAF_LENGTH	src/pagemap.h	/^  static const int LEAF_LENGTH = 1 << LEAF_BITS;$/;"	m	class:TCMalloc_PageMap3	access:private
TCMalloc_PageMap3::Leaf	src/pagemap.h	/^  struct Leaf {$/;"	s	class:TCMalloc_PageMap3	access:private
TCMalloc_PageMap3::Leaf::values	src/pagemap.h	/^    void* values[LEAF_LENGTH];$/;"	m	struct:TCMalloc_PageMap3::Leaf	access:public
TCMalloc_PageMap3::NewNode	src/pagemap.h	/^  Node* NewNode() {$/;"	f	class:TCMalloc_PageMap3	access:private	signature:()
TCMalloc_PageMap3::Next	src/pagemap.h	/^  void* Next(Number k) const {$/;"	f	class:TCMalloc_PageMap3	access:public	signature:(Number k) const
TCMalloc_PageMap3::Node	src/pagemap.h	/^  struct Node {$/;"	s	class:TCMalloc_PageMap3	access:private
TCMalloc_PageMap3::Node::ptrs	src/pagemap.h	/^    Node* ptrs[INTERIOR_LENGTH];$/;"	m	struct:TCMalloc_PageMap3::Node	access:public
TCMalloc_PageMap3::Number	src/pagemap.h	/^  typedef uintptr_t Number;$/;"	t	class:TCMalloc_PageMap3	access:public
TCMalloc_PageMap3::PreallocateMoreMemory	src/pagemap.h	/^  void PreallocateMoreMemory() {$/;"	f	class:TCMalloc_PageMap3	access:public	signature:()
TCMalloc_PageMap3::TCMalloc_PageMap3	src/pagemap.h	/^  explicit TCMalloc_PageMap3(void* (*allocator)(size_t)) {$/;"	f	class:TCMalloc_PageMap3	access:public	signature:(void* (*allocator)(size_t))
TCMalloc_PageMap3::allocator_	src/pagemap.h	/^  void* (*allocator_)(size_t);          \/\/ Memory allocator$/;"	m	class:TCMalloc_PageMap3	access:private
TCMalloc_PageMap3::get	src/pagemap.h	/^  void* get(Number k) const {$/;"	f	class:TCMalloc_PageMap3	access:public	signature:(Number k) const
TCMalloc_PageMap3::root_	src/pagemap.h	/^  Node  root_;                          \/\/ Root of radix tree$/;"	m	class:TCMalloc_PageMap3	access:private
TCMalloc_PageMap3::set	src/pagemap.h	/^  void set(Number k, void* v) {$/;"	f	class:TCMalloc_PageMap3	access:public	signature:(Number k, void* v)
TCMalloc_Printer	src/internal_logging.h	/^  TCMalloc_Printer(char* buf, int length) : buf_(buf), left_(length) {$/;"	f	class:TCMalloc_Printer	access:public	signature:(char* buf, int length)
TCMalloc_Printer	src/internal_logging.h	/^class TCMalloc_Printer {$/;"	c
TCMalloc_Printer::TCMalloc_Printer	src/internal_logging.h	/^  TCMalloc_Printer(char* buf, int length) : buf_(buf), left_(length) {$/;"	f	class:TCMalloc_Printer	access:public	signature:(char* buf, int length)
TCMalloc_Printer::buf_	src/internal_logging.h	/^  char* buf_;           \/\/ Where should we write next$/;"	m	class:TCMalloc_Printer	access:private
TCMalloc_Printer::left_	src/internal_logging.h	/^  int   left_;          \/\/ Space left in buffer (including space for \\0)$/;"	m	class:TCMalloc_Printer	access:private
TCMalloc_Printer::printf	src/internal_logging.cc	/^void TCMalloc_Printer::printf(const char* format, ...) {$/;"	f	class:TCMalloc_Printer	signature:(const char* format, ...)
TCMalloc_Printer::printf	src/internal_logging.h	/^  void printf(const char* format, ...)$/;"	p	class:TCMalloc_Printer	access:public	signature:(const char* format, ...)
TCMalloc_ResumeAllProcessThreads	src/base/linuxthreads.cc	/^int TCMalloc_ResumeAllProcessThreads(int num_threads, pid_t *thread_pids) {$/;"	f	signature:(int num_threads, pid_t *thread_pids)
TCMalloc_ResumeAllProcessThreads	src/base/thread_lister.c	/^int TCMalloc_ResumeAllProcessThreads(int num_threads, pid_t *thread_pids) {$/;"	f	signature:(int num_threads, pid_t *thread_pids)
TCMalloc_ResumeAllProcessThreads	src/base/thread_lister.h	/^int TCMalloc_ResumeAllProcessThreads(int num_threads, pid_t *thread_pids);$/;"	p	signature:(int num_threads, pid_t *thread_pids)
TCMalloc_SystemAlloc	src/system-alloc.cc	/^void* TCMalloc_SystemAlloc(size_t size, size_t *actual_size,$/;"	f	signature:(size_t size, size_t *actual_size, size_t alignment)
TCMalloc_SystemAlloc	src/system-alloc.h	/^void* TCMalloc_SystemAlloc(size_t bytes, size_t *actual_bytes,$/;"	p	signature:(size_t bytes, size_t *actual_bytes, size_t alignment = 0)
TCMalloc_SystemAlloc	src/windows/system-alloc.cc	/^void* TCMalloc_SystemAlloc(size_t size, size_t *actual_size,$/;"	f	signature:(size_t size, size_t *actual_size, size_t alignment)
TCMalloc_SystemCommit	src/system-alloc.cc	/^void TCMalloc_SystemCommit(void* start, size_t length) {$/;"	f	signature:(void* start, size_t length)
TCMalloc_SystemCommit	src/system-alloc.h	/^void TCMalloc_SystemCommit(void* start, size_t length);$/;"	p	signature:(void* start, size_t length)
TCMalloc_SystemCommit	src/windows/system-alloc.cc	/^void TCMalloc_SystemCommit(void* start, size_t length) {$/;"	f	signature:(void* start, size_t length)
TCMalloc_SystemRelease	src/system-alloc.cc	/^bool TCMalloc_SystemRelease(void* start, size_t length) {$/;"	f	signature:(void* start, size_t length)
TCMalloc_SystemRelease	src/system-alloc.h	/^bool TCMalloc_SystemRelease(void* start, size_t length);$/;"	p	signature:(void* start, size_t length)
TCMalloc_SystemRelease	src/windows/system-alloc.cc	/^bool TCMalloc_SystemRelease(void* start, size_t length) {$/;"	f	signature:(void* start, size_t length)
TCMalloc_SystemTaken	src/system-alloc.cc	/^size_t TCMalloc_SystemTaken = 0;$/;"	v
TCMalloc_SystemTaken	src/windows/system-alloc.cc	/^size_t TCMalloc_SystemTaken = 0;$/;"	v
TC_ALIAS	src/tcmalloc.cc	/^  TC_ALIAS(tc_free_sized);$/;"	p	file:	signature:(tc_free_sized)
TC_ALIAS	src/tcmalloc.cc	/^TC_ALIAS(tc_delete);$/;"	p	file:	signature:(tc_delete)
TC_ALIAS	src/tcmalloc.cc	/^TC_ALIAS(tc_delete_aligned);$/;"	p	file:	signature:(tc_delete_aligned)
TC_ALIAS	src/tcmalloc.cc	/^TC_ALIAS(tc_delete_aligned_nothrow);$/;"	p	file:	signature:(tc_delete_aligned_nothrow)
TC_ALIAS	src/tcmalloc.cc	/^TC_ALIAS(tc_delete_nothrow);$/;"	p	file:	signature:(tc_delete_nothrow)
TC_ALIAS	src/tcmalloc.cc	/^TC_ALIAS(tc_delete_sized_aligned);$/;"	p	file:	signature:(tc_delete_sized_aligned)
TC_ALIAS	src/tcmalloc.cc	/^TC_ALIAS(tc_free);$/;"	p	file:	signature:(tc_free)
TC_ALIAS	src/tcmalloc.cc	/^TC_ALIAS(tc_new_aligned_nothrow);$/;"	p	file:	signature:(tc_new_aligned_nothrow)
TC_ALIAS	src/tcmalloc.cc	/^TC_ALIAS(tc_new_nothrow);$/;"	p	file:	signature:(tc_new_nothrow)
TC_ALIAS	src/tcmalloc.cc	185;"	d	file:
TC_VERSION_MAJOR	src/gperftools/tcmalloc.h	45;"	d
TC_VERSION_MAJOR	src/gperftools/tcmalloc.h.in	45;"	d	file:
TC_VERSION_MAJOR	src/windows/gperftools/tcmalloc.h	45;"	d
TC_VERSION_MAJOR	src/windows/gperftools/tcmalloc.h.in	45;"	d	file:
TC_VERSION_MINOR	src/gperftools/tcmalloc.h	46;"	d
TC_VERSION_MINOR	src/gperftools/tcmalloc.h.in	46;"	d	file:
TC_VERSION_MINOR	src/windows/gperftools/tcmalloc.h	46;"	d
TC_VERSION_MINOR	src/windows/gperftools/tcmalloc.h.in	46;"	d	file:
TC_VERSION_PATCH	src/gperftools/tcmalloc.h	47;"	d
TC_VERSION_PATCH	src/gperftools/tcmalloc.h.in	47;"	d	file:
TC_VERSION_PATCH	src/windows/gperftools/tcmalloc.h	47;"	d
TC_VERSION_PATCH	src/windows/gperftools/tcmalloc.h.in	47;"	d	file:
TC_VERSION_STRING	src/gperftools/tcmalloc.h	48;"	d
TC_VERSION_STRING	src/gperftools/tcmalloc.h.in	48;"	d	file:
TC_VERSION_STRING	src/windows/gperftools/tcmalloc.h	48;"	d
TC_VERSION_STRING	src/windows/gperftools/tcmalloc.h.in	48;"	d	file:
TClass	src/tests/heap-checker_unittest.cc	/^  explicit TClass(int a) : ptr(NULL) { }$/;"	f	class:TClass	access:public	signature:(int a)
TClass	src/tests/heap-checker_unittest.cc	/^class TClass {$/;"	c	file:
TClass::TClass	src/tests/heap-checker_unittest.cc	/^  explicit TClass(int a) : ptr(NULL) { }$/;"	f	class:TClass	access:public	signature:(int a)
TClass::ptr	src/tests/heap-checker_unittest.cc	/^  mutable C* ptr;$/;"	m	class:TClass	file:	access:public
TClass::val	src/tests/heap-checker_unittest.cc	/^  mutable C val;$/;"	m	class:TClass	file:	access:public
TEST	src/tests/debugallocation_test.cc	/^TEST(DebugAllocationTest, CurrentlyAllocated) {$/;"	f	signature:(DebugAllocationTest, CurrentlyAllocated)
TEST	src/tests/debugallocation_test.cc	/^TEST(DebugAllocationTest, DanglingPointerWriteTest) {$/;"	f	signature:(DebugAllocationTest, DanglingPointerWriteTest)
TEST	src/tests/debugallocation_test.cc	/^TEST(DebugAllocationTest, DanglingWriteAtExitTest) {$/;"	f	signature:(DebugAllocationTest, DanglingWriteAtExitTest)
TEST	src/tests/debugallocation_test.cc	/^TEST(DebugAllocationTest, DeallocMismatch) {$/;"	f	signature:(DebugAllocationTest, DeallocMismatch)
TEST	src/tests/debugallocation_test.cc	/^TEST(DebugAllocationTest, DoubleFree) {$/;"	f	signature:(DebugAllocationTest, DoubleFree)
TEST	src/tests/debugallocation_test.cc	/^TEST(DebugAllocationTest, FreeQueueTest) {$/;"	f	signature:(DebugAllocationTest, FreeQueueTest)
TEST	src/tests/debugallocation_test.cc	/^TEST(DebugAllocationTest, GetAllocatedSizeTest) {$/;"	f	signature:(DebugAllocationTest, GetAllocatedSizeTest)
TEST	src/tests/debugallocation_test.cc	/^TEST(DebugAllocationTest, HugeAlloc) {$/;"	f	signature:(DebugAllocationTest, HugeAlloc)
TEST	src/tests/debugallocation_test.cc	/^TEST(DebugAllocationTest, ReallocAfterMemalign) {$/;"	f	signature:(DebugAllocationTest, ReallocAfterMemalign)
TEST	src/tests/debugallocation_test.cc	/^TEST(DebugAllocationTest, StackTraceWithDanglingWriteAtExitTest) {$/;"	f	signature:(DebugAllocationTest, StackTraceWithDanglingWriteAtExitTest)
TEST	src/tests/debugallocation_test.cc	/^TEST(DebugAllocationTest, StompAfter) {$/;"	f	signature:(DebugAllocationTest, StompAfter)
TEST	src/tests/debugallocation_test.cc	/^TEST(DebugAllocationTest, StompBefore) {$/;"	f	signature:(DebugAllocationTest, StompBefore)
TEST	src/tests/debugallocation_test.cc	46;"	d	file:
TEST	src/tests/malloc_hook_test.cc	/^TEST(HookListTest, AddAppends) {$/;"	f	namespace:__anon57	signature:(HookListTest, AddAppends)
TEST	src/tests/malloc_hook_test.cc	/^TEST(HookListTest, AddPrependsAfterRemove) {$/;"	f	namespace:__anon57	signature:(HookListTest, AddPrependsAfterRemove)
TEST	src/tests/malloc_hook_test.cc	/^TEST(HookListTest, CanRemoveInitialValue) {$/;"	f	namespace:__anon57	signature:(HookListTest, CanRemoveInitialValue)
TEST	src/tests/malloc_hook_test.cc	/^TEST(HookListTest, FillUpTheList) {$/;"	f	namespace:__anon57	signature:(HookListTest, FillUpTheList)
TEST	src/tests/malloc_hook_test.cc	/^TEST(HookListTest, InitialValueExists) {$/;"	f	namespace:__anon57	signature:(HookListTest, InitialValueExists)
TEST	src/tests/malloc_hook_test.cc	/^TEST(HookListTest, InvalidAddRejected) {$/;"	f	namespace:__anon57	signature:(HookListTest, InvalidAddRejected)
TEST	src/tests/malloc_hook_test.cc	/^TEST(HookListTest, MultithreadedTest) {$/;"	f	namespace:__anon57	signature:(HookListTest, MultithreadedTest)
TEST	src/tests/malloc_hook_test.cc	/^TEST(HookListTest, RemoveWorksAndWillClearSize) {$/;"	f	namespace:__anon57	signature:(HookListTest, RemoveWorksAndWillClearSize)
TEST	src/tests/malloc_hook_test.cc	/^TEST(MallocMookTest, MmapReplacements) {$/;"	f	namespace:__anon57	signature:(MallocMookTest, MmapReplacements)
TEST	src/tests/malloc_hook_test.cc	66;"	d	file:
TEST	src/tests/raw_printer_test.cc	/^TEST(RawPrinter, Empty) {$/;"	f	signature:(RawPrinter, Empty)
TEST	src/tests/raw_printer_test.cc	/^TEST(RawPrinter, ExactlyFilled) {$/;"	f	signature:(RawPrinter, ExactlyFilled)
TEST	src/tests/raw_printer_test.cc	/^TEST(RawPrinter, PartiallyFilled) {$/;"	f	signature:(RawPrinter, PartiallyFilled)
TEST	src/tests/raw_printer_test.cc	/^TEST(RawPrinter, Truncated) {$/;"	f	signature:(RawPrinter, Truncated)
TEST	src/tests/raw_printer_test.cc	15;"	d	file:
TEST	src/tests/sampler_test.cc	/^TEST(Sample, size_of_class) {$/;"	f	signature:(Sample, size_of_class)
TEST	src/tests/sampler_test.cc	/^TEST(Sampler, IsMeanRight) {$/;"	f	signature:(Sampler, IsMeanRight)
TEST	src/tests/sampler_test.cc	/^TEST(Sampler, LargeAndSmallAllocs_CombinedTest) {$/;"	f	signature:(Sampler, LargeAndSmallAllocs_CombinedTest)
TEST	src/tests/sampler_test.cc	/^TEST(Sampler, NextRand_range) {$/;"	f	signature:(Sampler, NextRand_range)
TEST	src/tests/sampler_test.cc	/^TEST(Sampler, TestGetSamplePeriod) {$/;"	f	signature:(Sampler, TestGetSamplePeriod)
TEST	src/tests/sampler_test.cc	/^TEST(Sampler, TestNextRandom_MultipleValues) {$/;"	f	signature:(Sampler, TestNextRandom_MultipleValues)
TEST	src/tests/sampler_test.cc	/^TEST(Sampler, TestPickNextSample_MultipleValues) {$/;"	f	signature:(Sampler, TestPickNextSample_MultipleValues)
TEST	src/tests/sampler_test.cc	/^TEST(Sampler, arithmetic_1) {$/;"	f	signature:(Sampler, arithmetic_1)
TEST	src/tests/sampler_test.cc	/^TEST(Sampler, arithmetic_2) {$/;"	f	signature:(Sampler, arithmetic_2)
TEST	src/tests/sampler_test.cc	/^TEST(Sampler, bytes_until_sample_Overflow_Underflow) {$/;"	f	signature:(Sampler, bytes_until_sample_Overflow_Underflow)
TEST	src/tests/sampler_test.cc	64;"	d	file:
TEST_F	src/tests/profile-handler_unittest.cc	/^TEST_F(ProfileHandlerTest, MultipleCallbacks) {$/;"	f	namespace:__anon56	signature:(ProfileHandlerTest, MultipleCallbacks)
TEST_F	src/tests/profile-handler_unittest.cc	/^TEST_F(ProfileHandlerTest, RegisterCallbackBeforeThread) {$/;"	f	namespace:__anon56	signature:(ProfileHandlerTest, RegisterCallbackBeforeThread)
TEST_F	src/tests/profile-handler_unittest.cc	/^TEST_F(ProfileHandlerTest, RegisterUnregisterCallback) {$/;"	f	namespace:__anon56	signature:(ProfileHandlerTest, RegisterUnregisterCallback)
TEST_F	src/tests/profile-handler_unittest.cc	/^TEST_F(ProfileHandlerTest, Reset) {$/;"	f	namespace:__anon56	signature:(ProfileHandlerTest, Reset)
TEST_F	src/tests/profile-handler_unittest.cc	23;"	d	file:
TEST_F	src/tests/profiledata_unittest.cc	/^TEST_F(ProfileDataTest, CollectOne) {$/;"	f	namespace:__anon53	signature:(ProfileDataTest, CollectOne)
TEST_F	src/tests/profiledata_unittest.cc	/^TEST_F(ProfileDataTest, CollectTwoFlush) {$/;"	f	namespace:__anon53	signature:(ProfileDataTest, CollectTwoFlush)
TEST_F	src/tests/profiledata_unittest.cc	/^TEST_F(ProfileDataTest, CollectTwoMatching) {$/;"	f	namespace:__anon53	signature:(ProfileDataTest, CollectTwoMatching)
TEST_F	src/tests/profiledata_unittest.cc	/^TEST_F(ProfileDataTest, OpsWhenStopped) {$/;"	f	namespace:__anon53	signature:(ProfileDataTest, OpsWhenStopped)
TEST_F	src/tests/profiledata_unittest.cc	/^TEST_F(ProfileDataTest, StartResetRestart) {$/;"	f	namespace:__anon53	signature:(ProfileDataTest, StartResetRestart)
TEST_F	src/tests/profiledata_unittest.cc	/^TEST_F(ProfileDataTest, StartStopEmpty) {$/;"	f	namespace:__anon53	signature:(ProfileDataTest, StartStopEmpty)
TEST_F	src/tests/profiledata_unittest.cc	/^TEST_F(ProfileDataTest, StartStopEmpty2) {$/;"	f	namespace:__anon53	signature:(ProfileDataTest, StartStopEmpty2)
TEST_F	src/tests/profiledata_unittest.cc	/^TEST_F(ProfileDataTest, StartStopNoOptionsEmpty) {$/;"	f	namespace:__anon53	signature:(ProfileDataTest, StartStopNoOptionsEmpty)
TEST_F	src/tests/profiledata_unittest.cc	/^TEST_F(ProfileDataTest, StartWhenStarted) {$/;"	f	namespace:__anon53	signature:(ProfileDataTest, StartWhenStarted)
TEST_F	src/tests/profiledata_unittest.cc	55;"	d	file:
TH32CS_SNAPMODULE32	src/base/sysinfo.cc	79;"	d	file:
THREADS	src/base/linuxthreads.h	50;"	d
THREAD_ANNOTATION_ATTRIBUTE__	src/base/thread_annotations.h	52;"	d
THREAD_ANNOTATION_ATTRIBUTE__	src/base/thread_annotations.h	54;"	d
THREAD_ATOMICOPS_H_	src/base/atomicops.h	78;"	d
THREAD_DATA	src/heap-checker.cc	/^  THREAD_DATA,       \/\/ Part of a thread stack and a thread descriptor with TLS$/;"	e	enum:ObjectPlacement	file:
THREAD_REGISTERS	src/heap-checker.cc	/^  THREAD_REGISTERS,  \/\/ Values in registers of some thread$/;"	e	enum:ObjectPlacement	file:
THREAD_REGS	src/heap-checker.cc	1015;"	d	file:
THREAD_REGS	src/heap-checker.cc	1017;"	d	file:
TMPDIR	profiler_unittest.sh	/^TMPDIR=\/tmp\/profile_info$/;"	v
TMPDIR	src/tests/profiler_unittest.sh	/^TMPDIR=\/tmp\/profile_info$/;"	v
TO	COPYING	/^LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR$/;"	v
TO	packages/deb/copyright	/^LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR$/;"	v
TO	src/windows/shortproc.asm	/^; LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR$/;"	v
TOP_STACK	src/stacktrace_powerpc-inl.h	106;"	d
TOP_STACK	src/stacktrace_powerpc-inl.h	113;"	d
TORT	src/windows/shortproc.asm	/^; THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT$/;"	v
TRIAL_NSEC	benchmark/run_benchmark.c	71;"	d	file:
T_should_fit_in_AtomicWord	src/malloc_hook-inl.h	/^  COMPILE_ASSERT(sizeof(T) <= sizeof(AtomicWord), T_should_fit_in_AtomicWord);$/;"	m	struct:base::internal::HookList	access:public
Tag	src/internal_logging.h	/^  enum Tag {$/;"	g	class:tcmalloc::LogItem	access:private
TakeSnapshot	src/heap-profile-table.cc	/^HeapProfileTable::Snapshot* HeapProfileTable::TakeSnapshot() {$/;"	f	class:HeapProfileTable	signature:()
TakeSnapshot	src/heap-profile-table.h	/^  Snapshot* TakeSnapshot();$/;"	p	class:HeapProfileTable	access:public	signature:()
TearDown	src/tests/profile-handler_unittest.cc	/^  virtual void TearDown() {$/;"	f	class:__anon56::ProfileHandlerTest	access:protected	signature:()
Test	src/tests/low_level_alloc_unittest.cc	/^static void Test(bool use_new_arena, bool call_malloc_hook, int n) {$/;"	f	file:	signature:(bool use_new_arena, bool call_malloc_hook, int n)
TestAggressiveDecommit	src/tests/tcmalloc_unittest.cc	/^static void TestAggressiveDecommit() {$/;"	f	namespace:testing	signature:()
TestAlignmentForSize	src/tests/tcmalloc_unittest.cc	/^static void TestAlignmentForSize(int size) {$/;"	f	namespace:testing	signature:(int size)
TestAllocation	src/tests/markidle_unittest.cc	/^static void TestAllocation() {$/;"	f	file:	signature:()
TestAtomicExchange	src/tests/atomicops_unittest.cc	/^static void TestAtomicExchange(AtomicType (*atomic_exchange_func)$/;"	f	file:	signature:(AtomicType (atomic_exchange_func) volatile AtomicType*, AtomicType))
TestAtomicOps	src/tests/atomicops_unittest.cc	/^static void TestAtomicOps() {$/;"	f	file:	signature:()
TestBasicInvoked	src/tests/system-alloc_unittest.cc	/^static void TestBasicInvoked() {$/;"	f	file:	signature:()
TestBasicRetryFailTest	src/tests/system-alloc_unittest.cc	/^static void TestBasicRetryFailTest() {$/;"	f	file:	signature:()
TestCalloc	src/tests/tcmalloc_unittest.cc	/^static void TestCalloc(size_t n, size_t s, bool ok) {$/;"	f	namespace:testing	signature:(size_t n, size_t s, bool ok)
TestCompareAndSwap	src/tests/atomicops_unittest.cc	/^static void TestCompareAndSwap(AtomicType (*compare_and_swap_func)$/;"	f	file:	signature:(AtomicType (compare_and_swap_func) volatile AtomicType*, AtomicType, AtomicType))
TestDeleteHook	src/tests/malloc_extension_c_test.c	/^void TestDeleteHook(const void* ptr) {$/;"	f	signature:(const void* ptr)
TestDisassembler	src/windows/preamble_patcher_test.cc	/^bool TestDisassembler() {$/;"	f	namespace:sidestep	signature:()
TestDumpHeapProfiler	src/tests/heap-profiler_unittest.cc	/^static void TestDumpHeapProfiler() {$/;"	f	file:	signature:()
TestErrno	src/tests/tcmalloc_unittest.cc	/^static void TestErrno(void) {$/;"	f	namespace:testing	signature:(void)
TestHarness	src/tests/tcmalloc_unittest.cc	/^  TestHarness(int seed)$/;"	f	class:testing::TestHarness	access:public	signature:(int seed)
TestHarness	src/tests/tcmalloc_unittest.cc	/^class TestHarness {$/;"	c	namespace:testing	file:
TestHeapLeakChecker	src/tests/heap-checker_unittest.cc	/^static void TestHeapLeakChecker() {$/;"	f	file:	signature:()
TestHeapLeakCheckerDeathCountLess	src/tests/heap-checker_unittest.cc	/^static void TestHeapLeakCheckerDeathCountLess() {$/;"	f	file:	signature:()
TestHeapLeakCheckerDeathCountMore	src/tests/heap-checker_unittest.cc	/^static void TestHeapLeakCheckerDeathCountMore() {$/;"	f	file:	signature:()
TestHeapLeakCheckerDeathInverse	src/tests/heap-checker_unittest.cc	/^static void TestHeapLeakCheckerDeathInverse() {$/;"	f	file:	signature:()
TestHeapLeakCheckerDeathLoop	src/tests/heap-checker_unittest.cc	/^static void TestHeapLeakCheckerDeathLoop() {$/;"	f	file:	signature:()
TestHeapLeakCheckerDeathNoLeaks	src/tests/heap-checker_unittest.cc	/^static void TestHeapLeakCheckerDeathNoLeaks() {$/;"	f	file:	signature:()
TestHeapLeakCheckerDeathSimple	src/tests/heap-checker_unittest.cc	/^static void TestHeapLeakCheckerDeathSimple() {$/;"	f	file:	signature:()
TestHeapLeakCheckerDeathTrick	src/tests/heap-checker_unittest.cc	/^static void TestHeapLeakCheckerDeathTrick() {$/;"	f	file:	signature:()
TestHeapLeakCheckerDisabling	src/tests/heap-checker_unittest.cc	/^static void TestHeapLeakCheckerDisabling() {$/;"	f	file:	signature:()
TestHeapLeakCheckerLiveness	src/tests/heap-checker_unittest.cc	/^static void TestHeapLeakCheckerLiveness() {$/;"	f	file:	signature:()
TestHeapLeakCheckerNamedDisabling	src/gperftools/heap-checker.h	/^  friend void TestHeapLeakCheckerNamedDisabling();$/;"	p	class:HeapLeakChecker	access:friend	signature:()
TestHeapLeakCheckerNoFalsePositives	src/tests/heap-checker_unittest.cc	/^static void TestHeapLeakCheckerNoFalsePositives() {$/;"	f	file:	signature:()
TestHeapProfilerStartStopIsRunning	src/tests/heap-profiler_unittest.cc	/^static void TestHeapProfilerStartStopIsRunning() {$/;"	f	file:	signature:()
TestHiddenPointer	src/tests/heap-checker_unittest.cc	/^static void TestHiddenPointer() {$/;"	f	file:	signature:()
TestHookList	src/tests/malloc_hook_test.cc	/^typedef base::internal::HookList<MallocHook::NewHook> TestHookList;$/;"	t	namespace:__anon57	file:
TestHookList_Add	src/tests/malloc_hook_test.cc	/^bool TestHookList_Add(TestHookList* list, int val) {$/;"	f	namespace:__anon57	signature:(TestHookList* list, int val)
TestHookList_Remove	src/tests/malloc_hook_test.cc	/^bool TestHookList_Remove(TestHookList* list, int val) {$/;"	f	namespace:__anon57	signature:(TestHookList* list, int val)
TestHookList_Traverse	src/tests/malloc_hook_test.cc	/^int TestHookList_Traverse(const TestHookList& list, uintptr_t* output_array, int n) {$/;"	f	namespace:__anon57	signature:(const TestHookList& list, uintptr_t* output_array, int n)
TestHugeAllocations	src/tests/tcmalloc_unittest.cc	/^static void TestHugeAllocations(AllocatorState* rnd) {$/;"	f	namespace:testing	signature:(AllocatorState* rnd)
TestHugeThreadCache	src/tests/tcmalloc_unittest.cc	/^static void TestHugeThreadCache() {$/;"	f	namespace:testing	signature:()
TestIdleUsage	src/tests/markidle_unittest.cc	/^static void TestIdleUsage() {$/;"	f	file:	signature:()
TestLRand64Spread	src/tests/sampler_test.cc	/^void TestLRand64Spread() {$/;"	f	signature:()
TestLeakButTotalsMatch	src/tests/heap-checker_unittest.cc	/^static void TestLeakButTotalsMatch() {$/;"	f	file:	signature:()
TestLibCAllocate	src/tests/heap-checker_unittest.cc	/^static void TestLibCAllocate() {$/;"	f	file:	signature:()
TestLoad	src/tests/atomicops_unittest.cc	/^static void TestLoad() {$/;"	f	file:	signature:()
TestMallocAlignment	src/tests/tcmalloc_unittest.cc	/^static void TestMallocAlignment() {$/;"	f	namespace:testing	signature:()
TestMallocExtension	src/tests/malloc_extension_c_test.c	/^void TestMallocExtension(void) {$/;"	f	signature:(void)
TestMallocHook	src/tests/malloc_extension_c_test.c	/^void TestMallocHook(void) {$/;"	f	signature:(void)
TestMap	src/tests/pagemap_unittest.cc	/^void TestMap(int limit, bool limit_is_below_the_overflow_boundary) {$/;"	f	signature:(int limit, bool limit_is_below_the_overflow_boundary)
TestNAllocX	src/tests/tcmalloc_unittest.cc	/^static void TestNAllocX() {$/;"	f	namespace:testing	signature:()
TestNAllocXAlignment	src/tests/tcmalloc_unittest.cc	/^static void TestNAllocXAlignment() {$/;"	f	namespace:testing	signature:()
TestNew	src/tests/tcmalloc_unittest.cc	/^static void TestNew(void* (*func)(size_t)) {$/;"	f	namespace:testing	signature:(void* (*func)(size_t))
TestNewHandler	src/tests/tcmalloc_unittest.cc	/^static void TestNewHandler() {$/;"	f	namespace:testing	signature:()
TestNewHook	src/tests/malloc_extension_c_test.c	/^void TestNewHook(const void* ptr, size_t size) {$/;"	f	signature:(const void* ptr, size_t size)
TestNewOOMHandling	src/tests/tcmalloc_unittest.cc	/^static ATTRIBUTE_NOINLINE void TestNewOOMHandling() {$/;"	f	namespace:testing	signature:()
TestNext	src/tests/pagemap_unittest.cc	/^void TestNext(const char* name) {$/;"	f	signature:(const char* name)
TestNextRandom	src/tests/sampler_test.cc	/^void TestNextRandom(int n) {$/;"	f	signature:(int n)
TestNothrowNew	src/tests/tcmalloc_unittest.cc	/^static void TestNothrowNew(void* (*func)(size_t, const std::nothrow_t&)) {$/;"	f	namespace:testing	signature:(void* (*func)(size_t, const std::nothrow_t&))
TestObjMakers	src/tests/heap-checker_unittest.cc	/^static void TestObjMakers() {$/;"	f	file:	signature:()
TestOneNew	src/tests/tcmalloc_unittest.cc	/^static void TestOneNew(void* (*func)(size_t)) {$/;"	f	namespace:testing	signature:(void* (*func)(size_t))
TestOneNothrowNew	src/tests/tcmalloc_unittest.cc	/^static void TestOneNothrowNew(void* (*func)(size_t, const std::nothrow_t&)) {$/;"	f	namespace:testing	signature:(void* (*func)(size_t, const std::nothrow_t&))
TestPageHeap_Limit	src/tests/page_heap_test.cc	/^static void TestPageHeap_Limit() {$/;"	f	namespace:__anon55	signature:()
TestPageHeap_Stats	src/tests/page_heap_test.cc	/^static void TestPageHeap_Stats() {$/;"	f	namespace:__anon55	signature:()
TestPatchUsingDynamicStub	src/windows/preamble_patcher_test.cc	/^bool TestPatchUsingDynamicStub() {$/;"	f	namespace:sidestep	signature:()
TestPatchWithLongJump	src/windows/preamble_patcher_test.cc	/^bool TestPatchWithLongJump() {$/;"	f	namespace:sidestep	signature:()
TestPatchWithPreambleAbsoluteJump	src/windows/preamble_patcher_test.cc	/^bool TestPatchWithPreambleAbsoluteJump() {$/;"	f	namespace:sidestep	signature:()
TestPatchWithPreambleNearRelativeCall	src/windows/preamble_patcher_test.cc	/^bool TestPatchWithPreambleNearRelativeCall() {$/;"	f	namespace:sidestep	signature:()
TestPatchWithPreambleNearRelativeCondJump	src/windows/preamble_patcher_test.cc	/^bool TestPatchWithPreambleNearRelativeCondJump() {$/;"	f	namespace:sidestep	signature:()
TestPatchWithPreambleShortCondJump	src/windows/preamble_patcher_test.cc	/^bool TestPatchWithPreambleShortCondJump() {$/;"	f	namespace:sidestep	signature:()
TestPickNextSample	src/tests/sampler_test.cc	/^void TestPickNextSample(int n) {$/;"	f	signature:(int n)
TestPointerReach	src/tests/heap-checker_unittest.cc	/^static void TestPointerReach(ObjMakerFunc obj_maker) {$/;"	f	file:	signature:(ObjMakerFunc obj_maker)
TestPreambleAllocation	src/windows/preamble_patcher_test.cc	/^bool TestPreambleAllocation() {$/;"	f	namespace:sidestep	signature:()
TestRanges	src/tests/tcmalloc_unittest.cc	/^static void TestRanges() {$/;"	f	namespace:testing	signature:()
TestRealloc	src/tests/tcmalloc_unittest.cc	/^static void TestRealloc() {$/;"	f	namespace:testing	signature:()
TestReleaseToSystem	src/tests/tcmalloc_unittest.cc	/^static void TestReleaseToSystem() {$/;"	f	namespace:testing	signature:()
TestSTLAlloc	src/tests/heap-checker_unittest.cc	/^static void TestSTLAlloc() {$/;"	f	file:	signature:()
TestSTLAllocInverse	src/tests/heap-checker_unittest.cc	/^static void TestSTLAllocInverse() {$/;"	f	file:	signature:()
TestSetNewMode	src/tests/tcmalloc_unittest.cc	/^static void TestSetNewMode() {$/;"	f	namespace:testing	signature:()
TestStore	src/tests/atomicops_unittest.cc	/^static void TestStore() {$/;"	f	file:	signature:()
TestTemporarilyIdleUsage	src/tests/markidle_unittest.cc	/^static void TestTemporarilyIdleUsage() {$/;"	f	file:	signature:()
TesterThread	src/tests/tcmalloc_unittest.cc	/^  TesterThread(int id)$/;"	f	class:testing::TesterThread	access:public	signature:(int id)
TesterThread	src/tests/tcmalloc_unittest.cc	/^class TesterThread {$/;"	c	namespace:testing	file:
Thread	src/tests/profile-handler_unittest.cc	/^  Thread() : joinable_(false) { }$/;"	f	class:__anon56::Thread	access:public	signature:()
Thread	src/tests/profile-handler_unittest.cc	/^class Thread {$/;"	c	namespace:__anon56	file:
ThreadCache	src/thread_cache.h	/^class ThreadCache {$/;"	c	namespace:tcmalloc
ThreadDisabledLeaks	src/tests/heap-checker_unittest.cc	/^static void ThreadDisabledLeaks() {$/;"	f	file:	signature:()
ThreadLocalData	src/thread_cache.h	/^  struct ThreadLocalData {$/;"	s	class:tcmalloc::ThreadCache	access:private
ThreadTimerDestructor	src/profile-handler.cc	/^  static void ThreadTimerDestructor(void *arg) {$/;"	f	file:	signature:(void *arg)
TickCounter	src/tests/profile-handler_unittest.cc	/^static void TickCounter(int sig, siginfo_t* sig_info, void *vuc,$/;"	f	namespace:__anon56	signature:(int sig, siginfo_t* sig_info, void *vuc, void* tick_counter)
TooShortFunction	src/windows/preamble_patcher_test.cc	/^extern "C" int TooShortFunction(int);$/;"	p	namespace:__anon12	file:	signature:(int)
TraceFd	src/debugallocation.cc	/^static int TraceFd() {$/;"	f	file:	signature:()
TracePrintf	src/debugallocation.cc	/^static void TracePrintf(int fd, const char *fmt, ...) {$/;"	f	file:	signature:(int fd, const char *fmt, ...)
TracePrintf	src/debugallocation.cc	/^static void TracePrintf(int fd, const char *fmt, ...)$/;"	p	file:	signature:(int fd, const char *fmt, ...)
TraceStack	src/debugallocation.cc	/^static void TraceStack(void) {$/;"	f	file:	signature:(void)
TransLeaks	src/tests/heap-checker_unittest.cc	/^static void TransLeaks() {$/;"	f	file:	signature:()
Traverse	src/malloc_hook-inl.h	/^  int Traverse(T* output_array, int n) const;$/;"	p	struct:base::internal::HookList	access:public	signature:(T* output_array, int n) const
Traverse	src/malloc_hook.cc	/^int HookList<T>::Traverse(T* output_array, int n) const {$/;"	f	class:base::internal::HookList	signature:(T* output_array, int n) const
TryAllocExpectFail	src/tests/tcmalloc_large_unittest.cc	/^void TryAllocExpectFail(size_t size) {$/;"	f	signature:(size_t size)
TryAllocMightFail	src/tests/tcmalloc_large_unittest.cc	/^void TryAllocMightFail(size_t size) {$/;"	f	signature:(size_t size)
TryGet	src/packed-cache-inl.h	/^  bool TryGet(K key, V* out) const {$/;"	f	class:PackedCache	access:public	signature:(K key, V* out) const
TryGetSizeClass	src/page_heap.h	/^  bool TryGetSizeClass(PageID p, uint32* out) const {$/;"	f	class:tcmalloc::PageHeap	access:public	signature:(PageID p, uint32* out) const
TryHugeAllocation	src/tests/tcmalloc_unittest.cc	/^static void TryHugeAllocation(size_t s, AllocatorState* rnd) {$/;"	f	namespace:testing	signature:(size_t s, AllocatorState* rnd)
TryLock	src/base/simple_mutex.h	/^  inline bool TryLock(); \/\/ If free, Lock() and return true, else return false$/;"	p	class:MUTEX_NAMESPACE::Mutex	access:public	signature:()
TryLock	src/base/simple_mutex.h	/^bool Mutex::TryLock()      { if (mutex_) return false; Lock(); return true; }$/;"	f	class:MUTEX_NAMESPACE::Mutex	signature:()
TryLock	src/base/simple_mutex.h	/^bool Mutex::TryLock()      { return is_safe_ ?$/;"	f	class:MUTEX_NAMESPACE::Mutex	signature:()
TryPop	src/thread_cache.h	/^    bool TryPop(void **rv) {$/;"	f	class:tcmalloc::ThreadCache::FreeList	access:public	signature:(void **rv)
TryRecordAllocationFast	src/sampler.h	/^  bool TryRecordAllocationFast(size_t k);$/;"	p	class:tcmalloc::Sampler	access:public	signature:(size_t k)
TryRecordAllocationFast	src/sampler.h	/^inline bool Sampler::TryRecordAllocationFast(size_t k) {$/;"	f	class:tcmalloc::Sampler	signature:(size_t k)
TryRecordAllocationFast	src/thread_cache.h	/^  bool TryRecordAllocationFast(size_t k);$/;"	p	class:tcmalloc::ThreadCache	access:public	signature:(size_t k)
TryRecordAllocationFast	src/thread_cache.h	/^inline bool ThreadCache::TryRecordAllocationFast(size_t k) {$/;"	f	class:tcmalloc::ThreadCache	signature:(size_t k)
TurnItselfOffLocked	src/gperftools/heap-checker.h	/^  static void TurnItselfOffLocked();$/;"	p	class:HeapLeakChecker	access:private	signature:()
TurnItselfOffLocked	src/heap-checker.cc	/^void HeapLeakChecker::TurnItselfOffLocked() {$/;"	f	class:HeapLeakChecker	signature:()
Type	src/gperftools/malloc_extension.h	/^  enum Type {$/;"	g	struct:base::MallocRange	access:public
Type	src/page_heap.h	/^  typedef TCMalloc_PageMap2<32-kPageShift> Type;$/;"	t	class:tcmalloc::MapSelector	access:public
Type	src/page_heap.h	/^  typedef TCMalloc_PageMap2<48-kPageShift> Type;$/;"	t	class:tcmalloc::MapSelector	access:public
Type	src/page_heap.h	/^  typedef TCMalloc_PageMap3<BITS-kPageShift> Type;$/;"	t	class:tcmalloc::MapSelector	access:public
Type	src/tests/tcmalloc_unittest.cc	/^  enum Type { ALLOC, FREE, UPDATE, PASS };$/;"	g	class:testing::TesterThread	file:	access:private
Type	src/tests/tcmalloc_unittest.cc	/^  struct Type {$/;"	s	class:testing::TestHarness	file:	access:private
U	src/tests/frag_unittest-frag_unittest.o	/^/;"	v
UNAME_MACHINE	config.guess	/^		UNAME_MACHINE=`(uname -p) 2>\/dev\/null`$/;"	v
UNAME_MACHINE	config.guess	/^	    *Pent*|*Celeron) UNAME_MACHINE=i686 ;;$/;"	v
UNAME_MACHINE	config.guess	/^	    *Pentium)	     UNAME_MACHINE=i586 ;;$/;"	v
UNAME_MACHINE	config.guess	/^    	UNAME_MACHINE=`(uname -p) 2>\/dev\/null`$/;"	v
UNAME_MACHINE	config.guess	/^UNAME_MACHINE=`(uname -m) 2>\/dev\/null` || UNAME_MACHINE=unknown$/;"	v
UNAME_MACHINE_ARCH	config.guess	/^	UNAME_MACHINE_ARCH=`arch | sed 's\/OpenBSD.\/\/'`$/;"	v
UNAME_PROCESSOR	config.guess	/^		      UNAME_PROCESSOR="x86_64"$/;"	v
UNAME_PROCESSOR	config.guess	/^		UNAME_PROCESSOR=i386$/;"	v
UNAME_PROCESSOR	config.guess	/^	    unknown) UNAME_PROCESSOR=powerpc ;;$/;"	v
UNAME_PROCESSOR	config.guess	/^	UNAME_PROCESSOR=`uname -p` || UNAME_PROCESSOR=unknown$/;"	v
UNAME_PROCESSOR	config.guess	/^	UNAME_PROCESSOR=`uname -p`$/;"	v
UNAME_PROCESSOR	config.guess	/^        UNAME_PROCESSOR=`\/usr\/bin\/uname -p`$/;"	v
UNAME_REL	config.guess	/^		UNAME_REL=`(\/bin\/uname -X|grep Release|sed -e 's\/.*= \/\/')`$/;"	v
UNAME_REL	config.guess	/^		UNAME_REL=`sed -n 's\/.*Version \/\/p' <\/usr\/options\/cb.name`$/;"	v
UNAME_RELEASE	config.guess	/^		UNAME_RELEASE=`uname -v`$/;"	v
UNITTEST_DIR	src/tests/maybe_threads_unittest.sh	/^UNITTEST_DIR=${1:-$BINDIR}$/;"	v
UNKNOWN	src/gperftools/malloc_extension.h	/^    UNKNOWN$/;"	e	enum:base::MallocRange::Type
UNKNOWN_DIRECTION	src/heap-checker.cc	/^  UNKNOWN_DIRECTION$/;"	e	enum:StackDirection	file:
UNLOCK_FUNCTION	src/base/thread_annotations.h	127;"	d
UNLOCK_FUNCTION	src/memory_region_map.h	/^  static void Unlock() UNLOCK_FUNCTION(lock_);$/;"	p	class:MemoryRegionMap	access:public	signature:(lock_)
UNMAPPED	src/gperftools/malloc_extension.h	/^    UNMAPPED,             \/\/ Backing physical memory has been returned to the OS$/;"	e	enum:base::MallocRange::Type
UNPATCH	src/windows/preamble_patcher_test.cc	63;"	d	file:
UNW_LOCAL_ONLY	src/stacktrace_libunwind-inl.h	42;"	d
UPDATE	src/tests/tcmalloc_unittest.cc	/^  enum Type { ALLOC, FREE, UPDATE, PASS };$/;"	e	enum:testing::TesterThread::Type	file:
URL_FETCHER	src/pprof	/^my @URL_FETCHER = ("curl", "-s");$/;"	v
USE	src/windows/shortproc.asm	/^; (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE$/;"	v
USE_RESOURCE	src/tests/testutil.cc	59;"	d	file:
UnHide	src/tests/heap-checker_unittest.cc	/^static void UnHide(T** ptr) {$/;"	f	file:	signature:(T** ptr)
UnIgnoreObject	src/gperftools/heap-checker.h	/^  static void UnIgnoreObject(const void* ptr);$/;"	p	class:HeapLeakChecker	access:public	signature:(const void* ptr)
UnIgnoreObject	src/heap-checker.cc	/^void HeapLeakChecker::UnIgnoreObject(const void* ptr) {$/;"	f	class:HeapLeakChecker	signature:(const void* ptr)
UnMapPages	src/base/low_level_alloc.cc	/^    virtual void UnMapPages(int32 flags, void *addr, size_t size);$/;"	p	class:__anon38::DefaultPagesAllocator	file:	access:public	signature:(int32 flags, void *addr, size_t size)
UnMapPages	src/base/low_level_alloc.cc	/^void DefaultPagesAllocator::UnMapPages(int32 flags, void *region, size_t size) {$/;"	f	class:DefaultPagesAllocator	signature:(int32 flags, void *region, size_t size)
UnMapPages	src/base/low_level_alloc.h	/^    virtual void UnMapPages(int32 flags, void *addr, size_t size) = 0;$/;"	p	class:LowLevelAlloc::PagesAllocator	access:public	signature:(int32 flags, void *addr, size_t size)
UnMapPages	src/emergency_malloc.cc	/^    void UnMapPages(int32 flags, void *addr, size_t size) {$/;"	f	class:tcmalloc::EmergencyArenaPagesAllocator	file:	access:private	signature:(int32 flags, void *addr, size_t size)
UnhookedMMap	src/gperftools/malloc_hook.h	/^  static void* UnhookedMMap(void *start, size_t length, int prot, int flags,$/;"	p	class:MallocHook	access:public	signature:(void *start, size_t length, int prot, int flags, int fd, off_t offset)
UnhookedMMap	src/malloc_hook.cc	/^\/*static*\/void* MallocHook::UnhookedMMap(void *start, size_t length, int prot,$/;"	f	class:MallocHook	signature:(void *start, size_t length, int prot, int flags, int fd, off_t offset)
UnhookedMMap	src/malloc_hook_mmap_freebsd.h	/^\/*static*\/void* MallocHook::UnhookedMMap(void *start, size_t length, int prot,$/;"	f	class:MallocHook	signature:(void *start, size_t length, int prot, int flags, int fd, off_t offset)
UnhookedMMap	src/malloc_hook_mmap_linux.h	/^\/*static*\/void* MallocHook::UnhookedMMap(void *start, size_t length, int prot,$/;"	f	class:MallocHook	signature:(void *start, size_t length, int prot, int flags, int fd, off_t offset)
UnhookedMUnmap	src/gperftools/malloc_hook.h	/^  static int UnhookedMUnmap(void *start, size_t length);$/;"	p	class:MallocHook	access:public	signature:(void *start, size_t length)
UnhookedMUnmap	src/malloc_hook.cc	/^\/*static*\/int MallocHook::UnhookedMUnmap(void *start, size_t length) {$/;"	f	class:MallocHook	signature:(void *start, size_t length)
UnhookedMUnmap	src/malloc_hook_mmap_freebsd.h	/^\/*static*\/int MallocHook::UnhookedMUnmap(void *start, size_t length) {$/;"	f	class:MallocHook	signature:(void *start, size_t length)
UnhookedMUnmap	src/malloc_hook_mmap_linux.h	/^\/*static*\/int MallocHook::UnhookedMUnmap(void *start, size_t length) {$/;"	f	class:MallocHook	signature:(void *start, size_t length)
Uniform	src/tests/addressmap_unittest.cc	/^  size_t Uniform(size_t max_size) {$/;"	f	struct:UniformRandomNumberGenerator	access:public	signature:(size_t max_size)
Uniform	src/tests/tcmalloc_unittest.cc	/^  int Uniform(int n) {$/;"	f	class:testing::TestHarness	access:public	signature:(int n)
UniformRandomNumberGenerator	src/tests/addressmap_unittest.cc	/^struct UniformRandomNumberGenerator {$/;"	s	file:
UniformRandomNumberGenerator::Uniform	src/tests/addressmap_unittest.cc	/^  size_t Uniform(size_t max_size) {$/;"	f	struct:UniformRandomNumberGenerator	access:public	signature:(size_t max_size)
UnitTests	src/windows/preamble_patcher_test.cc	/^bool UnitTests() {$/;"	f	namespace:sidestep	signature:()
Unlock	src/base/simple_mutex.h	/^  inline void Unlock();  \/\/ Release a lock acquired via Lock()$/;"	p	class:MUTEX_NAMESPACE::Mutex	access:public	signature:()
Unlock	src/base/simple_mutex.h	/^void Mutex::Unlock()       { SAFE_PTHREAD(pthread_mutex_unlock); }$/;"	f	class:MUTEX_NAMESPACE::Mutex	signature:()
Unlock	src/base/simple_mutex.h	/^void Mutex::Unlock()       { SAFE_PTHREAD(pthread_rwlock_unlock); }$/;"	f	class:MUTEX_NAMESPACE::Mutex	signature:()
Unlock	src/base/simple_mutex.h	/^void Mutex::Unlock()       { assert(mutex_++ == -1); }$/;"	f	class:MUTEX_NAMESPACE::Mutex	signature:()
Unlock	src/base/simple_mutex.h	/^void Mutex::Unlock()       { if (is_safe_) LeaveCriticalSection(&mutex_); }$/;"	f	class:MUTEX_NAMESPACE::Mutex	signature:()
Unlock	src/base/spinlock.h	/^  inline void Unlock() \/*UNLOCK_FUNCTION()*\/ {$/;"	f	class:SpinLock	access:public	signature:()
Unlock	src/central_freelist.h	/^  void Unlock() {$/;"	f	class:tcmalloc::CentralFreeList	access:public	signature:()
Unlock	src/memory_region_map.cc	/^void MemoryRegionMap::Unlock() {$/;"	f	class:MemoryRegionMap	signature:()
UnmapSize	src/memory_region_map.h	/^  static int64 UnmapSize() { return unmap_size_; }$/;"	f	class:MemoryRegionMap	access:public	signature:()
UnparseBucket	src/heap-profile-table.cc	/^int HeapProfileTable::UnparseBucket(const Bucket& b,$/;"	f	class:HeapProfileTable	signature:(const Bucket& b, char* buf, int buflen, int bufsize, const char* extra, Stats* profile_stats)
UnparseBucket	src/heap-profile-table.h	/^  static int UnparseBucket(const Bucket& b,$/;"	p	class:HeapProfileTable	access:private	signature:(const Bucket& b, char* buf, int buflen, int bufsize, const char* extra, Stats* profile_stats)
Unpatch	src/windows/patch_functions.cc	/^  void Unpatch();$/;"	p	class:__anon13::LibcInfoWithPatchFunctions	file:	access:public	signature:()
Unpatch	src/windows/patch_functions.cc	/^  void Unpatch();$/;"	p	class:__anon13::WindowsInfo	file:	access:public	signature:()
Unpatch	src/windows/patch_functions.cc	/^void LibcInfoWithPatchFunctions<T>::Unpatch() {$/;"	f	class:__anon13::LibcInfoWithPatchFunctions	signature:()
Unpatch	src/windows/patch_functions.cc	/^void WindowsInfo::Unpatch() {$/;"	f	class:__anon13::WindowsInfo	signature:()
Unpatch	src/windows/preamble_patcher.cc	/^SideStepError PreamblePatcher::Unpatch(void* target_function,$/;"	f	class:sidestep::PreamblePatcher	signature:(void* target_function, void* replacement_function, void* original_function_stub)
Unpatch	src/windows/preamble_patcher.h	/^  static SideStepError Unpatch(void* target_function,$/;"	p	class:sidestep::PreamblePatcher	access:public	signature:(void* target_function, void* replacement_function, void* original_function_stub)
UnregisterCallback	src/profile-handler.cc	/^void ProfileHandler::UnregisterCallback(ProfileHandlerToken* token) {$/;"	f	class:ProfileHandler	signature:(ProfileHandlerToken* token)
UnregisterCallback	src/tests/profile-handler_unittest.cc	/^  void UnregisterCallback(ProfileHandlerToken* token) {$/;"	f	class:__anon56::ProfileHandlerTest	access:protected	signature:(ProfileHandlerToken* token)
Update	src/base/elf_mem_image.cc	/^void ElfMemImage::SymbolIterator::Update(int increment) {$/;"	f	class:base::ElfMemImage::SymbolIterator	signature:(int increment)
Update	src/base/elf_mem_image.h	/^    void Update(int incr);$/;"	p	class:base::ElfMemImage::SymbolIterator	access:private	signature:(int incr)
UpdateObject	src/tests/tcmalloc_unittest.cc	/^  void UpdateObject() {$/;"	f	class:testing::TesterThread	access:public	signature:()
UpdateTimer	src/profile-handler.cc	/^void ProfileHandler::UpdateTimer(bool enable) {$/;"	f	class:ProfileHandler	signature:(bool enable)
Use	src/tests/heap-checker_unittest.cc	/^static void Use(T** foo) {$/;"	f	file:	signature:(T** foo)
UseProcMapsLocked	src/gperftools/heap-checker.h	/^  static ProcMapsResult UseProcMapsLocked(ProcMapsTask proc_maps_task);$/;"	p	class:HeapLeakChecker	access:private	signature:(ProcMapsTask proc_maps_task)
UseProcMapsLocked	src/heap-checker.cc	/^HeapLeakChecker::ProcMapsResult HeapLeakChecker::UseProcMapsLocked($/;"	f	class:HeapLeakChecker	signature:( ProcMapsTask proc_maps_task)
V	src/.libs/libtcmalloc_minimal_internal_la-internal_logging.o	/^/;"	v
V	src/packed-cache-inl.h	/^  typedef uint32 V;$/;"	t	class:PackedCache	access:public
V	src/tests/profiledata_unittest.cc	/^inline void* V(intptr_t x) { return reinterpret_cast<void*>(x); }$/;"	f	namespace:__anon53	signature:(intptr_t x)
VALGRIND_BRANCH_AND_LINK_TO_NOREDIR_R11	src/third_party/valgrind.h	337;"	d
VALGRIND_BRANCH_AND_LINK_TO_NOREDIR_R11	src/third_party/valgrind.h	402;"	d
VALGRIND_BRANCH_AND_LINK_TO_NOREDIR_R11	src/third_party/valgrind.h	474;"	d
VALGRIND_BRANCH_AND_LINK_TO_NOREDIR_R11	src/third_party/valgrind.h	546;"	d
VALGRIND_CALL_NOREDIR_EAX	src/third_party/valgrind.h	223;"	d
VALGRIND_CALL_NOREDIR_RAX	src/third_party/valgrind.h	277;"	d
VALGRIND_COUNT_ERRORS	src/third_party/valgrind.h	3773;"	d
VALGRIND_CREATE_MEMPOOL	src/third_party/valgrind.h	3826;"	d
VALGRIND_DESTROY_MEMPOOL	src/third_party/valgrind.h	3834;"	d
VALGRIND_DISCARD_TRANSLATIONS	src/third_party/valgrind.h	3652;"	d
VALGRIND_DO_CLIENT_REQUEST	src/third_party/valgrind.h	131;"	d
VALGRIND_DO_CLIENT_REQUEST	src/third_party/valgrind.h	189;"	d
VALGRIND_DO_CLIENT_REQUEST	src/third_party/valgrind.h	243;"	d
VALGRIND_DO_CLIENT_REQUEST	src/third_party/valgrind.h	297;"	d
VALGRIND_DO_CLIENT_REQUEST	src/third_party/valgrind.h	358;"	d
VALGRIND_DO_CLIENT_REQUEST	src/third_party/valgrind.h	424;"	d
VALGRIND_DO_CLIENT_REQUEST	src/third_party/valgrind.h	496;"	d
VALGRIND_FREELIKE_BLOCK	src/third_party/valgrind.h	3818;"	d
VALGRIND_GET_NR_CONTEXT	src/third_party/valgrind.h	210;"	d
VALGRIND_GET_NR_CONTEXT	src/third_party/valgrind.h	264;"	d
VALGRIND_GET_NR_CONTEXT	src/third_party/valgrind.h	323;"	d
VALGRIND_GET_NR_CONTEXT	src/third_party/valgrind.h	381;"	d
VALGRIND_GET_NR_CONTEXT	src/third_party/valgrind.h	451;"	d
VALGRIND_GET_NR_CONTEXT	src/third_party/valgrind.h	523;"	d
VALGRIND_GET_ORIG_FN	src/third_party/valgrind.h	594;"	d
VALGRIND_MALLOCLIKE_BLOCK	src/third_party/valgrind.h	3807;"	d
VALGRIND_MEMPOOL_ALLOC	src/third_party/valgrind.h	3842;"	d
VALGRIND_MEMPOOL_CHANGE	src/third_party/valgrind.h	3874;"	d
VALGRIND_MEMPOOL_EXISTS	src/third_party/valgrind.h	3882;"	d
VALGRIND_MEMPOOL_FREE	src/third_party/valgrind.h	3850;"	d
VALGRIND_MEMPOOL_TRIM	src/third_party/valgrind.h	3858;"	d
VALGRIND_MOVE_MEMPOOL	src/third_party/valgrind.h	3866;"	d
VALGRIND_NON_SIMD_CALL0	src/third_party/valgrind.h	3728;"	d
VALGRIND_NON_SIMD_CALL1	src/third_party/valgrind.h	3738;"	d
VALGRIND_NON_SIMD_CALL2	src/third_party/valgrind.h	3748;"	d
VALGRIND_NON_SIMD_CALL3	src/third_party/valgrind.h	3758;"	d
VALGRIND_PRINTF	src/third_party/valgrind.h	/^VALGRIND_PRINTF(const char *format, ...)$/;"	f	signature:(const char *format, ...)
VALGRIND_PRINTF	src/third_party/valgrind.h	/^static int VALGRIND_PRINTF(const char *format, ...)$/;"	p	signature:(const char *format, ...)
VALGRIND_PRINTF	src/third_party/valgrind.h	3665;"	d
VALGRIND_PRINTF_BACKTRACE	src/third_party/valgrind.h	/^VALGRIND_PRINTF_BACKTRACE(const char *format, ...)$/;"	f	signature:(const char *format, ...)
VALGRIND_PRINTF_BACKTRACE	src/third_party/valgrind.h	/^static int VALGRIND_PRINTF_BACKTRACE(const char *format, ...)$/;"	p	signature:(const char *format, ...)
VALGRIND_PRINTF_BACKTRACE	src/third_party/valgrind.h	3666;"	d
VALGRIND_STACK_CHANGE	src/third_party/valgrind.h	3909;"	d
VALGRIND_STACK_DEREGISTER	src/third_party/valgrind.h	3901;"	d
VALGRIND_STACK_REGISTER	src/third_party/valgrind.h	3891;"	d
VDSOInitHelper	src/base/vdso_support.cc	/^  VDSOInitHelper() { VDSOSupport::Init(); }$/;"	f	class:base::VDSOInitHelper	access:public	signature:()
VDSOInitHelper	src/base/vdso_support.cc	/^static class VDSOInitHelper {$/;"	c	namespace:base	file:
VDSOSupport	src/base/vdso_support.cc	/^VDSOSupport::VDSOSupport()$/;"	f	class:base::VDSOSupport	signature:()
VDSOSupport	src/base/vdso_support.h	/^  VDSOSupport();$/;"	p	class:base::VDSOSupport	access:public	signature:()
VDSOSupport	src/base/vdso_support.h	/^class VDSOSupport {$/;"	c	namespace:base
VERSION	src/config.h	290;"	d
VERSION	src/config.h.in	289;"	d	file:
VERSION	src/windows/config.h	290;"	d
VERSYM_VERSION	src/base/elf_mem_image.cc	55;"	d	file:
VG_CONTRACT_FRAME_BY	src/third_party/valgrind.h	2462;"	d
VG_CONTRACT_FRAME_BY	src/third_party/valgrind.h	3023;"	d
VG_EXPAND_FRAME_BY_trashes_r3	src/third_party/valgrind.h	2457;"	d
VG_EXPAND_FRAME_BY_trashes_r3	src/third_party/valgrind.h	3018;"	d
VG_IS_TOOL_USERREQ	src/third_party/valgrind.h	3581;"	d
VG_USERREQ_TOOL_BASE	src/third_party/valgrind.h	3579;"	d
VG_USERREQ__CLIENT_CALL0	src/third_party/valgrind.h	/^          VG_USERREQ__CLIENT_CALL0 = 0x1101,$/;"	e	enum:__anon28
VG_USERREQ__CLIENT_CALL1	src/third_party/valgrind.h	/^          VG_USERREQ__CLIENT_CALL1 = 0x1102,$/;"	e	enum:__anon28
VG_USERREQ__CLIENT_CALL2	src/third_party/valgrind.h	/^          VG_USERREQ__CLIENT_CALL2 = 0x1103,$/;"	e	enum:__anon28
VG_USERREQ__CLIENT_CALL3	src/third_party/valgrind.h	/^          VG_USERREQ__CLIENT_CALL3 = 0x1104,$/;"	e	enum:__anon28
VG_USERREQ__COUNT_ERRORS	src/third_party/valgrind.h	/^          VG_USERREQ__COUNT_ERRORS = 0x1201,$/;"	e	enum:__anon28
VG_USERREQ__CREATE_MEMPOOL	src/third_party/valgrind.h	/^          VG_USERREQ__CREATE_MEMPOOL   = 0x1303,$/;"	e	enum:__anon28
VG_USERREQ__DESTROY_MEMPOOL	src/third_party/valgrind.h	/^          VG_USERREQ__DESTROY_MEMPOOL  = 0x1304,$/;"	e	enum:__anon28
VG_USERREQ__DISCARD_TRANSLATIONS	src/third_party/valgrind.h	/^          VG_USERREQ__DISCARD_TRANSLATIONS = 0x1002,$/;"	e	enum:__anon28
VG_USERREQ__FREELIKE_BLOCK	src/third_party/valgrind.h	/^          VG_USERREQ__FREELIKE_BLOCK   = 0x1302,$/;"	e	enum:__anon28
VG_USERREQ__MALLOCLIKE_BLOCK	src/third_party/valgrind.h	/^          VG_USERREQ__MALLOCLIKE_BLOCK = 0x1301,$/;"	e	enum:__anon28
VG_USERREQ__MEMPOOL_ALLOC	src/third_party/valgrind.h	/^          VG_USERREQ__MEMPOOL_ALLOC    = 0x1305,$/;"	e	enum:__anon28
VG_USERREQ__MEMPOOL_CHANGE	src/third_party/valgrind.h	/^          VG_USERREQ__MEMPOOL_CHANGE   = 0x1309,$/;"	e	enum:__anon28
VG_USERREQ__MEMPOOL_EXISTS	src/third_party/valgrind.h	/^          VG_USERREQ__MEMPOOL_EXISTS   = 0x130a,$/;"	e	enum:__anon28
VG_USERREQ__MEMPOOL_FREE	src/third_party/valgrind.h	/^          VG_USERREQ__MEMPOOL_FREE     = 0x1306,$/;"	e	enum:__anon28
VG_USERREQ__MEMPOOL_TRIM	src/third_party/valgrind.h	/^          VG_USERREQ__MEMPOOL_TRIM     = 0x1307,$/;"	e	enum:__anon28
VG_USERREQ__MOVE_MEMPOOL	src/third_party/valgrind.h	/^          VG_USERREQ__MOVE_MEMPOOL     = 0x1308,$/;"	e	enum:__anon28
VG_USERREQ__PRINTF	src/third_party/valgrind.h	/^          VG_USERREQ__PRINTF           = 0x1401,$/;"	e	enum:__anon28
VG_USERREQ__PRINTF_BACKTRACE	src/third_party/valgrind.h	/^          VG_USERREQ__PRINTF_BACKTRACE = 0x1402,$/;"	e	enum:__anon28
VG_USERREQ__RUNNING_ON_VALGRIND	src/third_party/valgrind.h	/^   enum { VG_USERREQ__RUNNING_ON_VALGRIND  = 0x1001,$/;"	e	enum:__anon28
VG_USERREQ__STACK_CHANGE	src/third_party/valgrind.h	/^          VG_USERREQ__STACK_CHANGE     = 0x1503$/;"	e	enum:__anon28
VG_USERREQ__STACK_DEREGISTER	src/third_party/valgrind.h	/^          VG_USERREQ__STACK_DEREGISTER = 0x1502,$/;"	e	enum:__anon28
VG_USERREQ__STACK_REGISTER	src/third_party/valgrind.h	/^          VG_USERREQ__STACK_REGISTER   = 0x1501,$/;"	e	enum:__anon28
VLOG	src/base/logging.h	/^inline void VLOG(int lvl, const char* pat, ...)     { LOG_PRINTF(lvl, pat); }$/;"	f	signature:(int lvl, const char* pat, ...)
VLOG	src/tests/heap-checker_unittest.cc	166;"	d	file:
VLOG	src/tests/heap-checker_unittest.cc	167;"	d	file:
VLOG_IS_ON	src/base/logging.h	215;"	d
VPATH	Makefile.in	/^VPATH = @srcdir@$/;"	v
ValgrindSlowdown	src/base/dynamic_annotations.c	/^double ValgrindSlowdown(void) {$/;"	f	signature:(void)
ValgrindSlowdown	src/base/dynamic_annotations.h	/^double ValgrindSlowdown(void);$/;"	p	signature:(void)
Valid	src/base/sysinfo.cc	/^bool ProcMapsIterator::Valid() const {$/;"	f	class:ProcMapsIterator	signature:() const
Valid	src/base/sysinfo.h	/^  bool Valid() const;$/;"	p	class:ProcMapsIterator	access:public	signature:() const
Valid	src/tests/memalign_unittest.cc	/^static bool Valid(const void* p, int n, char seed) {$/;"	f	file:	signature:(const void* p, int n, char seed)
Valid	src/tests/realloc_unittest.cc	/^static bool Valid(unsigned char* buffer, int n) {$/;"	f	file:	signature:(unsigned char* buffer, int n)
ValidateProfile	src/tests/profiledata_unittest.cc	/^  string ValidateProfile();$/;"	p	class:__anon53::ProfileDataChecker	file:	access:public	signature:()
ValidateProfile	src/tests/profiledata_unittest.cc	/^string ProfileDataChecker::ValidateProfile() {$/;"	f	class:__anon53::ProfileDataChecker	signature:()
ValueSizeFunc	src/addressmap-inl.h	/^  typedef size_t (*ValueSizeFunc)(const Value& v);$/;"	t	class:AddressMap	access:public
ValueT	src/tests/addressmap_unittest.cc	/^typedef pair<int, size_t> ValueT;$/;"	t	file:
VerifyAllMemory	src/debugallocation.cc	/^  virtual bool VerifyAllMemory() {$/;"	f	class:DebugMallocImplementation	access:public	signature:()
VerifyAllMemory	src/gperftools/malloc_extension.h	/^  virtual bool VerifyAllMemory();$/;"	p	class:MallocExtension	access:public	signature:()
VerifyAllMemory	src/malloc_extension.cc	/^bool MallocExtension::VerifyAllMemory() { return true; }$/;"	f	class:MallocExtension	signature:()
VerifyArrayNewMemory	src/debugallocation.cc	/^  virtual bool VerifyArrayNewMemory(const void* p) {$/;"	f	class:DebugMallocImplementation	access:public	signature:(const void* p)
VerifyArrayNewMemory	src/gperftools/malloc_extension.h	/^  virtual bool VerifyArrayNewMemory(const void* p);$/;"	p	class:MallocExtension	access:public	signature:(const void* p)
VerifyArrayNewMemory	src/malloc_extension.cc	/^bool MallocExtension::VerifyArrayNewMemory(const void* p) { return true; }$/;"	f	class:MallocExtension	signature:(const void* p)
VerifyDisabled	src/tests/profile-handler_unittest.cc	/^  void VerifyDisabled() {$/;"	f	class:__anon56::ProfileHandlerTest	access:protected	signature:()
VerifyHeapProfileTableStackGet	src/gperftools/heap-checker.h	/^  friend void VerifyHeapProfileTableStackGet();$/;"	p	class:HeapLeakChecker	access:friend	signature:()
VerifyHeapProfileTableStackGet	src/tests/heap-checker_unittest.cc	/^extern void VerifyHeapProfileTableStackGet() {$/;"	f	signature:()
VerifyLeaks	src/tests/heap-checker_unittest.cc	/^static void VerifyLeaks(HeapLeakChecker* check, CheckType type,$/;"	f	file:	signature:(HeapLeakChecker* check, CheckType type, int leaked_bytes, int leaked_objects)
VerifyMallocMemory	src/debugallocation.cc	/^  virtual bool VerifyMallocMemory(const void* p) {$/;"	f	class:DebugMallocImplementation	access:public	signature:(const void* p)
VerifyMallocMemory	src/gperftools/malloc_extension.h	/^  virtual bool VerifyMallocMemory(const void* p);$/;"	p	class:MallocExtension	access:public	signature:(const void* p)
VerifyMallocMemory	src/malloc_extension.cc	/^bool MallocExtension::VerifyMallocMemory(const void* p) { return true; }$/;"	f	class:MallocExtension	signature:(const void* p)
VerifyMemoryRegionMapStackGet	src/tests/heap-checker_unittest.cc	/^static void VerifyMemoryRegionMapStackGet() {$/;"	f	file:	signature:()
VerifyNewMemory	src/debugallocation.cc	/^  virtual bool VerifyNewMemory(const void* p) {$/;"	f	class:DebugMallocImplementation	access:public	signature:(const void* p)
VerifyNewMemory	src/gperftools/malloc_extension.h	/^  virtual bool VerifyNewMemory(const void* p);$/;"	p	class:MallocExtension	access:public	signature:(const void* p)
VerifyNewMemory	src/malloc_extension.cc	/^bool MallocExtension::VerifyNewMemory(const void* p) { return true; }$/;"	f	class:MallocExtension	signature:(const void* p)
VerifyRegistration	src/tests/profile-handler_unittest.cc	/^  void VerifyRegistration(const int& tick_counter) {$/;"	f	class:__anon56::ProfileHandlerTest	access:protected	signature:(const int& tick_counter)
VerifyUnregistration	src/tests/profile-handler_unittest.cc	/^  void VerifyUnregistration(const int& tick_counter) {$/;"	f	class:__anon56::ProfileHandlerTest	access:protected	signature:(const int& tick_counter)
Vg_ClientRequest	src/third_party/valgrind.h	/^   } Vg_ClientRequest;$/;"	t	typeref:enum:__anon28
VirtualSysAllocator	src/windows/system-alloc.cc	/^  VirtualSysAllocator() : SysAllocator() {$/;"	f	class:VirtualSysAllocator	access:public	signature:()
VirtualSysAllocator	src/windows/system-alloc.cc	/^class VirtualSysAllocator : public SysAllocator {$/;"	c	file:	inherits:SysAllocator
VirtualSysAllocator::Alloc	src/windows/system-alloc.cc	/^  void* Alloc(size_t size, size_t *actual_size, size_t alignment);$/;"	p	class:VirtualSysAllocator	file:	access:public	signature:(size_t size, size_t *actual_size, size_t alignment)
VirtualSysAllocator::Alloc	src/windows/system-alloc.cc	/^void* VirtualSysAllocator::Alloc(size_t size, size_t *actual_size,$/;"	f	class:VirtualSysAllocator	signature:(size_t size, size_t *actual_size, size_t alignment)
VirtualSysAllocator::VirtualSysAllocator	src/windows/system-alloc.cc	/^  VirtualSysAllocator() : SysAllocator() {$/;"	f	class:VirtualSysAllocator	access:public	signature:()
VoidFunction	src/base/googleinit.h	/^  typedef void (*VoidFunction)(void);$/;"	t	class:GoogleInitializer	access:public
W	src/tcm_min_asserts_unittest-thread_cache.o	/^/;"	v
WARNING	src/base/logging.h	/^enum LogSeverity {INFO = -1, WARNING = -2, ERROR = -3, FATAL = -4};$/;"	e	enum:LogSeverity
WARN_IF	src/tests/heap-checker_unittest.cc	163;"	d	file:
WARRANTIES	src/windows/shortproc.asm	/^; "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT$/;"	v
WEBSYM	src/windows/addr2line-pdb.c	49;"	d	file:
WEBSYM	src/windows/nm-pdb.c	60;"	d	file:
WIN32_DO_PATCHING	src/tcmalloc.cc	139;"	d	file:
WIN32_LEAN_AND_MEAN	src/base/simple_mutex.h	114;"	d
WIN32_LEAN_AND_MEAN	src/tests/testutil.cc	104;"	d	file:
WIN32_LEAN_AND_MEAN	src/windows/addr2line-pdb.c	38;"	d	file:
WIN32_LEAN_AND_MEAN	src/windows/nm-pdb.c	38;"	d	file:
WIN32_LEAN_AND_MEAN	src/windows/port.h	54;"	d
WIN32_LEAN_AND_MEAN	src/windows/preamble_patcher_test.cc	46;"	d	file:
WIN32_OVERRIDE_ALLOCATORS	src/windows/config.h	26;"	d
WRITE_TO_STDERR	src/base/logging.h	58;"	d
WRITE_TO_STDERR	src/base/logging.h	61;"	d
WRITE_TO_STDERR	src/base/logging.h	63;"	d
WindowsInfo	src/windows/patch_functions.cc	/^class WindowsInfo {$/;"	c	namespace:__anon13	file:
WindowsInfo::Perftools_FreeLibrary	src/windows/patch_functions.cc	/^BOOL WINAPI WindowsInfo::Perftools_FreeLibrary(HMODULE hLibModule) {$/;"	f	class:WindowsInfo	signature:(HMODULE hLibModule)
WindowsInfo::Perftools_HeapAlloc	src/windows/patch_functions.cc	/^LPVOID WINAPI WindowsInfo::Perftools_HeapAlloc(HANDLE hHeap, DWORD dwFlags,$/;"	f	class:WindowsInfo	signature:(HANDLE hHeap, DWORD dwFlags, DWORD_PTR dwBytes)
WindowsInfo::Perftools_HeapFree	src/windows/patch_functions.cc	/^BOOL WINAPI WindowsInfo::Perftools_HeapFree(HANDLE hHeap, DWORD dwFlags,$/;"	f	class:WindowsInfo	signature:(HANDLE hHeap, DWORD dwFlags, LPVOID lpMem)
WindowsInfo::Perftools_LoadLibraryExW	src/windows/patch_functions.cc	/^HMODULE WINAPI WindowsInfo::Perftools_LoadLibraryExW(LPCWSTR lpFileName,$/;"	f	class:WindowsInfo	signature:(LPCWSTR lpFileName, HANDLE hFile, DWORD dwFlags)
WindowsInfo::Perftools_MapViewOfFileEx	src/windows/patch_functions.cc	/^LPVOID WINAPI WindowsInfo::Perftools_MapViewOfFileEx($/;"	f	class:WindowsInfo	signature:( HANDLE hFileMappingObject, DWORD dwDesiredAccess, DWORD dwFileOffsetHigh, DWORD dwFileOffsetLow, SIZE_T dwNumberOfBytesToMap, LPVOID lpBaseAddress)
WindowsInfo::Perftools_UnmapViewOfFile	src/windows/patch_functions.cc	/^BOOL WINAPI WindowsInfo::Perftools_UnmapViewOfFile(LPCVOID lpBaseAddress) {$/;"	f	class:WindowsInfo	signature:(LPCVOID lpBaseAddress)
WindowsInfo::Perftools_VirtualAllocEx	src/windows/patch_functions.cc	/^LPVOID WINAPI WindowsInfo::Perftools_VirtualAllocEx(HANDLE process,$/;"	f	class:WindowsInfo	signature:(HANDLE process, LPVOID address, SIZE_T size, DWORD type, DWORD protect)
WindowsInfo::Perftools_VirtualFreeEx	src/windows/patch_functions.cc	/^BOOL WINAPI WindowsInfo::Perftools_VirtualFreeEx(HANDLE process, LPVOID address,$/;"	f	class:WindowsInfo	signature:(HANDLE process, LPVOID address, SIZE_T size, DWORD type)
WipeStack	src/tests/heap-checker_unittest.cc	/^static void WipeStack() { DoWipeStack(20); }$/;"	f	file:	signature:()
WriteMessage	src/internal_logging.cc	/^static void WriteMessage(const char* msg, int length) {$/;"	f	namespace:tcmalloc	signature:(const char* msg, int length)
WriteProfile	src/heap-profile-table.cc	/^bool HeapProfileTable::WriteProfile(const char* file_name,$/;"	f	class:HeapProfileTable	signature:(const char* file_name, const Bucket& total, AllocationMap* allocations)
WriteProfile	src/heap-profile-table.h	/^  static bool WriteProfile(const char* file_name,$/;"	p	class:HeapProfileTable	access:private	signature:(const char* file_name, const Bucket& total, AllocationMap* allocations)
WriteStringToFile	src/tests/sampling_test.cc	/^static void WriteStringToFile(const string& s, const string& filename) {$/;"	f	file:	signature:(const string& s, const string& filename)
WriteToStderr	src/windows/port.cc	/^extern "C" PERFTOOLS_DLL_DECL void WriteToStderr(const char* buf, int len) {$/;"	f	signature:(const char* buf, int len)
WriteToStderr	src/windows/port.h	/^EXTERN_C PERFTOOLS_DLL_DECL void WriteToStderr(const char* buf, int len);$/;"	p	signature:(const char* buf, int len)
WriterLock	src/base/simple_mutex.h	/^  inline void WriterLock() { Lock(); }     \/\/ Acquire an exclusive lock$/;"	f	class:MUTEX_NAMESPACE::Mutex	access:public	signature:()
WriterMutexLock	src/base/simple_mutex.h	/^  WriterMutexLock(const WriterMutexLock&);$/;"	p	class:MUTEX_NAMESPACE::WriterMutexLock	access:private	signature:(const WriterMutexLock&)
WriterMutexLock	src/base/simple_mutex.h	/^  explicit WriterMutexLock(Mutex *mu) : mu_(mu) { mu_->WriterLock(); }$/;"	f	class:MUTEX_NAMESPACE::WriterMutexLock	access:public	signature:(Mutex *mu)
WriterMutexLock	src/base/simple_mutex.h	/^class WriterMutexLock {$/;"	c	namespace:MUTEX_NAMESPACE
WriterMutexLock	src/base/simple_mutex.h	324;"	d
WriterUnlock	src/base/simple_mutex.h	/^  inline void WriterUnlock() { Unlock(); } \/\/ Release a lock from WriterLock()$/;"	f	class:MUTEX_NAMESPACE::Mutex	access:public	signature:()
X	src/tests/tcmalloc_large_unittest-tcmalloc_large_unittest.o	/^/;"	v
X	src/tests/tcmalloc_minimal_large_unittest-tcmalloc_large_unittest.o	/^/;"	v
X	tcm_min_asserts_unittest	/^ELF/;"	v
XT	src/libtcmalloc_internal_la-malloc_hook.o	/^»/;"	v
Xset	configure	/^  if test "X${echo_test_string+set}" != Xset; then$/;"	v
Xset	m4/libtool.m4	/^if test "X${COLLECT_NAMES+set}" != Xset; then$/;"	v
Y	src/.libs/libtcmalloc_internal_la-fake_stacktrace_scope.o	/^/;"	v
Y	src/.libs/libtcmalloc_minimal_internal_la-internal_logging.o	/^/;"	v
Y	src/libtcmalloc_minimal_internal_la-thread_cache.o	/^/;"	v
Z1	benchmark/unwind_bench-getcontext_light.o	/^/;"	v
ZD	src/libtcmalloc_internal_la-fake_stacktrace_scope.o	/^/;"	v
_	src/.libs/libtcmalloc_internal_la-internal_logging.o	/^/;"	v
_	src/.libs/libtcmalloc_internal_la-raw_printer.o	/^ü/;"	v
_	src/libtcmalloc_internal_la-raw_printer.o	/^ü/;"	v
_	src/libtcmalloc_internal_la-symbolize.o	/^c$:/;"	v
_	src/libtcmalloc_minimal_internal_la-symbolize.o	/^c$:/;"	v
_	src/tcm_min_asserts_unittest-thread_cache.o	/^/;"	v
_BASE_LOW_LEVEL_ALLOC_H_	src/base/low_level_alloc.h	33;"	d
_BASICTYPES_H_	src/base/basictypes.h	32;"	d
_CRT_SECURE_NO_DEPRECATE	src/windows/addr2line-pdb.c	40;"	d	file:
_CRT_SECURE_NO_DEPRECATE	src/windows/nm-pdb.c	40;"	d	file:
_CRT_SECURE_NO_WARNINGS	src/windows/addr2line-pdb.c	39;"	d	file:
_CRT_SECURE_NO_WARNINGS	src/windows/nm-pdb.c	39;"	d	file:
_CrtDbgReport	src/windows/override_functions.cc	/^int _CrtDbgReport(int, const char*, int, const char*, const char*, ...) {$/;"	f	signature:(int, const char*, int, const char*, const char*, ...)
_CrtDbgReportW	src/windows/override_functions.cc	/^int _CrtDbgReportW(int, const wchar_t*, int, const wchar_t*, const wchar_t*, ...) {$/;"	f	signature:(int, const wchar_t*, int, const wchar_t*, const wchar_t*, ...)
_CrtSetReportMode	src/windows/override_functions.cc	/^int _CrtSetReportMode(int, int) {$/;"	f	signature:(int, int)
_ELFCORE_H	src/base/elfcore.h	36;"	d
_GNU_SOURCE	src/getpc.h	52;"	d
_GOOGLEINIT_H	src/base/googleinit.h	35;"	d
_HPUX_SOURCE	config.guess	613;"	d	file:
_InterlockedCompareExchange	src/base/atomicops-internals-windows.h	/^LONG _InterlockedCompareExchange(volatile LONG* ptr, LONG newval, LONG oldval);$/;"	p	signature:(volatile LONG* ptr, LONG newval, LONG oldval)
_InterlockedCompareExchangePointer	src/base/atomicops-internals-windows.h	/^PVOID _InterlockedCompareExchangePointer(volatile PVOID* ptr,$/;"	p	signature:(volatile PVOID* ptr, PVOID newval, PVOID oldval)
_InterlockedExchange	src/base/atomicops-internals-windows.h	/^LONG _InterlockedExchange(volatile LONG* ptr, LONG newval);$/;"	p	signature:(volatile LONG* ptr, LONG newval)
_InterlockedExchangeAdd	src/base/atomicops-internals-windows.h	/^LONG _InterlockedExchangeAdd(volatile LONG* ptr, LONG increment);$/;"	p	signature:(volatile LONG* ptr, LONG increment)
_InterlockedExchangeAdd64	src/base/atomicops-internals-windows.h	/^LONGLONG _InterlockedExchangeAdd64(volatile LONGLONG* ptr, LONGLONG increment);$/;"	p	signature:(volatile LONGLONG* ptr, LONGLONG increment)
_InterlockedExchangePointer	src/base/atomicops-internals-windows.h	/^PVOID _InterlockedExchangePointer(volatile PVOID* ptr, PVOID newval);$/;"	p	signature:(volatile PVOID* ptr, PVOID newval)
_LINUXTHREADS_H	src/base/linuxthreads.h	35;"	d
_LOGGING_H_	src/base/logging.h	37;"	d
_LSS_BODY	src/base/linux_syscall_support.h	1305;"	d
_LSS_BODY	src/base/linux_syscall_support.h	1306;"	d
_LSS_RETURN	src/base/linux_syscall_support.h	1293;"	d
_LSS_RETURN	src/base/linux_syscall_support.h	1294;"	d
_LT_COMPILER_OPTION	m4/libtool.m4	/^  _LT_COMPILER_OPTION([if $compiler PIC flag $_LT_TAGVAR(lt_prog_compiler_pic, $1) works],$/;"	p	file:	signature:([if $compiler PIC flag $_LT_TAGVAR(lt_prog_compiler_pic, $1) works], [_LT_TAGVAR(lt_cv_prog_compiler_pic_works, $1)], [$_LT_TAGVAR(lt_prog_compiler_pic, $1)@&t@m4_if([$1],[],[ -DPIC],[m4_if([$1],[CXX],[ -DPIC],[])])], [], [case $_LT_TAGVAR(lt_prog_compiler_pic, $1) in Ó | Ó*)
_LT_TAGVAR	m4/libtool.m4	/^	      _LT_TAGVAR(lt_prog_compiler_pic, $1)='+Z'$/;"	p	file:	signature:(lt_prog_compiler_pic, $1)
_LT_TAGVAR	m4/libtool.m4	/^	      _LT_TAGVAR(lt_prog_compiler_pic, $1)='-KPIC'$/;"	p	file:	signature:(lt_prog_compiler_pic, $1)
_LT_TAGVAR	m4/libtool.m4	/^	    _LT_TAGVAR(lt_prog_compiler_pic, $1)=$/;"	p	file:	signature:(lt_prog_compiler_pic, $1)
_LT_TAGVAR	m4/libtool.m4	/^	    _LT_TAGVAR(lt_prog_compiler_pic, $1)='-KPIC'$/;"	p	file:	signature:(lt_prog_compiler_pic, $1)
_LT_TAGVAR	m4/libtool.m4	/^	    _LT_TAGVAR(lt_prog_compiler_pic, $1)='-PIC'$/;"	p	file:	signature:(lt_prog_compiler_pic, $1)
_LT_TAGVAR	m4/libtool.m4	/^	    _LT_TAGVAR(lt_prog_compiler_pic, $1)='-W c,exportall'$/;"	p	file:	signature:(lt_prog_compiler_pic, $1)
_LT_TAGVAR	m4/libtool.m4	/^	    _LT_TAGVAR(lt_prog_compiler_pic, $1)='-pic'$/;"	p	file:	signature:(lt_prog_compiler_pic, $1)
_LT_TAGVAR	m4/libtool.m4	/^	    _LT_TAGVAR(lt_prog_compiler_wl, $1)='--backend -Wl,'$/;"	p	file:	signature:(lt_prog_compiler_wl, $1)
_LT_TAGVAR	m4/libtool.m4	/^	    _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'$/;"	p	file:	signature:(lt_prog_compiler_wl, $1)
_LT_TAGVAR	m4/libtool.m4	/^	  _LT_TAGVAR(archive_cmds, $1)='$LD -G -h $soname -o $lib $libobjs $deplibs $linker_flags'$/;"	p	file:	signature:(archive_cmds, $1)
_LT_TAGVAR	m4/libtool.m4	/^	  _LT_TAGVAR(archive_cmds, $1)='$LD -G -o $lib $libobjs $deplibs $linker_flags'$/;"	p	file:	signature:(archive_cmds, $1)
_LT_TAGVAR	m4/libtool.m4	/^	  _LT_TAGVAR(lt_prog_compiler_static, $1)='-Bstatic'$/;"	p	file:	signature:(lt_prog_compiler_static, $1)
_LT_TAGVAR	m4/libtool.m4	/^	  _LT_TAGVAR(whole_archive_flag_spec, $1)='${wl}-z ${wl}allextract$convenience ${wl}-z ${wl}defaultextract'$/;"	p	file:	signature:(whole_archive_flag_spec, $1)
_LT_TAGVAR	m4/libtool.m4	/^	_LT_TAGVAR(allow_undefined_flag, $1)=' ${wl}-expect_unresolved ${wl}\\*'$/;"	p	file:	signature:(allow_undefined_flag, $1)
_LT_TAGVAR	m4/libtool.m4	/^	_LT_TAGVAR(archive_cmds, $1)='$CC -G ${wl}-h $soname -o $lib $libobjs $deplibs $compiler_flags'$/;"	p	file:	signature:(archive_cmds, $1)
_LT_TAGVAR	m4/libtool.m4	/^	_LT_TAGVAR(archive_cmds, $1)='$CC -shared ${wl}-h,$soname -o $lib $libobjs $deplibs $compiler_flags'$/;"	p	file:	signature:(archive_cmds, $1)
_LT_TAGVAR	m4/libtool.m4	/^	_LT_TAGVAR(archive_cmds, $1)='$LD -G -h $soname -o $lib $libobjs $deplibs $linker_flags'$/;"	p	file:	signature:(archive_cmds, $1)
_LT_TAGVAR	m4/libtool.m4	/^	_LT_TAGVAR(export_dynamic_flag_spec, $1)='${wl}-Blargedynsym'$/;"	p	file:	signature:(export_dynamic_flag_spec, $1)
_LT_TAGVAR	m4/libtool.m4	/^	_LT_TAGVAR(lt_prog_compiler_pic, $1)=-Kconform_pic$/;"	p	file:	signature:(lt_prog_compiler_pic, $1)
_LT_TAGVAR	m4/libtool.m4	/^            _LT_TAGVAR(lt_prog_compiler_pic, $1)='-fPIC'$/;"	p	file:	signature:(lt_prog_compiler_pic, $1)
_LT_TAGVAR	m4/libtool.m4	/^            _LT_TAGVAR(lt_prog_compiler_pic, $1)='-m68020 -resident32 -malways-restore-a4'$/;"	p	file:	signature:(lt_prog_compiler_pic, $1)
_LT_TAGVAR	m4/libtool.m4	/^        _LT_TAGVAR(lt_prog_compiler_pic, $1)='-fPIC -shared'$/;"	p	file:	signature:(lt_prog_compiler_pic, $1)
_LT_TAGVAR	m4/libtool.m4	/^       _LT_TAGVAR(lt_cv_prog_compiler_c_o, $1)=yes$/;"	p	file:	signature:(lt_cv_prog_compiler_c_o, $1)
_LT_TAGVAR	m4/libtool.m4	/^      _LT_TAGVAR(archive_cmds, $1)='$LD -G -h $soname -o $lib $libobjs $deplibs $linker_flags'$/;"	p	file:	signature:(archive_cmds, $1)
_LT_TAGVAR	m4/libtool.m4	/^      _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='-R$libdir'$/;"	p	file:	signature:(hardcode_libdir_flag_spec, $1)
_LT_TAGVAR	m4/libtool.m4	/^      _LT_TAGVAR(link_all_deplibs, $1)=yes$/;"	p	file:	signature:(link_all_deplibs, $1)
_LT_TAGVAR	m4/libtool.m4	/^      _LT_TAGVAR(lt_prog_compiler_pic, $1)=$/;"	p	file:	signature:(lt_prog_compiler_pic, $1)
_LT_TAGVAR	m4/libtool.m4	/^      _LT_TAGVAR(lt_prog_compiler_pic, $1)='-fPIC -shared'$/;"	p	file:	signature:(lt_prog_compiler_pic, $1)
_LT_TAGVAR	m4/libtool.m4	/^      _LT_TAGVAR(lt_prog_compiler_pic, $1)='-fno-common'$/;"	p	file:	signature:(lt_prog_compiler_pic, $1)
_LT_TAGVAR	m4/libtool.m4	/^      _LT_TAGVAR(no_undefined_flag, $1)=' -z defs'$/;"	p	file:	signature:(no_undefined_flag, $1)
_LT_TAGVAR	m4/libtool.m4	/^      _LT_TAGVAR(no_undefined_flag, $1)='${wl}-z,text'$/;"	p	file:	signature:(no_undefined_flag, $1)
_LT_TAGVAR	m4/libtool.m4	/^      _LT_TAGVAR(old_archive_from_new_cmds, $1)='emximp -o $output_objdir\/$libname.a $output_objdir\/$libname.def'$/;"	p	file:	signature:(old_archive_from_new_cmds, $1)
_LT_TAGVAR	m4/libtool.m4	/^    _LT_TAGVAR(lt_prog_compiler_pic, $1)=$/;"	p	file:	signature:(lt_prog_compiler_pic, $1)
_MALLOC_EXTENSION_C_H_	src/gperftools/malloc_extension_c.h	40;"	d
_MALLOC_HOOK_C_H_	src/gperftools/malloc_hook_c.h	38;"	d
_MALLOC_HOOK_H_	src/gperftools/malloc_hook.h	68;"	d
_MALLOC_HOOK_INL_H_	src/malloc_hook-inl.h	39;"	d
_NALLOCX_H_	src/gperftools/nallocx.h	2;"	d
_R	src/.libs/libtcmalloc_internal_la-static_vars.o	/^/;"	v
_R	src/.libs/libtcmalloc_minimal_internal_la-static_vars.o	/^/;"	v
_RUN_BENCHMARK_H_	benchmark/run_benchmark.h	28;"	d
_SYSINFO_H_	src/base/sysinfo.h	35;"	d
_THREAD_LISTER_H	src/base/thread_lister.h	36;"	d
_TIMESPEC_DEFINED	src/windows/port.h	68;"	d
_WIN32_WINNT	src/base/simple_mutex.h	120;"	d
_WIN32_WINNT	src/windows/config.h	311;"	d
_WIN32_WINNT	src/windows/mingw.h	54;"	d
_XOPEN_SOURCE	src/base/simple_mutex.h	130;"	d
_XOPEN_SOURCE	src/tcmalloc.h	41;"	d
__ARCHITECTURE__	config.guess	1342;"	d	file:
__CALLER_SAVED_REGS	src/third_party/valgrind.h	1019;"	d
__CALLER_SAVED_REGS	src/third_party/valgrind.h	1478;"	d
__CALLER_SAVED_REGS	src/third_party/valgrind.h	1924;"	d
__CALLER_SAVED_REGS	src/third_party/valgrind.h	2448;"	d
__CALLER_SAVED_REGS	src/third_party/valgrind.h	3009;"	d
__CALLER_SAVED_REGS	src/third_party/valgrind.h	621;"	d
__NR__exit	src/base/linux_syscall_support.h	2454;"	d
__NR__gettid	src/base/linux_syscall_support.h	2455;"	d
__NR__mremap	src/base/linux_syscall_support.h	2456;"	d
__NR__sigaction	src/base/linux_syscall_support.h	2637;"	d
__NR__sigprocmask	src/base/linux_syscall_support.h	2638;"	d
__NR_clock_getres	src/base/linux_syscall_support.h	829;"	d
__NR_clock_gettime	src/base/linux_syscall_support.h	826;"	d
__NR_fadvise64	src/base/linux_syscall_support.h	882;"	d
__NR_fadvise64_64	src/base/linux_syscall_support.h	934;"	d
__NR_fallocate	src/base/linux_syscall_support.h	856;"	d
__NR_fstat64	src/base/linux_syscall_support.h	586;"	d
__NR_fstat64	src/base/linux_syscall_support.h	630;"	d
__NR_fstat64	src/base/linux_syscall_support.h	666;"	d
__NR_fstat64	src/base/linux_syscall_support.h	732;"	d
__NR_fstatat	src/base/linux_syscall_support.h	681;"	d
__NR_fstatat	src/base/linux_syscall_support.h	698;"	d
__NR_fstatat	src/base/linux_syscall_support.h	715;"	d
__NR_fstatat	src/base/linux_syscall_support.h	755;"	d
__NR_fstatat64	src/base/linux_syscall_support.h	937;"	d
__NR_fstatfs64	src/base/linux_syscall_support.h	835;"	d
__NR_futex	src/base/linux_syscall_support.h	595;"	d
__NR_futex	src/base/linux_syscall_support.h	639;"	d
__NR_futex	src/base/linux_syscall_support.h	647;"	d
__NR_futex	src/base/linux_syscall_support.h	675;"	d
__NR_futex	src/base/linux_syscall_support.h	692;"	d
__NR_futex	src/base/linux_syscall_support.h	709;"	d
__NR_futex	src/base/linux_syscall_support.h	744;"	d
__NR_futex	src/base/linux_syscall_support.h	814;"	d
__NR_getcpu	src/base/linux_syscall_support.h	601;"	d
__NR_getcpu	src/base/linux_syscall_support.h	684;"	d
__NR_getcpu	src/base/linux_syscall_support.h	701;"	d
__NR_getcpu	src/base/linux_syscall_support.h	718;"	d
__NR_getcpu	src/base/linux_syscall_support.h	750;"	d
__NR_getcpu	src/base/linux_syscall_support.h	853;"	d
__NR_getdents64	src/base/linux_syscall_support.h	589;"	d
__NR_getdents64	src/base/linux_syscall_support.h	633;"	d
__NR_getdents64	src/base/linux_syscall_support.h	650;"	d
__NR_getdents64	src/base/linux_syscall_support.h	669;"	d
__NR_getdents64	src/base/linux_syscall_support.h	738;"	d
__NR_getdents64	src/base/linux_syscall_support.h	784;"	d
__NR_getresgid	src/base/linux_syscall_support.h	873;"	d
__NR_getresgid	src/base/linux_syscall_support.h	907;"	d
__NR_getresgid32	src/base/linux_syscall_support.h	925;"	d
__NR_getresuid	src/base/linux_syscall_support.h	867;"	d
__NR_getresuid	src/base/linux_syscall_support.h	901;"	d
__NR_getresuid32	src/base/linux_syscall_support.h	919;"	d
__NR_getrlimit	src/base/linux_syscall_support.h	861;"	d
__NR_getrlimit	src/base/linux_syscall_support.h	889;"	d
__NR_gettid	src/base/linux_syscall_support.h	592;"	d
__NR_gettid	src/base/linux_syscall_support.h	636;"	d
__NR_gettid	src/base/linux_syscall_support.h	644;"	d
__NR_gettid	src/base/linux_syscall_support.h	672;"	d
__NR_gettid	src/base/linux_syscall_support.h	689;"	d
__NR_gettid	src/base/linux_syscall_support.h	706;"	d
__NR_gettid	src/base/linux_syscall_support.h	741;"	d
__NR_gettid	src/base/linux_syscall_support.h	808;"	d
__NR_getxattr	src/base/linux_syscall_support.h	796;"	d
__NR_ioprio_get	src/base/linux_syscall_support.h	841;"	d
__NR_ioprio_set	src/base/linux_syscall_support.h	838;"	d
__NR_lgetxattr	src/base/linux_syscall_support.h	799;"	d
__NR_listxattr	src/base/linux_syscall_support.h	802;"	d
__NR_llistxattr	src/base/linux_syscall_support.h	805;"	d
__NR_lsetxattr	src/base/linux_syscall_support.h	793;"	d
__NR_mmap2	src/base/linux_syscall_support.h	913;"	d
__NR_move_pages	src/base/linux_syscall_support.h	850;"	d
__NR_newfstatat	src/base/linux_syscall_support.h	885;"	d
__NR_openat	src/base/linux_syscall_support.h	598;"	d
__NR_openat	src/base/linux_syscall_support.h	653;"	d
__NR_openat	src/base/linux_syscall_support.h	678;"	d
__NR_openat	src/base/linux_syscall_support.h	695;"	d
__NR_openat	src/base/linux_syscall_support.h	712;"	d
__NR_openat	src/base/linux_syscall_support.h	747;"	d
__NR_openat	src/base/linux_syscall_support.h	844;"	d
__NR_pread64	src/base/linux_syscall_support.h	778;"	d
__NR_pwrite64	src/base/linux_syscall_support.h	781;"	d
__NR_quotactl	src/base/linux_syscall_support.h	760;"	d
__NR_readahead	src/base/linux_syscall_support.h	787;"	d
__NR_rt_sigaction	src/base/linux_syscall_support.h	579;"	d
__NR_rt_sigaction	src/base/linux_syscall_support.h	623;"	d
__NR_rt_sigaction	src/base/linux_syscall_support.h	659;"	d
__NR_rt_sigaction	src/base/linux_syscall_support.h	725;"	d
__NR_rt_sigaction	src/base/linux_syscall_support.h	766;"	d
__NR_rt_sigpending	src/base/linux_syscall_support.h	772;"	d
__NR_rt_sigprocmask	src/base/linux_syscall_support.h	580;"	d
__NR_rt_sigprocmask	src/base/linux_syscall_support.h	624;"	d
__NR_rt_sigprocmask	src/base/linux_syscall_support.h	660;"	d
__NR_rt_sigprocmask	src/base/linux_syscall_support.h	726;"	d
__NR_rt_sigprocmask	src/base/linux_syscall_support.h	769;"	d
__NR_rt_sigreturn	src/base/linux_syscall_support.h	763;"	d
__NR_rt_sigsuspend	src/base/linux_syscall_support.h	775;"	d
__NR_sched_getaffinity	src/base/linux_syscall_support.h	820;"	d
__NR_sched_setaffinity	src/base/linux_syscall_support.h	817;"	d
__NR_set_tid_address	src/base/linux_syscall_support.h	823;"	d
__NR_setfsgid	src/base/linux_syscall_support.h	879;"	d
__NR_setfsgid	src/base/linux_syscall_support.h	895;"	d
__NR_setfsgid32	src/base/linux_syscall_support.h	931;"	d
__NR_setfsuid	src/base/linux_syscall_support.h	876;"	d
__NR_setfsuid	src/base/linux_syscall_support.h	892;"	d
__NR_setfsuid32	src/base/linux_syscall_support.h	928;"	d
__NR_setresgid	src/base/linux_syscall_support.h	870;"	d
__NR_setresgid	src/base/linux_syscall_support.h	904;"	d
__NR_setresgid32	src/base/linux_syscall_support.h	922;"	d
__NR_setresuid	src/base/linux_syscall_support.h	864;"	d
__NR_setresuid	src/base/linux_syscall_support.h	898;"	d
__NR_setresuid32	src/base/linux_syscall_support.h	916;"	d
__NR_setxattr	src/base/linux_syscall_support.h	790;"	d
__NR_socket	src/base/linux_syscall_support.h	735;"	d
__NR_stat64	src/base/linux_syscall_support.h	583;"	d
__NR_stat64	src/base/linux_syscall_support.h	627;"	d
__NR_stat64	src/base/linux_syscall_support.h	663;"	d
__NR_stat64	src/base/linux_syscall_support.h	729;"	d
__NR_statfs64	src/base/linux_syscall_support.h	832;"	d
__NR_tkill	src/base/linux_syscall_support.h	811;"	d
__NR_ugetrlimit	src/base/linux_syscall_support.h	910;"	d
__NR_unlinkat	src/base/linux_syscall_support.h	847;"	d
__SPECIAL_INSTRUCTION_PREAMBLE	src/third_party/valgrind.h	185;"	d
__SPECIAL_INSTRUCTION_PREAMBLE	src/third_party/valgrind.h	239;"	d
__SPECIAL_INSTRUCTION_PREAMBLE	src/third_party/valgrind.h	293;"	d
__SPECIAL_INSTRUCTION_PREAMBLE	src/third_party/valgrind.h	354;"	d
__SPECIAL_INSTRUCTION_PREAMBLE	src/third_party/valgrind.h	420;"	d
__SPECIAL_INSTRUCTION_PREAMBLE	src/third_party/valgrind.h	492;"	d
__STDC_FORMAT_MACROS	configure.ac	461;"	d	file:
__STDC_FORMAT_MACROS	src/config.h	294;"	d
__STDC_FORMAT_MACROS	src/config.h.in	293;"	d	file:
__STDC_FORMAT_MACROS	src/windows/config.h	294;"	d
__SYS_REG	src/base/linux_syscall_support.h	607;"	d
__SYS_REG	src/base/linux_syscall_support.h	616;"	d
__SYS_REG_LIST	src/base/linux_syscall_support.h	608;"	d
__SYS_REG_LIST	src/base/linux_syscall_support.h	617;"	d
__THROW	src/debugallocation.cc	91;"	d	file:
__THROW	src/libc_override_gcc_and_weak.h	51;"	d
__THROW	src/malloc_hook.cc	70;"	d	file:
__THROW	src/maybe_threads.cc	57;"	d	file:
__THROW	src/tcmalloc.h	53;"	d
__THROW	src/windows/patch_functions.cc	/^                                            const std::nothrow_t&) __THROW;$/;"	m	class:__anon13::LibcInfoWithPatchFunctions	file:	access:private
__THROW	src/windows/patch_functions.cc	/^                                          const std::nothrow_t&) __THROW;$/;"	m	class:__anon13::LibcInfoWithPatchFunctions	file:	access:private
__THROW	src/windows/patch_functions.cc	/^                                       const std::nothrow_t&) __THROW;$/;"	m	class:__anon13::LibcInfoWithPatchFunctions	file:	access:private
__THROW	src/windows/patch_functions.cc	/^                                     const std::nothrow_t&) __THROW;$/;"	m	class:__anon13::LibcInfoWithPatchFunctions	file:	access:private
__THROW	src/windows/patch_functions.cc	/^  static size_t Perftools__msize(void *ptr) __THROW;$/;"	m	class:__anon13::LibcInfoWithPatchFunctions	file:	access:private
__THROW	src/windows/patch_functions.cc	/^  static void Perftools_free(void* ptr) __THROW;$/;"	m	class:__anon13::LibcInfoWithPatchFunctions	file:	access:private
__THROW	src/windows/patch_functions.cc	/^  static void Perftools_free_base(void* ptr) __THROW;$/;"	m	class:__anon13::LibcInfoWithPatchFunctions	file:	access:private
__THROW	src/windows/patch_functions.cc	/^  static void* Perftools__expand(void *ptr, size_t size) __THROW;$/;"	m	class:__anon13::LibcInfoWithPatchFunctions	file:	access:private
__THROW	src/windows/patch_functions.cc	/^  static void* Perftools_calloc(size_t nmemb, size_t size) __THROW;$/;"	m	class:__anon13::LibcInfoWithPatchFunctions	file:	access:private
__THROW	src/windows/patch_functions.cc	/^  static void* Perftools_malloc(size_t size) __THROW;$/;"	m	class:__anon13::LibcInfoWithPatchFunctions	file:	access:private
__THROW	src/windows/patch_functions.cc	/^  static void* Perftools_realloc(void* ptr, size_t size) __THROW;$/;"	m	class:__anon13::LibcInfoWithPatchFunctions	file:	access:private
__THROW	src/windows/port.h	485;"	d
__VALGRIND_H	src/third_party/valgrind.h	74;"	d
___	docs/pprof-test.gif	/^GIF89a®Ä/;"	v
___	docs/spanmap.gif	/^GIF89aL/;"	v
___	docs/threadheap.gif	/^GIF89aNÌ/;"	v
__anon10::addr	src/windows/nm-pdb.c	/^  ULONG64 addr;$/;"	m	struct:__anon10	file:	access:public
__anon10::flags	src/windows/nm-pdb.c	/^  ULONG flags;$/;"	m	struct:__anon10	file:	access:public
__anon10::name	src/windows/nm-pdb.c	/^  char *name;$/;"	m	struct:__anon10	file:	access:public
__anon11::module_base	src/windows/nm-pdb.c	/^  ULONG64 module_base;$/;"	m	struct:__anon11	file:	access:public
__anon11::syms	src/windows/nm-pdb.c	/^  SYM *syms;$/;"	m	struct:__anon11	file:	access:public
__anon11::syms_cap	src/windows/nm-pdb.c	/^  DWORD syms_cap;$/;"	m	struct:__anon11	file:	access:public
__anon11::syms_len	src/windows/nm-pdb.c	/^  DWORD syms_len;$/;"	m	struct:__anon11	file:	access:public
__anon12::AutoHookIncrementNumber	src/windows/preamble_patcher_test.cc	/^int __declspec(noinline) AutoHookIncrementNumber(int i) {$/;"	f	namespace:__anon12	signature:(int i)
__anon12::CallNearRelativeFunction	src/windows/preamble_patcher_test.cc	/^extern "C" int CallNearRelativeFunction(int);$/;"	p	namespace:__anon12	file:	signature:(int)
__anon12::HookIncrementNumber	src/windows/preamble_patcher_test.cc	/^int HookIncrementNumber(int i) {$/;"	f	namespace:__anon12	signature:(int i)
__anon12::IncrementNumber	src/windows/preamble_patcher_test.cc	/^int __declspec(noinline) IncrementNumber(int i) {$/;"	f	namespace:__anon12	signature:(int i)
__anon12::IncrementingFunc	src/windows/preamble_patcher_test.cc	/^typedef int (*IncrementingFunc)(int);$/;"	t	namespace:__anon12	file:
__anon12::JumpAbsoluteFunction	src/windows/preamble_patcher_test.cc	/^extern "C" int JumpAbsoluteFunction(int);$/;"	p	namespace:__anon12	file:	signature:(int)
__anon12::JumpNearCondFunction	src/windows/preamble_patcher_test.cc	/^extern "C" int JumpNearCondFunction(int);$/;"	p	namespace:__anon12	file:	signature:(int)
__anon12::JumpShortCondFunction	src/windows/preamble_patcher_test.cc	/^extern "C" int JumpShortCondFunction(int);$/;"	p	namespace:__anon12	file:	signature:(int)
__anon12::TooShortFunction	src/windows/preamble_patcher_test.cc	/^extern "C" int TooShortFunction(int);$/;"	p	namespace:__anon12	file:	signature:(int)
__anon12::original_function	src/windows/preamble_patcher_test.cc	/^IncrementingFunc original_function = NULL;$/;"	m	namespace:__anon12	file:
__anon13::GenericFnPtr	src/windows/patch_functions.cc	/^typedef void (*GenericFnPtr)();$/;"	t	namespace:__anon13	file:
__anon13::LibcInfo	src/windows/patch_functions.cc	/^class LibcInfo {$/;"	c	namespace:__anon13	file:
__anon13::LibcInfo::CopyFrom	src/windows/patch_functions.cc	/^  void CopyFrom(const LibcInfo& that) {$/;"	f	class:__anon13::LibcInfo	access:protected	signature:(const LibcInfo& that)
__anon13::LibcInfo::LibcInfo	src/windows/patch_functions.cc	/^  LibcInfo() {$/;"	f	class:__anon13::LibcInfo	access:public	signature:()
__anon13::LibcInfo::PopulateWindowsFn	src/windows/patch_functions.cc	/^  bool PopulateWindowsFn(const ModuleEntryCopy& module_entry);$/;"	p	class:__anon13::LibcInfo	file:	access:public	signature:(const ModuleEntryCopy& module_entry)
__anon13::LibcInfo::PopulateWindowsFn	src/windows/patch_functions.cc	/^bool LibcInfo::PopulateWindowsFn(const ModuleEntryCopy& module_entry) {$/;"	f	class:__anon13::LibcInfo	signature:(const ModuleEntryCopy& module_entry)
__anon13::LibcInfo::ctrgProcAddress	src/windows/patch_functions.cc	/^  static const int ctrgProcAddress = kNumFunctions;$/;"	m	class:__anon13::LibcInfo	file:	access:public
__anon13::LibcInfo::function_name	src/windows/patch_functions.cc	/^  static const char* const function_name(int ifunction) {$/;"	f	class:__anon13::LibcInfo	access:public	signature:(int ifunction)
__anon13::LibcInfo::function_name_	src/windows/patch_functions.cc	/^  static const char* const function_name_[kNumFunctions];$/;"	m	class:__anon13::LibcInfo	file:	access:protected
__anon13::LibcInfo::function_name_	src/windows/patch_functions.cc	/^const char* const LibcInfo::function_name_[] = {$/;"	m	class:__anon13::LibcInfo	file:
__anon13::LibcInfo::hmodule	src/windows/patch_functions.cc	/^  HMODULE hmodule() const {$/;"	f	class:__anon13::LibcInfo	access:public	signature:() const
__anon13::LibcInfo::is_valid	src/windows/patch_functions.cc	/^  bool is_valid() const { return is_valid_; }$/;"	f	class:__anon13::LibcInfo	access:public	signature:() const
__anon13::LibcInfo::is_valid_	src/windows/patch_functions.cc	/^  bool is_valid_;$/;"	m	class:__anon13::LibcInfo	file:	access:protected
__anon13::LibcInfo::kCalloc	src/windows/patch_functions.cc	/^    kMalloc, kFree, kRealloc, kCalloc,$/;"	e	enum:__anon13::LibcInfo::__anon14	file:
__anon13::LibcInfo::kDelete	src/windows/patch_functions.cc	/^    kNew, kNewArray, kDelete, kDeleteArray,$/;"	e	enum:__anon13::LibcInfo::__anon14	file:
__anon13::LibcInfo::kDeleteArray	src/windows/patch_functions.cc	/^    kNew, kNewArray, kDelete, kDeleteArray,$/;"	e	enum:__anon13::LibcInfo::__anon14	file:
__anon13::LibcInfo::kDeleteArrayNothrow	src/windows/patch_functions.cc	/^    kNewNothrow, kNewArrayNothrow, kDeleteNothrow, kDeleteArrayNothrow,$/;"	e	enum:__anon13::LibcInfo::__anon14	file:
__anon13::LibcInfo::kDeleteNothrow	src/windows/patch_functions.cc	/^    kNewNothrow, kNewArrayNothrow, kDeleteNothrow, kDeleteArrayNothrow,$/;"	e	enum:__anon13::LibcInfo::__anon14	file:
__anon13::LibcInfo::kFree	src/windows/patch_functions.cc	/^    kMalloc, kFree, kRealloc, kCalloc,$/;"	e	enum:__anon13::LibcInfo::__anon14	file:
__anon13::LibcInfo::kFreeBase	src/windows/patch_functions.cc	/^    k_CallocCrt, kFreeBase,$/;"	e	enum:__anon13::LibcInfo::__anon14	file:
__anon13::LibcInfo::kMalloc	src/windows/patch_functions.cc	/^    kMalloc, kFree, kRealloc, kCalloc,$/;"	e	enum:__anon13::LibcInfo::__anon14	file:
__anon13::LibcInfo::kNew	src/windows/patch_functions.cc	/^    kNew, kNewArray, kDelete, kDeleteArray,$/;"	e	enum:__anon13::LibcInfo::__anon14	file:
__anon13::LibcInfo::kNewArray	src/windows/patch_functions.cc	/^    kNew, kNewArray, kDelete, kDeleteArray,$/;"	e	enum:__anon13::LibcInfo::__anon14	file:
__anon13::LibcInfo::kNewArrayNothrow	src/windows/patch_functions.cc	/^    kNewNothrow, kNewArrayNothrow, kDeleteNothrow, kDeleteArrayNothrow,$/;"	e	enum:__anon13::LibcInfo::__anon14	file:
__anon13::LibcInfo::kNewNothrow	src/windows/patch_functions.cc	/^    kNewNothrow, kNewArrayNothrow, kDeleteNothrow, kDeleteArrayNothrow,$/;"	e	enum:__anon13::LibcInfo::__anon14	file:
__anon13::LibcInfo::kNumFunctions	src/windows/patch_functions.cc	/^    kNumFunctions$/;"	e	enum:__anon13::LibcInfo::__anon14	file:
__anon13::LibcInfo::kRealloc	src/windows/patch_functions.cc	/^    kMalloc, kFree, kRealloc, kCalloc,$/;"	e	enum:__anon13::LibcInfo::__anon14	file:
__anon13::LibcInfo::k_CallocCrt	src/windows/patch_functions.cc	/^    k_CallocCrt, kFreeBase,$/;"	e	enum:__anon13::LibcInfo::__anon14	file:
__anon13::LibcInfo::k_Expand	src/windows/patch_functions.cc	/^    k_Msize, k_Expand,$/;"	e	enum:__anon13::LibcInfo::__anon14	file:
__anon13::LibcInfo::k_Msize	src/windows/patch_functions.cc	/^    k_Msize, k_Expand,$/;"	e	enum:__anon13::LibcInfo::__anon14	file:
__anon13::LibcInfo::module_base_address_	src/windows/patch_functions.cc	/^  const void *module_base_address_;$/;"	m	class:__anon13::LibcInfo	file:	access:protected
__anon13::LibcInfo::module_base_size_	src/windows/patch_functions.cc	/^  size_t module_base_size_;$/;"	m	class:__anon13::LibcInfo	file:	access:protected
__anon13::LibcInfo::patched	src/windows/patch_functions.cc	/^  bool patched() const { return is_valid(); }$/;"	f	class:__anon13::LibcInfo	access:public	signature:() const
__anon13::LibcInfo::set_is_valid	src/windows/patch_functions.cc	/^  void set_is_valid(bool b) { is_valid_ = b; }$/;"	f	class:__anon13::LibcInfo	access:public	signature:(bool b)
__anon13::LibcInfo::static_fn	src/windows/patch_functions.cc	/^  static GenericFnPtr static_fn(int ifunction) {$/;"	f	class:__anon13::LibcInfo	access:public	signature:(int ifunction)
__anon13::LibcInfo::static_fn_	src/windows/patch_functions.cc	/^  static const GenericFnPtr static_fn_[kNumFunctions];$/;"	m	class:__anon13::LibcInfo	file:	access:protected
__anon13::LibcInfo::static_fn_	src/windows/patch_functions.cc	/^const GenericFnPtr LibcInfo::static_fn_[] = {$/;"	m	class:__anon13::LibcInfo	file:
__anon13::LibcInfo::windows_fn	src/windows/patch_functions.cc	/^  GenericFnPtr windows_fn(int ifunction) const {$/;"	f	class:__anon13::LibcInfo	access:public	signature:(int ifunction) const
__anon13::LibcInfo::windows_fn_	src/windows/patch_functions.cc	/^  GenericFnPtr windows_fn_[kNumFunctions];$/;"	m	class:__anon13::LibcInfo	file:	access:protected
__anon13::LibcInfoWithPatchFunctions	src/windows/patch_functions.cc	/^template<int> class LibcInfoWithPatchFunctions : public LibcInfo {$/;"	c	namespace:__anon13	file:	inherits:LibcInfo
__anon13::LibcInfoWithPatchFunctions::Patch	src/windows/patch_functions.cc	/^  bool Patch(const LibcInfo& me_info);$/;"	p	class:__anon13::LibcInfoWithPatchFunctions	file:	access:public	signature:(const LibcInfo& me_info)
__anon13::LibcInfoWithPatchFunctions::Patch	src/windows/patch_functions.cc	/^bool LibcInfoWithPatchFunctions<T>::Patch(const LibcInfo& me_info) {$/;"	f	class:__anon13::LibcInfoWithPatchFunctions	signature:(const LibcInfo& me_info)
__anon13::LibcInfoWithPatchFunctions::Perftools_delete	src/windows/patch_functions.cc	/^  static void Perftools_delete(void *ptr);$/;"	p	class:__anon13::LibcInfoWithPatchFunctions	file:	access:private	signature:(void *ptr)
__anon13::LibcInfoWithPatchFunctions::Perftools_deletearray	src/windows/patch_functions.cc	/^  static void Perftools_deletearray(void *ptr);$/;"	p	class:__anon13::LibcInfoWithPatchFunctions	file:	access:private	signature:(void *ptr)
__anon13::LibcInfoWithPatchFunctions::Perftools_new	src/windows/patch_functions.cc	/^  static void* Perftools_new(size_t size);$/;"	p	class:__anon13::LibcInfoWithPatchFunctions	file:	access:private	signature:(size_t size)
__anon13::LibcInfoWithPatchFunctions::Perftools_newarray	src/windows/patch_functions.cc	/^  static void* Perftools_newarray(size_t size);$/;"	p	class:__anon13::LibcInfoWithPatchFunctions	file:	access:private	signature:(size_t size)
__anon13::LibcInfoWithPatchFunctions::Unpatch	src/windows/patch_functions.cc	/^  void Unpatch();$/;"	p	class:__anon13::LibcInfoWithPatchFunctions	file:	access:public	signature:()
__anon13::LibcInfoWithPatchFunctions::Unpatch	src/windows/patch_functions.cc	/^void LibcInfoWithPatchFunctions<T>::Unpatch() {$/;"	f	class:__anon13::LibcInfoWithPatchFunctions	signature:()
__anon13::LibcInfoWithPatchFunctions::__THROW	src/windows/patch_functions.cc	/^                                            const std::nothrow_t&) __THROW;$/;"	m	class:__anon13::LibcInfoWithPatchFunctions	file:	access:private
__anon13::LibcInfoWithPatchFunctions::__THROW	src/windows/patch_functions.cc	/^                                          const std::nothrow_t&) __THROW;$/;"	m	class:__anon13::LibcInfoWithPatchFunctions	file:	access:private
__anon13::LibcInfoWithPatchFunctions::__THROW	src/windows/patch_functions.cc	/^                                       const std::nothrow_t&) __THROW;$/;"	m	class:__anon13::LibcInfoWithPatchFunctions	file:	access:private
__anon13::LibcInfoWithPatchFunctions::__THROW	src/windows/patch_functions.cc	/^                                     const std::nothrow_t&) __THROW;$/;"	m	class:__anon13::LibcInfoWithPatchFunctions	file:	access:private
__anon13::LibcInfoWithPatchFunctions::__THROW	src/windows/patch_functions.cc	/^  static size_t Perftools__msize(void *ptr) __THROW;$/;"	m	class:__anon13::LibcInfoWithPatchFunctions	file:	access:private
__anon13::LibcInfoWithPatchFunctions::__THROW	src/windows/patch_functions.cc	/^  static void Perftools_free(void* ptr) __THROW;$/;"	m	class:__anon13::LibcInfoWithPatchFunctions	file:	access:private
__anon13::LibcInfoWithPatchFunctions::__THROW	src/windows/patch_functions.cc	/^  static void Perftools_free_base(void* ptr) __THROW;$/;"	m	class:__anon13::LibcInfoWithPatchFunctions	file:	access:private
__anon13::LibcInfoWithPatchFunctions::__THROW	src/windows/patch_functions.cc	/^  static void* Perftools__expand(void *ptr, size_t size) __THROW;$/;"	m	class:__anon13::LibcInfoWithPatchFunctions	file:	access:private
__anon13::LibcInfoWithPatchFunctions::__THROW	src/windows/patch_functions.cc	/^  static void* Perftools_calloc(size_t nmemb, size_t size) __THROW;$/;"	m	class:__anon13::LibcInfoWithPatchFunctions	file:	access:private
__anon13::LibcInfoWithPatchFunctions::__THROW	src/windows/patch_functions.cc	/^  static void* Perftools_malloc(size_t size) __THROW;$/;"	m	class:__anon13::LibcInfoWithPatchFunctions	file:	access:private
__anon13::LibcInfoWithPatchFunctions::__THROW	src/windows/patch_functions.cc	/^  static void* Perftools_realloc(void* ptr, size_t size) __THROW;$/;"	m	class:__anon13::LibcInfoWithPatchFunctions	file:	access:private
__anon13::LibcInfoWithPatchFunctions::origstub_fn_	src/windows/patch_functions.cc	/^  static GenericFnPtr origstub_fn_[kNumFunctions];$/;"	m	class:__anon13::LibcInfoWithPatchFunctions	file:	access:private
__anon13::LibcInfoWithPatchFunctions::origstub_fn_	src/windows/patch_functions.cc	/^template<int T> GenericFnPtr LibcInfoWithPatchFunctions<T>::origstub_fn_[] = {$/;"	m	class:__anon13::LibcInfoWithPatchFunctions	file:
__anon13::LibcInfoWithPatchFunctions::perftools_fn_	src/windows/patch_functions.cc	/^  static const GenericFnPtr perftools_fn_[kNumFunctions];$/;"	m	class:__anon13::LibcInfoWithPatchFunctions	file:	access:private
__anon13::LibcInfoWithPatchFunctions::perftools_fn_	src/windows/patch_functions.cc	/^const GenericFnPtr LibcInfoWithPatchFunctions<T>::perftools_fn_[] = {$/;"	m	class:__anon13::LibcInfoWithPatchFunctions	file:
__anon13::ModuleEntryCopy	src/windows/patch_functions.cc	/^struct ModuleEntryCopy {$/;"	s	namespace:__anon13	file:
__anon13::ModuleEntryCopy::ModuleEntryCopy	src/windows/patch_functions.cc	/^  ModuleEntryCopy() {$/;"	f	struct:__anon13::ModuleEntryCopy	access:public	signature:()
__anon13::ModuleEntryCopy::ModuleEntryCopy	src/windows/patch_functions.cc	/^  ModuleEntryCopy(const MODULEINFO& mi) {$/;"	f	struct:__anon13::ModuleEntryCopy	access:public	signature:(const MODULEINFO& mi)
__anon13::ModuleEntryCopy::modBaseAddr	src/windows/patch_functions.cc	/^  LPVOID  modBaseAddr;     \/\/ the same as hmodule$/;"	m	struct:__anon13::ModuleEntryCopy	file:	access:public
__anon13::ModuleEntryCopy::modBaseSize	src/windows/patch_functions.cc	/^  DWORD   modBaseSize;$/;"	m	struct:__anon13::ModuleEntryCopy	file:	access:public
__anon13::ModuleEntryCopy::rgProcAddresses	src/windows/patch_functions.cc	/^  GenericFnPtr rgProcAddresses[LibcInfo::ctrgProcAddress];$/;"	m	struct:__anon13::ModuleEntryCopy	file:	access:public
__anon13::PatchAllModules	src/windows/patch_functions.cc	/^bool PatchAllModules() {$/;"	f	namespace:__anon13	signature:()
__anon13::PatchMainExecutableLocked	src/windows/patch_functions.cc	/^void PatchMainExecutableLocked() {$/;"	f	namespace:__anon13	signature:()
__anon13::PatchOneModuleLocked	src/windows/patch_functions.cc	/^void PatchOneModuleLocked(const LibcInfo& me_info) {$/;"	f	namespace:__anon13	signature:(const LibcInfo& me_info)
__anon13::WindowsInfo	src/windows/patch_functions.cc	/^class WindowsInfo {$/;"	c	namespace:__anon13	file:
__anon13::WindowsInfo::FunctionInfo	src/windows/patch_functions.cc	/^  struct FunctionInfo {$/;"	s	class:__anon13::WindowsInfo	file:	access:private
__anon13::WindowsInfo::FunctionInfo::name	src/windows/patch_functions.cc	/^    const char* const name;          \/\/ name of fn in a module (eg "malloc")$/;"	m	struct:__anon13::WindowsInfo::FunctionInfo	file:	access:public
__anon13::WindowsInfo::FunctionInfo::origstub_fn	src/windows/patch_functions.cc	/^    GenericFnPtr origstub_fn;        \/\/ original fn contents after we patch$/;"	m	struct:__anon13::WindowsInfo::FunctionInfo	file:	access:public
__anon13::WindowsInfo::FunctionInfo::perftools_fn	src/windows/patch_functions.cc	/^    const GenericFnPtr perftools_fn; \/\/ fn we want to patch in$/;"	m	struct:__anon13::WindowsInfo::FunctionInfo	file:	access:public
__anon13::WindowsInfo::FunctionInfo::windows_fn	src/windows/patch_functions.cc	/^    GenericFnPtr windows_fn;         \/\/ the fn whose name we call (&malloc)$/;"	m	struct:__anon13::WindowsInfo::FunctionInfo	file:	access:public
__anon13::WindowsInfo::Patch	src/windows/patch_functions.cc	/^  void Patch();$/;"	p	class:__anon13::WindowsInfo	file:	access:public	signature:()
__anon13::WindowsInfo::Patch	src/windows/patch_functions.cc	/^void WindowsInfo::Patch() {$/;"	f	class:__anon13::WindowsInfo	signature:()
__anon13::WindowsInfo::Perftools_FreeLibrary	src/windows/patch_functions.cc	/^  static BOOL WINAPI Perftools_FreeLibrary(HMODULE hLibModule);$/;"	p	class:__anon13::WindowsInfo	file:	access:private	signature:(HMODULE hLibModule)
__anon13::WindowsInfo::Perftools_HeapAlloc	src/windows/patch_functions.cc	/^  static LPVOID WINAPI Perftools_HeapAlloc(HANDLE hHeap, DWORD dwFlags,$/;"	p	class:__anon13::WindowsInfo	file:	access:private	signature:(HANDLE hHeap, DWORD dwFlags, DWORD_PTR dwBytes)
__anon13::WindowsInfo::Perftools_HeapFree	src/windows/patch_functions.cc	/^  static BOOL WINAPI Perftools_HeapFree(HANDLE hHeap, DWORD dwFlags,$/;"	p	class:__anon13::WindowsInfo	file:	access:private	signature:(HANDLE hHeap, DWORD dwFlags, LPVOID lpMem)
__anon13::WindowsInfo::Perftools_LoadLibraryExW	src/windows/patch_functions.cc	/^  static HMODULE WINAPI Perftools_LoadLibraryExW(LPCWSTR lpFileName,$/;"	p	class:__anon13::WindowsInfo	file:	access:private	signature:(LPCWSTR lpFileName, HANDLE hFile, DWORD dwFlags)
__anon13::WindowsInfo::Perftools_MapViewOfFileEx	src/windows/patch_functions.cc	/^  static LPVOID WINAPI Perftools_MapViewOfFileEx(HANDLE hFileMappingObject,$/;"	p	class:__anon13::WindowsInfo	file:	access:private	signature:(HANDLE hFileMappingObject, DWORD dwDesiredAccess, DWORD dwFileOffsetHigh, DWORD dwFileOffsetLow, SIZE_T dwNumberOfBytesToMap, LPVOID lpBaseAddress)
__anon13::WindowsInfo::Perftools_UnmapViewOfFile	src/windows/patch_functions.cc	/^  static BOOL WINAPI Perftools_UnmapViewOfFile(LPCVOID lpBaseAddress);$/;"	p	class:__anon13::WindowsInfo	file:	access:private	signature:(LPCVOID lpBaseAddress)
__anon13::WindowsInfo::Perftools_VirtualAllocEx	src/windows/patch_functions.cc	/^  static LPVOID WINAPI Perftools_VirtualAllocEx(HANDLE process, LPVOID address,$/;"	p	class:__anon13::WindowsInfo	file:	access:private	signature:(HANDLE process, LPVOID address, SIZE_T size, DWORD type, DWORD protect)
__anon13::WindowsInfo::Perftools_VirtualFreeEx	src/windows/patch_functions.cc	/^  static BOOL WINAPI Perftools_VirtualFreeEx(HANDLE process, LPVOID address,$/;"	p	class:__anon13::WindowsInfo	file:	access:private	signature:(HANDLE process, LPVOID address, SIZE_T size, DWORD type)
__anon13::WindowsInfo::Unpatch	src/windows/patch_functions.cc	/^  void Unpatch();$/;"	p	class:__anon13::WindowsInfo	file:	access:public	signature:()
__anon13::WindowsInfo::Unpatch	src/windows/patch_functions.cc	/^void WindowsInfo::Unpatch() {$/;"	f	class:__anon13::WindowsInfo	signature:()
__anon13::WindowsInfo::function_info_	src/windows/patch_functions.cc	/^  static FunctionInfo function_info_[kNumFunctions];$/;"	m	class:__anon13::WindowsInfo	file:	access:private
__anon13::WindowsInfo::function_info_	src/windows/patch_functions.cc	/^\/*static*\/ WindowsInfo::FunctionInfo WindowsInfo::function_info_[] = {$/;"	m	class:__anon13::WindowsInfo	file:
__anon13::WindowsInfo::kFreeLibrary	src/windows/patch_functions.cc	/^    kMapViewOfFileEx, kUnmapViewOfFile, kLoadLibraryExW, kFreeLibrary,$/;"	e	enum:__anon13::WindowsInfo::__anon15	file:
__anon13::WindowsInfo::kHeapAlloc	src/windows/patch_functions.cc	/^    kHeapAlloc, kHeapFree, kVirtualAllocEx, kVirtualFreeEx,$/;"	e	enum:__anon13::WindowsInfo::__anon15	file:
__anon13::WindowsInfo::kHeapFree	src/windows/patch_functions.cc	/^    kHeapAlloc, kHeapFree, kVirtualAllocEx, kVirtualFreeEx,$/;"	e	enum:__anon13::WindowsInfo::__anon15	file:
__anon13::WindowsInfo::kLoadLibraryExW	src/windows/patch_functions.cc	/^    kMapViewOfFileEx, kUnmapViewOfFile, kLoadLibraryExW, kFreeLibrary,$/;"	e	enum:__anon13::WindowsInfo::__anon15	file:
__anon13::WindowsInfo::kMapViewOfFileEx	src/windows/patch_functions.cc	/^    kMapViewOfFileEx, kUnmapViewOfFile, kLoadLibraryExW, kFreeLibrary,$/;"	e	enum:__anon13::WindowsInfo::__anon15	file:
__anon13::WindowsInfo::kNumFunctions	src/windows/patch_functions.cc	/^    kNumFunctions$/;"	e	enum:__anon13::WindowsInfo::__anon15	file:
__anon13::WindowsInfo::kUnmapViewOfFile	src/windows/patch_functions.cc	/^    kMapViewOfFileEx, kUnmapViewOfFile, kLoadLibraryExW, kFreeLibrary,$/;"	e	enum:__anon13::WindowsInfo::__anon15	file:
__anon13::WindowsInfo::kVirtualAllocEx	src/windows/patch_functions.cc	/^    kHeapAlloc, kHeapFree, kVirtualAllocEx, kVirtualFreeEx,$/;"	e	enum:__anon13::WindowsInfo::__anon15	file:
__anon13::WindowsInfo::kVirtualFreeEx	src/windows/patch_functions.cc	/^    kHeapAlloc, kHeapFree, kVirtualAllocEx, kVirtualFreeEx,$/;"	e	enum:__anon13::WindowsInfo::__anon15	file:
__anon13::g_last_loaded	src/windows/patch_functions.cc	/^static std::set<HMODULE> *g_last_loaded;$/;"	m	namespace:__anon13	file:
__anon13::g_module_libcs	src/windows/patch_functions.cc	/^static LibcInfo* g_module_libcs[] = {$/;"	m	namespace:__anon13	file:
__anon13::libc1	src/windows/patch_functions.cc	/^static LibcInfoWithPatchFunctions<1> libc1;$/;"	m	namespace:__anon13	file:
__anon13::libc2	src/windows/patch_functions.cc	/^static LibcInfoWithPatchFunctions<2> libc2;$/;"	m	namespace:__anon13	file:
__anon13::libc3	src/windows/patch_functions.cc	/^static LibcInfoWithPatchFunctions<3> libc3;$/;"	m	namespace:__anon13	file:
__anon13::libc4	src/windows/patch_functions.cc	/^static LibcInfoWithPatchFunctions<4> libc4;$/;"	m	namespace:__anon13	file:
__anon13::libc5	src/windows/patch_functions.cc	/^static LibcInfoWithPatchFunctions<5> libc5;$/;"	m	namespace:__anon13	file:
__anon13::libc6	src/windows/patch_functions.cc	/^static LibcInfoWithPatchFunctions<6> libc6;$/;"	m	namespace:__anon13	file:
__anon13::libc7	src/windows/patch_functions.cc	/^static LibcInfoWithPatchFunctions<7> libc7;$/;"	m	namespace:__anon13	file:
__anon13::libc8	src/windows/patch_functions.cc	/^static LibcInfoWithPatchFunctions<8> libc8;$/;"	m	namespace:__anon13	file:
__anon13::main_executable	src/windows/patch_functions.cc	/^static LibcInfoWithPatchFunctions<0> main_executable;$/;"	m	namespace:__anon13	file:
__anon13::main_executable_windows	src/windows/patch_functions.cc	/^static WindowsInfo main_executable_windows;$/;"	m	namespace:__anon13	file:
__anon13::patch_all_modules_lock	src/windows/patch_functions.cc	/^static SpinLock patch_all_modules_lock(SpinLock::LINKER_INITIALIZED);$/;"	p	namespace:__anon13	file:	signature:(SpinLock::LINKER_INITIALIZED)
__anon1::address	m4/libtool.m4	/^  void       *address;$/;"	m	struct:__anon1	file:	access:public
__anon1::name	m4/libtool.m4	/^  const char *name;$/;"	m	struct:__anon1	file:	access:public
__anon20::StacktraceScope	src/stacktrace.cc	/^  class StacktraceScope {$/;"	c	namespace:__anon20	file:
__anon20::StacktraceScope::IsStacktraceAllowed	src/stacktrace.cc	/^    bool IsStacktraceAllowed() {$/;"	f	class:__anon20::StacktraceScope	access:public	signature:()
__anon20::StacktraceScope::StacktraceScope	src/stacktrace.cc	/^    StacktraceScope() {$/;"	f	class:__anon20::StacktraceScope	access:public	signature:()
__anon20::StacktraceScope::stacktrace_allowed	src/stacktrace.cc	/^    bool stacktrace_allowed;$/;"	m	class:__anon20::StacktraceScope	file:	access:private
__anon20::StacktraceScope::~StacktraceScope	src/stacktrace.cc	/^    ~StacktraceScope() {$/;"	f	class:__anon20::StacktraceScope	access:public	signature:()
__anon21::Count	src/malloc_extension.cc	/^uintptr_t Count(void** entry) {$/;"	f	namespace:__anon21	signature:(void** entry)
__anon21::Depth	src/malloc_extension.cc	/^uintptr_t Depth(void** entry) {$/;"	f	namespace:__anon21	signature:(void** entry)
__anon21::PC	src/malloc_extension.cc	/^void* PC(void** entry, int i) {$/;"	f	namespace:__anon21	signature:(void** entry, int i)
__anon21::PrintCountAndSize	src/malloc_extension.cc	/^void PrintCountAndSize(MallocExtensionWriter* writer,$/;"	f	namespace:__anon21	signature:(MallocExtensionWriter* writer, uintptr_t count, uintptr_t size)
__anon21::PrintHeader	src/malloc_extension.cc	/^void PrintHeader(MallocExtensionWriter* writer,$/;"	f	namespace:__anon21	signature:(MallocExtensionWriter* writer, const char* label, void** entries)
__anon21::PrintStackEntry	src/malloc_extension.cc	/^void PrintStackEntry(MallocExtensionWriter* writer, void** entry) {$/;"	f	namespace:__anon21	signature:(MallocExtensionWriter* writer, void** entry)
__anon21::Size	src/malloc_extension.cc	/^uintptr_t Size(void** entry) {$/;"	f	namespace:__anon21	signature:(void** entry)
__anon22::nraddr	src/third_party/valgrind.h	/^      unsigned int nraddr; \/* where's the code? *\/$/;"	m	struct:__anon22	access:public
__anon23::nraddr	src/third_party/valgrind.h	/^      unsigned long long int nraddr; \/* where's the code? *\/$/;"	m	struct:__anon23	access:public
__anon24::nraddr	src/third_party/valgrind.h	/^      unsigned int nraddr; \/* where's the code? *\/$/;"	m	struct:__anon24	access:public
__anon25::nraddr	src/third_party/valgrind.h	/^      unsigned long long int nraddr; \/* where's the code? *\/$/;"	m	struct:__anon25	access:public
__anon25::r2	src/third_party/valgrind.h	/^      unsigned long long int r2;  \/* what tocptr do we need? *\/$/;"	m	struct:__anon25	access:public
__anon26::nraddr	src/third_party/valgrind.h	/^      unsigned int nraddr; \/* where's the code? *\/$/;"	m	struct:__anon26	access:public
__anon26::r2	src/third_party/valgrind.h	/^      unsigned int r2;  \/* what tocptr do we need? *\/$/;"	m	struct:__anon26	access:public
__anon27::nraddr	src/third_party/valgrind.h	/^      unsigned long long int nraddr; \/* where's the code? *\/$/;"	m	struct:__anon27	access:public
__anon27::r2	src/third_party/valgrind.h	/^      unsigned long long int r2;  \/* what tocptr do we need? *\/$/;"	m	struct:__anon27	access:public
__anon2::InvalidFree	src/tcmalloc.cc	/^ATTRIBUTE_NOINLINE void InvalidFree(void* ptr) {$/;"	f	namespace:__anon2	signature:(void* ptr)
__anon2::InvalidGetAllocatedSize	src/tcmalloc.cc	/^size_t InvalidGetAllocatedSize(const void* ptr) {$/;"	f	namespace:__anon2	signature:(const void* ptr)
__anon2::InvalidGetSizeForRealloc	src/tcmalloc.cc	/^size_t InvalidGetSizeForRealloc(const void* old_ptr) {$/;"	f	namespace:__anon2	signature:(const void* old_ptr)
__anon30::frame	src/stacktrace_instrument-inl.h	/^  void* frame[MAX_DEPTH];$/;"	m	struct:__anon30	access:public
__anon30::stack_depth	src/stacktrace_instrument-inl.h	/^  int   stack_depth;$/;"	m	struct:__anon30	access:public
__anon32::CheckAddressBits	src/system-alloc.cc	/^template <> bool CheckAddressBits<8 * sizeof(void*)>(uintptr_t ptr) {$/;"	f	namespace:__anon32	signature:(uintptr_t ptr)
__anon32::CheckAddressBits	src/system-alloc.cc	/^template <int ADDRESS_BITS> bool CheckAddressBits(uintptr_t ptr) {$/;"	f	namespace:__anon32	signature:(uintptr_t ptr)
__anon33::buf	src/system-alloc.cc	/^  char buf[sizeof(SbrkSysAllocator)];$/;"	m	union:__anon33	file:	access:public
__anon33::ptr	src/system-alloc.cc	/^  void *ptr;$/;"	m	union:__anon33	file:	access:public
__anon34::buf	src/system-alloc.cc	/^  char buf[sizeof(MmapSysAllocator)];$/;"	m	union:__anon34	file:	access:public
__anon34::ptr	src/system-alloc.cc	/^  void *ptr;$/;"	m	union:__anon34	file:	access:public
__anon35::buf	src/system-alloc.cc	/^  char buf[sizeof(DefaultSysAllocator)];$/;"	m	union:__anon35	file:	access:public
__anon35::ptr	src/system-alloc.cc	/^  void *ptr;$/;"	m	union:__anon35	file:	access:public
__anon36::SysCalls	src/base/linuxthreads.cc	/^  class SysCalls {$/;"	c	namespace:__anon36	file:
__anon36::SysCalls::SysCalls	src/base/linuxthreads.cc	/^    SysCalls() : my_errno(0) { }$/;"	f	class:__anon36::SysCalls	access:public	signature:()
__anon36::SysCalls::my_errno	src/base/linuxthreads.cc	/^    int my_errno;$/;"	m	class:__anon36::SysCalls	file:	access:public
__anon37::SpinLock_InitHelper	src/base/spinlock.cc	/^struct SpinLock_InitHelper {$/;"	s	namespace:__anon37	file:
__anon37::SpinLock_InitHelper::SpinLock_InitHelper	src/base/spinlock.cc	/^  SpinLock_InitHelper() {$/;"	f	struct:__anon37::SpinLock_InitHelper	access:public	signature:()
__anon37::SpinlockPause	src/base/spinlock.cc	/^inline void SpinlockPause(void) {$/;"	f	namespace:__anon37	signature:(void)
__anon37::init_helper	src/base/spinlock.cc	/^static SpinLock_InitHelper init_helper;$/;"	m	namespace:__anon37	file:
__anon38::DefaultPagesAllocator	src/base/low_level_alloc.cc	/^  class DefaultPagesAllocator : public LowLevelAlloc::PagesAllocator {$/;"	c	namespace:__anon38	file:	inherits:LowLevelAlloc::PagesAllocator
__anon38::DefaultPagesAllocator::MapPages	src/base/low_level_alloc.cc	/^    virtual void *MapPages(int32 flags, size_t size);$/;"	p	class:__anon38::DefaultPagesAllocator	file:	access:public	signature:(int32 flags, size_t size)
__anon38::DefaultPagesAllocator::UnMapPages	src/base/low_level_alloc.cc	/^    virtual void UnMapPages(int32 flags, void *addr, size_t size);$/;"	p	class:__anon38::DefaultPagesAllocator	file:	access:public	signature:(int32 flags, void *addr, size_t size)
__anon38::DefaultPagesAllocator::~DefaultPagesAllocator	src/base/low_level_alloc.cc	/^    virtual ~DefaultPagesAllocator() {};$/;"	f	class:__anon38::DefaultPagesAllocator	access:public	signature:()
__anon39::ArenaLock	src/base/low_level_alloc.cc	/^  class SCOPED_LOCKABLE ArenaLock {$/;"	c	namespace:__anon39	file:
__anon39::ArenaLock::DISALLOW_COPY_AND_ASSIGN	src/base/low_level_alloc.cc	/^    DISALLOW_COPY_AND_ASSIGN(ArenaLock);$/;"	p	class:__anon39::ArenaLock	file:	access:private	signature:(ArenaLock)
__anon39::ArenaLock::Leave	src/base/low_level_alloc.cc	/^    void Leave() \/*UNLOCK_FUNCTION()*\/ {$/;"	f	class:__anon39::ArenaLock	access:public	signature:()
__anon39::ArenaLock::arena_	src/base/low_level_alloc.cc	/^        : left_(false), mask_valid_(false), arena_(arena) {$/;"	f	class:__anon39::ArenaLock	access:public	signature:(arena)
__anon39::ArenaLock::arena_	src/base/low_level_alloc.cc	/^    LowLevelAlloc::Arena *arena_;$/;"	m	class:__anon39::ArenaLock	file:	access:private
__anon39::ArenaLock::left_	src/base/low_level_alloc.cc	/^        : left_(false), mask_valid_(false), arena_(arena) {$/;"	p	class:__anon39::ArenaLock	file:	access:public	signature:(false)
__anon39::ArenaLock::left_	src/base/low_level_alloc.cc	/^    bool left_;       \/\/ whether left region$/;"	m	class:__anon39::ArenaLock	file:	access:private
__anon39::ArenaLock::mask_valid_	src/base/low_level_alloc.cc	/^        : left_(false), mask_valid_(false), arena_(arena) {$/;"	p	class:__anon39::ArenaLock	file:	access:public	signature:(false)
__anon39::ArenaLock::mask_valid_	src/base/low_level_alloc.cc	/^    bool mask_valid_;$/;"	m	class:__anon39::ArenaLock	file:	access:private
__anon39::ArenaLock::~ArenaLock	src/base/low_level_alloc.cc	/^    ~ArenaLock() { RAW_CHECK(this->left_, "haven't left Arena region"); }$/;"	f	class:__anon39::ArenaLock	access:public	signature:()
__anon3::GetSizeWithCallback	src/tcmalloc.cc	/^inline size_t GetSizeWithCallback(const void* ptr,$/;"	f	namespace:__anon3	signature:(const void* ptr, size_t (*invalid_getsize_fn)(const void*))
__anon3::ReportLargeAlloc	src/tcmalloc.cc	/^static void ReportLargeAlloc(Length num_pages, void* result) {$/;"	f	namespace:__anon3	signature:(Length num_pages, void* result)
__anon3::do_calloc	src/tcmalloc.cc	/^ATTRIBUTE_ALWAYS_INLINE inline void* do_calloc(size_t n, size_t elem_size) {$/;"	f	namespace:__anon3	signature:(size_t n, size_t elem_size)
__anon3::do_free	src/tcmalloc.cc	/^ATTRIBUTE_ALWAYS_INLINE inline void do_free(void* ptr) {$/;"	f	namespace:__anon3	signature:(void* ptr)
__anon3::do_free_pages	src/tcmalloc.cc	/^static ATTRIBUTE_NOINLINE void do_free_pages(Span* span, void* ptr) {$/;"	f	namespace:__anon3	signature:(Span* span, void* ptr)
__anon3::do_free_with_callback	src/tcmalloc.cc	/^void do_free_with_callback(void* ptr,$/;"	f	namespace:__anon3	signature:(void* ptr, void (*invalid_free_fn)(void*), bool use_hint, size_t size_hint)
__anon3::do_mallinfo	src/tcmalloc.cc	/^inline struct mallinfo do_mallinfo() {$/;"	f	namespace:__anon3	signature:()
__anon3::do_malloc	src/tcmalloc.cc	/^ATTRIBUTE_ALWAYS_INLINE inline void* do_malloc(size_t size) {$/;"	f	namespace:__anon3	signature:(size_t size)
__anon3::do_malloc_or_cpp_alloc	src/tcmalloc.cc	/^ATTRIBUTE_ALWAYS_INLINE inline void* do_malloc_or_cpp_alloc(size_t size) {$/;"	f	namespace:__anon3	signature:(size_t size)
__anon3::do_malloc_pages	src/tcmalloc.cc	/^static void* do_malloc_pages(ThreadCache* heap, size_t size) {$/;"	f	namespace:__anon3	signature:(ThreadCache* heap, size_t size)
__anon3::do_malloc_stats	src/tcmalloc.cc	/^inline void do_malloc_stats() {$/;"	f	namespace:__anon3	signature:()
__anon3::do_mallopt	src/tcmalloc.cc	/^inline int do_mallopt(int cmd, int value) {$/;"	f	namespace:__anon3	signature:(int cmd, int value)
__anon3::do_memalign_pages	src/tcmalloc.cc	/^void* do_memalign_pages(size_t align, size_t size) {$/;"	f	namespace:__anon3	signature:(size_t align, size_t size)
__anon3::do_realloc	src/tcmalloc.cc	/^ATTRIBUTE_ALWAYS_INLINE inline void* do_realloc(void* old_ptr, size_t new_size) {$/;"	f	namespace:__anon3	signature:(void* old_ptr, size_t new_size)
__anon3::do_realloc_with_callback	src/tcmalloc.cc	/^ATTRIBUTE_ALWAYS_INLINE inline void* do_realloc_with_callback($/;"	f	namespace:__anon3	signature:( void* old_ptr, size_t new_size, void (*invalid_free_fn)(void*), size_t (*invalid_get_size_fn)(const void*))
__anon3::free_null_or_invalid	src/tcmalloc.cc	/^inline void free_null_or_invalid(void* ptr, void (*invalid_free_fn)(void*)) {$/;"	f	namespace:__anon3	signature:(void* ptr, void (*invalid_free_fn)(void*))
__anon3::handle_oom	src/tcmalloc.cc	/^void* handle_oom(malloc_fn retry_fn,$/;"	f	namespace:__anon3	signature:(malloc_fn retry_fn, void* retry_arg, bool from_operator, bool nothrow)
__anon3::large_alloc_threshold	src/tcmalloc.cc	/^static int64_t large_alloc_threshold =$/;"	m	namespace:__anon3	file:
__anon3::malloc_fn	src/tcmalloc.cc	/^typedef void* (*malloc_fn)(void *arg);$/;"	t	namespace:__anon3	file:
__anon3::nop_oom_handler	src/tcmalloc.cc	/^static void *nop_oom_handler(size_t size) {$/;"	f	namespace:__anon3	signature:(size_t size)
__anon3::retry_malloc	src/tcmalloc.cc	/^static void *retry_malloc(void* size) {$/;"	f	namespace:__anon3	signature:(void* size)
__anon3::set_new_handler_lock	src/tcmalloc.cc	/^SpinLock set_new_handler_lock(SpinLock::LINKER_INITIALIZED);$/;"	p	namespace:__anon3	file:	signature:(SpinLock::LINKER_INITIALIZED)
__anon3::should_report_large	src/tcmalloc.cc	/^inline bool should_report_large(Length num_pages) {$/;"	f	namespace:__anon3	signature:(Length num_pages)
__anon40::chars	src/base/low_level_alloc.cc	/^  char chars[sizeof(DefaultPagesAllocator)];$/;"	m	union:__anon40	file:	access:public
__anon40::ptr	src/base/low_level_alloc.cc	/^  void *ptr;$/;"	m	union:__anon40	file:	access:public
__anon45::InitModule	src/base/spinlock_linux-inl.h	/^static struct InitModule {$/;"	s	namespace:__anon45
__anon45::InitModule::InitModule	src/base/spinlock_linux-inl.h	/^  InitModule() {$/;"	f	struct:__anon45::InitModule	access:public	signature:()
__anon45::init_module	src/base/spinlock_linux-inl.h	/^} init_module;$/;"	m	namespace:__anon45	typeref:struct:__anon45::InitModule
__anon51::InitialNewHook	src/malloc_hook.cc	/^void InitialNewHook(const void* ptr, size_t size) {$/;"	f	namespace:__anon51	signature:(const void* ptr, size_t size)
__anon51::InitialPreMMapHook	src/malloc_hook.cc	/^void InitialPreMMapHook(const void* start,$/;"	f	namespace:__anon51	signature:(const void* start, size_t size, int protection, int flags, int fd, off_t offset)
__anon51::InitialPreSbrkHook	src/malloc_hook.cc	/^void InitialPreSbrkHook(ptrdiff_t increment) {$/;"	f	namespace:__anon51	signature:(ptrdiff_t increment)
__anon51::RemoveInitialHooksAndCallInitializers	src/malloc_hook.cc	/^void RemoveInitialHooksAndCallInitializers() {$/;"	f	namespace:__anon51	signature:()
__anon51::RemoveInitialHooksAndCallInitializers	src/malloc_hook.cc	/^void RemoveInitialHooksAndCallInitializers();  \/\/ below.$/;"	p	namespace:__anon51	file:	signature:()
__anon51::once	src/malloc_hook.cc	/^pthread_once_t once = PTHREAD_ONCE_INIT;$/;"	m	namespace:__anon51	file:
__anon52::AddressRange	src/tests/stacktrace_unittest.cc	/^struct AddressRange {$/;"	s	namespace:__anon52	file:
__anon52::AddressRange::end	src/tests/stacktrace_unittest.cc	/^  const void *start, *end;$/;"	m	struct:__anon52::AddressRange	file:	access:public
__anon52::AddressRange::start	src/tests/stacktrace_unittest.cc	/^  const void *start, *end;$/;"	m	struct:__anon52::AddressRange	file:	access:public
__anon52::BACKTRACE_STEPS	src/tests/stacktrace_unittest.cc	/^const int BACKTRACE_STEPS = 6;$/;"	m	namespace:__anon52	file:
__anon52::CheckRetAddrIsInFunction	src/tests/stacktrace_unittest.cc	/^void CheckRetAddrIsInFunction(void *ret_addr, const AddressRange &range)$/;"	f	namespace:__anon52	signature:(void *ret_addr, const AddressRange &range)
__anon52::CheckStackTrace	src/tests/stacktrace_unittest.cc	/^void ATTRIBUTE_NOINLINE CheckStackTrace(int i) {$/;"	f	namespace:__anon52	signature:(int i)
__anon52::CheckStackTrace	src/tests/stacktrace_unittest.cc	/^void ATTRIBUTE_NOINLINE CheckStackTrace(int);$/;"	p	namespace:__anon52	file:	signature:(int)
__anon52::CheckStackTrace1	src/tests/stacktrace_unittest.cc	/^void ATTRIBUTE_NOINLINE CheckStackTrace1(int i) {$/;"	f	namespace:__anon52	signature:(int i)
__anon52::CheckStackTrace2	src/tests/stacktrace_unittest.cc	/^void ATTRIBUTE_NOINLINE CheckStackTrace2(int i) {$/;"	f	namespace:__anon52	signature:(int i)
__anon52::CheckStackTrace3	src/tests/stacktrace_unittest.cc	/^void ATTRIBUTE_NOINLINE CheckStackTrace3(int i) {$/;"	f	namespace:__anon52	signature:(int i)
__anon52::CheckStackTrace4	src/tests/stacktrace_unittest.cc	/^void ATTRIBUTE_NOINLINE CheckStackTrace4(int i) {$/;"	f	namespace:__anon52	signature:(int i)
__anon52::CheckStackTraceLeaf	src/tests/stacktrace_unittest.cc	/^void ATTRIBUTE_NOINLINE CheckStackTraceLeaf(void) {$/;"	f	namespace:__anon52	signature:(void)
__anon52::expected_range	src/tests/stacktrace_unittest.cc	/^AddressRange expected_range[BACKTRACE_STEPS];$/;"	m	namespace:__anon52	file:
__anon53::FileDescriptor	src/tests/profiledata_unittest.cc	/^struct FileDescriptor {$/;"	s	namespace:__anon53	file:
__anon53::FileDescriptor::FileDescriptor	src/tests/profiledata_unittest.cc	/^  explicit FileDescriptor(int fd) : fd_(fd) {}$/;"	f	struct:__anon53::FileDescriptor	access:public	signature:(int fd)
__anon53::FileDescriptor::fd_	src/tests/profiledata_unittest.cc	/^  const int fd_;$/;"	m	struct:__anon53::FileDescriptor	file:	access:public
__anon53::FileDescriptor::get	src/tests/profiledata_unittest.cc	/^  int get() { return fd_; }$/;"	f	struct:__anon53::FileDescriptor	access:public	signature:()
__anon53::FileDescriptor::~FileDescriptor	src/tests/profiledata_unittest.cc	/^  ~FileDescriptor() {$/;"	f	struct:__anon53::FileDescriptor	access:public	signature:()
__anon53::ProfileDataChecker	src/tests/profiledata_unittest.cc	/^class ProfileDataChecker {$/;"	c	namespace:__anon53	file:
__anon53::ProfileDataChecker::Check	src/tests/profiledata_unittest.cc	/^  string Check(const ProfileDataSlot* slots, int num_slots) {$/;"	f	class:__anon53::ProfileDataChecker	access:public	signature:(const ProfileDataSlot* slots, int num_slots)
__anon53::ProfileDataChecker::CheckWithSkips	src/tests/profiledata_unittest.cc	/^  string CheckWithSkips(const ProfileDataSlot* slots, int num_slots,$/;"	p	class:__anon53::ProfileDataChecker	file:	access:public	signature:(const ProfileDataSlot* slots, int num_slots, const int* skips, int num_skips)
__anon53::ProfileDataChecker::CheckWithSkips	src/tests/profiledata_unittest.cc	/^string ProfileDataChecker::CheckWithSkips(const ProfileDataSlot* slots,$/;"	f	class:__anon53::ProfileDataChecker	signature:(const ProfileDataSlot* slots, int num_slots, const int* skips, int num_skips)
__anon53::ProfileDataChecker::ProfileDataChecker	src/tests/profiledata_unittest.cc	/^  ProfileDataChecker() {$/;"	f	class:__anon53::ProfileDataChecker	access:public	signature:()
__anon53::ProfileDataChecker::ValidateProfile	src/tests/profiledata_unittest.cc	/^  string ValidateProfile();$/;"	p	class:__anon53::ProfileDataChecker	file:	access:public	signature:()
__anon53::ProfileDataChecker::ValidateProfile	src/tests/profiledata_unittest.cc	/^string ProfileDataChecker::ValidateProfile() {$/;"	f	class:__anon53::ProfileDataChecker	signature:()
__anon53::ProfileDataChecker::filename	src/tests/profiledata_unittest.cc	/^  string filename() const { return filename_; }$/;"	f	class:__anon53::ProfileDataChecker	access:public	signature:() const
__anon53::ProfileDataChecker::filename_	src/tests/profiledata_unittest.cc	/^  string filename_;$/;"	m	class:__anon53::ProfileDataChecker	file:	access:private
__anon53::ProfileDataSlot	src/tests/profiledata_unittest.cc	/^typedef uintptr_t ProfileDataSlot;$/;"	t	namespace:__anon53	file:
__anon53::ProfileDataTest	src/tests/profiledata_unittest.cc	/^class ProfileDataTest {$/;"	c	namespace:__anon53	file:
__anon53::ProfileDataTest::CollectOne	src/tests/profiledata_unittest.cc	/^  void CollectOne();$/;"	p	class:__anon53::ProfileDataTest	file:	access:private	signature:()
__anon53::ProfileDataTest::CollectTwoFlush	src/tests/profiledata_unittest.cc	/^  void CollectTwoFlush();$/;"	p	class:__anon53::ProfileDataTest	file:	access:private	signature:()
__anon53::ProfileDataTest::CollectTwoMatching	src/tests/profiledata_unittest.cc	/^  void CollectTwoMatching();$/;"	p	class:__anon53::ProfileDataTest	file:	access:private	signature:()
__anon53::ProfileDataTest::ExpectRunningSamples	src/tests/profiledata_unittest.cc	/^  void ExpectRunningSamples(int samples) {$/;"	f	class:__anon53::ProfileDataTest	access:protected	signature:(int samples)
__anon53::ProfileDataTest::ExpectSameState	src/tests/profiledata_unittest.cc	/^  void ExpectSameState(const ProfileData::State& before,$/;"	f	class:__anon53::ProfileDataTest	access:protected	signature:(const ProfileData::State& before, const ProfileData::State& after)
__anon53::ProfileDataTest::ExpectStopped	src/tests/profiledata_unittest.cc	/^  void ExpectStopped() {$/;"	f	class:__anon53::ProfileDataTest	access:protected	signature:()
__anon53::ProfileDataTest::OpsWhenStopped	src/tests/profiledata_unittest.cc	/^  void OpsWhenStopped();$/;"	p	class:__anon53::ProfileDataTest	file:	access:private	signature:()
__anon53::ProfileDataTest::RUN_ALL_TESTS	src/tests/profiledata_unittest.cc	/^  static int RUN_ALL_TESTS() {$/;"	f	class:__anon53::ProfileDataTest	access:public	signature:()
__anon53::ProfileDataTest::StartResetRestart	src/tests/profiledata_unittest.cc	/^  void StartResetRestart();$/;"	p	class:__anon53::ProfileDataTest	file:	access:private	signature:()
__anon53::ProfileDataTest::StartStopEmpty	src/tests/profiledata_unittest.cc	/^  void StartStopEmpty();$/;"	p	class:__anon53::ProfileDataTest	file:	access:private	signature:()
__anon53::ProfileDataTest::StartStopEmpty2	src/tests/profiledata_unittest.cc	/^  void StartStopEmpty2();$/;"	p	class:__anon53::ProfileDataTest	file:	access:private	signature:()
__anon53::ProfileDataTest::StartStopNoOptionsEmpty	src/tests/profiledata_unittest.cc	/^  void StartStopNoOptionsEmpty();$/;"	p	class:__anon53::ProfileDataTest	file:	access:private	signature:()
__anon53::ProfileDataTest::StartWhenStarted	src/tests/profiledata_unittest.cc	/^  void StartWhenStarted();$/;"	p	class:__anon53::ProfileDataTest	file:	access:private	signature:()
__anon53::ProfileDataTest::checker_	src/tests/profiledata_unittest.cc	/^  ProfileDataChecker checker_;$/;"	m	class:__anon53::ProfileDataTest	file:	access:protected
__anon53::ProfileDataTest::collector_	src/tests/profiledata_unittest.cc	/^  ProfileData        collector_;$/;"	m	class:__anon53::ProfileDataTest	file:	access:protected
__anon53::ReadPersistent	src/tests/profiledata_unittest.cc	/^static ssize_t ReadPersistent(const int fd, void *buf, const size_t count) {$/;"	f	namespace:__anon53	signature:(const int fd, void *buf, const size_t count)
__anon53::TEST_F	src/tests/profiledata_unittest.cc	/^TEST_F(ProfileDataTest, CollectOne) {$/;"	f	namespace:__anon53	signature:(ProfileDataTest, CollectOne)
__anon53::TEST_F	src/tests/profiledata_unittest.cc	/^TEST_F(ProfileDataTest, CollectTwoFlush) {$/;"	f	namespace:__anon53	signature:(ProfileDataTest, CollectTwoFlush)
__anon53::TEST_F	src/tests/profiledata_unittest.cc	/^TEST_F(ProfileDataTest, CollectTwoMatching) {$/;"	f	namespace:__anon53	signature:(ProfileDataTest, CollectTwoMatching)
__anon53::TEST_F	src/tests/profiledata_unittest.cc	/^TEST_F(ProfileDataTest, OpsWhenStopped) {$/;"	f	namespace:__anon53	signature:(ProfileDataTest, OpsWhenStopped)
__anon53::TEST_F	src/tests/profiledata_unittest.cc	/^TEST_F(ProfileDataTest, StartResetRestart) {$/;"	f	namespace:__anon53	signature:(ProfileDataTest, StartResetRestart)
__anon53::TEST_F	src/tests/profiledata_unittest.cc	/^TEST_F(ProfileDataTest, StartStopEmpty) {$/;"	f	namespace:__anon53	signature:(ProfileDataTest, StartStopEmpty)
__anon53::TEST_F	src/tests/profiledata_unittest.cc	/^TEST_F(ProfileDataTest, StartStopEmpty2) {$/;"	f	namespace:__anon53	signature:(ProfileDataTest, StartStopEmpty2)
__anon53::TEST_F	src/tests/profiledata_unittest.cc	/^TEST_F(ProfileDataTest, StartStopNoOptionsEmpty) {$/;"	f	namespace:__anon53	signature:(ProfileDataTest, StartStopNoOptionsEmpty)
__anon53::TEST_F	src/tests/profiledata_unittest.cc	/^TEST_F(ProfileDataTest, StartWhenStarted) {$/;"	f	namespace:__anon53	signature:(ProfileDataTest, StartWhenStarted)
__anon53::V	src/tests/profiledata_unittest.cc	/^inline void* V(intptr_t x) { return reinterpret_cast<void*>(x); }$/;"	f	namespace:__anon53	signature:(intptr_t x)
__anon53::kNoError	src/tests/profiledata_unittest.cc	/^const char kNoError[] = "";$/;"	m	namespace:__anon53	file:
__anon53::scoped_array	src/tests/profiledata_unittest.cc	/^template<typename T> class scoped_array {$/;"	c	namespace:__anon53	file:
__anon53::scoped_array::data_	src/tests/profiledata_unittest.cc	/^  T* const data_;$/;"	m	class:__anon53::scoped_array	file:	access:private
__anon53::scoped_array::get	src/tests/profiledata_unittest.cc	/^  T* get() { return data_; }$/;"	f	class:__anon53::scoped_array	access:public	signature:()
__anon53::scoped_array::operator []	src/tests/profiledata_unittest.cc	/^  T& operator[](int i) { return data_[i]; }$/;"	f	class:__anon53::scoped_array	access:public	signature:(int i)
__anon53::scoped_array::scoped_array	src/tests/profiledata_unittest.cc	/^  scoped_array(T* data) : data_(data) { }$/;"	f	class:__anon53::scoped_array	access:public	signature:(T* data)
__anon53::scoped_array::~scoped_array	src/tests/profiledata_unittest.cc	/^  ~scoped_array() { delete[] data_; }$/;"	f	class:__anon53::scoped_array	access:public	signature:()
__anon54::scoped_array	src/tests/sampler_test.cc	/^template<typename T> class scoped_array {$/;"	c	namespace:__anon54	file:
__anon54::scoped_array::get	src/tests/sampler_test.cc	/^  T* get() { return p_; }$/;"	f	class:__anon54::scoped_array	access:public	signature:()
__anon54::scoped_array::get	src/tests/sampler_test.cc	/^  const T* get() const { return p_; }$/;"	f	class:__anon54::scoped_array	access:public	signature:() const
__anon54::scoped_array::operator []	src/tests/sampler_test.cc	/^  T& operator[](int i) { return p_[i]; }$/;"	f	class:__anon54::scoped_array	access:public	signature:(int i)
__anon54::scoped_array::p_	src/tests/sampler_test.cc	/^  T* p_;$/;"	m	class:__anon54::scoped_array	file:	access:private
__anon54::scoped_array::scoped_array	src/tests/sampler_test.cc	/^  scoped_array(T* p) : p_(p) { }$/;"	f	class:__anon54::scoped_array	access:public	signature:(T* p)
__anon54::scoped_array::~scoped_array	src/tests/sampler_test.cc	/^  ~scoped_array() { delete[] p_; }$/;"	f	class:__anon54::scoped_array	access:public	signature:()
__anon55::CheckStats	src/tests/page_heap_test.cc	/^static void CheckStats(const tcmalloc::PageHeap* ph,$/;"	f	namespace:__anon55	signature:(const tcmalloc::PageHeap* ph, uint64_t system_pages, uint64_t free_pages, uint64_t unmapped_pages)
__anon55::HaveSystemRelease	src/tests/page_heap_test.cc	/^static bool HaveSystemRelease =$/;"	m	namespace:__anon55	file:
__anon55::TestPageHeap_Limit	src/tests/page_heap_test.cc	/^static void TestPageHeap_Limit() {$/;"	f	namespace:__anon55	signature:()
__anon55::TestPageHeap_Stats	src/tests/page_heap_test.cc	/^static void TestPageHeap_Stats() {$/;"	f	namespace:__anon55	signature:()
__anon56::BusyThread	src/tests/profile-handler_unittest.cc	/^class BusyThread : public Thread {$/;"	c	namespace:__anon56	file:	inherits:Thread
__anon56::BusyThread::BusyThread	src/tests/profile-handler_unittest.cc	/^  BusyThread() : stop_work_(false) {$/;"	f	class:__anon56::BusyThread	access:public	signature:()
__anon56::BusyThread::Run	src/tests/profile-handler_unittest.cc	/^  void Run() {$/;"	f	class:__anon56::BusyThread	file:	access:private	signature:()
__anon56::BusyThread::mu_	src/tests/profile-handler_unittest.cc	/^  Mutex mu_;$/;"	m	class:__anon56::BusyThread	file:	access:private
__anon56::BusyThread::set_stop_work	src/tests/profile-handler_unittest.cc	/^  void set_stop_work(bool stop_work) {$/;"	f	class:__anon56::BusyThread	access:public	signature:(bool stop_work)
__anon56::BusyThread::stop_work	src/tests/profile-handler_unittest.cc	/^  bool stop_work() {$/;"	f	class:__anon56::BusyThread	access:public	signature:()
__anon56::BusyThread::stop_work_	src/tests/profile-handler_unittest.cc	/^  bool stop_work_;$/;"	m	class:__anon56::BusyThread	file:	access:private
__anon56::Delay	src/tests/profile-handler_unittest.cc	/^void Delay(int delay_ns) {$/;"	f	namespace:__anon56	signature:(int delay_ns)
__anon56::IsTimerEnabled	src/tests/profile-handler_unittest.cc	/^bool IsTimerEnabled() {$/;"	f	namespace:__anon56	signature:()
__anon56::NullThread	src/tests/profile-handler_unittest.cc	/^class NullThread : public Thread {$/;"	c	namespace:__anon56	file:	inherits:Thread
__anon56::NullThread::Run	src/tests/profile-handler_unittest.cc	/^  void Run() {$/;"	f	class:__anon56::NullThread	file:	access:private	signature:()
__anon56::ProfileHandlerTest	src/tests/profile-handler_unittest.cc	/^class ProfileHandlerTest {$/;"	c	namespace:__anon56	file:
__anon56::ProfileHandlerTest::GetCallbackCount	src/tests/profile-handler_unittest.cc	/^  uint32 GetCallbackCount() {$/;"	f	class:__anon56::ProfileHandlerTest	access:protected	signature:()
__anon56::ProfileHandlerTest::GetInterruptCount	src/tests/profile-handler_unittest.cc	/^  uint64 GetInterruptCount() {$/;"	f	class:__anon56::ProfileHandlerTest	access:protected	signature:()
__anon56::ProfileHandlerTest::MultipleCallbacks	src/tests/profile-handler_unittest.cc	/^  void MultipleCallbacks();$/;"	p	class:__anon56::ProfileHandlerTest	file:	access:private	signature:()
__anon56::ProfileHandlerTest::RUN_ALL_TESTS	src/tests/profile-handler_unittest.cc	/^  static int RUN_ALL_TESTS() {$/;"	f	class:__anon56::ProfileHandlerTest	access:public	signature:()
__anon56::ProfileHandlerTest::RegisterCallback	src/tests/profile-handler_unittest.cc	/^  ProfileHandlerToken* RegisterCallback(void* callback_arg) {$/;"	f	class:__anon56::ProfileHandlerTest	access:protected	signature:(void* callback_arg)
__anon56::ProfileHandlerTest::RegisterCallbackBeforeThread	src/tests/profile-handler_unittest.cc	/^  void RegisterCallbackBeforeThread();$/;"	p	class:__anon56::ProfileHandlerTest	file:	access:private	signature:()
__anon56::ProfileHandlerTest::RegisterUnregisterCallback	src/tests/profile-handler_unittest.cc	/^  void RegisterUnregisterCallback();$/;"	p	class:__anon56::ProfileHandlerTest	file:	access:private	signature:()
__anon56::ProfileHandlerTest::Reset	src/tests/profile-handler_unittest.cc	/^  void Reset();$/;"	p	class:__anon56::ProfileHandlerTest	file:	access:private	signature:()
__anon56::ProfileHandlerTest::SetUp	src/tests/profile-handler_unittest.cc	/^  virtual void SetUp() {$/;"	f	class:__anon56::ProfileHandlerTest	access:protected	signature:()
__anon56::ProfileHandlerTest::SetUpTestCase	src/tests/profile-handler_unittest.cc	/^  static void SetUpTestCase() {$/;"	f	class:__anon56::ProfileHandlerTest	access:protected	signature:()
__anon56::ProfileHandlerTest::StartWorker	src/tests/profile-handler_unittest.cc	/^  void StartWorker() {$/;"	f	class:__anon56::ProfileHandlerTest	access:protected	signature:()
__anon56::ProfileHandlerTest::StopWorker	src/tests/profile-handler_unittest.cc	/^  void StopWorker() {$/;"	f	class:__anon56::ProfileHandlerTest	access:protected	signature:()
__anon56::ProfileHandlerTest::TearDown	src/tests/profile-handler_unittest.cc	/^  virtual void TearDown() {$/;"	f	class:__anon56::ProfileHandlerTest	access:protected	signature:()
__anon56::ProfileHandlerTest::UnregisterCallback	src/tests/profile-handler_unittest.cc	/^  void UnregisterCallback(ProfileHandlerToken* token) {$/;"	f	class:__anon56::ProfileHandlerTest	access:protected	signature:(ProfileHandlerToken* token)
__anon56::ProfileHandlerTest::VerifyDisabled	src/tests/profile-handler_unittest.cc	/^  void VerifyDisabled() {$/;"	f	class:__anon56::ProfileHandlerTest	access:protected	signature:()
__anon56::ProfileHandlerTest::VerifyRegistration	src/tests/profile-handler_unittest.cc	/^  void VerifyRegistration(const int& tick_counter) {$/;"	f	class:__anon56::ProfileHandlerTest	access:protected	signature:(const int& tick_counter)
__anon56::ProfileHandlerTest::VerifyUnregistration	src/tests/profile-handler_unittest.cc	/^  void VerifyUnregistration(const int& tick_counter) {$/;"	f	class:__anon56::ProfileHandlerTest	access:protected	signature:(const int& tick_counter)
__anon56::ProfileHandlerTest::busy_worker_	src/tests/profile-handler_unittest.cc	/^  BusyThread* busy_worker_;$/;"	m	class:__anon56::ProfileHandlerTest	file:	access:protected
__anon56::TEST_F	src/tests/profile-handler_unittest.cc	/^TEST_F(ProfileHandlerTest, MultipleCallbacks) {$/;"	f	namespace:__anon56	signature:(ProfileHandlerTest, MultipleCallbacks)
__anon56::TEST_F	src/tests/profile-handler_unittest.cc	/^TEST_F(ProfileHandlerTest, RegisterCallbackBeforeThread) {$/;"	f	namespace:__anon56	signature:(ProfileHandlerTest, RegisterCallbackBeforeThread)
__anon56::TEST_F	src/tests/profile-handler_unittest.cc	/^TEST_F(ProfileHandlerTest, RegisterUnregisterCallback) {$/;"	f	namespace:__anon56	signature:(ProfileHandlerTest, RegisterUnregisterCallback)
__anon56::TEST_F	src/tests/profile-handler_unittest.cc	/^TEST_F(ProfileHandlerTest, Reset) {$/;"	f	namespace:__anon56	signature:(ProfileHandlerTest, Reset)
__anon56::Thread	src/tests/profile-handler_unittest.cc	/^class Thread {$/;"	c	namespace:__anon56	file:
__anon56::Thread::DoRun	src/tests/profile-handler_unittest.cc	/^  static void* DoRun(void* cls) {$/;"	f	class:__anon56::Thread	file:	access:private	signature:(void* cls)
__anon56::Thread::Join	src/tests/profile-handler_unittest.cc	/^  void Join()  {$/;"	f	class:__anon56::Thread	access:public	signature:()
__anon56::Thread::Run	src/tests/profile-handler_unittest.cc	/^  virtual void Run() = 0;$/;"	p	class:__anon56::Thread	file:	access:public	signature:()
__anon56::Thread::SetJoinable	src/tests/profile-handler_unittest.cc	/^  void SetJoinable(bool value) { joinable_ = value; }$/;"	f	class:__anon56::Thread	access:public	signature:(bool value)
__anon56::Thread::Start	src/tests/profile-handler_unittest.cc	/^  void Start() {$/;"	f	class:__anon56::Thread	access:public	signature:()
__anon56::Thread::Thread	src/tests/profile-handler_unittest.cc	/^  Thread() : joinable_(false) { }$/;"	f	class:__anon56::Thread	access:public	signature:()
__anon56::Thread::joinable_	src/tests/profile-handler_unittest.cc	/^  bool joinable_;$/;"	m	class:__anon56::Thread	file:	access:private
__anon56::Thread::thread_	src/tests/profile-handler_unittest.cc	/^  pthread_t thread_;$/;"	m	class:__anon56::Thread	file:	access:private
__anon56::Thread::~Thread	src/tests/profile-handler_unittest.cc	/^  virtual ~Thread() { }$/;"	f	class:__anon56::Thread	access:public	signature:()
__anon56::TickCounter	src/tests/profile-handler_unittest.cc	/^static void TickCounter(int sig, siginfo_t* sig_info, void *vuc,$/;"	f	namespace:__anon56	signature:(int sig, siginfo_t* sig_info, void *vuc, void* tick_counter)
__anon56::kSleepInterval	src/tests/profile-handler_unittest.cc	/^int kSleepInterval = 200000000;$/;"	m	namespace:__anon56	file:
__anon56::kTimerResetInterval	src/tests/profile-handler_unittest.cc	/^int kTimerResetInterval = 5000000;$/;"	m	namespace:__anon56	file:
__anon56::linux_per_thread_timers_mode_	src/tests/profile-handler_unittest.cc	/^static bool linux_per_thread_timers_mode_ = false;$/;"	m	namespace:__anon56	file:
__anon56::timer_type_	src/tests/profile-handler_unittest.cc	/^static int timer_type_ = ITIMER_PROF;$/;"	m	namespace:__anon56	file:
__anon57::MmapReplacement	src/tests/malloc_hook_test.cc	/^int MmapReplacement(const void* start,$/;"	f	namespace:__anon57	signature:(const void* start, size_t size, int protection, int flags, int fd, off_t offset, void** result)
__anon57::MultithreadedTestThread	src/tests/malloc_hook_test.cc	/^void MultithreadedTestThread(TestHookList* list, int shift,$/;"	f	namespace:__anon57	signature:(TestHookList* list, int shift, int thread_num)
__anon57::MultithreadedTestThreadRunner	src/tests/malloc_hook_test.cc	/^void MultithreadedTestThreadRunner(int thread_num) {$/;"	f	namespace:__anon57	signature:(int thread_num)
__anon57::MunmapReplacement	src/tests/malloc_hook_test.cc	/^int MunmapReplacement(const void* ptr, size_t size, int* result) {$/;"	f	namespace:__anon57	signature:(const void* ptr, size_t size, int* result)
__anon57::RUN_ALL_TESTS	src/tests/malloc_hook_test.cc	/^static int RUN_ALL_TESTS() {$/;"	f	namespace:__anon57	signature:()
__anon57::Sleep	src/tests/malloc_hook_test.cc	/^void Sleep(int seconds) {$/;"	f	namespace:__anon57	signature:(int seconds)
__anon57::TEST	src/tests/malloc_hook_test.cc	/^TEST(HookListTest, AddAppends) {$/;"	f	namespace:__anon57	signature:(HookListTest, AddAppends)
__anon57::TEST	src/tests/malloc_hook_test.cc	/^TEST(HookListTest, AddPrependsAfterRemove) {$/;"	f	namespace:__anon57	signature:(HookListTest, AddPrependsAfterRemove)
__anon57::TEST	src/tests/malloc_hook_test.cc	/^TEST(HookListTest, CanRemoveInitialValue) {$/;"	f	namespace:__anon57	signature:(HookListTest, CanRemoveInitialValue)
__anon57::TEST	src/tests/malloc_hook_test.cc	/^TEST(HookListTest, FillUpTheList) {$/;"	f	namespace:__anon57	signature:(HookListTest, FillUpTheList)
__anon57::TEST	src/tests/malloc_hook_test.cc	/^TEST(HookListTest, InitialValueExists) {$/;"	f	namespace:__anon57	signature:(HookListTest, InitialValueExists)
__anon57::TEST	src/tests/malloc_hook_test.cc	/^TEST(HookListTest, InvalidAddRejected) {$/;"	f	namespace:__anon57	signature:(HookListTest, InvalidAddRejected)
__anon57::TEST	src/tests/malloc_hook_test.cc	/^TEST(HookListTest, MultithreadedTest) {$/;"	f	namespace:__anon57	signature:(HookListTest, MultithreadedTest)
__anon57::TEST	src/tests/malloc_hook_test.cc	/^TEST(HookListTest, RemoveWorksAndWillClearSize) {$/;"	f	namespace:__anon57	signature:(HookListTest, RemoveWorksAndWillClearSize)
__anon57::TEST	src/tests/malloc_hook_test.cc	/^TEST(MallocMookTest, MmapReplacements) {$/;"	f	namespace:__anon57	signature:(MallocMookTest, MmapReplacements)
__anon57::TestHookList	src/tests/malloc_hook_test.cc	/^typedef base::internal::HookList<MallocHook::NewHook> TestHookList;$/;"	t	namespace:__anon57	file:
__anon57::TestHookList_Add	src/tests/malloc_hook_test.cc	/^bool TestHookList_Add(TestHookList* list, int val) {$/;"	f	namespace:__anon57	signature:(TestHookList* list, int val)
__anon57::TestHookList_Remove	src/tests/malloc_hook_test.cc	/^bool TestHookList_Remove(TestHookList* list, int val) {$/;"	f	namespace:__anon57	signature:(TestHookList* list, int val)
__anon57::TestHookList_Traverse	src/tests/malloc_hook_test.cc	/^int TestHookList_Traverse(const TestHookList& list, uintptr_t* output_array, int n) {$/;"	f	namespace:__anon57	signature:(const TestHookList& list, uintptr_t* output_array, int n)
__anon57::kMmapMagicFd	src/tests/malloc_hook_test.cc	/^const int kMmapMagicFd = 1;$/;"	m	namespace:__anon57	file:
__anon57::kMmapMagicPointer	src/tests/malloc_hook_test.cc	/^void* const kMmapMagicPointer = reinterpret_cast<void*>(1);$/;"	m	namespace:__anon57	file:
__anon57::list	src/tests/malloc_hook_test.cc	/^static TestHookList list = INIT_HOOK_LIST(69);$/;"	m	namespace:__anon57	file:
__anon57::mmap_calls	src/tests/malloc_hook_test.cc	/^int mmap_calls = 0;$/;"	m	namespace:__anon57	file:
__anon57::mmap_matching_calls	src/tests/malloc_hook_test.cc	/^int mmap_matching_calls = 0;$/;"	m	namespace:__anon57	file:
__anon57::munmap_calls	src/tests/malloc_hook_test.cc	/^int munmap_calls = 0;$/;"	m	namespace:__anon57	file:
__anon57::munmap_matching_calls	src/tests/malloc_hook_test.cc	/^int munmap_matching_calls = 0;$/;"	m	namespace:__anon57	file:
__anon57::num_threads_remaining	src/tests/malloc_hook_test.cc	/^static volatile int num_threads_remaining;$/;"	m	namespace:__anon57	file:
__anon57::threadcount_lock	src/tests/malloc_hook_test.cc	/^static Mutex threadcount_lock;$/;"	m	namespace:__anon57	file:
__anon58::buf	src/tests/tcmalloc_unittest.cc	/^  char buf[sizeof(OOMAbleSysAlloc)];$/;"	m	union:__anon58	file:	access:public
__anon58::ptr	src/tests/tcmalloc_unittest.cc	/^  void *ptr;$/;"	m	union:__anon58	file:	access:public
__anon5::buf	src/memfs_malloc.cc	/^  char buf[sizeof(HugetlbSysAllocator)];$/;"	m	union:__anon5	file:	access:public
__anon5::ptr	src/memfs_malloc.cc	/^  void *ptr;$/;"	m	union:__anon5	file:	access:public
__anon7::mi_check	src/libc_override_osx.h	/^boolean_t mi_check(malloc_zone_t *zone) {$/;"	f	namespace:__anon7	signature:(malloc_zone_t *zone)
__anon7::mi_enumerator	src/libc_override_osx.h	/^kern_return_t mi_enumerator(task_t task, void *,$/;"	f	namespace:__anon7	signature:(task_t task, void *, unsigned type_mask, vm_address_t zone_address, memory_reader_t reader, vm_range_recorder_t recorder)
__anon7::mi_force_lock	src/libc_override_osx.h	/^void mi_force_lock(malloc_zone_t *zone) {$/;"	f	namespace:__anon7	signature:(malloc_zone_t *zone)
__anon7::mi_force_unlock	src/libc_override_osx.h	/^void mi_force_unlock(malloc_zone_t *zone) {$/;"	f	namespace:__anon7	signature:(malloc_zone_t *zone)
__anon7::mi_good_size	src/libc_override_osx.h	/^size_t mi_good_size(malloc_zone_t *zone, size_t size) {$/;"	f	namespace:__anon7	signature:(malloc_zone_t *zone, size_t size)
__anon7::mi_log	src/libc_override_osx.h	/^void mi_log(malloc_zone_t *zone, void *address) {$/;"	f	namespace:__anon7	signature:(malloc_zone_t *zone, void *address)
__anon7::mi_print	src/libc_override_osx.h	/^void mi_print(malloc_zone_t *zone, boolean_t verbose) {$/;"	f	namespace:__anon7	signature:(malloc_zone_t *zone, boolean_t verbose)
__anon7::mi_statistics	src/libc_override_osx.h	/^void mi_statistics(malloc_zone_t *zone, malloc_statistics_t *stats) {$/;"	f	namespace:__anon7	signature:(malloc_zone_t *zone, malloc_statistics_t *stats)
__anon7::mi_zone_locked	src/libc_override_osx.h	/^boolean_t mi_zone_locked(malloc_zone_t *zone) {$/;"	f	namespace:__anon7	signature:(malloc_zone_t *zone)
__anon7::mz_calloc	src/libc_override_osx.h	/^void* mz_calloc(malloc_zone_t* zone, size_t num_items, size_t size) {$/;"	f	namespace:__anon7	signature:(malloc_zone_t* zone, size_t num_items, size_t size)
__anon7::mz_destroy	src/libc_override_osx.h	/^void mz_destroy(malloc_zone_t* zone) {$/;"	f	namespace:__anon7	signature:(malloc_zone_t* zone)
__anon7::mz_free	src/libc_override_osx.h	/^void mz_free(malloc_zone_t* zone, void* ptr) {$/;"	f	namespace:__anon7	signature:(malloc_zone_t* zone, void* ptr)
__anon7::mz_malloc	src/libc_override_osx.h	/^void* mz_malloc(malloc_zone_t* zone, size_t size) {$/;"	f	namespace:__anon7	signature:(malloc_zone_t* zone, size_t size)
__anon7::mz_memalign	src/libc_override_osx.h	/^void* mz_memalign(malloc_zone_t* zone, size_t align, size_t size) {$/;"	f	namespace:__anon7	signature:(malloc_zone_t* zone, size_t align, size_t size)
__anon7::mz_realloc	src/libc_override_osx.h	/^void* mz_realloc(malloc_zone_t* zone, void* ptr, size_t size) {$/;"	f	namespace:__anon7	signature:(malloc_zone_t* zone, void* ptr, size_t size)
__anon7::mz_size	src/libc_override_osx.h	/^size_t mz_size(malloc_zone_t* zone, const void* ptr) {$/;"	f	namespace:__anon7	signature:(malloc_zone_t* zone, const void* ptr)
__anon7::mz_valloc	src/libc_override_osx.h	/^void* mz_valloc(malloc_zone_t* zone, size_t size) {$/;"	f	namespace:__anon7	signature:(malloc_zone_t* zone, size_t size)
__anon8::chars	src/debugallocation.cc	/^  char chars[sizeof(DebugMallocImplementation)];$/;"	m	union:__anon8	file:	access:public
__anon8::ptr	src/debugallocation.cc	/^  void *ptr;$/;"	m	union:__anon8	file:	access:public
__cyg_profile_func_enter	src/stacktrace_instrument-inl.h	/^void __cyg_profile_func_enter(void *func_address, void *call_site) {$/;"	f	signature:(void *func_address, void *call_site)
__cyg_profile_func_exit	src/stacktrace_instrument-inl.h	/^void __cyg_profile_func_exit(void *func_address, void *call_site) {$/;"	f	signature:(void *func_address, void *call_site)
__extension__	src/third_party/valgrind.h	3632;"	d
__malloctrace_write	src/debugallocation.cc	/^void __malloctrace_write(const char *buf, size_t size) {$/;"	f	signature:(const char *buf, size_t size)
__n	src/libtcmalloc_internal_la-symbolize.o	/^a/;"	v
__n	src/libtcmalloc_minimal_internal_la-symbolize.o	/^a/;"	v
__pad0	src/base/linux_syscall_support.h	/^  unsigned           __pad0;$/;"	m	struct:kernel_stat	access:public
__pad0	src/base/linux_syscall_support.h	/^  unsigned           __pad0[3];$/;"	m	struct:kernel_stat	access:public
__pad0	src/base/linux_syscall_support.h	/^  unsigned char      __pad0[4];$/;"	m	struct:kernel_stat64	access:public
__pad1	src/base/linux_syscall_support.h	/^  unsigned           __pad1[3];$/;"	m	struct:kernel_stat	access:public
__pad1	src/base/linux_syscall_support.h	/^  unsigned int       __pad1;$/;"	m	struct:kernel_stat	access:public
__pad1	src/base/linux_syscall_support.h	/^  unsigned long      __pad1;$/;"	m	struct:kernel_stat	access:public
__pad1	src/base/linux_syscall_support.h	/^  unsigned short     __pad1;$/;"	m	struct:kernel_stat	access:public
__pad2	src/base/linux_syscall_support.h	/^  int                __pad2;$/;"	m	struct:kernel_stat	access:public
__pad2	src/base/linux_syscall_support.h	/^  int                __pad2;$/;"	m	struct:kernel_stat64	access:public
__pad2	src/base/linux_syscall_support.h	/^  unsigned           __pad2;$/;"	m	struct:kernel_stat	access:public
__pad2	src/base/linux_syscall_support.h	/^  unsigned short     __pad2;$/;"	m	struct:kernel_stat	access:public
__pad3	src/base/linux_syscall_support.h	/^  unsigned char      __pad3[4];$/;"	m	struct:kernel_stat64	access:public
__sbrk	src/malloc_hook_mmap_linux.h	/^extern "C" void* __sbrk(ptrdiff_t increment);$/;"	p	signature:(ptrdiff_t increment)
__sbrk	src/windows/port.cc	/^extern "C" PERFTOOLS_DLL_DECL void* __sbrk(ptrdiff_t increment) {$/;"	f	signature:(ptrdiff_t increment)
__st_ino	src/base/linux_syscall_support.h	/^  unsigned           __st_ino;$/;"	m	struct:kernel_stat64	access:public
__sync_val_compare_and_swap	src/base/atomicops-internals-x86.h	/^inline Atomic64 __sync_val_compare_and_swap(volatile Atomic64* ptr,$/;"	f	namespace:base::subtle	signature:(volatile Atomic64* ptr, Atomic64 old_value, Atomic64 new_value)
__syscall	src/base/linux_syscall_support.h	609;"	d
__syscall	src/base/linux_syscall_support.h	618;"	d
__syscall_safe	src/base/linux_syscall_support.h	610;"	d
__syscall_safe	src/base/linux_syscall_support.h	619;"	d
__tcmalloc	src/windows/patch_functions.cc	/^extern "C" PERFTOOLS_DLL_DECL void __tcmalloc();$/;"	p	file:	signature:()
__tcmalloc	src/windows/patch_functions.cc	/^void __tcmalloc() { }$/;"	f	signature:()
__thread	src/windows/port.h	192;"	d
__unused	src/base/linux_syscall_support.h	/^  int64_t            __unused[3];$/;"	m	struct:kernel_stat	access:public
__unused	src/base/linux_syscall_support.h	/^  unsigned long      __unused[3];$/;"	m	struct:kernel_stat	access:public
__unused4	src/base/linux_syscall_support.h	/^  unsigned           __unused4;$/;"	m	struct:kernel_stat	access:public
__unused4	src/base/linux_syscall_support.h	/^  unsigned int       __unused4;$/;"	m	struct:kernel_stat	access:public
__unused4	src/base/linux_syscall_support.h	/^  unsigned long      __unused4;$/;"	m	struct:kernel_stat	access:public
__unused4	src/base/linux_syscall_support.h	/^  unsigned long      __unused4;$/;"	m	struct:kernel_stat64	access:public
__unused5	src/base/linux_syscall_support.h	/^  unsigned           __unused5;$/;"	m	struct:kernel_stat	access:public
__unused5	src/base/linux_syscall_support.h	/^  unsigned int       __unused5;$/;"	m	struct:kernel_stat	access:public
__unused5	src/base/linux_syscall_support.h	/^  unsigned long      __unused5;$/;"	m	struct:kernel_stat	access:public
__unused5	src/base/linux_syscall_support.h	/^  unsigned long      __unused5;$/;"	m	struct:kernel_stat64	access:public
__unused6	src/base/linux_syscall_support.h	/^  unsigned long      __unused6;$/;"	m	struct:kernel_stat	access:public
__unused6	src/base/linux_syscall_support.h	/^  unsigned long      __unused6;$/;"	m	struct:kernel_stat64	access:public
_calloc_dbg	src/windows/override_functions.cc	/^extern "C" void* _calloc_dbg(size_t n, size_t size, int, const char*, int) {$/;"	f	signature:(size_t n, size_t size, int, const char*, int)
_calloc_impl	src/windows/override_functions.cc	/^extern "C" void* _calloc_impl(size_t n, size_t size) {$/;"	f	signature:(size_t n, size_t size)
_crtheap	src/windows/override_functions.cc	/^extern "C" void* _crtheap = reinterpret_cast<void*>(1);$/;"	v
_free_dbg	src/windows/override_functions.cc	/^extern "C" void _free_dbg(void* ptr, int) {$/;"	f	signature:(void* ptr, int)
_get_heap_handle	src/windows/override_functions.cc	/^extern "C" intptr_t _get_heap_handle() {$/;"	f	signature:()
_heap_init	src/windows/override_functions.cc	/^extern "C" int _heap_init() {$/;"	f	signature:()
_heap_term	src/windows/override_functions.cc	/^extern "C" void _heap_term() {$/;"	f	signature:()
_instead	src/tcm_min_asserts_unittest-internal_logging.o	/^/;"	n	file:
_isync	src/base/atomicops-internals-linuxppc.h	/^static inline void _isync(void) {$/;"	f	namespace:base::subtle	signature:(void)
_lt_dar_export_syms	m4/libtool.m4	/^      _lt_dar_export_syms=' ${wl}-exported_symbols_list,$output_objdir\/${libname}-symbols.expsym'$/;"	v
_lt_dar_single_mod	m4/libtool.m4	/^      _lt_dar_single_mod='$single_module'$/;"	v
_lt_dsymutil	m4/libtool.m4	/^      _lt_dsymutil='~$DSYMUTIL $lib || :'$/;"	v
_lwsync	src/base/atomicops-internals-linuxppc.h	/^static inline void _lwsync(void) {$/;"	f	namespace:base::subtle	signature:(void)
_malloc_dbg	src/windows/override_functions.cc	/^extern "C" void* _malloc_dbg(size_t size, int , const char*, int) {$/;"	f	signature:(size_t size, int , const char*, int)
_mmap2	src/base/linux_syscall_support.h	/^    LSS_INLINE void* LSS_NAME(_mmap2)(void *s, size_t l, int p, int f, int d,$/;"	f	signature:(void *s, size_t l, int p, int f, int d, off_t o)
_msize	src/windows/override_functions.cc	/^extern "C" size_t _msize(void* p) {$/;"	f	signature:(void* p)
_recalloc	src/windows/override_functions.cc	/^extern "C" void* _recalloc(void* p, size_t n, size_t size) {$/;"	f	signature:(void* p, size_t n, size_t size)
_set_new_mode	src/windows/override_functions.cc	/^extern "C" int _set_new_mode(int flag) {$/;"	f	signature:(int flag)
_sync	src/base/atomicops-internals-linuxppc.h	/^static inline void _sync(void) {$/;"	f	namespace:base::subtle	signature:(void)
_syscall0	src/base/linux_syscall_support.h	1071;"	d
_syscall0	src/base/linux_syscall_support.h	1072;"	d
_syscall0	src/base/linux_syscall_support.h	1368;"	d
_syscall0	src/base/linux_syscall_support.h	1369;"	d
_syscall0	src/base/linux_syscall_support.h	1541;"	d
_syscall0	src/base/linux_syscall_support.h	1542;"	d
_syscall0	src/base/linux_syscall_support.h	1726;"	d
_syscall0	src/base/linux_syscall_support.h	1727;"	d
_syscall0	src/base/linux_syscall_support.h	2000;"	d
_syscall0	src/base/linux_syscall_support.h	2001;"	d
_syscall0	src/base/linux_syscall_support.h	2213;"	d
_syscall0	src/base/linux_syscall_support.h	2214;"	d
_syscall0	src/base/linux_syscall_support.h	2337;"	d
_syscall0	src/base/linux_syscall_support.h	2338;"	d
_syscall1	src/base/linux_syscall_support.h	1081;"	d
_syscall1	src/base/linux_syscall_support.h	1082;"	d
_syscall1	src/base/linux_syscall_support.h	1373;"	d
_syscall1	src/base/linux_syscall_support.h	1374;"	d
_syscall1	src/base/linux_syscall_support.h	1546;"	d
_syscall1	src/base/linux_syscall_support.h	1547;"	d
_syscall1	src/base/linux_syscall_support.h	1732;"	d
_syscall1	src/base/linux_syscall_support.h	1733;"	d
_syscall1	src/base/linux_syscall_support.h	2005;"	d
_syscall1	src/base/linux_syscall_support.h	2006;"	d
_syscall1	src/base/linux_syscall_support.h	2218;"	d
_syscall1	src/base/linux_syscall_support.h	2219;"	d
_syscall1	src/base/linux_syscall_support.h	2342;"	d
_syscall1	src/base/linux_syscall_support.h	2343;"	d
_syscall2	src/base/linux_syscall_support.h	1088;"	d
_syscall2	src/base/linux_syscall_support.h	1089;"	d
_syscall2	src/base/linux_syscall_support.h	1378;"	d
_syscall2	src/base/linux_syscall_support.h	1379;"	d
_syscall2	src/base/linux_syscall_support.h	1553;"	d
_syscall2	src/base/linux_syscall_support.h	1554;"	d
_syscall2	src/base/linux_syscall_support.h	1738;"	d
_syscall2	src/base/linux_syscall_support.h	1739;"	d
_syscall2	src/base/linux_syscall_support.h	2010;"	d
_syscall2	src/base/linux_syscall_support.h	2011;"	d
_syscall2	src/base/linux_syscall_support.h	2223;"	d
_syscall2	src/base/linux_syscall_support.h	2224;"	d
_syscall2	src/base/linux_syscall_support.h	2348;"	d
_syscall2	src/base/linux_syscall_support.h	2349;"	d
_syscall3	src/base/linux_syscall_support.h	/^    LSS_INLINE _syscall3(long, getcpu, unsigned *, cpu,$/;"	p	signature:(long, getcpu, unsigned *, cpu, unsigned *, node, void *, unused)
_syscall3	src/base/linux_syscall_support.h	1095;"	d
_syscall3	src/base/linux_syscall_support.h	1096;"	d
_syscall3	src/base/linux_syscall_support.h	1383;"	d
_syscall3	src/base/linux_syscall_support.h	1384;"	d
_syscall3	src/base/linux_syscall_support.h	1562;"	d
_syscall3	src/base/linux_syscall_support.h	1563;"	d
_syscall3	src/base/linux_syscall_support.h	1745;"	d
_syscall3	src/base/linux_syscall_support.h	1746;"	d
_syscall3	src/base/linux_syscall_support.h	2015;"	d
_syscall3	src/base/linux_syscall_support.h	2016;"	d
_syscall3	src/base/linux_syscall_support.h	2229;"	d
_syscall3	src/base/linux_syscall_support.h	2230;"	d
_syscall3	src/base/linux_syscall_support.h	2354;"	d
_syscall3	src/base/linux_syscall_support.h	2355;"	d
_syscall4	src/base/linux_syscall_support.h	/^  LSS_INLINE _syscall4(int, rt_sigprocmask,      int,         h,$/;"	p	signature:(int, rt_sigprocmask, int, h, const struct kernel_sigset_t*, s, struct kernel_sigset_t*, o, size_t, c)
_syscall4	src/base/linux_syscall_support.h	1103;"	d
_syscall4	src/base/linux_syscall_support.h	1104;"	d
_syscall4	src/base/linux_syscall_support.h	1389;"	d
_syscall4	src/base/linux_syscall_support.h	1390;"	d
_syscall4	src/base/linux_syscall_support.h	1573;"	d
_syscall4	src/base/linux_syscall_support.h	1574;"	d
_syscall4	src/base/linux_syscall_support.h	1752;"	d
_syscall4	src/base/linux_syscall_support.h	1753;"	d
_syscall4	src/base/linux_syscall_support.h	2020;"	d
_syscall4	src/base/linux_syscall_support.h	2021;"	d
_syscall4	src/base/linux_syscall_support.h	2235;"	d
_syscall4	src/base/linux_syscall_support.h	2236;"	d
_syscall4	src/base/linux_syscall_support.h	2360;"	d
_syscall4	src/base/linux_syscall_support.h	2361;"	d
_syscall5	src/base/linux_syscall_support.h	1111;"	d
_syscall5	src/base/linux_syscall_support.h	1112;"	d
_syscall5	src/base/linux_syscall_support.h	1395;"	d
_syscall5	src/base/linux_syscall_support.h	1396;"	d
_syscall5	src/base/linux_syscall_support.h	1587;"	d
_syscall5	src/base/linux_syscall_support.h	1588;"	d
_syscall5	src/base/linux_syscall_support.h	1759;"	d
_syscall5	src/base/linux_syscall_support.h	1764;"	d
_syscall5	src/base/linux_syscall_support.h	1786;"	d
_syscall5	src/base/linux_syscall_support.h	2026;"	d
_syscall5	src/base/linux_syscall_support.h	2027;"	d
_syscall5	src/base/linux_syscall_support.h	2242;"	d
_syscall5	src/base/linux_syscall_support.h	2243;"	d
_syscall5	src/base/linux_syscall_support.h	2370;"	d
_syscall5	src/base/linux_syscall_support.h	2371;"	d
_syscall6	src/base/linux_syscall_support.h	1129;"	d
_syscall6	src/base/linux_syscall_support.h	1130;"	d
_syscall6	src/base/linux_syscall_support.h	1404;"	d
_syscall6	src/base/linux_syscall_support.h	1405;"	d
_syscall6	src/base/linux_syscall_support.h	1604;"	d
_syscall6	src/base/linux_syscall_support.h	1605;"	d
_syscall6	src/base/linux_syscall_support.h	1796;"	d
_syscall6	src/base/linux_syscall_support.h	1801;"	d
_syscall6	src/base/linux_syscall_support.h	1826;"	d
_syscall6	src/base/linux_syscall_support.h	2033;"	d
_syscall6	src/base/linux_syscall_support.h	2034;"	d
_syscall6	src/base/linux_syscall_support.h	2252;"	d
_syscall6	src/base/linux_syscall_support.h	2253;"	d
_syscall6	src/base/linux_syscall_support.h	2380;"	d
_syscall6	src/base/linux_syscall_support.h	2381;"	d
_tcmalloc	src/windows/patch_functions.cc	/^extern "C" PERFTOOLS_DLL_DECL void _tcmalloc();$/;"	p	file:	signature:()
_tcmalloc	src/windows/patch_functions.cc	/^void _tcmalloc() { }$/;"	f	signature:()
_tmain	src/windows/preamble_patcher_test.cc	/^int _tmain(int argc, _TCHAR* argv[])$/;"	f	signature:(int argc, _TCHAR* argv[])
a	docs/heapprofile.html	/^does not start with a <code>\/<\/code>, the profile files will be$/;"	v
a	src/.libs/libtcmalloc_minimal_internal_la-internal_logging.o	/^/;"	v
a	src/tests/system-alloc_unittest.cc	/^ArraySysAllocator a;$/;"	v
above	src/windows/shortproc.asm	/^;     * Redistributions in binary form must reproduce the above$/;"	v
absdir	binary_trees_shared	/^  absdir=`cd "$thisdir" && pwd`$/;"	v
absdir	current_allocated_bytes_test	/^  absdir=`cd "$thisdir" && pwd`$/;"	v
absdir	debugallocation_test	/^  absdir=`cd "$thisdir" && pwd`$/;"	v
absdir	frag_unittest	/^  absdir=`cd "$thisdir" && pwd`$/;"	v
absdir	heap-checker_debug_unittest	/^  absdir=`cd "$thisdir" && pwd`$/;"	v
absdir	heap-checker_unittest	/^  absdir=`cd "$thisdir" && pwd`$/;"	v
absdir	heap-profiler_debug_unittest	/^  absdir=`cd "$thisdir" && pwd`$/;"	v
absdir	heap-profiler_unittest	/^  absdir=`cd "$thisdir" && pwd`$/;"	v
absdir	malloc_bench_shared	/^  absdir=`cd "$thisdir" && pwd`$/;"	v
absdir	malloc_bench_shared_full	/^  absdir=`cd "$thisdir" && pwd`$/;"	v
absdir	malloc_extension_c_test	/^  absdir=`cd "$thisdir" && pwd`$/;"	v
absdir	malloc_extension_debug_test	/^  absdir=`cd "$thisdir" && pwd`$/;"	v
absdir	malloc_extension_test	/^  absdir=`cd "$thisdir" && pwd`$/;"	v
absdir	malloc_hook_test	/^  absdir=`cd "$thisdir" && pwd`$/;"	v
absdir	markidle_unittest	/^  absdir=`cd "$thisdir" && pwd`$/;"	v
absdir	memalign_debug_unittest	/^  absdir=`cd "$thisdir" && pwd`$/;"	v
absdir	memalign_unittest	/^  absdir=`cd "$thisdir" && pwd`$/;"	v
absdir	packed_cache_test	/^  absdir=`cd "$thisdir" && pwd`$/;"	v
absdir	page_heap_test	/^  absdir=`cd "$thisdir" && pwd`$/;"	v
absdir	pagemap_unittest	/^  absdir=`cd "$thisdir" && pwd`$/;"	v
absdir	profile_handler_unittest	/^  absdir=`cd "$thisdir" && pwd`$/;"	v
absdir	profiledata_unittest	/^  absdir=`cd "$thisdir" && pwd`$/;"	v
absdir	profiler1_unittest	/^  absdir=`cd "$thisdir" && pwd`$/;"	v
absdir	profiler2_unittest	/^  absdir=`cd "$thisdir" && pwd`$/;"	v
absdir	profiler3_unittest	/^  absdir=`cd "$thisdir" && pwd`$/;"	v
absdir	profiler4_unittest	/^  absdir=`cd "$thisdir" && pwd`$/;"	v
absdir	raw_printer_test	/^  absdir=`cd "$thisdir" && pwd`$/;"	v
absdir	realloc_debug_unittest	/^  absdir=`cd "$thisdir" && pwd`$/;"	v
absdir	realloc_unittest	/^  absdir=`cd "$thisdir" && pwd`$/;"	v
absdir	sampler_debug_test	/^  absdir=`cd "$thisdir" && pwd`$/;"	v
absdir	sampler_test	/^  absdir=`cd "$thisdir" && pwd`$/;"	v
absdir	sampling_debug_test	/^  absdir=`cd "$thisdir" && pwd`$/;"	v
absdir	sampling_test	/^  absdir=`cd "$thisdir" && pwd`$/;"	v
absdir	simple_compat_test	/^  absdir=`cd "$thisdir" && pwd`$/;"	v
absdir	stack_trace_table_test	/^  absdir=`cd "$thisdir" && pwd`$/;"	v
absdir	system_alloc_unittest	/^  absdir=`cd "$thisdir" && pwd`$/;"	v
absdir	tcmalloc_and_profiler_unittest	/^  absdir=`cd "$thisdir" && pwd`$/;"	v
absdir	tcmalloc_both_unittest	/^  absdir=`cd "$thisdir" && pwd`$/;"	v
absdir	tcmalloc_debug_unittest	/^  absdir=`cd "$thisdir" && pwd`$/;"	v
absdir	tcmalloc_large_heap_fragmentation_unittest	/^  absdir=`cd "$thisdir" && pwd`$/;"	v
absdir	tcmalloc_large_unittest	/^  absdir=`cd "$thisdir" && pwd`$/;"	v
absdir	tcmalloc_minimal_debug_unittest	/^  absdir=`cd "$thisdir" && pwd`$/;"	v
absdir	tcmalloc_minimal_large_heap_fragmentation_unittest	/^  absdir=`cd "$thisdir" && pwd`$/;"	v
absdir	tcmalloc_minimal_large_unittest	/^  absdir=`cd "$thisdir" && pwd`$/;"	v
absdir	tcmalloc_minimal_unittest	/^  absdir=`cd "$thisdir" && pwd`$/;"	v
absdir	tcmalloc_unittest	/^  absdir=`cd "$thisdir" && pwd`$/;"	v
absdir	thread_dealloc_unittest	/^  absdir=`cd "$thisdir" && pwd`$/;"	v
absdir	unwind_bench	/^  absdir=`cd "$thisdir" && pwd`$/;"	v
ac_configure_extra_args	config.status	/^  ac_configure_extra_args="$ac_configure_extra_args --silent"$/;"	v
ac_configure_extra_args	config.status	/^ac_configure_extra_args=$/;"	v
access	src/windows/port.h	/^inline int access(const char *pathname, int mode) {$/;"	f	signature:(const char *pathname, int mode)
accuracy	docs/heap_checker.html	/^time and accuracy, and others that increase the sensitivity at the$/;"	v
adaptive_spin_count	src/base/spinlock.cc	/^static int adaptive_spin_count = 0;$/;"	v	file:
addr	src/windows/nm-pdb.c	/^  ULONG64 addr;$/;"	m	struct:__anon10	file:	access:public
address	m4/libtool.m4	/^  void       *address;$/;"	m	struct:__anon1	file:	access:public
address	src/base/elf_mem_image.h	/^    const void      *address;   \/\/ Relocated symbol address.$/;"	m	struct:base::ElfMemImage::SymbolInfo	access:public
address	src/base/stl_allocator.h	/^  const_pointer address(const_reference x) const { return &x; }$/;"	f	class:STL_Allocator	access:public	signature:(const_reference x) const
address	src/base/stl_allocator.h	/^  pointer address(reference x) const { return &x; }$/;"	f	class:STL_Allocator	access:public	signature:(reference x) const
address	src/gperftools/malloc_extension.h	/^  uintptr_t address;    \/\/ Address of range$/;"	m	struct:base::MallocRange	access:public
address_default_is_32_bits_	src/windows/mini_disassembler.h	/^  bool address_default_is_32_bits_;$/;"	m	class:sidestep::MiniDisassembler	access:private
address_is_32_bits_	src/windows/mini_disassembler.h	/^  bool address_is_32_bits_;$/;"	m	class:sidestep::MiniDisassembler	access:private
address_map_	src/heap-profile-table.h	/^  AllocationMap* address_map_;$/;"	m	class:HeapProfileTable	access:private
aggressive_decommit_	src/page_heap.h	/^  bool aggressive_decommit_;$/;"	m	class:tcmalloc::PageHeap	access:private
align	src/debugallocation.cc	/^  size_t align;$/;"	m	struct:memalign_retry_data	file:	access:public
align	src/tcmalloc.cc	/^  size_t align;$/;"	m	struct:tcmalloc::retry_memalign_data	file:	access:public
align_it	src/memory_region_map.cc	/^  void* align_it;  \/\/ do not need a better alignment for 'rep' than this$/;"	m	union:MemoryRegionMap::RegionSetRep	file:	access:public
align_size_up	src/tcmalloc.cc	/^size_t align_size_up(size_t size, size_t align) {$/;"	f	file:	signature:(size_t size, size_t align)
aligned_alloc	src/libc_override_redefine.h	/^  void* aligned_alloc(size_t a, size_t s)        { return tc_memalign(a, s);  }$/;"	f	signature:(size_t a, size_t s)
alignment_checker_lock	src/heap-checker.cc	/^static SpinLock alignment_checker_lock(SpinLock::LINKER_INITIALIZED);$/;"	p	file:	signature:(SpinLock::LINKER_INITIALIZED)
all_impls	src/stacktrace.cc	/^static GetStackImplementation *all_impls[] = {$/;"	v	file:
alloc	src/tests/tcmalloc_unittest.cc	/^  void* alloc(size_t size) {$/;"	f	class:testing::AllocatorState	access:public	signature:(size_t size)
alloc_	src/addressmap-inl.h	/^  Allocator     alloc_;                 \/\/ The allocator$/;"	m	class:AddressMap	access:private
alloc_	src/heap-profile-table.h	/^  Allocator alloc_;$/;"	m	class:HeapProfileTable	access:private
alloc_count	src/heap-checker.cc	/^  static int alloc_count() {$/;"	f	class:HeapLeakChecker::Allocator	access:public	signature:()
alloc_count_	src/heap-checker.cc	/^  static int alloc_count_;$/;"	m	class:HeapLeakChecker::Allocator	file:	access:private
alloc_count_	src/heap-checker.cc	/^int HeapLeakChecker::Allocator::alloc_count_ = 0;$/;"	m	class:HeapLeakChecker::Allocator	file:
alloc_map_	src/debugallocation.cc	/^  static AllocMap* alloc_map_;$/;"	m	class:MallocBlock	file:	access:private
alloc_map_	src/debugallocation.cc	/^MallocBlock::AllocMap* MallocBlock::alloc_map_ = NULL;$/;"	m	class:MallocBlock	file:
alloc_map_lock_	src/debugallocation.cc	/^  static SpinLock alloc_map_lock_;$/;"	m	class:MallocBlock	file:	access:private
alloc_map_lock_	src/debugallocation.cc	/^SpinLock MallocBlock::alloc_map_lock_(SpinLock::LINKER_INITIALIZED);$/;"	p	class:MallocBlock	file:	signature:(SpinLock::LINKER_INITIALIZED)
alloc_size	src/heap-profile-stats.h	/^  int64 alloc_size;  \/\/ Total size of all allocated objects so far.$/;"	m	struct:HeapProfileStats	access:public
alloc_type_	src/debugallocation.cc	/^  size_t alloc_type_;$/;"	m	class:MallocBlock	file:	access:private
allocate	src/base/stl_allocator.h	/^  pointer allocate(size_type n, const void* = 0) {$/;"	f	class:STL_Allocator	access:public	signature:(size_type n, const void* = 0)
allocated_	src/addressmap-inl.h	/^  Object*       allocated_;             \/\/ List of allocated objects$/;"	m	class:AddressMap	access:private
allocates	src/tests/low_level_alloc_unittest.cc	/^static int32 allocates;$/;"	v	file:
allocation_count	src/base/low_level_alloc.cc	/^  int32 allocation_count; \/\/ count of allocated blocks (under mu)$/;"	m	struct:LowLevelAlloc::Arena	file:	access:public
allocator	src/base/low_level_alloc.cc	/^  PagesAllocator *allocator;$/;"	m	struct:LowLevelAlloc::Arena	file:	access:public
allocator_	src/pagemap.h	/^  void* (*allocator_)(size_t);          \/\/ Memory allocator$/;"	m	class:TCMalloc_PageMap2	access:private
allocator_	src/pagemap.h	/^  void* (*allocator_)(size_t);          \/\/ Memory allocator$/;"	m	class:TCMalloc_PageMap3	access:private
allocs	src/heap-profile-stats.h	/^  int32 allocs;      \/\/ Number of allocation calls.$/;"	m	struct:HeapProfileStats	access:public
allocs_	src/system-alloc.cc	/^  SysAllocator* allocs_[kMaxAllocators];$/;"	m	class:DefaultSysAllocator	file:	access:private
allowed	src/profile-handler.h	/^  bool allowed; \/* Profiling is allowed *\/$/;"	m	struct:ProfileHandlerState	access:public
allowed_	src/profile-handler.cc	/^  bool allowed_;$/;"	m	class:ProfileHandler	file:	access:private
altstack_mem	src/base/linuxthreads.cc	/^  char        *altstack_mem;$/;"	m	struct:ListerParams	file:	access:public
analysis	packages/deb/control	/^Description: libraries for CPU and heap analysis, plus an efficient thread-caching malloc$/;"	v
ap	src/base/linuxthreads.cc	/^  va_list     ap;$/;"	m	struct:ListerParams	file:	access:public
append	src/tests/heap-checker_unittest.cc	/^  void append(const Array& x) {$/;"	f	struct:Array	access:public	signature:(const Array& x)
application	docs/tcmalloc.html	/^either a large object that has been handed off to the application, or$/;"	m	class:object	file:	access:private
architectures	INSTALL	/^_same_ architectures, `configure' can figure that out, but if it prints$/;"	v
are	src/windows/shortproc.asm	/^; modification, are permitted provided that the following conditions are$/;"	v
area	docs/heap_checker.html	/^area, even though the leak actually happened before the$/;"	v
arena	src/base/low_level_alloc.cc	/^      LowLevelAlloc::Arena *arena; \/\/ pointer to parent arena$/;"	m	struct:low_level_alloc_internal::AllocList::Header	file:	access:public
arena_	src/base/low_level_alloc.cc	/^        : left_(false), mask_valid_(false), arena_(arena) {$/;"	f	class:__anon39::ArenaLock	access:public	signature:(arena)
arena_	src/base/low_level_alloc.cc	/^    LowLevelAlloc::Arena *arena_;$/;"	m	class:__anon39::ArenaLock	file:	access:private
arena_	src/heap-checker.cc	/^  static LowLevelAlloc::Arena* arena_;$/;"	m	class:HeapLeakChecker::Allocator	file:	access:private
arena_	src/heap-checker.cc	/^LowLevelAlloc::Arena* HeapLeakChecker::Allocator::arena_ = NULL;$/;"	m	class:HeapLeakChecker::Allocator	file:
arena_	src/memory_region_map.cc	/^LowLevelAlloc::Arena* MemoryRegionMap::arena_ = NULL;$/;"	m	class:MemoryRegionMap	file:
arena_	src/memory_region_map.h	/^  static LowLevelAlloc::Arena* arena_;$/;"	m	class:MemoryRegionMap	access:private
arm	src/base/elfcore.h	/^    struct arm_regs arm;$/;"	m	struct:Frame	typeref:struct:Frame::arm_regs	access:public
arm_regs	src/base/elfcore.h	/^  typedef struct arm_regs {     \/* General purpose registers                 *\/$/;"	s
arm_regs	src/base/elfcore.h	/^  } arm_regs;$/;"	t	typeref:struct:arm_regs
arm_regs::uregs	src/base/elfcore.h	/^    long uregs[18];$/;"	m	struct:arm_regs	access:public
array	docs/tcmalloc.html	/^central array, which seems acceptable.<\/p>$/;"	m	class:object	file:	access:private
array	src/stacktrace_libgcc-inl.h	/^  void **array;$/;"	m	struct:libgcc_backtrace_data	access:public
array_	src/packed-cache-inl.h	/^  volatile T array_[1 << kHashbits];$/;"	m	class:PackedCache	access:private
array_	src/pagemap.h	/^  void** array_;$/;"	m	class:TCMalloc_PageMap1	access:private
array_	src/tests/system-alloc_unittest.cc	/^  char array_[kArraySize];$/;"	m	class:ArraySysAllocator	file:	access:private
array_	src/windows/preamble_patcher.cc	/^  unsigned char* array_;$/;"	m	class:sidestep::DeleteUnsignedCharArray	file:	access:private
arraysize	src/base/basictypes.h	212;"	d
as	debugallocation_test.sh	/^while :; do        # same as 'while true', but more portable$/;"	v
as	docs/pprof_remote_servers.html	/^positive value, such as 524288, before running.<\/p>$/;"	v
as	src/tests/debugallocation_test.sh	/^while :; do        # same as 'while true', but more portable$/;"	v
as_basename	config.status	/^  as_basename=basename$/;"	v
as_basename	configure	/^  as_basename=basename$/;"	v
as_candidate_shells	configure	/^  as_candidate_shells=$/;"	v
as_cr_letters	config.status	/^as_cr_letters='abcdefghijklmnopqrstuvwxyz'$/;"	v
as_cr_letters	configure	/^as_cr_letters='abcdefghijklmnopqrstuvwxyz'$/;"	v
as_dirname	config.status	/^  as_dirname=dirname$/;"	v
as_dirname	configure	/^  as_dirname=dirname$/;"	v
as_dirname	tags	/^as_dirname	configure	\/^  as_dirname=dirname$\/;"	v$/;"	v
as_echo	config.status	/^  as_echo='printf %s\\n'$/;"	v
as_echo	configure	/^  as_echo='printf %s\\n'$/;"	v
as_echo	tags	/^as_echo	configure	\/^  as_echo='printf %s\\\\n'$\/;"	v$/;"	v
as_echo_body	config.status	/^    as_echo_body='eval \/usr\/ucb\/echo -n "$1$as_nl"'$/;"	v
as_echo_body	configure	/^    as_echo_body='eval \/usr\/ucb\/echo -n "$1$as_nl"'$/;"	v
as_executable_p	config.status	/^as_executable_p=$as_test_x$/;"	v
as_executable_p	configure	/^as_executable_p=$as_test_x$/;"	v
as_executable_p	tags	/^as_executable_p	configure	\/^as_executable_p=$as_test_x$\/;"	v$/;"	v
as_expr	config.status	/^  as_expr=expr$/;"	v
as_expr	configure	/^  as_expr=expr$/;"	v
as_expr	tags	/^as_expr	configure	\/^  as_expr=expr$\/;"	v$/;"	v
as_have_required	configure	/^  as_have_required=yes$/;"	v
as_have_required	tags	/^as_have_required	configure	\/^  as_have_required=yes$\/;"	v$/;"	v
as_lineno_1	config.status	/^  as_lineno_1=$LINENO$/;"	v
as_ln_s	config.status	/^    as_ln_s='ln -s'$/;"	v
as_ln_s	config.status	/^    as_ln_s=ln$/;"	v
as_ln_s	configure	/^    as_ln_s='ln -s'$/;"	v
as_ln_s	configure	/^    as_ln_s=ln$/;"	v
as_ln_s	tags	/^as_ln_s	configure	\/^    as_ln_s=ln$\/;"	v$/;"	v
as_ls_L_option	config.status	/^    as_ls_L_option=L$/;"	v
as_ls_L_option	configure	/^    as_ls_L_option=L$/;"	v
as_mkdir_p	config.status	/^  as_mkdir_p=:$/;"	v
as_mkdir_p	configure	/^  as_mkdir_p=:$/;"	v
as_myself	config.status	/^  as_myself=$0$/;"	v
as_myself	configure	/^  as_myself=$0$/;"	v
as_myself	tags	/^as_myself	configure	\/^  as_myself=$0$\/;"	v$/;"	v
as_test_x	config.status	/^  as_test_x='test -x'$/;"	v
as_test_x	configure	/^  as_test_x='test -x'$/;"	v
as_test_x	tags	/^as_test_x	configure	\/^  as_test_x='test -x'$\/;"	v$/;"	v
as_unset	config.status	/^  as_unset=unset$/;"	v
as_unset	configure	/^  as_unset=unset$/;"	v
as_unset	tags	/^as_unset	configure	\/^  as_unset=unset$\/;"	v$/;"	v
atoll	src/windows/port.h	/^inline long long atoll(const char *nptr) {$/;"	f	signature:(const char *nptr)
atomic_word_is_atomic	src/base/atomicops-internals-windows.h	/^COMPILE_ASSERT(sizeof(Atomic64) == sizeof(PVOID), atomic_word_is_atomic);$/;"	m	namespace:base::subtle
automatically	INSTALL	/^find the X include and library files automatically, but if it doesn't,$/;"	v
b	src/libtcmalloc_internal_la-symbolize.o	/^ELF/;"	v
b	src/libtcmalloc_minimal_internal_la-symbolize.o	/^ELF/;"	v
b	src/tests/heap-checker_unittest.cc	/^  char b[7];$/;"	m	class:ClassB	file:	access:public
b2	src/tests/heap-checker_unittest.cc	/^  char b2[11];$/;"	m	class:ClassB2	file:	access:public
base	src/base/atomicops-internals-arm-generic.h	/^namespace base {$/;"	n
base	src/base/atomicops-internals-arm-v6plus.h	/^namespace base {$/;"	n
base	src/base/atomicops-internals-gcc.h	/^namespace base {$/;"	n
base	src/base/atomicops-internals-linuxppc.h	/^namespace base {$/;"	n
base	src/base/atomicops-internals-macosx.h	/^namespace base {$/;"	n
base	src/base/atomicops-internals-mips.h	/^namespace base {$/;"	n
base	src/base/atomicops-internals-windows.h	/^namespace base {$/;"	n
base	src/base/atomicops-internals-x86.h	/^namespace base {$/;"	n
base	src/base/atomicops.h	/^namespace base {$/;"	n
base	src/base/basictypes.h	/^namespace base {$/;"	n
base	src/base/elf_mem_image.cc	/^namespace base {$/;"	n	file:
base	src/base/elf_mem_image.h	/^namespace base {$/;"	n
base	src/base/spinlock_internal.cc	/^namespace base { namespace internal { static int SuggestedDelayNS(int loop); }}$/;"	n	file:
base	src/base/spinlock_internal.cc	/^namespace base {$/;"	n	file:
base	src/base/spinlock_internal.h	/^namespace base {$/;"	n
base	src/base/spinlock_linux-inl.h	/^namespace base {$/;"	n
base	src/base/spinlock_posix-inl.h	/^namespace base {$/;"	n
base	src/base/spinlock_win32-inl.h	/^namespace base {$/;"	n
base	src/base/vdso_support.cc	/^namespace base {$/;"	n	file:
base	src/base/vdso_support.h	/^namespace base {$/;"	n
base	src/gperftools/malloc_extension.h	/^namespace base {$/;"	n
base	src/heap-profile-table.h	/^    Snapshot* base;$/;"	m	struct:HeapProfileTable::AddNonLiveArgs	access:public
base	src/malloc_hook-inl.h	/^namespace base { namespace internal {$/;"	n
base	src/malloc_hook.cc	/^namespace base { namespace internal {$/;"	n	file:
base	src/page_heap.h	/^namespace base {$/;"	n
base	src/raw_printer.cc	/^namespace base {$/;"	n	file:
base	src/raw_printer.h	/^namespace base {$/;"	n
base::ElfMemImage	src/base/elf_mem_image.h	/^class ElfMemImage {$/;"	c	namespace:base
base::ElfMemImage::ElfMemImage	src/base/elf_mem_image.cc	/^ElfMemImage::ElfMemImage(const void *base) {$/;"	f	class:base::ElfMemImage	signature:(const void *base)
base::ElfMemImage::ElfMemImage	src/base/elf_mem_image.h	/^  explicit ElfMemImage(const void *base);$/;"	p	class:base::ElfMemImage	access:public	signature:(const void *base)
base::ElfMemImage::GetDynsym	src/base/elf_mem_image.cc	/^const ElfW(Sym) *ElfMemImage::GetDynsym(int index) const {$/;"	f	class:base::ElfMemImage	signature:(int index) const
base::ElfMemImage::GetDynsym	src/base/elf_mem_image.h	/^  const ElfW(Sym)*     GetDynsym(int index) const;$/;"	p	class:base::ElfMemImage	access:public	signature:(int index) const
base::ElfMemImage::GetNumSymbols	src/base/elf_mem_image.cc	/^int ElfMemImage::GetNumSymbols() const {$/;"	f	class:base::ElfMemImage	signature:() const
base::ElfMemImage::GetNumSymbols	src/base/elf_mem_image.h	/^  int                  GetNumSymbols() const;$/;"	p	class:base::ElfMemImage	access:public	signature:() const
base::ElfMemImage::GetPhdr	src/base/elf_mem_image.cc	/^const ElfW(Phdr) *ElfMemImage::GetPhdr(int index) const {$/;"	f	class:base::ElfMemImage	signature:(int index) const
base::ElfMemImage::GetPhdr	src/base/elf_mem_image.h	/^  const ElfW(Phdr)*    GetPhdr(int index) const;$/;"	p	class:base::ElfMemImage	access:public	signature:(int index) const
base::ElfMemImage::GetVerdef	src/base/elf_mem_image.cc	/^const ElfW(Verdef) *ElfMemImage::GetVerdef(int index) const {$/;"	f	class:base::ElfMemImage	signature:(int index) const
base::ElfMemImage::GetVerdef	src/base/elf_mem_image.h	/^  const ElfW(Verdef)*  GetVerdef(int index) const;$/;"	p	class:base::ElfMemImage	access:public	signature:(int index) const
base::ElfMemImage::GetVersym	src/base/elf_mem_image.cc	/^const ElfW(Versym) *ElfMemImage::GetVersym(int index) const {$/;"	f	class:base::ElfMemImage	signature:(int index) const
base::ElfMemImage::GetVersym	src/base/elf_mem_image.h	/^  const ElfW(Versym)*  GetVersym(int index) const;$/;"	p	class:base::ElfMemImage	access:public	signature:(int index) const
base::ElfMemImage::Init	src/base/elf_mem_image.cc	/^void ElfMemImage::Init(const void *base) {$/;"	f	class:base::ElfMemImage	signature:(const void *base)
base::ElfMemImage::Init	src/base/elf_mem_image.h	/^  void                 Init(const void *base);$/;"	p	class:base::ElfMemImage	access:public	signature:(const void *base)
base::ElfMemImage::IsPresent	src/base/elf_mem_image.h	/^  bool                 IsPresent() const { return ehdr_ != NULL; }$/;"	f	class:base::ElfMemImage	access:public	signature:() const
base::ElfMemImage::LookupSymbol	src/base/elf_mem_image.cc	/^bool ElfMemImage::LookupSymbol(const char *name,$/;"	f	class:base::ElfMemImage	signature:(const char *name, const char *version, int type, SymbolInfo *info) const
base::ElfMemImage::LookupSymbol	src/base/elf_mem_image.h	/^  bool LookupSymbol(const char *name, const char *version,$/;"	p	class:base::ElfMemImage	access:public	signature:(const char *name, const char *version, int symbol_type, SymbolInfo *info_out) const
base::ElfMemImage::LookupSymbolByAddress	src/base/elf_mem_image.cc	/^bool ElfMemImage::LookupSymbolByAddress(const void *address,$/;"	f	class:base::ElfMemImage	signature:(const void *address, SymbolInfo *info_out) const
base::ElfMemImage::LookupSymbolByAddress	src/base/elf_mem_image.h	/^  bool LookupSymbolByAddress(const void *address, SymbolInfo *info_out) const;$/;"	p	class:base::ElfMemImage	access:public	signature:(const void *address, SymbolInfo *info_out) const
base::ElfMemImage::SymbolInfo	src/base/elf_mem_image.h	/^  struct SymbolInfo {$/;"	s	class:base::ElfMemImage	access:public
base::ElfMemImage::SymbolInfo::address	src/base/elf_mem_image.h	/^    const void      *address;   \/\/ Relocated symbol address.$/;"	m	struct:base::ElfMemImage::SymbolInfo	access:public
base::ElfMemImage::SymbolInfo::name	src/base/elf_mem_image.h	/^    const char      *name;      \/\/ E.g. "__vdso_getcpu"$/;"	m	struct:base::ElfMemImage::SymbolInfo	access:public
base::ElfMemImage::SymbolInfo::symbol	src/base/elf_mem_image.h	/^    const ElfW(Sym) *symbol;    \/\/ Symbol in the dynamic symbol table.$/;"	m	struct:base::ElfMemImage::SymbolInfo	access:public
base::ElfMemImage::SymbolInfo::version	src/base/elf_mem_image.h	/^    const char      *version;   \/\/ E.g. "LINUX_2.6", could be ""$/;"	m	struct:base::ElfMemImage::SymbolInfo	access:public
base::ElfMemImage::SymbolIterator	src/base/elf_mem_image.h	/^  class SymbolIterator {$/;"	c	class:base::ElfMemImage	access:public
base::ElfMemImage::SymbolIterator::SymbolIterator	src/base/elf_mem_image.cc	/^ElfMemImage::SymbolIterator::SymbolIterator(const void *const image, int index)$/;"	f	class:base::ElfMemImage::SymbolIterator	signature:(const void *const image, int index)
base::ElfMemImage::SymbolIterator::SymbolIterator	src/base/elf_mem_image.h	/^    SymbolIterator(const void *const image, int index);$/;"	p	class:base::ElfMemImage::SymbolIterator	access:private	signature:(const void *const image, int index)
base::ElfMemImage::SymbolIterator::Update	src/base/elf_mem_image.cc	/^void ElfMemImage::SymbolIterator::Update(int increment) {$/;"	f	class:base::ElfMemImage::SymbolIterator	signature:(int increment)
base::ElfMemImage::SymbolIterator::Update	src/base/elf_mem_image.h	/^    void Update(int incr);$/;"	p	class:base::ElfMemImage::SymbolIterator	access:private	signature:(int incr)
base::ElfMemImage::SymbolIterator::image_	src/base/elf_mem_image.h	/^    const void *const image_;$/;"	m	class:base::ElfMemImage::SymbolIterator	access:private
base::ElfMemImage::SymbolIterator::index_	src/base/elf_mem_image.h	/^    int index_;$/;"	m	class:base::ElfMemImage::SymbolIterator	access:private
base::ElfMemImage::SymbolIterator::info_	src/base/elf_mem_image.h	/^    SymbolInfo info_;$/;"	m	class:base::ElfMemImage::SymbolIterator	access:private
base::ElfMemImage::SymbolIterator::operator !=	src/base/elf_mem_image.cc	/^bool ElfMemImage::SymbolIterator::operator!=(const SymbolIterator &rhs) const {$/;"	f	class:base::ElfMemImage::SymbolIterator	signature:(const SymbolIterator &rhs) const
base::ElfMemImage::SymbolIterator::operator !=	src/base/elf_mem_image.h	/^    bool operator!=(const SymbolIterator &rhs) const;$/;"	p	class:base::ElfMemImage::SymbolIterator	access:public	signature:(const SymbolIterator &rhs) const
base::ElfMemImage::SymbolIterator::operator *	src/base/elf_mem_image.cc	/^const ElfMemImage::SymbolInfo& ElfMemImage::SymbolIterator::operator*() const {$/;"	f	class:base::ElfMemImage::SymbolIterator	signature:() const
base::ElfMemImage::SymbolIterator::operator *	src/base/elf_mem_image.h	/^    const SymbolInfo &operator*() const;$/;"	p	class:base::ElfMemImage::SymbolIterator	access:public	signature:() const
base::ElfMemImage::SymbolIterator::operator ++	src/base/elf_mem_image.cc	/^ElfMemImage::SymbolIterator &ElfMemImage::SymbolIterator::operator++() {$/;"	f	class:base::ElfMemImage::SymbolIterator	signature:()
base::ElfMemImage::SymbolIterator::operator ++	src/base/elf_mem_image.h	/^    SymbolIterator& operator++();$/;"	p	class:base::ElfMemImage::SymbolIterator	access:public	signature:()
base::ElfMemImage::SymbolIterator::operator ->	src/base/elf_mem_image.cc	/^const ElfMemImage::SymbolInfo *ElfMemImage::SymbolIterator::operator->() const {$/;"	f	class:base::ElfMemImage::SymbolIterator	signature:() const
base::ElfMemImage::SymbolIterator::operator ->	src/base/elf_mem_image.h	/^    const SymbolInfo *operator->() const;$/;"	p	class:base::ElfMemImage::SymbolIterator	access:public	signature:() const
base::ElfMemImage::SymbolIterator::operator ==	src/base/elf_mem_image.cc	/^bool ElfMemImage::SymbolIterator::operator==(const SymbolIterator &rhs) const {$/;"	f	class:base::ElfMemImage::SymbolIterator	signature:(const SymbolIterator &rhs) const
base::ElfMemImage::SymbolIterator::operator ==	src/base/elf_mem_image.h	/^    bool operator==(const SymbolIterator &rhs) const;$/;"	p	class:base::ElfMemImage::SymbolIterator	access:public	signature:(const SymbolIterator &rhs) const
base::ElfMemImage::begin	src/base/elf_mem_image.cc	/^ElfMemImage::SymbolIterator ElfMemImage::begin() const {$/;"	f	class:base::ElfMemImage	signature:() const
base::ElfMemImage::begin	src/base/elf_mem_image.h	/^  SymbolIterator begin() const;$/;"	p	class:base::ElfMemImage	access:public	signature:() const
base::ElfMemImage::dynstr_	src/base/elf_mem_image.h	/^  const char *dynstr_;$/;"	m	class:base::ElfMemImage	access:private
base::ElfMemImage::dynsym_	src/base/elf_mem_image.h	/^  const ElfW(Sym) *dynsym_;$/;"	m	class:base::ElfMemImage	access:private
base::ElfMemImage::ehdr_	src/base/elf_mem_image.h	/^  const ElfW(Ehdr) *ehdr_;$/;"	m	class:base::ElfMemImage	access:private
base::ElfMemImage::end	src/base/elf_mem_image.cc	/^ElfMemImage::SymbolIterator ElfMemImage::end() const {$/;"	f	class:base::ElfMemImage	signature:() const
base::ElfMemImage::end	src/base/elf_mem_image.h	/^  SymbolIterator end() const;$/;"	p	class:base::ElfMemImage	access:public	signature:() const
base::ElfMemImage::hash_	src/base/elf_mem_image.h	/^  const ElfW(Word) *hash_;$/;"	m	class:base::ElfMemImage	access:private
base::ElfMemImage::kInvalidBase	src/base/elf_mem_image.cc	/^const void *const ElfMemImage::kInvalidBase =$/;"	m	class:base::ElfMemImage	file:
base::ElfMemImage::kInvalidBase	src/base/elf_mem_image.h	/^  static const void *const kInvalidBase;$/;"	m	class:base::ElfMemImage	access:public
base::ElfMemImage::link_base_	src/base/elf_mem_image.h	/^  ElfW(Addr) link_base_;     \/\/ Link-time base (p_vaddr of first PT_LOAD).$/;"	m	class:base::ElfMemImage	access:private
base::ElfMemImage::strsize_	src/base/elf_mem_image.h	/^  size_t strsize_;$/;"	m	class:base::ElfMemImage	access:private
base::ElfMemImage::verdef_	src/base/elf_mem_image.h	/^  const ElfW(Verdef) *verdef_;$/;"	m	class:base::ElfMemImage	access:private
base::ElfMemImage::verdefnum_	src/base/elf_mem_image.h	/^  size_t verdefnum_;$/;"	m	class:base::ElfMemImage	access:private
base::ElfMemImage::versym_	src/base/elf_mem_image.h	/^  const ElfW(Versym) *versym_;$/;"	m	class:base::ElfMemImage	access:private
base::LINKER_INITIALIZED	src/base/basictypes.h	/^enum LinkerInitialized { LINKER_INITIALIZED };$/;"	e	enum:base::LinkerInitialized
base::LinkerInitialized	src/base/basictypes.h	/^enum LinkerInitialized { LINKER_INITIALIZED };$/;"	g	namespace:base
base::MallocRange	src/gperftools/malloc_extension.h	/^struct MallocRange {$/;"	s	namespace:base
base::MallocRange::FREE	src/gperftools/malloc_extension.h	/^    FREE,                 \/\/ Range is currently free$/;"	e	enum:base::MallocRange::Type
base::MallocRange::INUSE	src/gperftools/malloc_extension.h	/^    INUSE,                \/\/ Application is using this range$/;"	e	enum:base::MallocRange::Type
base::MallocRange::Type	src/gperftools/malloc_extension.h	/^  enum Type {$/;"	g	struct:base::MallocRange	access:public
base::MallocRange::UNKNOWN	src/gperftools/malloc_extension.h	/^    UNKNOWN$/;"	e	enum:base::MallocRange::Type
base::MallocRange::UNMAPPED	src/gperftools/malloc_extension.h	/^    UNMAPPED,             \/\/ Backing physical memory has been returned to the OS$/;"	e	enum:base::MallocRange::Type
base::MallocRange::address	src/gperftools/malloc_extension.h	/^  uintptr_t address;    \/\/ Address of range$/;"	m	struct:base::MallocRange	access:public
base::MallocRange::fraction	src/gperftools/malloc_extension.h	/^  double fraction;      \/\/ Fraction of range that is being used (0 if !INUSE)$/;"	m	struct:base::MallocRange	access:public
base::MallocRange::length	src/gperftools/malloc_extension.h	/^  size_t length;        \/\/ Byte length of range$/;"	m	struct:base::MallocRange	access:public
base::MallocRange::type	src/gperftools/malloc_extension.h	/^  Type type;            \/\/ Type of this range$/;"	m	struct:base::MallocRange	access:public
base::RawPrinter	src/raw_printer.h	/^class RawPrinter {$/;"	c	namespace:base
base::RawPrinter::DISALLOW_COPY_AND_ASSIGN	src/raw_printer.h	/^  DISALLOW_COPY_AND_ASSIGN(RawPrinter);$/;"	p	class:base::RawPrinter	access:private	signature:(RawPrinter)
base::RawPrinter::Printf	src/raw_printer.cc	/^void RawPrinter::Printf(const char* format, ...) {$/;"	f	class:base::RawPrinter	signature:(const char* format, ...)
base::RawPrinter::Printf	src/raw_printer.h	/^  void Printf(const char* format, ...)$/;"	p	class:base::RawPrinter	access:public	signature:(const char* format, ...)
base::RawPrinter::RawPrinter	src/raw_printer.cc	/^RawPrinter::RawPrinter(char* buf, int length)$/;"	f	class:base::RawPrinter	signature:(char* buf, int length)
base::RawPrinter::RawPrinter	src/raw_printer.h	/^  RawPrinter(char* buf, int length);$/;"	p	class:base::RawPrinter	access:public	signature:(char* buf, int length)
base::RawPrinter::base_	src/raw_printer.h	/^  char* base_;          \/\/ Initial pointer$/;"	m	class:base::RawPrinter	access:private
base::RawPrinter::length	src/raw_printer.h	/^  int length() const { return (ptr_ - base_); }$/;"	f	class:base::RawPrinter	access:public	signature:() const
base::RawPrinter::limit_	src/raw_printer.h	/^  char* limit_;         \/\/ One past last non-\\0 char we can write$/;"	m	class:base::RawPrinter	access:private
base::RawPrinter::ptr_	src/raw_printer.h	/^  char* ptr_;           \/\/ Where should we write next$/;"	m	class:base::RawPrinter	access:private
base::RawPrinter::space_left	src/raw_printer.h	/^  int space_left() const { return (limit_ - ptr_); }$/;"	f	class:base::RawPrinter	access:public	signature:() const
base::VDSOInitHelper	src/base/vdso_support.cc	/^static class VDSOInitHelper {$/;"	c	namespace:base	file:
base::VDSOInitHelper::VDSOInitHelper	src/base/vdso_support.cc	/^  VDSOInitHelper() { VDSOSupport::Init(); }$/;"	f	class:base::VDSOInitHelper	access:public	signature:()
base::VDSOSupport	src/base/vdso_support.h	/^class VDSOSupport {$/;"	c	namespace:base
base::VDSOSupport::DISALLOW_COPY_AND_ASSIGN	src/base/vdso_support.h	/^  DISALLOW_COPY_AND_ASSIGN(VDSOSupport);$/;"	p	class:base::VDSOSupport	access:private	signature:(VDSOSupport)
base::VDSOSupport::Init	src/base/vdso_support.cc	/^const void *VDSOSupport::Init() {$/;"	f	class:base::VDSOSupport	signature:()
base::VDSOSupport::Init	src/base/vdso_support.h	/^  static const void *Init();$/;"	p	class:base::VDSOSupport	access:public	signature:()
base::VDSOSupport::IsPresent	src/base/vdso_support.h	/^  bool IsPresent() const { return image_.IsPresent(); }$/;"	f	class:base::VDSOSupport	access:public	signature:() const
base::VDSOSupport::LookupSymbol	src/base/vdso_support.cc	/^bool VDSOSupport::LookupSymbol(const char *name,$/;"	f	class:base::VDSOSupport	signature:(const char *name, const char *version, int type, SymbolInfo *info) const
base::VDSOSupport::LookupSymbol	src/base/vdso_support.h	/^  bool LookupSymbol(const char *name, const char *version,$/;"	p	class:base::VDSOSupport	access:public	signature:(const char *name, const char *version, int symbol_type, SymbolInfo *info_out) const
base::VDSOSupport::LookupSymbolByAddress	src/base/vdso_support.cc	/^bool VDSOSupport::LookupSymbolByAddress(const void *address,$/;"	f	class:base::VDSOSupport	signature:(const void *address, SymbolInfo *info_out) const
base::VDSOSupport::LookupSymbolByAddress	src/base/vdso_support.h	/^  bool LookupSymbolByAddress(const void *address, SymbolInfo *info_out) const;$/;"	p	class:base::VDSOSupport	access:public	signature:(const void *address, SymbolInfo *info_out) const
base::VDSOSupport::SetBase	src/base/vdso_support.cc	/^const void *VDSOSupport::SetBase(const void *base) {$/;"	f	class:base::VDSOSupport	signature:(const void *base)
base::VDSOSupport::SetBase	src/base/vdso_support.h	/^  const void *SetBase(const void *s);$/;"	p	class:base::VDSOSupport	access:public	signature:(const void *s)
base::VDSOSupport::SymbolInfo	src/base/vdso_support.h	/^  typedef ElfMemImage::SymbolInfo SymbolInfo;$/;"	t	class:base::VDSOSupport	access:public
base::VDSOSupport::SymbolIterator	src/base/vdso_support.h	/^  typedef ElfMemImage::SymbolIterator SymbolIterator;$/;"	t	class:base::VDSOSupport	access:public
base::VDSOSupport::VDSOSupport	src/base/vdso_support.cc	/^VDSOSupport::VDSOSupport()$/;"	f	class:base::VDSOSupport	signature:()
base::VDSOSupport::VDSOSupport	src/base/vdso_support.h	/^  VDSOSupport();$/;"	p	class:base::VDSOSupport	access:public	signature:()
base::VDSOSupport::begin	src/base/vdso_support.h	/^  SymbolIterator begin() const { return image_.begin(); }$/;"	f	class:base::VDSOSupport	access:public	signature:() const
base::VDSOSupport::end	src/base/vdso_support.h	/^  SymbolIterator end() const { return image_.end(); }$/;"	f	class:base::VDSOSupport	access:public	signature:() const
base::VDSOSupport::image_	src/base/vdso_support.h	/^  ElfMemImage image_;$/;"	m	class:base::VDSOSupport	access:private
base::VDSOSupport::vdso_base_	src/base/vdso_support.cc	/^const void *VDSOSupport::vdso_base_ = ElfMemImage::kInvalidBase;$/;"	m	class:base::VDSOSupport	file:
base::VDSOSupport::vdso_base_	src/base/vdso_support.h	/^  static const void *vdso_base_;$/;"	m	class:base::VDSOSupport	access:private
base::__anon50::CurrentElfClass	src/base/elf_mem_image.cc	/^typedef ElfClass<__WORDSIZE> CurrentElfClass;$/;"	t	namespace:base::__anon50	file:
base::__anon50::ElfClass	src/base/elf_mem_image.cc	/^template <> class ElfClass<32> {$/;"	c	namespace:base::__anon50	file:
base::__anon50::ElfClass	src/base/elf_mem_image.cc	/^template <> class ElfClass<64> {$/;"	c	namespace:base::__anon50	file:
base::__anon50::ElfClass	src/base/elf_mem_image.cc	/^template <int N> class ElfClass {$/;"	c	namespace:base::__anon50	file:
base::__anon50::ElfClass::ElfW	src/base/elf_mem_image.cc	/^  static int ElfBind(const ElfW(Sym) *) {$/;"	f	class:base::__anon50::ElfClass	access:public	signature:(Sym)
base::__anon50::ElfClass::ElfW	src/base/elf_mem_image.cc	/^  static int ElfType(const ElfW(Sym) *) {$/;"	f	class:base::__anon50::ElfClass	access:public	signature:(Sym)
base::__anon50::ElfClass::kElfClass	src/base/elf_mem_image.cc	/^  static const int kElfClass = -1;$/;"	m	class:base::__anon50::ElfClass	file:	access:public
base::__anon50::ElfClass::kElfClass	src/base/elf_mem_image.cc	/^  static const int kElfClass = ELFCLASS32;$/;"	m	class:base::__anon50::ElfClass	file:	access:public
base::__anon50::ElfClass::kElfClass	src/base/elf_mem_image.cc	/^  static const int kElfClass = ELFCLASS64;$/;"	m	class:base::__anon50::ElfClass	file:	access:public
base::__anon50::ehdr	src/base/elf_mem_image.cc	/^const T* GetTableElement(const ElfW(Ehdr) *ehdr,$/;"	m	namespace:base::__anon50	file:
base::__anon50::element_size	src/base/elf_mem_image.cc	/^                         ElfW(Word) element_size,$/;"	m	namespace:base::__anon50	file:
base::__anon50::table_offset	src/base/elf_mem_image.cc	/^                         ElfW(Off) table_offset,$/;"	m	namespace:base::__anon50	file:
base::internal	src/base/spinlock_internal.cc	/^namespace base { namespace internal { static int SuggestedDelayNS(int loop); }}$/;"	n	namespace:base	file:
base::internal	src/base/spinlock_internal.cc	/^namespace internal {$/;"	n	namespace:base	file:
base::internal	src/base/spinlock_internal.h	/^namespace internal {$/;"	n	namespace:base
base::internal	src/base/spinlock_linux-inl.h	/^namespace internal {$/;"	n	namespace:base
base::internal	src/base/spinlock_posix-inl.h	/^namespace internal {$/;"	n	namespace:base
base::internal	src/base/spinlock_win32-inl.h	/^namespace internal {$/;"	n	namespace:base
base::internal	src/malloc_hook-inl.h	/^namespace base { namespace internal {$/;"	n	namespace:base
base::internal	src/malloc_hook.cc	/^namespace base { namespace internal {$/;"	n	namespace:base	file:
base::internal::HookList	src/malloc_hook-inl.h	/^struct PERFTOOLS_DLL_DECL HookList {$/;"	s	namespace:base::internal
base::internal::HookList::Add	src/malloc_hook-inl.h	/^  bool Add(T value);$/;"	p	struct:base::internal::HookList	access:public	signature:(T value)
base::internal::HookList::Add	src/malloc_hook.cc	/^bool HookList<T>::Add(T value_as_t) {$/;"	f	class:base::internal::HookList	signature:(T value_as_t)
base::internal::HookList::ExchangeSingular	src/malloc_hook-inl.h	/^  T ExchangeSingular(T new_val);$/;"	p	struct:base::internal::HookList	access:public	signature:(T new_val)
base::internal::HookList::ExchangeSingular	src/malloc_hook.cc	/^T HookList<T>::ExchangeSingular(T value_as_t) {$/;"	f	class:base::internal::HookList	signature:(T value_as_t)
base::internal::HookList::FixupPrivEndLocked	src/malloc_hook-inl.h	/^  void FixupPrivEndLocked();$/;"	p	struct:base::internal::HookList	access:public	signature:()
base::internal::HookList::FixupPrivEndLocked	src/malloc_hook.cc	/^void HookList<T>::FixupPrivEndLocked() {$/;"	f	class:base::internal::HookList	signature:()
base::internal::HookList::GetSingular	src/malloc_hook-inl.h	/^  T GetSingular() const {$/;"	f	struct:base::internal::HookList	access:public	signature:() const
base::internal::HookList::Remove	src/malloc_hook-inl.h	/^  bool Remove(T value);$/;"	p	struct:base::internal::HookList	access:public	signature:(T value)
base::internal::HookList::Remove	src/malloc_hook.cc	/^bool HookList<T>::Remove(T value_as_t) {$/;"	f	class:base::internal::HookList	signature:(T value_as_t)
base::internal::HookList::T_should_fit_in_AtomicWord	src/malloc_hook-inl.h	/^  COMPILE_ASSERT(sizeof(T) <= sizeof(AtomicWord), T_should_fit_in_AtomicWord);$/;"	m	struct:base::internal::HookList	access:public
base::internal::HookList::Traverse	src/malloc_hook-inl.h	/^  int Traverse(T* output_array, int n) const;$/;"	p	struct:base::internal::HookList	access:public	signature:(T* output_array, int n) const
base::internal::HookList::Traverse	src/malloc_hook.cc	/^int HookList<T>::Traverse(T* output_array, int n) const {$/;"	f	class:base::internal::HookList	signature:(T* output_array, int n) const
base::internal::HookList::empty	src/malloc_hook-inl.h	/^  bool empty() const {$/;"	f	struct:base::internal::HookList	access:public	signature:() const
base::internal::HookList::priv_data	src/malloc_hook-inl.h	/^  AtomicWord priv_data[kHookListCapacity];$/;"	m	struct:base::internal::HookList	access:public
base::internal::HookList::priv_end	src/malloc_hook-inl.h	/^  AtomicWord priv_end;$/;"	m	struct:base::internal::HookList	access:public
base::internal::HookList::sizeof	src/malloc_hook-inl.h	/^  COMPILE_ASSERT(sizeof(T) <= sizeof(AtomicWord), T_should_fit_in_AtomicWord);$/;"	p	struct:base::internal::HookList	access:public	signature:(T)
base::internal::SpinLockDelay	src/base/spinlock_internal.h	/^void SpinLockDelay(volatile Atomic32 *w, int32 value, int loop);$/;"	p	namespace:base::internal	signature:(volatile Atomic32 *w, int32 value, int loop)
base::internal::SpinLockDelay	src/base/spinlock_linux-inl.h	/^void SpinLockDelay(volatile Atomic32 *w, int32 value, int loop) {$/;"	f	namespace:base::internal	signature:(volatile Atomic32 *w, int32 value, int loop)
base::internal::SpinLockDelay	src/base/spinlock_posix-inl.h	/^void SpinLockDelay(volatile Atomic32 *w, int32 value, int loop) {$/;"	f	namespace:base::internal	signature:(volatile Atomic32 *w, int32 value, int loop)
base::internal::SpinLockDelay	src/base/spinlock_win32-inl.h	/^void SpinLockDelay(volatile Atomic32 *w, int32 value, int loop) {$/;"	f	namespace:base::internal	signature:(volatile Atomic32 *w, int32 value, int loop)
base::internal::SpinLockWake	src/base/spinlock_internal.h	/^void SpinLockWake(volatile Atomic32 *w, bool all);$/;"	p	namespace:base::internal	signature:(volatile Atomic32 *w, bool all)
base::internal::SpinLockWake	src/base/spinlock_linux-inl.h	/^void SpinLockWake(volatile Atomic32 *w, bool all) {$/;"	f	namespace:base::internal	signature:(volatile Atomic32 *w, bool all)
base::internal::SpinLockWake	src/base/spinlock_posix-inl.h	/^void SpinLockWake(volatile Atomic32 *w, bool all) {$/;"	f	namespace:base::internal	signature:(volatile Atomic32 *w, bool all)
base::internal::SpinLockWake	src/base/spinlock_win32-inl.h	/^void SpinLockWake(volatile Atomic32 *w, bool all) {$/;"	f	namespace:base::internal	signature:(volatile Atomic32 *w, bool all)
base::internal::SuggestedDelayNS	src/base/spinlock_internal.cc	/^namespace base { namespace internal { static int SuggestedDelayNS(int loop); }}$/;"	p	namespace:base::internal	file:	signature:(int loop)
base::internal::SuggestedDelayNS	src/base/spinlock_internal.cc	/^static int SuggestedDelayNS(int loop) {$/;"	f	namespace:base::internal	signature:(int loop)
base::internal::delete_hooks_	src/malloc_hook.cc	/^HookList<MallocHook::DeleteHook> delete_hooks_ = INIT_HOOK_LIST;$/;"	m	namespace:base::internal	file:
base::internal::hooklist_spinlock	src/malloc_hook.cc	/^static SpinLock hooklist_spinlock(base::LINKER_INITIALIZED);$/;"	p	namespace:base::internal	file:	signature:(base::LINKER_INITIALIZED)
base::internal::kHookListCapacity	src/malloc_hook-inl.h	/^static const int kHookListCapacity = 8;$/;"	m	namespace:base::internal
base::internal::kHookListMaxValues	src/malloc_hook-inl.h	/^static const int kHookListMaxValues = 7;$/;"	m	namespace:base::internal
base::internal::kHookListSingularIdx	src/malloc_hook-inl.h	/^static const int kHookListSingularIdx = 7;$/;"	m	namespace:base::internal
base::internal::mmap_hooks_	src/malloc_hook.cc	/^HookList<MallocHook::MmapHook> mmap_hooks_ = INIT_HOOK_LIST;$/;"	m	namespace:base::internal	file:
base::internal::mmap_replacement_	src/malloc_hook.cc	/^HookList<MallocHook::MmapReplacement> mmap_replacement_ = { 0 };$/;"	m	namespace:base::internal	file:
base::internal::mremap_hooks_	src/malloc_hook.cc	/^HookList<MallocHook::MremapHook> mremap_hooks_ = INIT_HOOK_LIST;$/;"	m	namespace:base::internal	file:
base::internal::munmap_hooks_	src/malloc_hook.cc	/^HookList<MallocHook::MunmapHook> munmap_hooks_ = INIT_HOOK_LIST;$/;"	m	namespace:base::internal	file:
base::internal::munmap_replacement_	src/malloc_hook.cc	/^HookList<MallocHook::MunmapReplacement> munmap_replacement_ = { 0 };$/;"	m	namespace:base::internal	file:
base::internal::new_hooks_	src/malloc_hook.cc	/^HookList<MallocHook::NewHook> new_hooks_ =$/;"	m	namespace:base::internal	file:
base::internal::premmap_hooks_	src/malloc_hook.cc	/^HookList<MallocHook::PreMmapHook> premmap_hooks_ =$/;"	m	namespace:base::internal	file:
base::internal::presbrk_hooks_	src/malloc_hook.cc	/^HookList<MallocHook::PreSbrkHook> presbrk_hooks_ =$/;"	m	namespace:base::internal	file:
base::internal::sbrk_hooks_	src/malloc_hook.cc	/^HookList<MallocHook::SbrkHook> sbrk_hooks_ = INIT_HOOK_LIST;$/;"	m	namespace:base::internal	file:
base::subtle	src/base/atomicops-internals-arm-generic.h	/^namespace subtle {$/;"	n	namespace:base
base::subtle	src/base/atomicops-internals-arm-v6plus.h	/^namespace subtle {$/;"	n	namespace:base
base::subtle	src/base/atomicops-internals-gcc.h	/^namespace subtle {$/;"	n	namespace:base
base::subtle	src/base/atomicops-internals-linuxppc.h	/^namespace subtle {$/;"	n	namespace:base
base::subtle	src/base/atomicops-internals-macosx.h	/^namespace subtle {$/;"	n	namespace:base
base::subtle	src/base/atomicops-internals-mips.h	/^namespace subtle {$/;"	n	namespace:base
base::subtle	src/base/atomicops-internals-windows.h	/^namespace subtle {$/;"	n	namespace:base
base::subtle	src/base/atomicops-internals-x86.h	/^namespace subtle {$/;"	n	namespace:base
base::subtle	src/base/atomicops.h	/^namespace subtle {$/;"	n	namespace:base
base::subtle::ATTRIBUTE_WEAK	src/base/atomicops-internals-arm-generic.h	/^LinuxKernelCmpxchgFunc pLinuxKernelCmpxchg ATTRIBUTE_WEAK =$/;"	m	namespace:base::subtle
base::subtle::ATTRIBUTE_WEAK	src/base/atomicops-internals-arm-generic.h	/^LinuxKernelMemoryBarrierFunc pLinuxKernelMemoryBarrier ATTRIBUTE_WEAK =$/;"	m	namespace:base::subtle
base::subtle::Acquire_AtomicExchange	src/base/atomicops-internals-arm-generic.h	/^inline Atomic32 Acquire_AtomicExchange(volatile Atomic32* ptr,$/;"	f	namespace:base::subtle	signature:(volatile Atomic32* ptr, Atomic32 new_value)
base::subtle::Acquire_AtomicExchange	src/base/atomicops-internals-arm-generic.h	/^inline Atomic64 Acquire_AtomicExchange(volatile Atomic64* ptr,$/;"	f	namespace:base::subtle	signature:(volatile Atomic64* ptr, Atomic64 new_value)
base::subtle::Acquire_AtomicExchange	src/base/atomicops-internals-arm-v6plus.h	/^inline Atomic32 Acquire_AtomicExchange(volatile Atomic32* ptr,$/;"	f	namespace:base::subtle	signature:(volatile Atomic32* ptr, Atomic32 new_value)
base::subtle::Acquire_AtomicExchange	src/base/atomicops-internals-arm-v6plus.h	/^inline Atomic64 Acquire_AtomicExchange(volatile Atomic64* ptr,$/;"	f	namespace:base::subtle	signature:(volatile Atomic64* ptr, Atomic64 new_value)
base::subtle::Acquire_AtomicExchange	src/base/atomicops-internals-gcc.h	/^inline Atomic32 Acquire_AtomicExchange(volatile Atomic32* ptr,$/;"	f	namespace:base::subtle	signature:(volatile Atomic32* ptr, Atomic32 new_value)
base::subtle::Acquire_AtomicExchange	src/base/atomicops-internals-gcc.h	/^inline Atomic64 Acquire_AtomicExchange(volatile Atomic64* ptr,$/;"	f	namespace:base::subtle	signature:(volatile Atomic64* ptr, Atomic64 new_value)
base::subtle::Acquire_AtomicExchange	src/base/atomicops-internals-linuxppc.h	/^inline Atomic32 Acquire_AtomicExchange(volatile Atomic32 *ptr,$/;"	f	namespace:base::subtle	signature:(volatile Atomic32 *ptr, Atomic32 new_value)
base::subtle::Acquire_AtomicExchange	src/base/atomicops-internals-linuxppc.h	/^inline Atomic64 Acquire_AtomicExchange(volatile Atomic64 *ptr,$/;"	f	namespace:base::subtle	signature:(volatile Atomic64 *ptr, Atomic64 new_value)
base::subtle::Acquire_AtomicExchange	src/base/atomicops-internals-macosx.h	/^inline Atomic32 Acquire_AtomicExchange(volatile Atomic32 *ptr,$/;"	f	namespace:base::subtle	signature:(volatile Atomic32 *ptr, Atomic32 new_value)
base::subtle::Acquire_AtomicExchange	src/base/atomicops-internals-macosx.h	/^inline Atomic64 Acquire_AtomicExchange(volatile Atomic64 *ptr,$/;"	f	namespace:base::subtle	signature:(volatile Atomic64 *ptr, Atomic64 new_value)
base::subtle::Acquire_AtomicExchange	src/base/atomicops-internals-mips.h	/^inline Atomic32 Acquire_AtomicExchange(volatile Atomic32* ptr,$/;"	f	namespace:base::subtle	signature:(volatile Atomic32* ptr, Atomic32 new_value)
base::subtle::Acquire_AtomicExchange	src/base/atomicops-internals-mips.h	/^inline Atomic64 Acquire_AtomicExchange(volatile Atomic64* ptr,$/;"	f	namespace:base::subtle	signature:(volatile Atomic64* ptr, Atomic64 new_value)
base::subtle::Acquire_AtomicExchange	src/base/atomicops-internals-windows.h	/^inline Atomic32 Acquire_AtomicExchange(volatile Atomic32* ptr,$/;"	f	namespace:base::subtle	signature:(volatile Atomic32* ptr, Atomic32 new_value)
base::subtle::Acquire_AtomicExchange	src/base/atomicops-internals-windows.h	/^inline Atomic64 Acquire_AtomicExchange(volatile Atomic64* ptr,$/;"	f	namespace:base::subtle	signature:(volatile Atomic64* ptr, Atomic64 new_value)
base::subtle::Acquire_AtomicExchange	src/base/atomicops-internals-x86.h	/^inline Atomic32 Acquire_AtomicExchange(volatile Atomic32* ptr,$/;"	f	namespace:base::subtle	signature:(volatile Atomic32* ptr, Atomic32 new_value)
base::subtle::Acquire_AtomicExchange	src/base/atomicops-internals-x86.h	/^inline Atomic64 Acquire_AtomicExchange(volatile Atomic64* ptr,$/;"	f	namespace:base::subtle	signature:(volatile Atomic64* ptr, Atomic64 new_val)
base::subtle::Acquire_AtomicExchange	src/base/atomicops-internals-x86.h	/^inline Atomic64 Acquire_AtomicExchange(volatile Atomic64* ptr,$/;"	f	namespace:base::subtle	signature:(volatile Atomic64* ptr, Atomic64 new_value)
base::subtle::Acquire_AtomicExchange	src/base/atomicops.h	/^inline AtomicWord Acquire_AtomicExchange(volatile AtomicWord* ptr,$/;"	f	namespace:base::subtle	signature:(volatile AtomicWord* ptr, AtomicWord new_value)
base::subtle::Acquire_CompareAndSwap	src/base/atomicops-internals-arm-generic.h	/^inline Atomic32 Acquire_CompareAndSwap(volatile Atomic32* ptr,$/;"	f	namespace:base::subtle	signature:(volatile Atomic32* ptr, Atomic32 old_value, Atomic32 new_value)
base::subtle::Acquire_CompareAndSwap	src/base/atomicops-internals-arm-generic.h	/^inline Atomic64 Acquire_CompareAndSwap(volatile Atomic64* ptr,$/;"	f	namespace:base::subtle	signature:(volatile Atomic64* ptr, Atomic64 old_value, Atomic64 new_value)
base::subtle::Acquire_CompareAndSwap	src/base/atomicops-internals-arm-v6plus.h	/^inline Atomic32 Acquire_CompareAndSwap(volatile Atomic32* ptr,$/;"	f	namespace:base::subtle	signature:(volatile Atomic32* ptr, Atomic32 old_value, Atomic32 new_value)
base::subtle::Acquire_CompareAndSwap	src/base/atomicops-internals-arm-v6plus.h	/^inline Atomic64 Acquire_CompareAndSwap(volatile Atomic64* ptr,$/;"	f	namespace:base::subtle	signature:(volatile Atomic64* ptr, Atomic64 old_value, Atomic64 new_value)
base::subtle::Acquire_CompareAndSwap	src/base/atomicops-internals-gcc.h	/^inline Atomic32 Acquire_CompareAndSwap(volatile Atomic32* ptr,$/;"	f	namespace:base::subtle	signature:(volatile Atomic32* ptr, Atomic32 old_value, Atomic32 new_value)
base::subtle::Acquire_CompareAndSwap	src/base/atomicops-internals-gcc.h	/^inline Atomic64 Acquire_CompareAndSwap(volatile Atomic64* ptr,$/;"	f	namespace:base::subtle	signature:(volatile Atomic64* ptr, Atomic64 old_value, Atomic64 new_value)
base::subtle::Acquire_CompareAndSwap	src/base/atomicops-internals-linuxppc.h	/^inline Atomic32 Acquire_CompareAndSwap(volatile Atomic32 *ptr,$/;"	f	namespace:base::subtle	signature:(volatile Atomic32 *ptr, Atomic32 old_value, Atomic32 new_value)
base::subtle::Acquire_CompareAndSwap	src/base/atomicops-internals-linuxppc.h	/^inline Atomic64 Acquire_CompareAndSwap(volatile Atomic64 *ptr,$/;"	f	namespace:base::subtle	signature:(volatile Atomic64 *ptr, Atomic64 old_value, Atomic64 new_value)
base::subtle::Acquire_CompareAndSwap	src/base/atomicops-internals-macosx.h	/^inline Atomic32 Acquire_CompareAndSwap(volatile Atomic32 *ptr,$/;"	f	namespace:base::subtle	signature:(volatile Atomic32 *ptr, Atomic32 old_value, Atomic32 new_value)
base::subtle::Acquire_CompareAndSwap	src/base/atomicops-internals-macosx.h	/^inline Atomic64 Acquire_CompareAndSwap(volatile Atomic64 *ptr,$/;"	f	namespace:base::subtle	signature:(volatile Atomic64 *ptr, Atomic64 old_value, Atomic64 new_value)
base::subtle::Acquire_CompareAndSwap	src/base/atomicops-internals-mips.h	/^inline Atomic32 Acquire_CompareAndSwap(volatile Atomic32* ptr,$/;"	f	namespace:base::subtle	signature:(volatile Atomic32* ptr, Atomic32 old_value, Atomic32 new_value)
base::subtle::Acquire_CompareAndSwap	src/base/atomicops-internals-mips.h	/^inline Atomic64 Acquire_CompareAndSwap(volatile Atomic64* ptr,$/;"	f	namespace:base::subtle	signature:(volatile Atomic64* ptr, Atomic64 old_value, Atomic64 new_value)
base::subtle::Acquire_CompareAndSwap	src/base/atomicops-internals-windows.h	/^inline Atomic32 Acquire_CompareAndSwap(volatile Atomic32* ptr,$/;"	f	namespace:base::subtle	signature:(volatile Atomic32* ptr, Atomic32 old_value, Atomic32 new_value)
base::subtle::Acquire_CompareAndSwap	src/base/atomicops-internals-windows.h	/^inline Atomic64 Acquire_CompareAndSwap(volatile Atomic64* ptr,$/;"	f	namespace:base::subtle	signature:(volatile Atomic64* ptr, Atomic64 old_value, Atomic64 new_value)
base::subtle::Acquire_CompareAndSwap	src/base/atomicops-internals-x86.h	/^inline Atomic32 Acquire_CompareAndSwap(volatile Atomic32* ptr,$/;"	f	namespace:base::subtle	signature:(volatile Atomic32* ptr, Atomic32 old_value, Atomic32 new_value)
base::subtle::Acquire_CompareAndSwap	src/base/atomicops-internals-x86.h	/^inline Atomic64 Acquire_CompareAndSwap(volatile Atomic64* ptr,$/;"	f	namespace:base::subtle	signature:(volatile Atomic64* ptr, Atomic64 old_value, Atomic64 new_value)
base::subtle::Acquire_CompareAndSwap	src/base/atomicops.h	/^inline AtomicWord Acquire_CompareAndSwap(volatile AtomicWord* ptr,$/;"	f	namespace:base::subtle	signature:(volatile AtomicWord* ptr, AtomicWord old_value, AtomicWord new_value)
base::subtle::Acquire_Load	src/base/atomicops-internals-arm-generic.h	/^inline Atomic32 Acquire_Load(volatile const Atomic32* ptr) {$/;"	f	namespace:base::subtle	signature:(volatile const Atomic32* ptr)
base::subtle::Acquire_Load	src/base/atomicops-internals-arm-generic.h	/^inline Atomic64 Acquire_Load(volatile const Atomic64* ptr) {$/;"	f	namespace:base::subtle	signature:(volatile const Atomic64* ptr)
base::subtle::Acquire_Load	src/base/atomicops-internals-arm-v6plus.h	/^inline Atomic32 Acquire_Load(volatile const Atomic32* ptr) {$/;"	f	namespace:base::subtle	signature:(volatile const Atomic32* ptr)
base::subtle::Acquire_Load	src/base/atomicops-internals-arm-v6plus.h	/^inline Atomic64 Acquire_Load(volatile const Atomic64* ptr) {$/;"	f	namespace:base::subtle	signature:(volatile const Atomic64* ptr)
base::subtle::Acquire_Load	src/base/atomicops-internals-gcc.h	/^inline Atomic32 Acquire_Load(volatile const Atomic32* ptr) {$/;"	f	namespace:base::subtle	signature:(volatile const Atomic32* ptr)
base::subtle::Acquire_Load	src/base/atomicops-internals-gcc.h	/^inline Atomic64 Acquire_Load(volatile const Atomic64* ptr) {$/;"	f	namespace:base::subtle	signature:(volatile const Atomic64* ptr)
base::subtle::Acquire_Load	src/base/atomicops-internals-linuxppc.h	/^inline Atomic32 Acquire_Load(volatile const Atomic32 *ptr) {$/;"	f	namespace:base::subtle	signature:(volatile const Atomic32 *ptr)
base::subtle::Acquire_Load	src/base/atomicops-internals-linuxppc.h	/^inline Atomic64 Acquire_Load(volatile const Atomic64 *ptr) {$/;"	f	namespace:base::subtle	signature:(volatile const Atomic64 *ptr)
base::subtle::Acquire_Load	src/base/atomicops-internals-macosx.h	/^inline Atomic32 Acquire_Load(volatile const Atomic32 *ptr) {$/;"	f	namespace:base::subtle	signature:(volatile const Atomic32 *ptr)
base::subtle::Acquire_Load	src/base/atomicops-internals-macosx.h	/^inline Atomic64 Acquire_Load(volatile const Atomic64 *ptr) {$/;"	f	namespace:base::subtle	signature:(volatile const Atomic64 *ptr)
base::subtle::Acquire_Load	src/base/atomicops-internals-mips.h	/^inline Atomic32 Acquire_Load(volatile const Atomic32* ptr)$/;"	f	namespace:base::subtle	signature:(volatile const Atomic32* ptr)
base::subtle::Acquire_Load	src/base/atomicops-internals-mips.h	/^inline Atomic64 Acquire_Load(volatile const Atomic64* ptr)$/;"	f	namespace:base::subtle	signature:(volatile const Atomic64* ptr)
base::subtle::Acquire_Load	src/base/atomicops-internals-windows.h	/^inline Atomic32 Acquire_Load(volatile const Atomic32* ptr) {$/;"	f	namespace:base::subtle	signature:(volatile const Atomic32* ptr)
base::subtle::Acquire_Load	src/base/atomicops-internals-windows.h	/^inline Atomic64 Acquire_Load(volatile const Atomic64* ptr) {$/;"	f	namespace:base::subtle	signature:(volatile const Atomic64* ptr)
base::subtle::Acquire_Load	src/base/atomicops-internals-x86.h	/^inline Atomic32 Acquire_Load(volatile const Atomic32* ptr) {$/;"	f	namespace:base::subtle	signature:(volatile const Atomic32* ptr)
base::subtle::Acquire_Load	src/base/atomicops-internals-x86.h	/^inline Atomic64 Acquire_Load(volatile const Atomic64* ptr) {$/;"	f	namespace:base::subtle	signature:(volatile const Atomic64* ptr)
base::subtle::Acquire_Load	src/base/atomicops.h	/^inline AtomicWord Acquire_Load(volatile const AtomicWord* ptr) {$/;"	f	namespace:base::subtle	signature:(volatile const AtomicWord* ptr)
base::subtle::Acquire_Store	src/base/atomicops-internals-arm-generic.h	/^inline void Acquire_Store(volatile Atomic32* ptr, Atomic32 value) {$/;"	f	namespace:base::subtle	signature:(volatile Atomic32* ptr, Atomic32 value)
base::subtle::Acquire_Store	src/base/atomicops-internals-arm-generic.h	/^inline void Acquire_Store(volatile Atomic64* ptr, Atomic64 value) {$/;"	f	namespace:base::subtle	signature:(volatile Atomic64* ptr, Atomic64 value)
base::subtle::Acquire_Store	src/base/atomicops-internals-arm-v6plus.h	/^inline void Acquire_Store(volatile Atomic32* ptr, Atomic32 value) {$/;"	f	namespace:base::subtle	signature:(volatile Atomic32* ptr, Atomic32 value)
base::subtle::Acquire_Store	src/base/atomicops-internals-arm-v6plus.h	/^inline void Acquire_Store(volatile Atomic64* ptr, Atomic64 value) {$/;"	f	namespace:base::subtle	signature:(volatile Atomic64* ptr, Atomic64 value)
base::subtle::Acquire_Store	src/base/atomicops-internals-gcc.h	/^inline void Acquire_Store(volatile Atomic32* ptr, Atomic32 value) {$/;"	f	namespace:base::subtle	signature:(volatile Atomic32* ptr, Atomic32 value)
base::subtle::Acquire_Store	src/base/atomicops-internals-gcc.h	/^inline void Acquire_Store(volatile Atomic64* ptr, Atomic64 value) {$/;"	f	namespace:base::subtle	signature:(volatile Atomic64* ptr, Atomic64 value)
base::subtle::Acquire_Store	src/base/atomicops-internals-linuxppc.h	/^inline void Acquire_Store(volatile Atomic32 *ptr, Atomic32 value) {$/;"	f	namespace:base::subtle	signature:(volatile Atomic32 *ptr, Atomic32 value)
base::subtle::Acquire_Store	src/base/atomicops-internals-linuxppc.h	/^inline void Acquire_Store(volatile Atomic64 *ptr, Atomic64 value) {$/;"	f	namespace:base::subtle	signature:(volatile Atomic64 *ptr, Atomic64 value)
base::subtle::Acquire_Store	src/base/atomicops-internals-macosx.h	/^inline void Acquire_Store(volatile Atomic32 *ptr, Atomic32 value) {$/;"	f	namespace:base::subtle	signature:(volatile Atomic32 *ptr, Atomic32 value)
base::subtle::Acquire_Store	src/base/atomicops-internals-macosx.h	/^inline void Acquire_Store(volatile Atomic64 *ptr, Atomic64 value) {$/;"	f	namespace:base::subtle	signature:(volatile Atomic64 *ptr, Atomic64 value)
base::subtle::Acquire_Store	src/base/atomicops-internals-mips.h	/^inline void Acquire_Store(volatile Atomic32* ptr, Atomic32 value)$/;"	f	namespace:base::subtle	signature:(volatile Atomic32* ptr, Atomic32 value)
base::subtle::Acquire_Store	src/base/atomicops-internals-mips.h	/^inline void Acquire_Store(volatile Atomic64* ptr, Atomic64 value)$/;"	f	namespace:base::subtle	signature:(volatile Atomic64* ptr, Atomic64 value)
base::subtle::Acquire_Store	src/base/atomicops-internals-windows.h	/^inline void Acquire_Store(volatile Atomic32* ptr, Atomic32 value) {$/;"	f	namespace:base::subtle	signature:(volatile Atomic32* ptr, Atomic32 value)
base::subtle::Acquire_Store	src/base/atomicops-internals-windows.h	/^inline void Acquire_Store(volatile Atomic64* ptr, Atomic64 value) {$/;"	f	namespace:base::subtle	signature:(volatile Atomic64* ptr, Atomic64 value)
base::subtle::Acquire_Store	src/base/atomicops-internals-x86.h	/^inline void Acquire_Store(volatile Atomic32* ptr, Atomic32 value) {$/;"	f	namespace:base::subtle	signature:(volatile Atomic32* ptr, Atomic32 value)
base::subtle::Acquire_Store	src/base/atomicops-internals-x86.h	/^inline void Acquire_Store(volatile Atomic64* ptr, Atomic64 value) {$/;"	f	namespace:base::subtle	signature:(volatile Atomic64* ptr, Atomic64 value)
base::subtle::Acquire_Store	src/base/atomicops.h	/^inline void Acquire_Store(volatile AtomicWord* ptr, AtomicWord value) {$/;"	f	namespace:base::subtle	signature:(volatile AtomicWord* ptr, AtomicWord value)
base::subtle::Atomic64	src/base/atomicops-internals-arm-generic.h	/^typedef int64_t Atomic64;$/;"	t	namespace:base::subtle
base::subtle::Atomic64	src/base/atomicops-internals-arm-v6plus.h	/^typedef int64_t Atomic64;$/;"	t	namespace:base::subtle
base::subtle::Atomic64	src/base/atomicops-internals-gcc.h	/^typedef int64_t Atomic64;$/;"	t	namespace:base::subtle
base::subtle::Atomic64	src/base/atomicops-internals-linuxppc.h	/^typedef int64_t Atomic64;$/;"	t	namespace:base::subtle
base::subtle::Atomic64	src/base/atomicops-internals-macosx.h	/^typedef int64_t Atomic64;$/;"	t	namespace:base::subtle
base::subtle::Atomic64	src/base/atomicops-internals-mips.h	/^typedef int64_t Atomic64;$/;"	t	namespace:base::subtle
base::subtle::Atomic64	src/base/atomicops-internals-windows.h	/^typedef int64 Atomic64;$/;"	t	namespace:base::subtle
base::subtle::Atomic64	src/base/atomicops-internals-x86.h	/^typedef int64_t Atomic64;$/;"	t	namespace:base::subtle
base::subtle::FastInterlockedCompareExchange	src/base/atomicops-internals-windows.h	/^inline LONG FastInterlockedCompareExchange(volatile LONG* ptr,$/;"	f	signature:(volatile LONG* ptr, LONG newval, LONG oldval)
base::subtle::FastInterlockedCompareExchangePointer	src/base/atomicops-internals-windows.h	/^inline PVOID FastInterlockedCompareExchangePointer(volatile PVOID* ptr,$/;"	f	signature:(volatile PVOID* ptr, PVOID newval, PVOID oldval)
base::subtle::FastInterlockedExchange	src/base/atomicops-internals-windows.h	/^inline LONG FastInterlockedExchange(volatile LONG* ptr, LONG newval) {$/;"	f	signature:(volatile LONG* ptr, LONG newval)
base::subtle::FastInterlockedExchangeAdd	src/base/atomicops-internals-windows.h	/^inline LONG FastInterlockedExchangeAdd(volatile LONG* ptr, LONG increment) {$/;"	f	signature:(volatile LONG* ptr, LONG increment)
base::subtle::FastInterlockedExchangeAdd64	src/base/atomicops-internals-windows.h	/^inline LONGLONG FastInterlockedExchangeAdd64(volatile LONGLONG* ptr,$/;"	f	signature:(volatile LONGLONG* ptr, LONGLONG increment)
base::subtle::FastInterlockedExchangePointer	src/base/atomicops-internals-windows.h	/^inline PVOID FastInterlockedExchangePointer(volatile PVOID* ptr, PVOID newval) {$/;"	f	signature:(volatile PVOID* ptr, PVOID newval)
base::subtle::LinuxKernelCmpxchgFunc	src/base/atomicops-internals-arm-generic.h	/^typedef Atomic32 (*LinuxKernelCmpxchgFunc)(Atomic32 old_value,$/;"	t	namespace:base::subtle
base::subtle::LinuxKernelMemoryBarrierFunc	src/base/atomicops-internals-arm-generic.h	/^typedef void (*LinuxKernelMemoryBarrierFunc)(void);$/;"	t	namespace:base::subtle
base::subtle::MemoryBarrier	src/base/atomicops-internals-arm-generic.h	/^inline void MemoryBarrier() {$/;"	f	namespace:base::subtle	signature:()
base::subtle::MemoryBarrier	src/base/atomicops-internals-arm-v6plus.h	/^inline void MemoryBarrier() {$/;"	f	namespace:base::subtle	signature:()
base::subtle::MemoryBarrier	src/base/atomicops-internals-gcc.h	/^inline void MemoryBarrier() {$/;"	f	namespace:base::subtle	signature:()
base::subtle::MemoryBarrier	src/base/atomicops-internals-linuxppc.h	/^inline void MemoryBarrier() {$/;"	f	namespace:base::subtle	signature:()
base::subtle::MemoryBarrier	src/base/atomicops-internals-macosx.h	/^inline void MemoryBarrier() {$/;"	f	namespace:base::subtle	signature:()
base::subtle::MemoryBarrier	src/base/atomicops-internals-mips.h	/^inline void MemoryBarrier()$/;"	f	namespace:base::subtle	signature:()
base::subtle::MemoryBarrier	src/base/atomicops-internals-windows.h	/^inline void MemoryBarrier() {$/;"	f	namespace:base::subtle	signature:()
base::subtle::MemoryBarrier	src/base/atomicops-internals-x86.h	/^inline void MemoryBarrier() {$/;"	f	namespace:base::subtle	signature:()
base::subtle::NoBarrier_AtomicExchange	src/base/atomicops-internals-arm-generic.h	/^inline Atomic32 NoBarrier_AtomicExchange(volatile Atomic32* ptr,$/;"	f	namespace:base::subtle	signature:(volatile Atomic32* ptr, Atomic32 new_value)
base::subtle::NoBarrier_AtomicExchange	src/base/atomicops-internals-arm-generic.h	/^inline Atomic64 NoBarrier_AtomicExchange(volatile Atomic64* ptr,$/;"	f	namespace:base::subtle	signature:(volatile Atomic64* ptr, Atomic64 new_value)
base::subtle::NoBarrier_AtomicExchange	src/base/atomicops-internals-arm-v6plus.h	/^inline Atomic32 NoBarrier_AtomicExchange(volatile Atomic32* ptr,$/;"	f	namespace:base::subtle	signature:(volatile Atomic32* ptr, Atomic32 new_value)
base::subtle::NoBarrier_AtomicExchange	src/base/atomicops-internals-arm-v6plus.h	/^inline Atomic64 NoBarrier_AtomicExchange(volatile Atomic64* ptr,$/;"	f	namespace:base::subtle	signature:(volatile Atomic64* ptr, Atomic64 new_value)
base::subtle::NoBarrier_AtomicExchange	src/base/atomicops-internals-gcc.h	/^inline Atomic32 NoBarrier_AtomicExchange(volatile Atomic32* ptr,$/;"	f	namespace:base::subtle	signature:(volatile Atomic32* ptr, Atomic32 new_value)
base::subtle::NoBarrier_AtomicExchange	src/base/atomicops-internals-gcc.h	/^inline Atomic64 NoBarrier_AtomicExchange(volatile Atomic64* ptr,$/;"	f	namespace:base::subtle	signature:(volatile Atomic64* ptr, Atomic64 new_value)
base::subtle::NoBarrier_AtomicExchange	src/base/atomicops-internals-linuxppc.h	/^inline Atomic32 NoBarrier_AtomicExchange(volatile Atomic32 *ptr,$/;"	f	namespace:base::subtle	signature:(volatile Atomic32 *ptr, Atomic32 new_value)
base::subtle::NoBarrier_AtomicExchange	src/base/atomicops-internals-linuxppc.h	/^inline Atomic64 NoBarrier_AtomicExchange(volatile Atomic64 *ptr,$/;"	f	namespace:base::subtle	signature:(volatile Atomic64 *ptr, Atomic64 new_value)
base::subtle::NoBarrier_AtomicExchange	src/base/atomicops-internals-macosx.h	/^inline Atomic32 NoBarrier_AtomicExchange(volatile Atomic32 *ptr,$/;"	f	namespace:base::subtle	signature:(volatile Atomic32 *ptr, Atomic32 new_value)
base::subtle::NoBarrier_AtomicExchange	src/base/atomicops-internals-macosx.h	/^inline Atomic64 NoBarrier_AtomicExchange(volatile Atomic64 *ptr,$/;"	f	namespace:base::subtle	signature:(volatile Atomic64 *ptr, Atomic64 new_value)
base::subtle::NoBarrier_AtomicExchange	src/base/atomicops-internals-mips.h	/^inline Atomic32 NoBarrier_AtomicExchange(volatile Atomic32* ptr,$/;"	f	namespace:base::subtle	signature:(volatile Atomic32* ptr, Atomic32 new_value)
base::subtle::NoBarrier_AtomicExchange	src/base/atomicops-internals-mips.h	/^inline Atomic64 NoBarrier_AtomicExchange(volatile Atomic64* ptr,$/;"	f	namespace:base::subtle	signature:(volatile Atomic64* ptr, Atomic64 new_value)
base::subtle::NoBarrier_AtomicExchange	src/base/atomicops-internals-windows.h	/^inline Atomic32 NoBarrier_AtomicExchange(volatile Atomic32* ptr,$/;"	f	namespace:base::subtle	signature:(volatile Atomic32* ptr, Atomic32 new_value)
base::subtle::NoBarrier_AtomicExchange	src/base/atomicops-internals-windows.h	/^inline Atomic64 NoBarrier_AtomicExchange(volatile Atomic64* ptr,$/;"	f	namespace:base::subtle	signature:(volatile Atomic64* ptr, Atomic64 new_value)
base::subtle::NoBarrier_AtomicExchange	src/base/atomicops-internals-x86.h	/^inline Atomic32 NoBarrier_AtomicExchange(volatile Atomic32* ptr,$/;"	f	namespace:base::subtle	signature:(volatile Atomic32* ptr, Atomic32 new_value)
base::subtle::NoBarrier_AtomicExchange	src/base/atomicops-internals-x86.h	/^inline Atomic64 NoBarrier_AtomicExchange(volatile Atomic64* ptr,$/;"	f	namespace:base::subtle	signature:(volatile Atomic64* ptr, Atomic64 new_val)
base::subtle::NoBarrier_AtomicExchange	src/base/atomicops-internals-x86.h	/^inline Atomic64 NoBarrier_AtomicExchange(volatile Atomic64* ptr,$/;"	f	namespace:base::subtle	signature:(volatile Atomic64* ptr, Atomic64 new_value)
base::subtle::NoBarrier_AtomicExchange	src/base/atomicops.h	/^inline AtomicWord NoBarrier_AtomicExchange(volatile AtomicWord* ptr,$/;"	f	namespace:base::subtle	signature:(volatile AtomicWord* ptr, AtomicWord new_value)
base::subtle::NoBarrier_CompareAndSwap	src/base/atomicops-internals-arm-generic.h	/^inline Atomic32 NoBarrier_CompareAndSwap(volatile Atomic32* ptr,$/;"	f	namespace:base::subtle	signature:(volatile Atomic32* ptr, Atomic32 old_value, Atomic32 new_value)
base::subtle::NoBarrier_CompareAndSwap	src/base/atomicops-internals-arm-generic.h	/^inline Atomic64 NoBarrier_CompareAndSwap(volatile Atomic64* ptr,$/;"	f	namespace:base::subtle	signature:(volatile Atomic64* ptr, Atomic64 old_value, Atomic64 new_value)
base::subtle::NoBarrier_CompareAndSwap	src/base/atomicops-internals-arm-v6plus.h	/^inline Atomic32 NoBarrier_CompareAndSwap(volatile Atomic32* ptr,$/;"	f	namespace:base::subtle	signature:(volatile Atomic32* ptr, Atomic32 old_value, Atomic32 new_value)
base::subtle::NoBarrier_CompareAndSwap	src/base/atomicops-internals-arm-v6plus.h	/^inline Atomic64 NoBarrier_CompareAndSwap(volatile Atomic64* ptr,$/;"	f	namespace:base::subtle	signature:(volatile Atomic64* ptr, Atomic64 old_value, Atomic64 new_value)
base::subtle::NoBarrier_CompareAndSwap	src/base/atomicops-internals-gcc.h	/^inline Atomic32 NoBarrier_CompareAndSwap(volatile Atomic32* ptr,$/;"	f	namespace:base::subtle	signature:(volatile Atomic32* ptr, Atomic32 old_value, Atomic32 new_value)
base::subtle::NoBarrier_CompareAndSwap	src/base/atomicops-internals-gcc.h	/^inline Atomic64 NoBarrier_CompareAndSwap(volatile Atomic64* ptr,$/;"	f	namespace:base::subtle	signature:(volatile Atomic64* ptr, Atomic64 old_value, Atomic64 new_value)
base::subtle::NoBarrier_CompareAndSwap	src/base/atomicops-internals-linuxppc.h	/^inline Atomic32 NoBarrier_CompareAndSwap(volatile Atomic32 *ptr,$/;"	f	namespace:base::subtle	signature:(volatile Atomic32 *ptr, Atomic32 old_value, Atomic32 new_value)
base::subtle::NoBarrier_CompareAndSwap	src/base/atomicops-internals-linuxppc.h	/^inline Atomic64 NoBarrier_CompareAndSwap(volatile Atomic64 *ptr,$/;"	f	namespace:base::subtle	signature:(volatile Atomic64 *ptr, Atomic64 old_value, Atomic64 new_value)
base::subtle::NoBarrier_CompareAndSwap	src/base/atomicops-internals-macosx.h	/^inline Atomic32 NoBarrier_CompareAndSwap(volatile Atomic32 *ptr,$/;"	f	namespace:base::subtle	signature:(volatile Atomic32 *ptr, Atomic32 old_value, Atomic32 new_value)
base::subtle::NoBarrier_CompareAndSwap	src/base/atomicops-internals-macosx.h	/^inline Atomic64 NoBarrier_CompareAndSwap(volatile Atomic64 *ptr,$/;"	f	namespace:base::subtle	signature:(volatile Atomic64 *ptr, Atomic64 old_value, Atomic64 new_value)
base::subtle::NoBarrier_CompareAndSwap	src/base/atomicops-internals-mips.h	/^inline Atomic32 NoBarrier_CompareAndSwap(volatile Atomic32* ptr,$/;"	f	namespace:base::subtle	signature:(volatile Atomic32* ptr, Atomic32 old_value, Atomic32 new_value)
base::subtle::NoBarrier_CompareAndSwap	src/base/atomicops-internals-mips.h	/^inline Atomic64 NoBarrier_CompareAndSwap(volatile Atomic64* ptr,$/;"	f	namespace:base::subtle	signature:(volatile Atomic64* ptr, Atomic64 old_value, Atomic64 new_value)
base::subtle::NoBarrier_CompareAndSwap	src/base/atomicops-internals-windows.h	/^inline Atomic32 NoBarrier_CompareAndSwap(volatile Atomic32* ptr,$/;"	f	namespace:base::subtle	signature:(volatile Atomic32* ptr, Atomic32 old_value, Atomic32 new_value)
base::subtle::NoBarrier_CompareAndSwap	src/base/atomicops-internals-windows.h	/^inline Atomic64 NoBarrier_CompareAndSwap(volatile Atomic64* ptr,$/;"	f	namespace:base::subtle	signature:(volatile Atomic64* ptr, Atomic64 old_value, Atomic64 new_value)
base::subtle::NoBarrier_CompareAndSwap	src/base/atomicops-internals-x86.h	/^inline Atomic32 NoBarrier_CompareAndSwap(volatile Atomic32* ptr,$/;"	f	namespace:base::subtle	signature:(volatile Atomic32* ptr, Atomic32 old_value, Atomic32 new_value)
base::subtle::NoBarrier_CompareAndSwap	src/base/atomicops-internals-x86.h	/^inline Atomic64 NoBarrier_CompareAndSwap(volatile Atomic64* ptr,$/;"	f	namespace:base::subtle	signature:(volatile Atomic64* ptr, Atomic64 old_val, Atomic64 new_val)
base::subtle::NoBarrier_CompareAndSwap	src/base/atomicops-internals-x86.h	/^inline Atomic64 NoBarrier_CompareAndSwap(volatile Atomic64* ptr,$/;"	f	namespace:base::subtle	signature:(volatile Atomic64* ptr, Atomic64 old_value, Atomic64 new_value)
base::subtle::NoBarrier_CompareAndSwap	src/base/atomicops.h	/^inline AtomicWord NoBarrier_CompareAndSwap(volatile AtomicWord* ptr,$/;"	f	namespace:base::subtle	signature:(volatile AtomicWord* ptr, AtomicWord old_value, AtomicWord new_value)
base::subtle::NoBarrier_Load	src/base/atomicops-internals-arm-generic.h	/^inline Atomic32 NoBarrier_Load(volatile const Atomic32* ptr) {$/;"	f	namespace:base::subtle	signature:(volatile const Atomic32* ptr)
base::subtle::NoBarrier_Load	src/base/atomicops-internals-arm-generic.h	/^inline Atomic64 NoBarrier_Load(volatile const Atomic64* ptr) {$/;"	f	namespace:base::subtle	signature:(volatile const Atomic64* ptr)
base::subtle::NoBarrier_Load	src/base/atomicops-internals-arm-v6plus.h	/^inline Atomic32 NoBarrier_Load(volatile const Atomic32* ptr) {$/;"	f	namespace:base::subtle	signature:(volatile const Atomic32* ptr)
base::subtle::NoBarrier_Load	src/base/atomicops-internals-arm-v6plus.h	/^inline Atomic64 NoBarrier_Load(volatile const Atomic64* ptr) {$/;"	f	namespace:base::subtle	signature:(volatile const Atomic64* ptr)
base::subtle::NoBarrier_Load	src/base/atomicops-internals-gcc.h	/^inline Atomic32 NoBarrier_Load(volatile const Atomic32* ptr) {$/;"	f	namespace:base::subtle	signature:(volatile const Atomic32* ptr)
base::subtle::NoBarrier_Load	src/base/atomicops-internals-gcc.h	/^inline Atomic64 NoBarrier_Load(volatile const Atomic64* ptr) {$/;"	f	namespace:base::subtle	signature:(volatile const Atomic64* ptr)
base::subtle::NoBarrier_Load	src/base/atomicops-internals-linuxppc.h	/^inline Atomic32 NoBarrier_Load(volatile const Atomic32 *ptr) {$/;"	f	namespace:base::subtle	signature:(volatile const Atomic32 *ptr)
base::subtle::NoBarrier_Load	src/base/atomicops-internals-linuxppc.h	/^inline Atomic64 NoBarrier_Load(volatile const Atomic64 *ptr) {$/;"	f	namespace:base::subtle	signature:(volatile const Atomic64 *ptr)
base::subtle::NoBarrier_Load	src/base/atomicops-internals-macosx.h	/^inline Atomic32 NoBarrier_Load(volatile const Atomic32* ptr) {$/;"	f	namespace:base::subtle	signature:(volatile const Atomic32* ptr)
base::subtle::NoBarrier_Load	src/base/atomicops-internals-macosx.h	/^inline Atomic64 NoBarrier_Load(volatile const Atomic64* ptr) {$/;"	f	namespace:base::subtle	signature:(volatile const Atomic64* ptr)
base::subtle::NoBarrier_Load	src/base/atomicops-internals-mips.h	/^inline Atomic32 NoBarrier_Load(volatile const Atomic32* ptr)$/;"	f	namespace:base::subtle	signature:(volatile const Atomic32* ptr)
base::subtle::NoBarrier_Load	src/base/atomicops-internals-mips.h	/^inline Atomic64 NoBarrier_Load(volatile const Atomic64* ptr)$/;"	f	namespace:base::subtle	signature:(volatile const Atomic64* ptr)
base::subtle::NoBarrier_Load	src/base/atomicops-internals-windows.h	/^inline Atomic32 NoBarrier_Load(volatile const Atomic32* ptr) {$/;"	f	namespace:base::subtle	signature:(volatile const Atomic32* ptr)
base::subtle::NoBarrier_Load	src/base/atomicops-internals-windows.h	/^inline Atomic64 NoBarrier_Load(volatile const Atomic64* ptr) {$/;"	f	namespace:base::subtle	signature:(volatile const Atomic64* ptr)
base::subtle::NoBarrier_Load	src/base/atomicops-internals-windows.h	/^inline Atomic64 NoBarrier_Load(volatile const Atomic64* ptrValue)$/;"	f	namespace:base::subtle	signature:(volatile const Atomic64* ptrValue)
base::subtle::NoBarrier_Load	src/base/atomicops-internals-x86.h	/^inline Atomic32 NoBarrier_Load(volatile const Atomic32* ptr) {$/;"	f	namespace:base::subtle	signature:(volatile const Atomic32* ptr)
base::subtle::NoBarrier_Load	src/base/atomicops-internals-x86.h	/^inline Atomic64 NoBarrier_Load(volatile const Atomic64* ptr) {$/;"	f	namespace:base::subtle	signature:(volatile const Atomic64* ptr)
base::subtle::NoBarrier_Load	src/base/atomicops.h	/^inline AtomicWord NoBarrier_Load(volatile const AtomicWord *ptr) {$/;"	f	namespace:base::subtle	signature:(volatile const AtomicWord *ptr)
base::subtle::NoBarrier_Store	src/base/atomicops-internals-arm-generic.h	/^inline void NoBarrier_Store(volatile Atomic32* ptr, Atomic32 value) {$/;"	f	namespace:base::subtle	signature:(volatile Atomic32* ptr, Atomic32 value)
base::subtle::NoBarrier_Store	src/base/atomicops-internals-arm-generic.h	/^inline void NoBarrier_Store(volatile Atomic64* ptr, Atomic64 value) {$/;"	f	namespace:base::subtle	signature:(volatile Atomic64* ptr, Atomic64 value)
base::subtle::NoBarrier_Store	src/base/atomicops-internals-arm-v6plus.h	/^inline void NoBarrier_Store(volatile Atomic32* ptr, Atomic32 value) {$/;"	f	namespace:base::subtle	signature:(volatile Atomic32* ptr, Atomic32 value)
base::subtle::NoBarrier_Store	src/base/atomicops-internals-arm-v6plus.h	/^inline void NoBarrier_Store(volatile Atomic64* ptr, Atomic64 value) {$/;"	f	namespace:base::subtle	signature:(volatile Atomic64* ptr, Atomic64 value)
base::subtle::NoBarrier_Store	src/base/atomicops-internals-gcc.h	/^inline void NoBarrier_Store(volatile Atomic32* ptr, Atomic32 value) {$/;"	f	namespace:base::subtle	signature:(volatile Atomic32* ptr, Atomic32 value)
base::subtle::NoBarrier_Store	src/base/atomicops-internals-gcc.h	/^inline void NoBarrier_Store(volatile Atomic64* ptr, Atomic64 value) {$/;"	f	namespace:base::subtle	signature:(volatile Atomic64* ptr, Atomic64 value)
base::subtle::NoBarrier_Store	src/base/atomicops-internals-linuxppc.h	/^inline void NoBarrier_Store(volatile Atomic32 *ptr, Atomic32 value) {$/;"	f	namespace:base::subtle	signature:(volatile Atomic32 *ptr, Atomic32 value)
base::subtle::NoBarrier_Store	src/base/atomicops-internals-linuxppc.h	/^inline void NoBarrier_Store(volatile Atomic64 *ptr, Atomic64 value) {$/;"	f	namespace:base::subtle	signature:(volatile Atomic64 *ptr, Atomic64 value)
base::subtle::NoBarrier_Store	src/base/atomicops-internals-macosx.h	/^inline void NoBarrier_Store(volatile Atomic32* ptr, Atomic32 value) {$/;"	f	namespace:base::subtle	signature:(volatile Atomic32* ptr, Atomic32 value)
base::subtle::NoBarrier_Store	src/base/atomicops-internals-macosx.h	/^inline void NoBarrier_Store(volatile Atomic64* ptr, Atomic64 value) {$/;"	f	namespace:base::subtle	signature:(volatile Atomic64* ptr, Atomic64 value)
base::subtle::NoBarrier_Store	src/base/atomicops-internals-mips.h	/^inline void NoBarrier_Store(volatile Atomic32* ptr, Atomic32 value)$/;"	f	namespace:base::subtle	signature:(volatile Atomic32* ptr, Atomic32 value)
base::subtle::NoBarrier_Store	src/base/atomicops-internals-mips.h	/^inline void NoBarrier_Store(volatile Atomic64* ptr, Atomic64 value)$/;"	f	namespace:base::subtle	signature:(volatile Atomic64* ptr, Atomic64 value)
base::subtle::NoBarrier_Store	src/base/atomicops-internals-windows.h	/^inline void NoBarrier_Store(volatile Atomic32* ptr, Atomic32 value) {$/;"	f	namespace:base::subtle	signature:(volatile Atomic32* ptr, Atomic32 value)
base::subtle::NoBarrier_Store	src/base/atomicops-internals-windows.h	/^inline void NoBarrier_Store(volatile Atomic64* ptr, Atomic64 value) {$/;"	f	namespace:base::subtle	signature:(volatile Atomic64* ptr, Atomic64 value)
base::subtle::NoBarrier_Store	src/base/atomicops-internals-windows.h	/^inline void NoBarrier_Store(volatile Atomic64* ptrValue, Atomic64 value)$/;"	f	namespace:base::subtle	signature:(volatile Atomic64* ptrValue, Atomic64 value)
base::subtle::NoBarrier_Store	src/base/atomicops-internals-x86.h	/^inline void NoBarrier_Store(volatile Atomic32* ptr, Atomic32 value) {$/;"	f	namespace:base::subtle	signature:(volatile Atomic32* ptr, Atomic32 value)
base::subtle::NoBarrier_Store	src/base/atomicops-internals-x86.h	/^inline void NoBarrier_Store(volatile Atomic64* ptr, Atomic64 value) {$/;"	f	namespace:base::subtle	signature:(volatile Atomic64* ptr, Atomic64 value)
base::subtle::NoBarrier_Store	src/base/atomicops.h	/^inline void NoBarrier_Store(volatile AtomicWord *ptr, AtomicWord value) {$/;"	f	namespace:base::subtle	signature:(volatile AtomicWord *ptr, AtomicWord value)
base::subtle::NotImplementedFatalError	src/base/atomicops-internals-arm-generic.h	/^inline void NotImplementedFatalError(const char *function_name) {$/;"	f	namespace:base::subtle	signature:(const char *function_name)
base::subtle::NotImplementedFatalError	src/base/atomicops-internals-arm-v6plus.h	/^inline void NotImplementedFatalError(const char *function_name) {$/;"	f	namespace:base::subtle	signature:(const char *function_name)
base::subtle::NotImplementedFatalError	src/base/atomicops-internals-windows.h	/^inline void NotImplementedFatalError(const char *function_name) {$/;"	f	namespace:base::subtle	signature:(const char *function_name)
base::subtle::OSAtomicAdd32	src/base/atomicops-internals-linuxppc.h	/^static inline Atomic32 OSAtomicAdd32(Atomic32 amount, Atomic32 *value) {$/;"	f	namespace:base::subtle	signature:(Atomic32 amount, Atomic32 *value)
base::subtle::OSAtomicAdd32Barrier	src/base/atomicops-internals-linuxppc.h	/^static inline Atomic32 OSAtomicAdd32Barrier(Atomic32 amount, Atomic32 *value) {$/;"	f	namespace:base::subtle	signature:(Atomic32 amount, Atomic32 *value)
base::subtle::OSAtomicAdd64	src/base/atomicops-internals-linuxppc.h	/^static inline Atomic64 OSAtomicAdd64(Atomic64 amount, Atomic64 *value) {$/;"	f	namespace:base::subtle	signature:(Atomic64 amount, Atomic64 *value)
base::subtle::OSAtomicAdd64	src/base/atomicops-internals-macosx.h	/^inline int64_t OSAtomicAdd64(int64_t theAmount, int64_t *theValue) {$/;"	f	namespace:base::subtle	signature:(int64_t theAmount, int64_t *theValue)
base::subtle::OSAtomicAdd64Barrier	src/base/atomicops-internals-linuxppc.h	/^static inline Atomic64 OSAtomicAdd64Barrier(Atomic64 amount, Atomic64 *value) {$/;"	f	namespace:base::subtle	signature:(Atomic64 amount, Atomic64 *value)
base::subtle::OSAtomicAdd64Barrier	src/base/atomicops-internals-macosx.h	/^inline int64_t OSAtomicAdd64Barrier($/;"	f	namespace:base::subtle	signature:( int64_t theAmount, int64_t *theValue)
base::subtle::OSAtomicCompareAndSwap32	src/base/atomicops-internals-linuxppc.h	/^static inline bool OSAtomicCompareAndSwap32(Atomic32 old_value,$/;"	f	namespace:base::subtle	signature:(Atomic32 old_value, Atomic32 new_value, Atomic32 *value)
base::subtle::OSAtomicCompareAndSwap32Acquire	src/base/atomicops-internals-linuxppc.h	/^static inline Atomic32 OSAtomicCompareAndSwap32Acquire(Atomic32 old_value,$/;"	f	namespace:base::subtle	signature:(Atomic32 old_value, Atomic32 new_value, Atomic32 *value)
base::subtle::OSAtomicCompareAndSwap32Release	src/base/atomicops-internals-linuxppc.h	/^static inline Atomic32 OSAtomicCompareAndSwap32Release(Atomic32 old_value,$/;"	f	namespace:base::subtle	signature:(Atomic32 old_value, Atomic32 new_value, Atomic32 *value)
base::subtle::OSAtomicCompareAndSwap64	src/base/atomicops-internals-linuxppc.h	/^static inline bool OSAtomicCompareAndSwap64(Atomic64 old_value,$/;"	f	namespace:base::subtle	signature:(Atomic64 old_value, Atomic64 new_value, Atomic64 *value)
base::subtle::OSAtomicCompareAndSwap64	src/base/atomicops-internals-macosx.h	/^inline int64_t OSAtomicCompareAndSwap64($/;"	f	namespace:base::subtle	signature:( int64_t oldValue, int64_t newValue, int64_t *theValue)
base::subtle::OSAtomicCompareAndSwap64Acquire	src/base/atomicops-internals-linuxppc.h	/^static inline Atomic64 OSAtomicCompareAndSwap64Acquire(Atomic64 old_value,$/;"	f	namespace:base::subtle	signature:(Atomic64 old_value, Atomic64 new_value, Atomic64 *value)
base::subtle::OSAtomicCompareAndSwap64Barrier	src/base/atomicops-internals-macosx.h	/^inline int64_t OSAtomicCompareAndSwap64Barrier($/;"	f	namespace:base::subtle	signature:( int64_t oldValue, int64_t newValue, int64_t *theValue)
base::subtle::OSAtomicCompareAndSwap64Release	src/base/atomicops-internals-linuxppc.h	/^static inline Atomic64 OSAtomicCompareAndSwap64Release(Atomic64 old_value,$/;"	f	namespace:base::subtle	signature:(Atomic64 old_value, Atomic64 new_value, Atomic64 *value)
base::subtle::Release_AtomicExchange	src/base/atomicops-internals-arm-generic.h	/^inline Atomic32 Release_AtomicExchange(volatile Atomic32* ptr,$/;"	f	namespace:base::subtle	signature:(volatile Atomic32* ptr, Atomic32 new_value)
base::subtle::Release_AtomicExchange	src/base/atomicops-internals-arm-generic.h	/^inline Atomic64 Release_AtomicExchange(volatile Atomic64* ptr,$/;"	f	namespace:base::subtle	signature:(volatile Atomic64* ptr, Atomic64 new_value)
base::subtle::Release_AtomicExchange	src/base/atomicops-internals-arm-v6plus.h	/^inline Atomic32 Release_AtomicExchange(volatile Atomic32* ptr,$/;"	f	namespace:base::subtle	signature:(volatile Atomic32* ptr, Atomic32 new_value)
base::subtle::Release_AtomicExchange	src/base/atomicops-internals-arm-v6plus.h	/^inline Atomic64 Release_AtomicExchange(volatile Atomic64* ptr,$/;"	f	namespace:base::subtle	signature:(volatile Atomic64* ptr, Atomic64 new_value)
base::subtle::Release_AtomicExchange	src/base/atomicops-internals-gcc.h	/^inline Atomic32 Release_AtomicExchange(volatile Atomic32* ptr,$/;"	f	namespace:base::subtle	signature:(volatile Atomic32* ptr, Atomic32 new_value)
base::subtle::Release_AtomicExchange	src/base/atomicops-internals-gcc.h	/^inline Atomic64 Release_AtomicExchange(volatile Atomic64* ptr,$/;"	f	namespace:base::subtle	signature:(volatile Atomic64* ptr, Atomic64 new_value)
base::subtle::Release_AtomicExchange	src/base/atomicops-internals-linuxppc.h	/^inline Atomic32 Release_AtomicExchange(volatile Atomic32 *ptr,$/;"	f	namespace:base::subtle	signature:(volatile Atomic32 *ptr, Atomic32 new_value)
base::subtle::Release_AtomicExchange	src/base/atomicops-internals-linuxppc.h	/^inline Atomic64 Release_AtomicExchange(volatile Atomic64 *ptr,$/;"	f	namespace:base::subtle	signature:(volatile Atomic64 *ptr, Atomic64 new_value)
base::subtle::Release_AtomicExchange	src/base/atomicops-internals-macosx.h	/^inline Atomic32 Release_AtomicExchange(volatile Atomic32 *ptr,$/;"	f	namespace:base::subtle	signature:(volatile Atomic32 *ptr, Atomic32 new_value)
base::subtle::Release_AtomicExchange	src/base/atomicops-internals-macosx.h	/^inline Atomic64 Release_AtomicExchange(volatile Atomic64 *ptr,$/;"	f	namespace:base::subtle	signature:(volatile Atomic64 *ptr, Atomic64 new_value)
base::subtle::Release_AtomicExchange	src/base/atomicops-internals-mips.h	/^inline Atomic32 Release_AtomicExchange(volatile Atomic32* ptr,$/;"	f	namespace:base::subtle	signature:(volatile Atomic32* ptr, Atomic32 new_value)
base::subtle::Release_AtomicExchange	src/base/atomicops-internals-mips.h	/^inline Atomic64 Release_AtomicExchange(volatile Atomic64* ptr,$/;"	f	namespace:base::subtle	signature:(volatile Atomic64* ptr, Atomic64 new_value)
base::subtle::Release_AtomicExchange	src/base/atomicops-internals-windows.h	/^inline Atomic32 Release_AtomicExchange(volatile Atomic32* ptr,$/;"	f	namespace:base::subtle	signature:(volatile Atomic32* ptr, Atomic32 new_value)
base::subtle::Release_AtomicExchange	src/base/atomicops-internals-windows.h	/^inline Atomic64 Release_AtomicExchange(volatile Atomic64* ptr,$/;"	f	namespace:base::subtle	signature:(volatile Atomic64* ptr, Atomic64 new_value)
base::subtle::Release_AtomicExchange	src/base/atomicops-internals-x86.h	/^inline Atomic32 Release_AtomicExchange(volatile Atomic32* ptr,$/;"	f	namespace:base::subtle	signature:(volatile Atomic32* ptr, Atomic32 new_value)
base::subtle::Release_AtomicExchange	src/base/atomicops-internals-x86.h	/^inline Atomic64 Release_AtomicExchange(volatile Atomic64* ptr,$/;"	f	namespace:base::subtle	signature:(volatile Atomic64* ptr, Atomic64 new_val)
base::subtle::Release_AtomicExchange	src/base/atomicops-internals-x86.h	/^inline Atomic64 Release_AtomicExchange(volatile Atomic64* ptr,$/;"	f	namespace:base::subtle	signature:(volatile Atomic64* ptr, Atomic64 new_value)
base::subtle::Release_AtomicExchange	src/base/atomicops.h	/^inline AtomicWord Release_AtomicExchange(volatile AtomicWord* ptr,$/;"	f	namespace:base::subtle	signature:(volatile AtomicWord* ptr, AtomicWord new_value)
base::subtle::Release_CompareAndSwap	src/base/atomicops-internals-arm-generic.h	/^inline Atomic32 Release_CompareAndSwap(volatile Atomic32* ptr,$/;"	f	namespace:base::subtle	signature:(volatile Atomic32* ptr, Atomic32 old_value, Atomic32 new_value)
base::subtle::Release_CompareAndSwap	src/base/atomicops-internals-arm-generic.h	/^inline Atomic64 Release_CompareAndSwap(volatile Atomic64* ptr,$/;"	f	namespace:base::subtle	signature:(volatile Atomic64* ptr, Atomic64 old_value, Atomic64 new_value)
base::subtle::Release_CompareAndSwap	src/base/atomicops-internals-arm-v6plus.h	/^inline Atomic32 Release_CompareAndSwap(volatile Atomic32* ptr,$/;"	f	namespace:base::subtle	signature:(volatile Atomic32* ptr, Atomic32 old_value, Atomic32 new_value)
base::subtle::Release_CompareAndSwap	src/base/atomicops-internals-arm-v6plus.h	/^inline Atomic64 Release_CompareAndSwap(volatile Atomic64* ptr,$/;"	f	namespace:base::subtle	signature:(volatile Atomic64* ptr, Atomic64 old_value, Atomic64 new_value)
base::subtle::Release_CompareAndSwap	src/base/atomicops-internals-gcc.h	/^inline Atomic32 Release_CompareAndSwap(volatile Atomic32* ptr,$/;"	f	namespace:base::subtle	signature:(volatile Atomic32* ptr, Atomic32 old_value, Atomic32 new_value)
base::subtle::Release_CompareAndSwap	src/base/atomicops-internals-gcc.h	/^inline Atomic64 Release_CompareAndSwap(volatile Atomic64* ptr,$/;"	f	namespace:base::subtle	signature:(volatile Atomic64* ptr, Atomic64 old_value, Atomic64 new_value)
base::subtle::Release_CompareAndSwap	src/base/atomicops-internals-linuxppc.h	/^inline Atomic32 Release_CompareAndSwap(volatile Atomic32 *ptr,$/;"	f	namespace:base::subtle	signature:(volatile Atomic32 *ptr, Atomic32 old_value, Atomic32 new_value)
base::subtle::Release_CompareAndSwap	src/base/atomicops-internals-linuxppc.h	/^inline Atomic64 Release_CompareAndSwap(volatile Atomic64 *ptr,$/;"	f	namespace:base::subtle	signature:(volatile Atomic64 *ptr, Atomic64 old_value, Atomic64 new_value)
base::subtle::Release_CompareAndSwap	src/base/atomicops-internals-macosx.h	/^inline Atomic32 Release_CompareAndSwap(volatile Atomic32 *ptr,$/;"	f	namespace:base::subtle	signature:(volatile Atomic32 *ptr, Atomic32 old_value, Atomic32 new_value)
base::subtle::Release_CompareAndSwap	src/base/atomicops-internals-macosx.h	/^inline Atomic64 Release_CompareAndSwap(volatile Atomic64 *ptr,$/;"	f	namespace:base::subtle	signature:(volatile Atomic64 *ptr, Atomic64 old_value, Atomic64 new_value)
base::subtle::Release_CompareAndSwap	src/base/atomicops-internals-mips.h	/^inline Atomic32 Release_CompareAndSwap(volatile Atomic32* ptr,$/;"	f	namespace:base::subtle	signature:(volatile Atomic32* ptr, Atomic32 old_value, Atomic32 new_value)
base::subtle::Release_CompareAndSwap	src/base/atomicops-internals-mips.h	/^inline Atomic64 Release_CompareAndSwap(volatile Atomic64* ptr,$/;"	f	namespace:base::subtle	signature:(volatile Atomic64* ptr, Atomic64 old_value, Atomic64 new_value)
base::subtle::Release_CompareAndSwap	src/base/atomicops-internals-windows.h	/^inline Atomic32 Release_CompareAndSwap(volatile Atomic32* ptr,$/;"	f	namespace:base::subtle	signature:(volatile Atomic32* ptr, Atomic32 old_value, Atomic32 new_value)
base::subtle::Release_CompareAndSwap	src/base/atomicops-internals-windows.h	/^inline Atomic64 Release_CompareAndSwap(volatile Atomic64* ptr,$/;"	f	namespace:base::subtle	signature:(volatile Atomic64* ptr, Atomic64 old_value, Atomic64 new_value)
base::subtle::Release_CompareAndSwap	src/base/atomicops-internals-x86.h	/^inline Atomic32 Release_CompareAndSwap(volatile Atomic32* ptr,$/;"	f	namespace:base::subtle	signature:(volatile Atomic32* ptr, Atomic32 old_value, Atomic32 new_value)
base::subtle::Release_CompareAndSwap	src/base/atomicops-internals-x86.h	/^inline Atomic64 Release_CompareAndSwap(volatile Atomic64* ptr,$/;"	f	namespace:base::subtle	signature:(volatile Atomic64* ptr, Atomic64 old_value, Atomic64 new_value)
base::subtle::Release_CompareAndSwap	src/base/atomicops.h	/^inline AtomicWord Release_CompareAndSwap(volatile AtomicWord* ptr,$/;"	f	namespace:base::subtle	signature:(volatile AtomicWord* ptr, AtomicWord old_value, AtomicWord new_value)
base::subtle::Release_Load	src/base/atomicops-internals-arm-generic.h	/^inline Atomic32 Release_Load(volatile const Atomic32* ptr) {$/;"	f	namespace:base::subtle	signature:(volatile const Atomic32* ptr)
base::subtle::Release_Load	src/base/atomicops-internals-arm-generic.h	/^inline Atomic64 Release_Load(volatile const Atomic64* ptr) {$/;"	f	namespace:base::subtle	signature:(volatile const Atomic64* ptr)
base::subtle::Release_Load	src/base/atomicops-internals-arm-v6plus.h	/^inline Atomic32 Release_Load(volatile const Atomic32* ptr) {$/;"	f	namespace:base::subtle	signature:(volatile const Atomic32* ptr)
base::subtle::Release_Load	src/base/atomicops-internals-arm-v6plus.h	/^inline Atomic64 Release_Load(volatile const Atomic64* ptr) {$/;"	f	namespace:base::subtle	signature:(volatile const Atomic64* ptr)
base::subtle::Release_Load	src/base/atomicops-internals-gcc.h	/^inline Atomic32 Release_Load(volatile const Atomic32* ptr) {$/;"	f	namespace:base::subtle	signature:(volatile const Atomic32* ptr)
base::subtle::Release_Load	src/base/atomicops-internals-gcc.h	/^inline Atomic64 Release_Load(volatile const Atomic64* ptr) {$/;"	f	namespace:base::subtle	signature:(volatile const Atomic64* ptr)
base::subtle::Release_Load	src/base/atomicops-internals-linuxppc.h	/^inline Atomic32 Release_Load(volatile const Atomic32 *ptr) {$/;"	f	namespace:base::subtle	signature:(volatile const Atomic32 *ptr)
base::subtle::Release_Load	src/base/atomicops-internals-linuxppc.h	/^inline Atomic64 Release_Load(volatile const Atomic64 *ptr) {$/;"	f	namespace:base::subtle	signature:(volatile const Atomic64 *ptr)
base::subtle::Release_Load	src/base/atomicops-internals-macosx.h	/^inline Atomic32 Release_Load(volatile const Atomic32 *ptr) {$/;"	f	namespace:base::subtle	signature:(volatile const Atomic32 *ptr)
base::subtle::Release_Load	src/base/atomicops-internals-macosx.h	/^inline Atomic64 Release_Load(volatile const Atomic64 *ptr) {$/;"	f	namespace:base::subtle	signature:(volatile const Atomic64 *ptr)
base::subtle::Release_Load	src/base/atomicops-internals-mips.h	/^inline Atomic32 Release_Load(volatile const Atomic32* ptr)$/;"	f	namespace:base::subtle	signature:(volatile const Atomic32* ptr)
base::subtle::Release_Load	src/base/atomicops-internals-mips.h	/^inline Atomic64 Release_Load(volatile const Atomic64* ptr)$/;"	f	namespace:base::subtle	signature:(volatile const Atomic64* ptr)
base::subtle::Release_Load	src/base/atomicops-internals-windows.h	/^inline Atomic32 Release_Load(volatile const Atomic32* ptr) {$/;"	f	namespace:base::subtle	signature:(volatile const Atomic32* ptr)
base::subtle::Release_Load	src/base/atomicops-internals-windows.h	/^inline Atomic64 Release_Load(volatile const Atomic64* ptr) {$/;"	f	namespace:base::subtle	signature:(volatile const Atomic64* ptr)
base::subtle::Release_Load	src/base/atomicops-internals-x86.h	/^inline Atomic32 Release_Load(volatile const Atomic32* ptr) {$/;"	f	namespace:base::subtle	signature:(volatile const Atomic32* ptr)
base::subtle::Release_Load	src/base/atomicops-internals-x86.h	/^inline Atomic64 Release_Load(volatile const Atomic64* ptr) {$/;"	f	namespace:base::subtle	signature:(volatile const Atomic64* ptr)
base::subtle::Release_Load	src/base/atomicops.h	/^inline AtomicWord Release_Load(volatile const AtomicWord* ptr) {$/;"	f	namespace:base::subtle	signature:(volatile const AtomicWord* ptr)
base::subtle::Release_Store	src/base/atomicops-internals-arm-generic.h	/^inline void Release_Store(volatile Atomic32* ptr, Atomic32 value) {$/;"	f	namespace:base::subtle	signature:(volatile Atomic32* ptr, Atomic32 value)
base::subtle::Release_Store	src/base/atomicops-internals-arm-generic.h	/^inline void Release_Store(volatile Atomic64* ptr, Atomic64 value) {$/;"	f	namespace:base::subtle	signature:(volatile Atomic64* ptr, Atomic64 value)
base::subtle::Release_Store	src/base/atomicops-internals-arm-v6plus.h	/^inline void Release_Store(volatile Atomic32* ptr, Atomic32 value) {$/;"	f	namespace:base::subtle	signature:(volatile Atomic32* ptr, Atomic32 value)
base::subtle::Release_Store	src/base/atomicops-internals-arm-v6plus.h	/^inline void Release_Store(volatile Atomic64* ptr, Atomic64 value) {$/;"	f	namespace:base::subtle	signature:(volatile Atomic64* ptr, Atomic64 value)
base::subtle::Release_Store	src/base/atomicops-internals-gcc.h	/^inline void Release_Store(volatile Atomic32* ptr, Atomic32 value) {$/;"	f	namespace:base::subtle	signature:(volatile Atomic32* ptr, Atomic32 value)
base::subtle::Release_Store	src/base/atomicops-internals-gcc.h	/^inline void Release_Store(volatile Atomic64* ptr, Atomic64 value) {$/;"	f	namespace:base::subtle	signature:(volatile Atomic64* ptr, Atomic64 value)
base::subtle::Release_Store	src/base/atomicops-internals-linuxppc.h	/^inline void Release_Store(volatile Atomic32 *ptr, Atomic32 value) {$/;"	f	namespace:base::subtle	signature:(volatile Atomic32 *ptr, Atomic32 value)
base::subtle::Release_Store	src/base/atomicops-internals-linuxppc.h	/^inline void Release_Store(volatile Atomic64 *ptr, Atomic64 value) {$/;"	f	namespace:base::subtle	signature:(volatile Atomic64 *ptr, Atomic64 value)
base::subtle::Release_Store	src/base/atomicops-internals-macosx.h	/^inline void Release_Store(volatile Atomic32 *ptr, Atomic32 value) {$/;"	f	namespace:base::subtle	signature:(volatile Atomic32 *ptr, Atomic32 value)
base::subtle::Release_Store	src/base/atomicops-internals-macosx.h	/^inline void Release_Store(volatile Atomic64 *ptr, Atomic64 value) {$/;"	f	namespace:base::subtle	signature:(volatile Atomic64 *ptr, Atomic64 value)
base::subtle::Release_Store	src/base/atomicops-internals-mips.h	/^inline void Release_Store(volatile Atomic32* ptr, Atomic32 value)$/;"	f	namespace:base::subtle	signature:(volatile Atomic32* ptr, Atomic32 value)
base::subtle::Release_Store	src/base/atomicops-internals-mips.h	/^inline void Release_Store(volatile Atomic64* ptr, Atomic64 value)$/;"	f	namespace:base::subtle	signature:(volatile Atomic64* ptr, Atomic64 value)
base::subtle::Release_Store	src/base/atomicops-internals-windows.h	/^inline void Release_Store(volatile Atomic32* ptr, Atomic32 value) {$/;"	f	namespace:base::subtle	signature:(volatile Atomic32* ptr, Atomic32 value)
base::subtle::Release_Store	src/base/atomicops-internals-windows.h	/^inline void Release_Store(volatile Atomic64* ptr, Atomic64 value) {$/;"	f	namespace:base::subtle	signature:(volatile Atomic64* ptr, Atomic64 value)
base::subtle::Release_Store	src/base/atomicops-internals-x86.h	/^inline void Release_Store(volatile Atomic32* ptr, Atomic32 value) {$/;"	f	namespace:base::subtle	signature:(volatile Atomic32* ptr, Atomic32 value)
base::subtle::Release_Store	src/base/atomicops-internals-x86.h	/^inline void Release_Store(volatile Atomic64* ptr, Atomic64 value) {$/;"	f	namespace:base::subtle	signature:(volatile Atomic64* ptr, Atomic64 value)
base::subtle::Release_Store	src/base/atomicops.h	/^inline void Release_Store(volatile AtomicWord* ptr, AtomicWord value) {$/;"	f	namespace:base::subtle	signature:(volatile AtomicWord* ptr, AtomicWord value)
base::subtle::_InterlockedCompareExchange	src/base/atomicops-internals-windows.h	/^LONG _InterlockedCompareExchange(volatile LONG* ptr, LONG newval, LONG oldval);$/;"	p	signature:(volatile LONG* ptr, LONG newval, LONG oldval)
base::subtle::_InterlockedCompareExchangePointer	src/base/atomicops-internals-windows.h	/^PVOID _InterlockedCompareExchangePointer(volatile PVOID* ptr,$/;"	p	signature:(volatile PVOID* ptr, PVOID newval, PVOID oldval)
base::subtle::_InterlockedExchange	src/base/atomicops-internals-windows.h	/^LONG _InterlockedExchange(volatile LONG* ptr, LONG newval);$/;"	p	signature:(volatile LONG* ptr, LONG newval)
base::subtle::_InterlockedExchangeAdd	src/base/atomicops-internals-windows.h	/^LONG _InterlockedExchangeAdd(volatile LONG* ptr, LONG increment);$/;"	p	signature:(volatile LONG* ptr, LONG increment)
base::subtle::_InterlockedExchangeAdd64	src/base/atomicops-internals-windows.h	/^LONGLONG _InterlockedExchangeAdd64(volatile LONGLONG* ptr, LONGLONG increment);$/;"	p	signature:(volatile LONGLONG* ptr, LONGLONG increment)
base::subtle::_InterlockedExchangePointer	src/base/atomicops-internals-windows.h	/^PVOID _InterlockedExchangePointer(volatile PVOID* ptr, PVOID newval);$/;"	p	signature:(volatile PVOID* ptr, PVOID newval)
base::subtle::__sync_val_compare_and_swap	src/base/atomicops-internals-x86.h	/^inline Atomic64 __sync_val_compare_and_swap(volatile Atomic64* ptr,$/;"	f	namespace:base::subtle	signature:(volatile Atomic64* ptr, Atomic64 old_value, Atomic64 new_value)
base::subtle::_isync	src/base/atomicops-internals-linuxppc.h	/^static inline void _isync(void) {$/;"	f	namespace:base::subtle	signature:(void)
base::subtle::_lwsync	src/base/atomicops-internals-linuxppc.h	/^static inline void _lwsync(void) {$/;"	f	namespace:base::subtle	signature:(void)
base::subtle::_sync	src/base/atomicops-internals-linuxppc.h	/^static inline void _sync(void) {$/;"	f	namespace:base::subtle	signature:(void)
base::subtle::atomic_word_is_atomic	src/base/atomicops-internals-windows.h	/^COMPILE_ASSERT(sizeof(Atomic64) == sizeof(PVOID), atomic_word_is_atomic);$/;"	m	namespace:base::subtle
base::subtle::sizeof	src/base/atomicops-internals-windows.h	/^COMPILE_ASSERT(sizeof(Atomic64) == sizeof(PVOID), atomic_word_is_atomic);$/;"	m	namespace:base::subtle
base::vdso_init_helper	src/base/vdso_support.cc	/^} vdso_init_helper;$/;"	m	namespace:base	typeref:class:base::VDSOInitHelper	file:
base_	src/raw_printer.h	/^  char* base_;          \/\/ Initial pointer$/;"	m	class:base::RawPrinter	access:private
basic_machine	config.sub	/^		basic_machine=$basic_machine-unknown$/;"	v
basic_machine	config.sub	/^		basic_machine=580-amdahl$/;"	v
basic_machine	config.sub	/^		basic_machine=`echo $1 | sed -e 's\/86.*\/86-pc\/'`$/;"	v
basic_machine	config.sub	/^		basic_machine=`echo $basic_machine | sed "s\/unknown\/$vendor\/"`$/;"	v
basic_machine	config.sub	/^		basic_machine=`echo $basic_machine | sed -e 's\/mips3\/mips64\/'`-unknown$/;"	v
basic_machine	config.sub	/^		basic_machine=a29k-amd$/;"	v
basic_machine	config.sub	/^		basic_machine=a29k-none$/;"	v
basic_machine	config.sub	/^		basic_machine=a29k-nyu$/;"	v
basic_machine	config.sub	/^		basic_machine=a29k-wrs$/;"	v
basic_machine	config.sub	/^		basic_machine=abacus-unknown$/;"	v
basic_machine	config.sub	/^		basic_machine=alphaev5-cray$/;"	v
basic_machine	config.sub	/^		basic_machine=arm-unknown$/;"	v
basic_machine	config.sub	/^		basic_machine=armv4l-rebel$/;"	v
basic_machine	config.sub	/^		basic_machine=bfin-unknown$/;"	v
basic_machine	config.sub	/^		basic_machine=c90-cray$/;"	v
basic_machine	config.sub	/^		basic_machine=clipper-highlevel$/;"	v
basic_machine	config.sub	/^		basic_machine=cr16-unknown$/;"	v
basic_machine	config.sub	/^		basic_machine=craynv-cray$/;"	v
basic_machine	config.sub	/^		basic_machine=crx-unknown$/;"	v
basic_machine	config.sub	/^		basic_machine=cydra-cydrome$/;"	v
basic_machine	config.sub	/^		basic_machine=elxsi-elxsi$/;"	v
basic_machine	config.sub	/^		basic_machine=fx80-alliant$/;"	v
basic_machine	config.sub	/^		basic_machine=h8300-hitachi$/;"	v
basic_machine	config.sub	/^		basic_machine=h8500-hitachi$/;"	v
basic_machine	config.sub	/^		basic_machine=hppa-unknown$/;"	v
basic_machine	config.sub	/^		basic_machine=hppa1.0-hp$/;"	v
basic_machine	config.sub	/^		basic_machine=hppa1.1-hitachi$/;"	v
basic_machine	config.sub	/^		basic_machine=hppa1.1-hp$/;"	v
basic_machine	config.sub	/^		basic_machine=hppa1.1-oki$/;"	v
basic_machine	config.sub	/^		basic_machine=hppa1.1-winbond$/;"	v
basic_machine	config.sub	/^		basic_machine=i370-ibm$/;"	v
basic_machine	config.sub	/^		basic_machine=i386-ibm$/;"	v
basic_machine	config.sub	/^		basic_machine=i386-mach$/;"	v
basic_machine	config.sub	/^		basic_machine=i386-pc$/;"	v
basic_machine	config.sub	/^		basic_machine=i386-sequent$/;"	v
basic_machine	config.sub	/^		basic_machine=i386-sun$/;"	v
basic_machine	config.sub	/^		basic_machine=i386-unknown$/;"	v
basic_machine	config.sub	/^		basic_machine=i486-ncr$/;"	v
basic_machine	config.sub	/^		basic_machine=i586-pc$/;"	v
basic_machine	config.sub	/^		basic_machine=i586-unknown$/;"	v
basic_machine	config.sub	/^		basic_machine=i686-pc$/;"	v
basic_machine	config.sub	/^		basic_machine=i786-pc$/;"	v
basic_machine	config.sub	/^		basic_machine=i860-alliant$/;"	v
basic_machine	config.sub	/^		basic_machine=i860-intel$/;"	v
basic_machine	config.sub	/^		basic_machine=i860-stratus$/;"	v
basic_machine	config.sub	/^		basic_machine=i960-intel$/;"	v
basic_machine	config.sub	/^		basic_machine=i960-wrs$/;"	v
basic_machine	config.sub	/^		basic_machine=j90-cray$/;"	v
basic_machine	config.sub	/^		basic_machine=m68000-convergent$/;"	v
basic_machine	config.sub	/^		basic_machine=m68000-ericsson$/;"	v
basic_machine	config.sub	/^		basic_machine=m68000-hp$/;"	v
basic_machine	config.sub	/^		basic_machine=m68000-sun$/;"	v
basic_machine	config.sub	/^		basic_machine=m68010-adobe$/;"	v
basic_machine	config.sub	/^		basic_machine=m68030-sony$/;"	v
basic_machine	config.sub	/^		basic_machine=m68k-altos$/;"	v
basic_machine	config.sub	/^		basic_machine=m68k-apollo$/;"	v
basic_machine	config.sub	/^		basic_machine=m68k-apple$/;"	v
basic_machine	config.sub	/^		basic_machine=m68k-bull$/;"	v
basic_machine	config.sub	/^		basic_machine=m68k-crds$/;"	v
basic_machine	config.sub	/^		basic_machine=m68k-ericsson$/;"	v
basic_machine	config.sub	/^		basic_machine=m68k-harris$/;"	v
basic_machine	config.sub	/^		basic_machine=m68k-hp$/;"	v
basic_machine	config.sub	/^		basic_machine=m68k-isi$/;"	v
basic_machine	config.sub	/^		basic_machine=m68k-none$/;"	v
basic_machine	config.sub	/^		basic_machine=m68k-rom68k$/;"	v
basic_machine	config.sub	/^		basic_machine=m68k-sony$/;"	v
basic_machine	config.sub	/^		basic_machine=m68k-sun$/;"	v
basic_machine	config.sub	/^		basic_machine=m68k-tandem$/;"	v
basic_machine	config.sub	/^		basic_machine=m68k-tti$/;"	v
basic_machine	config.sub	/^		basic_machine=m68k-unknown$/;"	v
basic_machine	config.sub	/^		basic_machine=m68k-wrs$/;"	v
basic_machine	config.sub	/^		basic_machine=m88k-harris$/;"	v
basic_machine	config.sub	/^		basic_machine=m88k-motorola$/;"	v
basic_machine	config.sub	/^		basic_machine=microblaze-xilinx$/;"	v
basic_machine	config.sub	/^		basic_machine=mips-compaq$/;"	v
basic_machine	config.sub	/^		basic_machine=mips-mips$/;"	v
basic_machine	config.sub	/^		basic_machine=mips-sei$/;"	v
basic_machine	config.sub	/^		basic_machine=mips-sgi$/;"	v
basic_machine	config.sub	/^		basic_machine=mips-siemens$/;"	v
basic_machine	config.sub	/^		basic_machine=mipsisa32-sde$/;"	v
basic_machine	config.sub	/^		basic_machine=mipsisa64sb1-unknown$/;"	v
basic_machine	config.sub	/^		basic_machine=mipsisa64sb1el-unknown$/;"	v
basic_machine	config.sub	/^		basic_machine=mipstx39-unknown$/;"	v
basic_machine	config.sub	/^		basic_machine=mipstx39el-unknown$/;"	v
basic_machine	config.sub	/^		basic_machine=mmix-knuth$/;"	v
basic_machine	config.sub	/^		basic_machine=mt-unknown$/;"	v
basic_machine	config.sub	/^		basic_machine=none-none$/;"	v
basic_machine	config.sub	/^		basic_machine=np1-gould$/;"	v
basic_machine	config.sub	/^		basic_machine=ns32k-encore$/;"	v
basic_machine	config.sub	/^		basic_machine=ns32k-ns$/;"	v
basic_machine	config.sub	/^		basic_machine=ns32k-sequent$/;"	v
basic_machine	config.sub	/^		basic_machine=ns32k-utek$/;"	v
basic_machine	config.sub	/^		basic_machine=orion-highlevel$/;"	v
basic_machine	config.sub	/^		basic_machine=pdp10-dec$/;"	v
basic_machine	config.sub	/^		basic_machine=pdp10-unknown$/;"	v
basic_machine	config.sub	/^		basic_machine=pdp10-xkl$/;"	v
basic_machine	config.sub	/^		basic_machine=pdp11-dec$/;"	v
basic_machine	config.sub	/^		basic_machine=pn-gould$/;"	v
basic_machine	config.sub	/^		basic_machine=powerpc-ibm$/;"	v
basic_machine	config.sub	/^		basic_machine=powerpc-unknown$/;"	v
basic_machine	config.sub	/^		basic_machine=romp-ibm$/;"	v
basic_machine	config.sub	/^		basic_machine=rs6000-ibm$/;"	v
basic_machine	config.sub	/^		basic_machine=s390x-ibm$/;"	v
basic_machine	config.sub	/^		basic_machine=sh-hitachi$/;"	v
basic_machine	config.sub	/^		basic_machine=sh-unknown$/;"	v
basic_machine	config.sub	/^		basic_machine=sh5le-unknown$/;"	v
basic_machine	config.sub	/^		basic_machine=sh64-unknown$/;"	v
basic_machine	config.sub	/^		basic_machine=sparc-sun$/;"	v
basic_machine	config.sub	/^		basic_machine=sparc-tti$/;"	v
basic_machine	config.sub	/^		basic_machine=spur-unknown$/;"	v
basic_machine	config.sub	/^		basic_machine=sv1-cray$/;"	v
basic_machine	config.sub	/^		basic_machine=t90-cray$/;"	v
basic_machine	config.sub	/^		basic_machine=tic54x-unknown$/;"	v
basic_machine	config.sub	/^		basic_machine=tic55x-unknown$/;"	v
basic_machine	config.sub	/^		basic_machine=tic6x-unknown$/;"	v
basic_machine	config.sub	/^		basic_machine=tile-unknown$/;"	v
basic_machine	config.sub	/^		basic_machine=tron-gmicro$/;"	v
basic_machine	config.sub	/^		basic_machine=v70-nec$/;"	v
basic_machine	config.sub	/^		basic_machine=v810-nec$/;"	v
basic_machine	config.sub	/^		basic_machine=vax-dec$/;"	v
basic_machine	config.sub	/^		basic_machine=w65-wdc$/;"	v
basic_machine	config.sub	/^		basic_machine=we32k-att$/;"	v
basic_machine	config.sub	/^		basic_machine=x86_64-pc$/;"	v
basic_machine	config.sub	/^		basic_machine=xps100-honeywell$/;"	v
basic_machine	config.sub	/^		basic_machine=ymp-cray$/;"	v
basic_machine	config.sub	/^	  basic_machine=$basic_machine-pc$/;"	v
basic_machine	config.sub	/^	power)	basic_machine=power-ibm$/;"	v
basic_machine	config.sub	/^	ppc)	basic_machine=powerpc-unknown$/;"	v
basic_machine	config.sub	/^	ppc64)	basic_machine=powerpc64-unknown$/;"	v
begin	src/base/elf_mem_image.cc	/^ElfMemImage::SymbolIterator ElfMemImage::begin() const {$/;"	f	class:base::ElfMemImage	signature:() const
begin	src/base/elf_mem_image.h	/^  SymbolIterator begin() const;$/;"	p	class:base::ElfMemImage	access:public	signature:() const
begin	src/base/vdso_support.h	/^  SymbolIterator begin() const { return image_.begin(); }$/;"	f	class:base::VDSOSupport	access:public	signature:() const
below	docs/cpuprofile-fileformat.html	/^(x86 and x86_64) profiles are shown below, for comparison.$/;"	v
bench_body	benchmark/run_benchmark.h	/^typedef void (*bench_body)(long iterations, uintptr_t param);$/;"	t
bench_body	tags	/^bench_body	benchmark\/run_benchmark.h	\/^typedef void (*bench_body)(long iterations, uintptr_t param);$\/;"	t$/;"	t	file:
bench_fastpath_dependent	benchmark/malloc_bench.cc	/^static void bench_fastpath_dependent(long iterations,$/;"	f	file:	signature:(long iterations, uintptr_t param)
bench_fastpath_memalign	benchmark/malloc_bench.cc	/^static void bench_fastpath_memalign(long iterations,$/;"	f	file:	signature:(long iterations, uintptr_t param)
bench_fastpath_rnd_dependent	benchmark/malloc_bench.cc	/^static void bench_fastpath_rnd_dependent(long iterations,$/;"	f	file:	signature:(long iterations, uintptr_t _param)
bench_fastpath_simple	benchmark/malloc_bench.cc	/^static void bench_fastpath_simple(long iterations,$/;"	f	file:	signature:(long iterations, uintptr_t param)
bench_fastpath_simple_sized	benchmark/malloc_bench.cc	/^static void bench_fastpath_simple_sized(long iterations,$/;"	f	file:	signature:(long iterations, uintptr_t param)
bench_fastpath_stack	benchmark/malloc_bench.cc	/^static void bench_fastpath_stack(long iterations,$/;"	f	file:	signature:(long iterations, uintptr_t _param)
bench_fastpath_stack_simple	benchmark/malloc_bench.cc	/^static void bench_fastpath_stack_simple(long iterations,$/;"	f	file:	signature:(long iterations, uintptr_t _param)
bench_fastpath_throughput	benchmark/malloc_bench.cc	/^static void bench_fastpath_throughput(long iterations,$/;"	f	file:	signature:(long iterations, uintptr_t param)
bench_unwind_context	benchmark/unwind_bench.cc	/^static void bench_unwind_context(long iterations, uintptr_t param) {$/;"	f	file:	signature:(long iterations, uintptr_t param)
bench_unwind_no_context	benchmark/unwind_bench.cc	/^static void bench_unwind_no_context(long iterations, uintptr_t param) {$/;"	f	file:	signature:(long iterations, uintptr_t param)
bench_unwind_no_op	benchmark/unwind_bench.cc	/^static void bench_unwind_no_op(long iterations, uintptr_t param) {$/;"	f	file:	signature:(long iterations, uintptr_t param)
big_page_size_	src/memfs_malloc.cc	/^  int64 big_page_size_;$/;"	m	class:HugetlbSysAllocator	file:	access:private
bin	INSTALL	/^`\/usr\/local\/bin', `\/usr\/local\/man', etc.  You can specify an$/;"	v
binaries	README_windows.txt	/^two binaries, nm-pdb and addr2line-pdb, which you should install in$/;"	v
bit_cast	src/base/basictypes.h	/^inline Dest bit_cast(const Source& source) {$/;"	f	signature:(const Source& source)
bit_store	src/base/basictypes.h	/^inline void bit_store(Dest *dest, const Source *source) {$/;"	f	signature:(Dest *dest, const Source *source)
block	src/debugallocation.cc	/^  MallocBlock* block;$/;"	m	struct:MallocBlockQueueEntry	file:	access:public
blocks	src/addressmap-inl.h	/^    Entry*   blocks[kClusterBlocks];    \/\/ Per-block linked-lists$/;"	m	struct:AddressMap::Cluster	access:public
body	benchmark/run_benchmark.c	/^  bench_body body;$/;"	m	struct:internal_bench	file:	access:public
break	m4/acx_pthread.m4	/^                break;$/;"	v
break	m4/libtool.m4	/^	test "$with_gnu_ld" != no && break$/;"	v
break	m4/libtool.m4	/^	test "$with_gnu_ld" != yes && break$/;"	v
bt	src/tests/packed_cache_test-packed-cache_test.o	/^/;"	v
bucket	src/heap-profile-table.cc	/^  Bucket* bucket;$/;"	m	struct:HeapProfileTable::Snapshot::Entry	file:	access:public
bucket	src/heap-profile-table.h	/^    Bucket* bucket() const {$/;"	f	struct:HeapProfileTable::AllocValue	access:public	signature:() const
bucket_allocator	src/static_vars.h	/^  static PageHeapAllocator<StackTraceTable::Bucket>* bucket_allocator() {$/;"	f	class:tcmalloc::Static	access:public	signature:()
bucket_allocator_	src/static_vars.cc	/^PageHeapAllocator<StackTraceTable::Bucket> Static::bucket_allocator_;$/;"	m	class:tcmalloc::Static	file:
bucket_allocator_	src/static_vars.h	/^  ATTRIBUTE_HIDDEN static PageHeapAllocator<StackTraceTable::Bucket> bucket_allocator_;$/;"	m	class:tcmalloc::Static	access:private
bucket_rep	src/heap-profile-table.h	/^    uintptr_t bucket_rep;$/;"	m	struct:HeapProfileTable::AllocValue	access:private
bucket_table_	src/heap-profile-table.h	/^  Bucket** bucket_table_;$/;"	m	class:HeapProfileTable	access:private
bucket_table_	src/memory_region_map.cc	/^HeapProfileBucket** MemoryRegionMap::bucket_table_ = NULL;  \/\/ GUARDED_BY(lock_)$/;"	m	class:MemoryRegionMap	file:
bucket_total	src/stack_trace_table.h	/^  int bucket_total() const { return bucket_total_; }$/;"	f	class:tcmalloc::StackTraceTable	access:public	signature:() const
bucket_total_	src/stack_trace_table.h	/^  int bucket_total_;$/;"	m	class:tcmalloc::StackTraceTable	access:private
buckets_	src/heap-profile-table.cc	/^  map<Bucket*, Entry> buckets_;$/;"	m	struct:HeapProfileTable::Snapshot::ReportState	file:	access:public
buf	src/heap-profile-table.h	/^    char* buf;$/;"	m	struct:HeapProfileTable::BufferArgs	access:public
buf	src/memfs_malloc.cc	/^  char buf[sizeof(HugetlbSysAllocator)];$/;"	m	union:__anon5	file:	access:public
buf	src/system-alloc.cc	/^  char buf[sizeof(DefaultSysAllocator)];$/;"	m	union:__anon35	file:	access:public
buf	src/system-alloc.cc	/^  char buf[sizeof(MmapSysAllocator)];$/;"	m	union:__anon34	file:	access:public
buf	src/system-alloc.cc	/^  char buf[sizeof(SbrkSysAllocator)];$/;"	m	union:__anon33	file:	access:public
buf	src/tests/tcmalloc_unittest.cc	/^  char buf[sizeof(OOMAbleSysAlloc)];$/;"	m	union:__anon58	file:	access:public
buf_	src/base/sysinfo.h	/^    char buf_[kBufSize];$/;"	m	struct:ProcMapsIterator::Buffer	access:public
buf_	src/internal_logging.cc	/^  char buf_[kBufSize];$/;"	m	class:tcmalloc::Logger	file:	access:public
buf_	src/internal_logging.h	/^  char* buf_;           \/\/ Where should we write next$/;"	m	class:TCMalloc_Printer	access:private
buflen	src/heap-profile-table.h	/^    int buflen;$/;"	m	struct:HeapProfileTable::BufferArgs	access:public
bufsize	src/heap-profile-table.h	/^    int bufsize;$/;"	m	struct:HeapProfileTable::BufferArgs	access:public
busy_worker_	src/tests/profile-handler_unittest.cc	/^  BusyThread* busy_worker_;$/;"	m	class:__anon56::ProfileHandlerTest	file:	access:protected
bytes	docs/tcmalloc.html	/^larger sizes by 32 bytes, and so forth.  The maximal spacing is$/;"	v
bytes	docs/tcmalloc.html	/^small sizes are separated by 8 bytes, larger sizes by 16 bytes, even$/;"	v
bytes	src/emergency_malloc.cc	/^    char bytes[sizeof(EmergencyArenaPagesAllocator)];$/;"	m	union:tcmalloc::__anon29	file:	access:public
bytes	src/heap-profile-table.cc	/^  int bytes;$/;"	m	struct:HeapProfileTable::Snapshot::Entry	file:	access:public
bytes	src/heap-profile-table.h	/^    size_t  bytes;   \/\/ Number of bytes in this allocation$/;"	m	struct:HeapProfileTable::AllocValue	access:public
bytes_until_sample_	src/sampler.h	/^  ssize_t bytes_until_sample_;$/;"	m	class:tcmalloc::Sampler	access:public
bytes_until_sample_	src/tests/sampler_test.cc	/^  size_t bytes_until_sample_;$/;"	m	class:OldSampler	file:	access:public
c	src/tests/markidle_unittest-testutil.o	/^/;"	v
c	src/tests/memalign_debug_unittest-testutil.o	/^/;"	v
c	src/tests/memalign_unittest-testutil.o	/^/;"	v
c	src/tests/tcmalloc_and_profiler_unittest-testutil.o	/^/;"	v
c	src/tests/tcmalloc_both_unittest-testutil.o	/^/;"	v
c	src/tests/tcmalloc_debug_unittest-testutil.o	/^/;"	v
c	src/tests/tcmalloc_minimal_debug_unittest-testutil.o	/^/;"	v
c	src/tests/tcmalloc_minimal_unittest-testutil.o	/^/;"	v
c	src/tests/tcmalloc_unittest-testutil.o	/^/;"	v
c	src/tests/thread_dealloc_unittest-testutil.o	/^/;"	v
c99	config.guess	/^	for c in cc gcc c89 c99 ; do$/;"	v
c_open	src/base/linuxthreads.cc	/^static int c_open(const char *fname, int flags, int mode) {$/;"	f	file:	signature:(const char *fname, int flags, int mode)
cache_size_	src/central_freelist.h	/^  int32_t cache_size_;$/;"	m	class:tcmalloc::CentralFreeList	access:private
call	docs/pprof_remote_servers.html	/^addr2line for every <code>pprof\/symbol<\/code> call, for instance$/;"	v
call_stack	src/heap-profile-table.h	/^    const void* const* call_stack;  \/\/ Stack trace$/;"	m	struct:HeapProfileTable::AllocContextInfo	access:public
call_stack	src/heap-profile-table.h	/^    const void* const* call_stack;  \/\/ call stack that made the allocation call$/;"	m	struct:HeapProfileTable::AllocInfo	access:public
call_stack	src/memory_region_map.h	/^    const void* call_stack[kMaxStackDepth];  \/\/ caller address stack array$/;"	m	struct:MemoryRegionMap::Region	access:public
call_stack_depth	src/memory_region_map.h	/^    int call_stack_depth;  \/\/ number of caller stack frames that we saved$/;"	m	struct:MemoryRegionMap::Region	access:public
callback	src/base/linuxthreads.cc	/^  ListAllProcessThreadsCallBack callback;$/;"	m	struct:ListerParams	file:	access:public
callback	src/profile-handler.cc	/^  ProfileHandlerCallback callback;$/;"	m	struct:ProfileHandlerToken	file:	access:public
callback_arg	src/profile-handler.cc	/^  void* callback_arg;$/;"	m	struct:ProfileHandlerToken	file:	access:public
callback_count	src/profile-handler.h	/^  int32 callback_count;  \/* Number of callbacks registered *\/$/;"	m	struct:ProfileHandlerState	access:public
called	docs/heap_checker.html	/^is called (for whole-program checking, this happens automatically at$/;"	p	file:	signature:(for whole-program checking, this happens automatically at program-exit)
caller	src/memory_region_map.h	/^    uintptr_t caller() const {$/;"	f	struct:MemoryRegionMap::Region	access:public	signature:() const
calloc	docs/heapprofile.html	/^    <code>malloc<\/code>, <code>calloc<\/code>, <code>realloc<\/code>,$/;"	v
calloc	docs/heapprofile.html	/^    to <code>malloc<\/code>, <code>calloc<\/code>, <code>realloc<\/code>,$/;"	v
calloc	docs/heapprofile.html	/^<code>malloc<\/code>, <code>calloc<\/code>, <code>realloc<\/code>, or,$/;"	v
calloc	src/libc_override_redefine.h	/^  void* calloc(size_t n, size_t s)               { return tc_calloc(n, s);    }$/;"	f	signature:(size_t n, size_t s)
calloc	src/windows/override_functions.cc	93;"	d	file:
calls	docs/heap_checker.html	/^<code>NoLeaks()<\/code> calls, we grab a lock$/;"	v
calls	docs/heapprofile.html	/^    calls; do not profile$/;"	v
callunrollinfo	src/getpc.h	/^static const CallUnrollInfo callunrollinfo[] = {$/;"	v
can_create_leaks_reliably	src/tests/heap-checker_unittest.cc	/^static bool can_create_leaks_reliably = false;$/;"	v	file:
cc_basename	m4/libtool.m4	/^cc_basename=`$ECHO "X$cc_temp" | $Xsed -e 's%.*\/%%' -e "s%^$host_alias-%%"`$/;"	v
ccr	src/base/elfcore.h	/^    unsigned long ccr;$/;"	m	struct:ppc_regs	access:public
central_bytes	src/tcmalloc.cc	/^  uint64_t central_bytes;     \/\/ Bytes in central cache$/;"	m	struct:TCMallocStats	file:	access:public
central_cache	src/static_vars.h	/^  static CentralFreeListPadded* central_cache() { return central_cache_; }$/;"	f	class:tcmalloc::Static	access:public	signature:()
central_cache_	src/static_vars.cc	/^CentralFreeListPadded Static::central_cache_[kClassSizesMax];$/;"	m	class:tcmalloc::Static	file:
central_cache_	src/static_vars.h	/^  ATTRIBUTE_HIDDEN static CentralFreeListPadded central_cache_[kClassSizesMax];$/;"	m	class:tcmalloc::Static	access:private
cfree	src/libc_override_osx.h	/^  void  cfree(void* p)                   { tc_cfree(p);               }$/;"	f	signature:(void* p)
cfree	src/libc_override_redefine.h	/^  void  cfree(void* p)                           { tc_cfree(p);               }$/;"	f	signature:(void* p)
cfree	src/tests/tcmalloc_unittest.cc	103;"	d	file:
character	docs/cpuprofile-fileformat.html	/^<tt>$build<\/tt> followed by a non-word character (i.e., characters$/;"	p	file:	signature:(i.e., characters other than underscore or alphanumeric characters)
chars	src/base/low_level_alloc.cc	/^  char chars[sizeof(DefaultPagesAllocator)];$/;"	m	union:__anon40	file:	access:public
chars	src/debugallocation.cc	/^  char chars[sizeof(DebugMallocImplementation)];$/;"	m	union:__anon8	file:	access:public
check	benchmark/binary_trees.cc	/^  int check() const {$/;"	f	struct:Node	access:public	signature:() const
check_global_nallocx	src/tests/tcmalloc_unittest.cc	/^static void check_global_nallocx() __attribute__((constructor));$/;"	p	namespace:testing	file:	signature:()
check_global_nallocx	src/tests/tcmalloc_unittest.cc	/^static void check_global_nallocx() { CHECK_GT(nallocx(99, 0), 99); }$/;"	f	namespace:testing	signature:()
checked_sections	src/malloc_hook.cc	/^static bool checked_sections = false;$/;"	v	file:
checker	README	/^The cpu profiler, heap checker, and heap profiler will lie dormant,$/;"	v
checker	docs/heap_checker.html	/^system.)  Note that if you wish to use the heap checker, you must$/;"	v
checker_	src/tests/profiledata_unittest.cc	/^  ProfileDataChecker checker_;$/;"	m	class:__anon53::ProfileDataTest	file:	access:protected
child	src/tests/tcmalloc_unittest.cc	/^  SysAllocator *child;$/;"	m	struct:OOMAbleSysAlloc	file:	access:public
choosing	docs/pprof_remote_servers.html	/^of its choosing, and to respond to HTTP requests on that port.<\/p>$/;"	v
cl	src/windows/shortproc.asm	/^	test cl, 1$/;"	v
class_array_	src/common.h	/^  unsigned char class_array_[kClassArraySize];$/;"	m	class:tcmalloc::SizeMap	access:private
class_to_pages	src/common.h	/^  inline size_t class_to_pages(uint32 cl) {$/;"	f	class:tcmalloc::SizeMap	access:public	signature:(uint32 cl)
class_to_pages_	src/common.h	/^  size_t class_to_pages_[kClassSizesMax];$/;"	m	class:tcmalloc::SizeMap	access:private
class_to_size	src/common.h	/^  inline int32 class_to_size(uint32 cl) {$/;"	f	class:tcmalloc::SizeMap	access:public	signature:(uint32 cl)
class_to_size_	src/common.h	/^  int32 class_to_size_[kClassSizesMax];$/;"	m	class:tcmalloc::SizeMap	access:private
clear_lowwatermark	src/thread_cache.h	/^    void clear_lowwatermark() { lowater_ = length_; }$/;"	f	class:tcmalloc::ThreadCache::FreeList	access:public	signature:()
client_count_	src/memory_region_map.cc	/^int MemoryRegionMap::client_count_ = 0;$/;"	m	class:MemoryRegionMap	file:
client_count_	src/memory_region_map.h	/^  static int client_count_;$/;"	m	class:MemoryRegionMap	access:private
clone	config.guess	/^    BeMac:BeOS:*:*)	# BeOS running on Mac or Mac clone, PPC only.$/;"	v
clone	src/base/linux_syscall_support.h	/^    LSS_INLINE int LSS_NAME(clone)(int (*fn)(void *), void *child_stack,$/;"	f	signature:(int (*fn)(void *), void *child_stack, int flags, void *arg, int *parent_tidptr, void *newtls, int *child_tidptr)
close	src/windows/port.h	/^inline int close(int fd) {$/;"	f	signature:(int fd)
code	README	/^your code, rather than setting CPUPROFILE.  This will profile only$/;"	v
code	docs/tcmalloc.html	/^    <code>madvise(MADV_DONTNEED)<\/code>, on systems that support$/;"	m	class:object::structure	file:	access:private
cofile	compile	/^cofile=`echo "$cfile" | sed 's|^.*[\\\\\/]||; s|^[a-zA-Z]:||; s\/\\.c$\/.o\/'`$/;"	v
collector_	src/profiler.cc	/^  ProfileData   collector_;$/;"	m	class:CpuProfiler	file:	access:private
collector_	src/tests/profiledata_unittest.cc	/^  ProfileData        collector_;$/;"	m	class:__anon53::ProfileDataTest	file:	access:protected
command	docs/heap_checker.html	/^First, you should run the reported <code>pprof<\/code> command;$/;"	v
commandlineflags	src/base/commandlineflags.h	/^  namespace commandlineflags {$/;"	n	namespace:tcmalloc
commit_count	src/page_heap.h	/^    uint64_t commit_count;          \/\/ Number of virtual memory commits$/;"	m	struct:tcmalloc::PageHeap::Stats	access:public
committed_bytes	src/page_heap.h	/^    uint64_t committed_bytes;  \/\/ Bytes committed, always <= system_bytes_.$/;"	m	struct:tcmalloc::PageHeap::Stats	access:public
condition_register	src/stacktrace_powerpc-inl.h	/^  long condition_register;$/;"	m	struct:layout_ppc	access:public
condition_register	src/stacktrace_powerpc-linux-inl.h	/^  long condition_register;$/;"	m	struct:layout_ppc	access:public
configure	config.log	/^running configure, to aid debugging if configure makes a mistake.$/;"	v
configure	missing	/^    touch configure$/;"	v
configure_ac	missing	/^  configure_ac=configure.ac$/;"	v
const_pointer	src/base/stl_allocator.h	/^  typedef const T*   const_pointer;$/;"	t	class:STL_Allocator	access:public
const_reference	src/base/stl_allocator.h	/^  typedef const T&   const_reference;$/;"	t	class:STL_Allocator	access:public
construct	src/base/stl_allocator.h	/^  void construct(pointer p) { ::new(p) T(); }$/;"	f	class:STL_Allocator	access:public	signature:(pointer p)
construct	src/base/stl_allocator.h	/^  void construct(pointer p, const T& val) { ::new(p) T(val); }$/;"	f	class:STL_Allocator	access:public	signature:(pointer p, const T& val)
constructor_heap_profiling	src/heap-checker.cc	/^static bool constructor_heap_profiling = false;$/;"	v	file:
continue	m4/acx_pthread.m4	/^		if test x"$acx_pthread_config" = xno; then continue; fi$/;"	v
copy	INSTALL	/^unlimited permission to copy, distribute and modify it.$/;"	v
copy	m4/libtool.m4	/^gives unlimited permision to copy, distribute and modify it."$/;"	v
copyright	src/windows/shortproc.asm	/^;     * Redistributions of source code must retain the above copyright$/;"	v
correctly	packages/deb/README	/^how to set this package up correctly, check out$/;"	v
count	src/heap-profile-table.cc	/^  int count;$/;"	m	struct:HeapProfileTable::Snapshot::Entry	file:	access:public
count	src/profiledata.h	/^    Slot count;                  \/\/ Number of hits$/;"	m	struct:ProfileData::Entry	access:public
count	src/stack_trace_table.h	/^    int count;$/;"	m	struct:tcmalloc::StackTraceTable::Bucket	access:public
count_	src/heap-checker-bcad.cc	/^  static int count_;$/;"	m	class:HeapLeakCheckerGlobalPrePost	file:	access:private
count_	src/heap-checker-bcad.cc	/^int HeapLeakCheckerGlobalPrePost::count_ = 0;$/;"	m	class:HeapLeakCheckerGlobalPrePost	file:
count_	src/profiledata.h	/^  int           count_;         \/\/ How many samples recorded$/;"	m	class:ProfileData	access:private
counter_	src/central_freelist.h	/^  size_t   counter_;        \/\/ Number of free objects in cache entry$/;"	m	class:tcmalloc::CentralFreeList	access:private
cp0_badvaddr	src/base/elfcore.h	/^    unsigned long cp0_badvaddr;$/;"	m	struct:mips_regs	access:public
cp0_cause	src/base/elfcore.h	/^    unsigned long cp0_cause;$/;"	m	struct:mips_regs	access:public
cp0_epc	src/base/elfcore.h	/^    unsigned long cp0_epc;      \/* Program counter.                          *\/$/;"	m	struct:mips_regs	access:public
cp0_status	src/base/elfcore.h	/^    unsigned long cp0_status;$/;"	m	struct:mips_regs	access:public
cpp_nothrow_oom	src/tcmalloc.cc	/^void* cpp_nothrow_oom(size_t size) {$/;"	f	namespace:tcmalloc	signature:(size_t size)
cpp_throw_oom	src/tcmalloc.cc	/^void* cpp_throw_oom(size_t size) {$/;"	f	namespace:tcmalloc	signature:(size_t size)
cpuid	src/base/atomicops-internals-x86.cc	52;"	d	file:
cpuid	src/base/atomicops-internals-x86.cc	58;"	d	file:
crash_lock	src/internal_logging.cc	/^static SpinLock crash_lock(base::LINKER_INITIALIZED);$/;"	p	file:	signature:(base::LINKER_INITIALIZED)
crashed	src/internal_logging.cc	/^static bool crashed = false;$/;"	v	file:
cs	src/base/elfcore.h	/^    uint64_t  rip,cs,eflags;$/;"	m	struct:i386_regs	access:public
ctr	src/base/elfcore.h	/^    unsigned long ctr;$/;"	m	struct:ppc_regs	access:public
ctrgProcAddress	src/windows/patch_functions.cc	/^  static const int ctrgProcAddress = kNumFunctions;$/;"	m	class:__anon13::LibcInfo	file:	access:public
current_filename_	src/base/sysinfo.h	/^  char current_filename_[PATH_MAX];$/;"	m	class:ProcMapsIterator	access:private
current_image_	src/base/sysinfo.h	/^  int current_image_; \/\/ dll's are called "images" in macos parlance$/;"	m	class:ProcMapsIterator	access:private
current_instance	src/malloc_extension.cc	/^static MallocExtension* current_instance;$/;"	v	file:
current_load_cmd_	src/base/sysinfo.h	/^  int current_load_cmd_;   \/\/ the segment of this dll we're examining$/;"	m	class:ProcMapsIterator	access:private
current_thread_is	src/memory_region_map.cc	/^static inline bool current_thread_is(pthread_t should_be) {$/;"	f	file:	signature:(pthread_t should_be)
cyg_backtrace	src/stacktrace_instrument-inl.h	/^static int cyg_backtrace(void **buffer, int size) {$/;"	f	signature:(void **buffer, int size)
cygpath_u	depcomp	/^   cygpath_u="sed s,\\\\\\\\\\\\\\\\,\/,g"$/;"	v
d	Makefile	/^	  if test -f "$$p"; then d=; else d="$(srcdir)\/"; fi; \\$/;"	v
d	Makefile.in	/^	  if test -f "$$p"; then d=; else d="$(srcdir)\/"; fi; \\$/;"	v
d	src/.libs/libtcmalloc_internal_la-internal_logging.o	/^/;"	v
d	src/base/basictypes.h	/^  double d;$/;"	m	union:MemoryAligner	access:public
d	src/tests/heap-checker_unittest.cc	/^  char d[3];$/;"	m	class:ClassD	file:	access:private
d1	src/tests/heap-checker_unittest.cc	/^  char d1[11];$/;"	m	class:ClassMltD1	file:	access:public
d1	src/tests/heap-checker_unittest.cc	/^  char d1[15];$/;"	m	class:ClassD1	file:	access:private
d2	src/tests/heap-checker_unittest.cc	/^  char d2[15];$/;"	m	class:ClassMltD2	file:	access:public
d2	src/tests/heap-checker_unittest.cc	/^  char d2[19];$/;"	m	class:ClassD2	file:	access:private
d_ino	src/base/linux_syscall_support.h	/^  long               d_ino;$/;"	m	struct:kernel_dirent	access:public
d_ino	src/base/linux_syscall_support.h	/^  unsigned long long d_ino;$/;"	m	struct:kernel_dirent64	access:public
d_name	src/base/linux_syscall_support.h	/^  char               d_name[256];$/;"	m	struct:kernel_dirent	access:public
d_name	src/base/linux_syscall_support.h	/^  char               d_name[256];$/;"	m	struct:kernel_dirent64	access:public
d_off	src/base/linux_syscall_support.h	/^  long               d_off;$/;"	m	struct:kernel_dirent	access:public
d_off	src/base/linux_syscall_support.h	/^  long long          d_off;$/;"	m	struct:kernel_dirent64	access:public
d_reclen	src/base/linux_syscall_support.h	/^  unsigned short     d_reclen;$/;"	m	struct:kernel_dirent	access:public
d_reclen	src/base/linux_syscall_support.h	/^  unsigned short     d_reclen;$/;"	m	struct:kernel_dirent64	access:public
d_type	src/base/linux_syscall_support.h	/^  unsigned char      d_type;$/;"	m	struct:kernel_dirent64	access:public
dashmflag	depcomp	/^   dashmflag=-xM$/;"	v
data	docs/pprof_remote_servers.html	/^the necessary data, which should allow the interested developer to add$/;"	v
data	src/tests/tcmalloc_unittest.cc	/^  unsigned char data[OVERALIGNMENT * 2]; \/\/ make the object size different from$/;"	m	struct:overaligned_type	file:	access:public
data_	src/tests/profiledata_unittest.cc	/^  T* const data_;$/;"	m	class:__anon53::scoped_array	file:	access:private
data_addr	src/debugallocation.cc	/^  const void* data_addr() const { return (const void*)&size2_; }$/;"	f	class:MallocBlock	access:public	signature:() const
data_addr	src/debugallocation.cc	/^  void* data_addr() { return (void*)&size2_; }$/;"	f	class:MallocBlock	access:public	signature:()
data_offset	src/debugallocation.cc	/^  static size_t data_offset() { return OFFSETOF_MEMBER(MallocBlock, size2_); }$/;"	f	class:MallocBlock	access:public	signature:()
data_size	src/debugallocation.cc	/^  size_t data_size() const { return size1_; }$/;"	f	class:MallocBlock	access:public	signature:() const
dealloc_	src/addressmap-inl.h	/^  DeAllocator   dealloc_;               \/\/ The deallocator$/;"	m	class:AddressMap	access:private
dealloc_	src/heap-profile-table.h	/^  DeAllocator dealloc_;$/;"	m	class:HeapProfileTable	access:private
deallocate	src/base/stl_allocator.h	/^  void deallocate(pointer p, size_type n) { Alloc::Free(p, n * sizeof(T)); }$/;"	f	class:STL_Allocator	access:public	signature:(pointer p, size_type n)
death_test_num	debugallocation_test.sh	/^  death_test_num=`expr $death_test_num + 1`$/;"	v
death_test_num	src/tests/debugallocation_test.sh	/^  death_test_num=`expr $death_test_num + 1`$/;"	v
debug_alloc_retry_data	src/debugallocation.cc	/^struct debug_alloc_retry_data {$/;"	s	file:
debug_alloc_retry_data::new_type	src/debugallocation.cc	/^  int new_type;$/;"	m	struct:debug_alloc_retry_data	file:	access:public
debug_alloc_retry_data::size	src/debugallocation.cc	/^  size_t size;$/;"	m	struct:debug_alloc_retry_data	file:	access:public
debug_cpp_alloc	src/debugallocation.cc	/^inline void* debug_cpp_alloc(size_t size, int new_type, bool nothrow) {$/;"	f	signature:(size_t size, int new_type, bool nothrow)
debug_malloc_implementation_space	src/debugallocation.cc	/^} debug_malloc_implementation_space;$/;"	v	typeref:union:__anon8	file:
debug_pages_allocator_space	src/base/low_level_alloc.cc	/^} debug_pages_allocator_space;$/;"	v	typeref:union:__anon40	file:
decommit_count	src/page_heap.h	/^    uint64_t decommit_count;        \/\/ Number of virtual memory decommits$/;"	m	struct:tcmalloc::PageHeap::Stats	access:public
default_arena	src/base/low_level_alloc.cc	/^static struct LowLevelAlloc::Arena default_arena;$/;"	v	typeref:struct:Arena	file:
default_pages_allocator	src/base/low_level_alloc.cc	/^static DefaultPagesAllocator *default_pages_allocator;$/;"	v	file:
default_space	src/system-alloc.cc	/^} default_space;$/;"	v	typeref:union:__anon35	file:
delegate_sized_aligned_delete	src/libc_override_gcc_and_weak.h	/^static void delegate_sized_aligned_delete(void *p, size_t s, std::align_val_t al) {$/;"	f	signature:(void *p, size_t s, std::align_val_t al)
delegate_sized_aligned_deletearray	src/libc_override_gcc_and_weak.h	/^static void delegate_sized_aligned_deletearray(void *p, size_t s, std::align_val_t al) {$/;"	f	signature:(void *p, size_t s, std::align_val_t al)
delegate_sized_delete	src/libc_override_gcc_and_weak.h	/^static void delegate_sized_delete(void *p, size_t s) {$/;"	f	signature:(void *p, size_t s)
delegate_sized_deletearray	src/libc_override_gcc_and_weak.h	/^static void delegate_sized_deletearray(void *p, size_t s) {$/;"	f	signature:(void *p, size_t s)
delete_hooks_	src/malloc_hook.cc	/^HookList<MallocHook::DeleteHook> delete_hooks_ = INIT_HOOK_LIST;$/;"	m	namespace:base::internal	file:
deleted_buffer_initialized_	src/debugallocation.cc	/^  static pthread_once_t deleted_buffer_initialized_;$/;"	m	class:MallocBlock	file:	access:private
deleted_buffer_initialized_	src/debugallocation.cc	/^pthread_once_t MallocBlock::deleted_buffer_initialized_ = PTHREAD_ONCE_INIT;$/;"	m	class:MallocBlock	file:
deleted_buffer_initialized_no_pthreads_	src/debugallocation.cc	/^  static bool deleted_buffer_initialized_no_pthreads_;$/;"	m	class:MallocBlock	file:	access:private
deleted_buffer_initialized_no_pthreads_	src/debugallocation.cc	/^bool MallocBlock::deleted_buffer_initialized_no_pthreads_ = false;$/;"	m	class:MallocBlock	file:
deleter_pcs	src/debugallocation.cc	/^  void* deleter_pcs[16];$/;"	m	struct:MallocBlockQueueEntry	file:	access:public
deleter_threadid	src/debugallocation.cc	/^  pthread_t deleter_threadid;$/;"	m	struct:MallocBlockQueueEntry	file:	access:public
depfile	depcomp	/^depfile=${depfile-`echo "$object" |$/;"	v
depth	src/common.h	/^  uintptr_t depth;         \/\/ Number of PC values stored in array below$/;"	m	struct:tcmalloc::StackTrace	access:public
depth	src/heap-profile-stats.h	/^  int depth;                \/\/ Depth of stack trace.$/;"	m	struct:HeapProfileBucket	access:public
depth	src/profiledata.h	/^    Slot depth;                  \/\/ Stack depth$/;"	m	struct:ProfileData::Entry	access:public
depth_total	src/stack_trace_table.h	/^  int depth_total() const { return depth_total_; }$/;"	f	class:tcmalloc::StackTraceTable	access:public	signature:() const
depth_total_	src/stack_trace_table.h	/^  int depth_total_;$/;"	m	class:tcmalloc::StackTraceTable	access:private
dest	src/heap-profile-table.h	/^    Snapshot* dest;$/;"	m	struct:HeapProfileTable::AddNonLiveArgs	access:public
destr_fn	src/windows/port.cc	/^  void (*destr_fn)(void*);$/;"	m	struct:DestrFnClosure	file:	access:public
destr_fn_info	src/windows/port.cc	/^static DestrFnClosure destr_fn_info;   \/\/ initted to all NULL\/0.$/;"	v	file:
destroy	src/base/stl_allocator.h	/^  void destroy(pointer p) { p->~T(); }$/;"	f	class:STL_Allocator	access:public	signature:(pointer p)
destroy_	src/base/simple_mutex.h	/^  bool destroy_;$/;"	m	class:MUTEX_NAMESPACE::Mutex	access:private
destructor_	src/base/googleinit.h	/^  const VoidFunction destructor_;$/;"	m	class:GoogleInitializer	access:private
did_it_	src/windows/auto_testing_hook.h	/^  bool did_it_;  \/\/ Remember if we did it or not...$/;"	m	class:sidestep::AutoTestingHookImpl	access:private
difference_type	src/base/stl_allocator.h	/^  typedef ptrdiff_t  difference_type;$/;"	t	class:STL_Allocator	access:public
dir	Makefile	/^	  test "$$dir" != "$$p" || dir=.; \\$/;"	v
dir	Makefile.in	/^	  test "$$dir" != "$$p" || dir=.; \\$/;"	v
dir	depcomp	/^  dir=`echo "$object" | sed -e 's|\/[^\/]*$|\/|'`$/;"	v
disabled_ranges	src/heap-checker.cc	/^static DisabledRangeMap* disabled_ranges = NULL;$/;"	v	file:
disclaimer	src/windows/shortproc.asm	/^; copyright notice, this list of conditions and the following disclaimer$/;"	v
dispatch_allocate_full	src/tcmalloc.cc	/^static ATTRIBUTE_ALWAYS_INLINE inline void* dispatch_allocate_full(size_t size) {$/;"	f	namespace:tcmalloc	signature:(size_t size)
do_allocate_full	src/tcmalloc.cc	/^static void* do_allocate_full(size_t size) {$/;"	f	namespace:tcmalloc	signature:(size_t size)
do_calloc	src/tcmalloc.cc	/^ATTRIBUTE_ALWAYS_INLINE inline void* do_calloc(size_t n, size_t elem_size) {$/;"	f	namespace:__anon3	signature:(size_t n, size_t elem_size)
do_debug_malloc_or_debug_cpp_alloc	src/debugallocation.cc	/^inline void* do_debug_malloc_or_debug_cpp_alloc(size_t size) {$/;"	f	signature:(size_t size)
do_debug_memalign	src/debugallocation.cc	/^static void *do_debug_memalign(size_t alignment, size_t size, int type) {$/;"	f	file:	signature:(size_t alignment, size_t size, int type)
do_debug_memalign_or_debug_cpp_memalign	src/debugallocation.cc	/^inline void* do_debug_memalign_or_debug_cpp_memalign(size_t align,$/;"	f	signature:(size_t align, size_t size, int type, bool from_operator, bool nothrow)
do_free	src/tcmalloc.cc	/^ATTRIBUTE_ALWAYS_INLINE inline void do_free(void* ptr) {$/;"	f	namespace:__anon3	signature:(void* ptr)
do_free_pages	src/tcmalloc.cc	/^static ATTRIBUTE_NOINLINE void do_free_pages(Span* span, void* ptr) {$/;"	f	namespace:__anon3	signature:(Span* span, void* ptr)
do_free_with_callback	src/tcmalloc.cc	/^void do_free_with_callback(void* ptr,$/;"	f	namespace:__anon3	signature:(void* ptr, void (*invalid_free_fn)(void*), bool use_hint, size_t size_hint)
do_main_heap_check	src/heap-checker.cc	/^static bool do_main_heap_check = false;$/;"	v	file:
do_mallinfo	src/tcmalloc.cc	/^inline struct mallinfo do_mallinfo() {$/;"	f	namespace:__anon3	signature:()
do_malloc	src/tcmalloc.cc	/^ATTRIBUTE_ALWAYS_INLINE inline void* do_malloc(size_t size) {$/;"	f	namespace:__anon3	signature:(size_t size)
do_malloc_or_cpp_alloc	src/tcmalloc.cc	/^ATTRIBUTE_ALWAYS_INLINE inline void* do_malloc_or_cpp_alloc(size_t size) {$/;"	f	namespace:__anon3	signature:(size_t size)
do_malloc_pages	src/tcmalloc.cc	/^static void* do_malloc_pages(ThreadCache* heap, size_t size) {$/;"	f	namespace:__anon3	signature:(ThreadCache* heap, size_t size)
do_malloc_stats	src/tcmalloc.cc	/^inline void do_malloc_stats() {$/;"	f	namespace:__anon3	signature:()
do_mallopt	src/tcmalloc.cc	/^inline int do_mallopt(int cmd, int value) {$/;"	f	namespace:__anon3	signature:(int cmd, int value)
do_memalign_pages	src/tcmalloc.cc	/^void* do_memalign_pages(size_t align, size_t size) {$/;"	f	namespace:__anon3	signature:(size_t align, size_t size)
do_realloc	src/tcmalloc.cc	/^ATTRIBUTE_ALWAYS_INLINE inline void* do_realloc(void* old_ptr, size_t new_size) {$/;"	f	namespace:__anon3	signature:(void* old_ptr, size_t new_size)
do_realloc_with_callback	src/tcmalloc.cc	/^ATTRIBUTE_ALWAYS_INLINE inline void* do_realloc_with_callback($/;"	f	namespace:__anon3	signature:( void* old_ptr, size_t new_size, void (*invalid_free_fn)(void*), size_t (*invalid_get_size_fn)(const void*))
do_sbrk	src/malloc_hook_mmap_freebsd.h	/^static inline void* do_sbrk(intptr_t increment) {$/;"	f	signature:(intptr_t increment)
doit_exec	install-sh	/^  doit_exec=exec$/;"	v
dormant	README	/^The cpu profiler, heap checker, and heap profiler will lie dormant,$/;"	v
ds	src/base/elfcore.h	/^    uint64_t  ds,es,fs,gs;$/;"	m	struct:i386_regs	access:public
dtors	ChangeLog.old	/^	* Replace atexit() calls with global dtors; helps freebsd (csilvers)$/;"	v
dummy_ap	src/heap-checker.cc	/^static va_list dummy_ap;$/;"	v	file:
dummy_for_alignment	src/base/low_level_alloc.cc	/^      void *dummy_for_alignment;   \/\/ aligns regions to 0 mod 2*sizeof(void*)$/;"	m	struct:low_level_alloc_internal::AllocList::Header	file:	access:public
dump_count	src/heap-profiler.cc	/^static int   dump_count = 0;          \/\/ How many dumps so far$/;"	v	file:
dumping	src/heap-profiler.cc	/^static bool  dumping = false;         \/\/ Dumping status to prevent recursion$/;"	v	file:
dynamic_buffer_	src/base/sysinfo.h	/^  Buffer* dynamic_buffer_;  \/\/ dynamically-allocated Buffer$/;"	m	class:ProcMapsIterator	access:private
dynamic_linker	m4/libtool.m4	/^  dynamic_linker="$host_os dyld"$/;"	v
dynamic_linker	m4/libtool.m4	/^  dynamic_linker='Win32 ld.exe'$/;"	v
dynamic_linker	m4/libtool.m4	/^  dynamic_linker=no$/;"	v
dynstr_	src/base/elf_mem_image.h	/^  const char *dynstr_;$/;"	m	class:base::ElfMemImage	access:private
dynsym_	src/base/elf_mem_image.h	/^  const ElfW(Sym) *dynsym_;$/;"	m	class:base::ElfMemImage	access:private
dz	src/.libs/libtcmalloc_internal_la-internal_logging.o	/^/;"	v
e	src/tests/profiler1_unittest-profiler_unittest.o	/^/;"	v
e	src/tests/profiler2_unittest-profiler_unittest.o	/^/;"	v
eO	src/tests/markidle_unittest-testutil.o	/^/;"	v
eO	src/tests/memalign_debug_unittest-testutil.o	/^/;"	v
eO	src/tests/memalign_unittest-testutil.o	/^/;"	v
eO	src/tests/tcmalloc_and_profiler_unittest-testutil.o	/^/;"	v
eO	src/tests/tcmalloc_both_unittest-testutil.o	/^/;"	v
eO	src/tests/tcmalloc_debug_unittest-testutil.o	/^/;"	v
eO	src/tests/tcmalloc_minimal_debug_unittest-testutil.o	/^/;"	v
eO	src/tests/tcmalloc_minimal_unittest-testutil.o	/^/;"	v
eO	src/tests/tcmalloc_unittest-testutil.o	/^/;"	v
eO	src/tests/thread_dealloc_unittest-testutil.o	/^/;"	v
eat	compile	/^    eat=$/;"	v
ebuf_	src/base/sysinfo.h	/^  char *ebuf_;        \/\/ end of buffer (1 char for a nul)$/;"	m	class:ProcMapsIterator	access:private
echo	Makefile	/^	  if test -f "$$d$$p"; then echo "$$d$$p"; echo "$$p"; else :; fi; \\$/;"	v
echo	Makefile	/^	  then echo "$$p"; echo "$$p"; else :; fi; \\$/;"	v
echo	Makefile.in	/^	  if test -f "$$d$$p"; then echo "$$d$$p"; echo "$$p"; else :; fi; \\$/;"	v
echo	Makefile.in	/^	  then echo "$$p"; echo "$$p"; else :; fi; \\$/;"	v
eflags	src/base/elfcore.h	/^    uint64_t  rip,cs,eflags;$/;"	m	struct:i386_regs	access:public
ehdr	src/base/elf_mem_image.cc	/^const T* GetTableElement(const ElfW(Ehdr) *ehdr,$/;"	m	namespace:base::__anon50	file:
ehdr_	src/base/elf_mem_image.h	/^  const ElfW(Ehdr) *ehdr_;$/;"	m	class:base::ElfMemImage	access:private
element_size	src/base/elf_mem_image.cc	/^                         ElfW(Word) element_size,$/;"	m	namespace:base::__anon50	file:
elink_command_output	binary_trees_shared	/^      if relink_command_output=`eval $relink_command 2>&1`; then :$/;"	v
elink_command_output	current_allocated_bytes_test	/^      if relink_command_output=`eval $relink_command 2>&1`; then :$/;"	v
elink_command_output	debugallocation_test	/^      if relink_command_output=`eval $relink_command 2>&1`; then :$/;"	v
elink_command_output	frag_unittest	/^      if relink_command_output=`eval $relink_command 2>&1`; then :$/;"	v
elink_command_output	heap-checker_debug_unittest	/^      if relink_command_output=`eval $relink_command 2>&1`; then :$/;"	v
elink_command_output	heap-checker_unittest	/^      if relink_command_output=`eval $relink_command 2>&1`; then :$/;"	v
elink_command_output	heap-profiler_debug_unittest	/^      if relink_command_output=`eval $relink_command 2>&1`; then :$/;"	v
elink_command_output	heap-profiler_unittest	/^      if relink_command_output=`eval $relink_command 2>&1`; then :$/;"	v
elink_command_output	malloc_bench_shared	/^      if relink_command_output=`eval $relink_command 2>&1`; then :$/;"	v
elink_command_output	malloc_bench_shared_full	/^      if relink_command_output=`eval $relink_command 2>&1`; then :$/;"	v
elink_command_output	malloc_extension_c_test	/^      if relink_command_output=`eval $relink_command 2>&1`; then :$/;"	v
elink_command_output	malloc_extension_debug_test	/^      if relink_command_output=`eval $relink_command 2>&1`; then :$/;"	v
elink_command_output	malloc_extension_test	/^      if relink_command_output=`eval $relink_command 2>&1`; then :$/;"	v
elink_command_output	malloc_hook_test	/^      if relink_command_output=`eval $relink_command 2>&1`; then :$/;"	v
elink_command_output	markidle_unittest	/^      if relink_command_output=`eval $relink_command 2>&1`; then :$/;"	v
elink_command_output	memalign_debug_unittest	/^      if relink_command_output=`eval $relink_command 2>&1`; then :$/;"	v
elink_command_output	memalign_unittest	/^      if relink_command_output=`eval $relink_command 2>&1`; then :$/;"	v
elink_command_output	packed_cache_test	/^      if relink_command_output=`eval $relink_command 2>&1`; then :$/;"	v
elink_command_output	page_heap_test	/^      if relink_command_output=`eval $relink_command 2>&1`; then :$/;"	v
elink_command_output	pagemap_unittest	/^      if relink_command_output=`eval $relink_command 2>&1`; then :$/;"	v
elink_command_output	profile_handler_unittest	/^      if relink_command_output=`eval $relink_command 2>&1`; then :$/;"	v
elink_command_output	profiledata_unittest	/^      if relink_command_output=`eval $relink_command 2>&1`; then :$/;"	v
elink_command_output	profiler1_unittest	/^      if relink_command_output=`eval $relink_command 2>&1`; then :$/;"	v
elink_command_output	profiler2_unittest	/^      if relink_command_output=`eval $relink_command 2>&1`; then :$/;"	v
elink_command_output	profiler3_unittest	/^      if relink_command_output=`eval $relink_command 2>&1`; then :$/;"	v
elink_command_output	profiler4_unittest	/^      if relink_command_output=`eval $relink_command 2>&1`; then :$/;"	v
elink_command_output	raw_printer_test	/^      if relink_command_output=`eval $relink_command 2>&1`; then :$/;"	v
elink_command_output	realloc_debug_unittest	/^      if relink_command_output=`eval $relink_command 2>&1`; then :$/;"	v
elink_command_output	realloc_unittest	/^      if relink_command_output=`eval $relink_command 2>&1`; then :$/;"	v
elink_command_output	sampler_debug_test	/^      if relink_command_output=`eval $relink_command 2>&1`; then :$/;"	v
elink_command_output	sampler_test	/^      if relink_command_output=`eval $relink_command 2>&1`; then :$/;"	v
elink_command_output	sampling_debug_test	/^      if relink_command_output=`eval $relink_command 2>&1`; then :$/;"	v
elink_command_output	sampling_test	/^      if relink_command_output=`eval $relink_command 2>&1`; then :$/;"	v
elink_command_output	simple_compat_test	/^      if relink_command_output=`eval $relink_command 2>&1`; then :$/;"	v
elink_command_output	stack_trace_table_test	/^      if relink_command_output=`eval $relink_command 2>&1`; then :$/;"	v
elink_command_output	system_alloc_unittest	/^      if relink_command_output=`eval $relink_command 2>&1`; then :$/;"	v
elink_command_output	tcmalloc_and_profiler_unittest	/^      if relink_command_output=`eval $relink_command 2>&1`; then :$/;"	v
elink_command_output	tcmalloc_both_unittest	/^      if relink_command_output=`eval $relink_command 2>&1`; then :$/;"	v
elink_command_output	tcmalloc_debug_unittest	/^      if relink_command_output=`eval $relink_command 2>&1`; then :$/;"	v
elink_command_output	tcmalloc_large_heap_fragmentation_unittest	/^      if relink_command_output=`eval $relink_command 2>&1`; then :$/;"	v
elink_command_output	tcmalloc_large_unittest	/^      if relink_command_output=`eval $relink_command 2>&1`; then :$/;"	v
elink_command_output	tcmalloc_minimal_debug_unittest	/^      if relink_command_output=`eval $relink_command 2>&1`; then :$/;"	v
elink_command_output	tcmalloc_minimal_large_heap_fragmentation_unittest	/^      if relink_command_output=`eval $relink_command 2>&1`; then :$/;"	v
elink_command_output	tcmalloc_minimal_large_unittest	/^      if relink_command_output=`eval $relink_command 2>&1`; then :$/;"	v
elink_command_output	tcmalloc_minimal_unittest	/^      if relink_command_output=`eval $relink_command 2>&1`; then :$/;"	v
elink_command_output	tcmalloc_unittest	/^      if relink_command_output=`eval $relink_command 2>&1`; then :$/;"	v
elink_command_output	thread_dealloc_unittest	/^      if relink_command_output=`eval $relink_command 2>&1`; then :$/;"	v
elink_command_output	unwind_bench	/^      if relink_command_output=`eval $relink_command 2>&1`; then :$/;"	v
emergency_arena	src/emergency_malloc.cc	/^  static LowLevelAlloc::Arena *emergency_arena;$/;"	m	namespace:tcmalloc	file:
emergency_arena_end	src/emergency_malloc.cc	/^  static char *emergency_arena_end;$/;"	m	namespace:tcmalloc	file:
emergency_arena_start	src/emergency_malloc.cc	/^  __attribute__ ((visibility("internal"))) char *emergency_arena_start;$/;"	m	namespace:tcmalloc	file:
emergency_arena_start_shifted	src/emergency_malloc.cc	/^  __attribute__ ((visibility("internal"))) uintptr_t emergency_arena_start_shifted;$/;"	m	namespace:tcmalloc	file:
emergency_malloc_lock	src/emergency_malloc.cc	/^  static CACHELINE_ALIGNED SpinLock emergency_malloc_lock(base::LINKER_INITIALIZED);$/;"	p	namespace:tcmalloc	file:	signature:(base::LINKER_INITIALIZED)
empty	src/malloc_hook-inl.h	/^  bool empty() const {$/;"	f	struct:base::internal::HookList	access:public	signature:() const
empty	src/thread_cache.h	/^    bool empty() const {$/;"	f	class:tcmalloc::ThreadCache::FreeList	access:public	signature:() const
empty_	src/central_freelist.h	/^  Span     empty_;          \/\/ Dummy header for list of empty spans$/;"	m	class:tcmalloc::CentralFreeList	access:private
enable_cpu_profiler	configure.ac	/^  enable_cpu_profiler=no$/;"	v
enable_dlopen	m4/libtool.m4	/^    enable_dlopen=yes$/;"	v
enable_fast_install	m4/ltoptions.m4	/^	  enable_fast_install=yes$/;"	v
enable_shared	m4/ltoptions.m4	/^	  enable_shared=yes$/;"	v
enable_static	m4/ltoptions.m4	/^	  enable_static=yes$/;"	v
enabled	src/gperftools/profiler.h	/^  int    enabled;             \/* Is profiling currently enabled? *\/$/;"	m	struct:ProfilerState	access:public
enabled	src/profiledata.h	/^    bool     enabled;             \/\/ Is profiling currently enabled?$/;"	m	struct:ProfileData::State	access:public
enabled	src/profiledata.h	/^  bool enabled() const { return out_ >= 0; }$/;"	f	class:ProfileData	access:public	signature:() const
end	src/base/elf_mem_image.cc	/^ElfMemImage::SymbolIterator ElfMemImage::end() const {$/;"	f	class:base::ElfMemImage	signature:() const
end	src/base/elf_mem_image.h	/^  SymbolIterator end() const;$/;"	p	class:base::ElfMemImage	access:public	signature:() const
end	src/base/vdso_support.h	/^  SymbolIterator end() const { return image_.end(); }$/;"	f	class:base::VDSOSupport	access:public	signature:() const
end	src/tests/stacktrace_unittest.cc	/^  const void *start, *end;$/;"	m	struct:__anon52::AddressRange	file:	access:public
end_	src/internal_logging.cc	/^  char* end_;$/;"	m	class:tcmalloc::Logger	file:	access:public
end_addr	src/memory_region_map.h	/^    uintptr_t end_addr;  \/\/ region end address$/;"	m	struct:MemoryRegionMap::Region	access:public
entry	src/profiledata.h	/^    Entry entry[kAssociativity];$/;"	m	struct:ProfileData::Bucket	access:public
environ	stacktrace_unittest	/^/;"	v
eo	src/.libs/libtcmalloc_internal_la-internal_logging.o	/^/;"	v
err	src/base/linuxthreads.cc	/^  int         result, err;$/;"	m	struct:ListerParams	file:	access:public
errno_	src/base/elfcore.h	/^    int              errno_;$/;"	m	struct:Frame	access:public
errno_	src/base/elfcore.h	/^    int             errno_;$/;"	m	struct:Frame	access:public
error_	src/stack_trace_table.h	/^  bool error_;$/;"	m	class:tcmalloc::StackTraceTable	access:private
es	src/base/elfcore.h	/^    uint64_t  ds,es,fs,gs;$/;"	m	struct:i386_regs	access:public
est	binary_trees_shared	/^    if test "$libtool_execute_magic" != "%%%MAGIC variable%%%"; then$/;"	v
est	binary_trees_shared	/^    if test "$thisdir" = "."; then$/;"	v
est	config.status	/^if test "x$as_myself" = x; then$/;"	v
est	configure	/^if test "X$1" = X--fallback-echo; then$/;"	v
est	configure	/^if test "x$CONFIG_SHELL" = x; then$/;"	v
est	configure	/^if test "x$as_myself" = x; then$/;"	v
est	current_allocated_bytes_test	/^    if test "$libtool_execute_magic" != "%%%MAGIC variable%%%"; then$/;"	v
est	current_allocated_bytes_test	/^    if test "$thisdir" = "."; then$/;"	v
est	debugallocation_test	/^    if test "$libtool_execute_magic" != "%%%MAGIC variable%%%"; then$/;"	v
est	debugallocation_test	/^    if test "$thisdir" = "."; then$/;"	v
est	depcomp	/^  if test "$libtool" = yes; then$/;"	v
est	frag_unittest	/^    if test "$libtool_execute_magic" != "%%%MAGIC variable%%%"; then$/;"	v
est	frag_unittest	/^    if test "$thisdir" = "."; then$/;"	v
est	heap-checker_debug_unittest	/^    if test "$libtool_execute_magic" != "%%%MAGIC variable%%%"; then$/;"	v
est	heap-checker_debug_unittest	/^    if test "$thisdir" = "."; then$/;"	v
est	heap-checker_unittest	/^    if test "$libtool_execute_magic" != "%%%MAGIC variable%%%"; then$/;"	v
est	heap-checker_unittest	/^    if test "$thisdir" = "."; then$/;"	v
est	heap-profiler_debug_unittest	/^    if test "$libtool_execute_magic" != "%%%MAGIC variable%%%"; then$/;"	v
est	heap-profiler_debug_unittest	/^    if test "$thisdir" = "."; then$/;"	v
est	heap-profiler_unittest	/^    if test "$libtool_execute_magic" != "%%%MAGIC variable%%%"; then$/;"	v
est	heap-profiler_unittest	/^    if test "$thisdir" = "."; then$/;"	v
est	m4/libtool.m4	/^	if test "$host_cpu" = ia64; then$/;"	v
est	m4/libtool.m4	/^      if test "$GCC" = yes; then$/;"	v
est	m4/libtool.m4	/^      if test "x$host_vendor" = xsequent; then$/;"	v
est	m4/libtool.m4	/^    if test "$lt_cv_apple_cc_single_mod" = "yes"; then$/;"	v
est	m4/libtool.m4	/^    if test "$lt_cv_prog_gnu_ld" = yes; then$/;"	v
est	m4/libtool.m4	/^  if test "$_lt_dar_can_shared" = "yes"; then$/;"	v
est	m4/libtool.m4	/^  if test "$host_cpu" = ia64; then$/;"	v
est	malloc_bench_shared	/^    if test "$libtool_execute_magic" != "%%%MAGIC variable%%%"; then$/;"	v
est	malloc_bench_shared	/^    if test "$thisdir" = "."; then$/;"	v
est	malloc_bench_shared_full	/^    if test "$libtool_execute_magic" != "%%%MAGIC variable%%%"; then$/;"	v
est	malloc_bench_shared_full	/^    if test "$thisdir" = "."; then$/;"	v
est	malloc_extension_c_test	/^    if test "$libtool_execute_magic" != "%%%MAGIC variable%%%"; then$/;"	v
est	malloc_extension_c_test	/^    if test "$thisdir" = "."; then$/;"	v
est	malloc_extension_debug_test	/^    if test "$libtool_execute_magic" != "%%%MAGIC variable%%%"; then$/;"	v
est	malloc_extension_debug_test	/^    if test "$thisdir" = "."; then$/;"	v
est	malloc_extension_test	/^    if test "$libtool_execute_magic" != "%%%MAGIC variable%%%"; then$/;"	v
est	malloc_extension_test	/^    if test "$thisdir" = "."; then$/;"	v
est	malloc_hook_test	/^    if test "$libtool_execute_magic" != "%%%MAGIC variable%%%"; then$/;"	v
est	malloc_hook_test	/^    if test "$thisdir" = "."; then$/;"	v
est	markidle_unittest	/^    if test "$libtool_execute_magic" != "%%%MAGIC variable%%%"; then$/;"	v
est	markidle_unittest	/^    if test "$thisdir" = "."; then$/;"	v
est	memalign_debug_unittest	/^    if test "$libtool_execute_magic" != "%%%MAGIC variable%%%"; then$/;"	v
est	memalign_debug_unittest	/^    if test "$thisdir" = "."; then$/;"	v
est	memalign_unittest	/^    if test "$libtool_execute_magic" != "%%%MAGIC variable%%%"; then$/;"	v
est	memalign_unittest	/^    if test "$thisdir" = "."; then$/;"	v
est	packed_cache_test	/^    if test "$libtool_execute_magic" != "%%%MAGIC variable%%%"; then$/;"	v
est	packed_cache_test	/^    if test "$thisdir" = "."; then$/;"	v
est	page_heap_test	/^    if test "$libtool_execute_magic" != "%%%MAGIC variable%%%"; then$/;"	v
est	page_heap_test	/^    if test "$thisdir" = "."; then$/;"	v
est	pagemap_unittest	/^    if test "$libtool_execute_magic" != "%%%MAGIC variable%%%"; then$/;"	v
est	pagemap_unittest	/^    if test "$thisdir" = "."; then$/;"	v
est	profile_handler_unittest	/^    if test "$libtool_execute_magic" != "%%%MAGIC variable%%%"; then$/;"	v
est	profile_handler_unittest	/^    if test "$thisdir" = "."; then$/;"	v
est	profiledata_unittest	/^    if test "$libtool_execute_magic" != "%%%MAGIC variable%%%"; then$/;"	v
est	profiledata_unittest	/^    if test "$thisdir" = "."; then$/;"	v
est	profiler1_unittest	/^    if test "$libtool_execute_magic" != "%%%MAGIC variable%%%"; then$/;"	v
est	profiler1_unittest	/^    if test "$thisdir" = "."; then$/;"	v
est	profiler2_unittest	/^    if test "$libtool_execute_magic" != "%%%MAGIC variable%%%"; then$/;"	v
est	profiler2_unittest	/^    if test "$thisdir" = "."; then$/;"	v
est	profiler3_unittest	/^    if test "$libtool_execute_magic" != "%%%MAGIC variable%%%"; then$/;"	v
est	profiler3_unittest	/^    if test "$thisdir" = "."; then$/;"	v
est	profiler4_unittest	/^    if test "$libtool_execute_magic" != "%%%MAGIC variable%%%"; then$/;"	v
est	profiler4_unittest	/^    if test "$thisdir" = "."; then$/;"	v
est	raw_printer_test	/^    if test "$libtool_execute_magic" != "%%%MAGIC variable%%%"; then$/;"	v
est	raw_printer_test	/^    if test "$thisdir" = "."; then$/;"	v
est	realloc_debug_unittest	/^    if test "$libtool_execute_magic" != "%%%MAGIC variable%%%"; then$/;"	v
est	realloc_debug_unittest	/^    if test "$thisdir" = "."; then$/;"	v
est	realloc_unittest	/^    if test "$libtool_execute_magic" != "%%%MAGIC variable%%%"; then$/;"	v
est	realloc_unittest	/^    if test "$thisdir" = "."; then$/;"	v
est	sampler_debug_test	/^    if test "$libtool_execute_magic" != "%%%MAGIC variable%%%"; then$/;"	v
est	sampler_debug_test	/^    if test "$thisdir" = "."; then$/;"	v
est	sampler_test	/^    if test "$libtool_execute_magic" != "%%%MAGIC variable%%%"; then$/;"	v
est	sampler_test	/^    if test "$thisdir" = "."; then$/;"	v
est	sampling_debug_test	/^    if test "$libtool_execute_magic" != "%%%MAGIC variable%%%"; then$/;"	v
est	sampling_debug_test	/^    if test "$thisdir" = "."; then$/;"	v
est	sampling_test	/^    if test "$libtool_execute_magic" != "%%%MAGIC variable%%%"; then$/;"	v
est	sampling_test	/^    if test "$thisdir" = "."; then$/;"	v
est	simple_compat_test	/^    if test "$libtool_execute_magic" != "%%%MAGIC variable%%%"; then$/;"	v
est	simple_compat_test	/^    if test "$thisdir" = "."; then$/;"	v
est	stack_trace_table_test	/^    if test "$libtool_execute_magic" != "%%%MAGIC variable%%%"; then$/;"	v
est	stack_trace_table_test	/^    if test "$thisdir" = "."; then$/;"	v
est	system_alloc_unittest	/^    if test "$libtool_execute_magic" != "%%%MAGIC variable%%%"; then$/;"	v
est	system_alloc_unittest	/^    if test "$thisdir" = "."; then$/;"	v
est	tags	/^est	configure	\/^if test "X$1" = X--fallback-echo; then$\/;"	v$/;"	v
est	tags	/^est	configure	\/^if test "x$CONFIG_SHELL" = x; then$\/;"	v$/;"	v
est	tcmalloc_and_profiler_unittest	/^    if test "$libtool_execute_magic" != "%%%MAGIC variable%%%"; then$/;"	v
est	tcmalloc_and_profiler_unittest	/^    if test "$thisdir" = "."; then$/;"	v
est	tcmalloc_both_unittest	/^    if test "$libtool_execute_magic" != "%%%MAGIC variable%%%"; then$/;"	v
est	tcmalloc_both_unittest	/^    if test "$thisdir" = "."; then$/;"	v
est	tcmalloc_debug_unittest	/^    if test "$libtool_execute_magic" != "%%%MAGIC variable%%%"; then$/;"	v
est	tcmalloc_debug_unittest	/^    if test "$thisdir" = "."; then$/;"	v
est	tcmalloc_large_heap_fragmentation_unittest	/^    if test "$libtool_execute_magic" != "%%%MAGIC variable%%%"; then$/;"	v
est	tcmalloc_large_heap_fragmentation_unittest	/^    if test "$thisdir" = "."; then$/;"	v
est	tcmalloc_large_unittest	/^    if test "$libtool_execute_magic" != "%%%MAGIC variable%%%"; then$/;"	v
est	tcmalloc_large_unittest	/^    if test "$thisdir" = "."; then$/;"	v
est	tcmalloc_minimal_debug_unittest	/^    if test "$libtool_execute_magic" != "%%%MAGIC variable%%%"; then$/;"	v
est	tcmalloc_minimal_debug_unittest	/^    if test "$thisdir" = "."; then$/;"	v
est	tcmalloc_minimal_large_heap_fragmentation_unittest	/^    if test "$libtool_execute_magic" != "%%%MAGIC variable%%%"; then$/;"	v
est	tcmalloc_minimal_large_heap_fragmentation_unittest	/^    if test "$thisdir" = "."; then$/;"	v
est	tcmalloc_minimal_large_unittest	/^    if test "$libtool_execute_magic" != "%%%MAGIC variable%%%"; then$/;"	v
est	tcmalloc_minimal_large_unittest	/^    if test "$thisdir" = "."; then$/;"	v
est	tcmalloc_minimal_unittest	/^    if test "$libtool_execute_magic" != "%%%MAGIC variable%%%"; then$/;"	v
est	tcmalloc_minimal_unittest	/^    if test "$thisdir" = "."; then$/;"	v
est	tcmalloc_unittest	/^    if test "$libtool_execute_magic" != "%%%MAGIC variable%%%"; then$/;"	v
est	tcmalloc_unittest	/^    if test "$thisdir" = "."; then$/;"	v
est	thread_dealloc_unittest	/^    if test "$libtool_execute_magic" != "%%%MAGIC variable%%%"; then$/;"	v
est	thread_dealloc_unittest	/^    if test "$thisdir" = "."; then$/;"	v
est	unwind_bench	/^    if test "$libtool_execute_magic" != "%%%MAGIC variable%%%"; then$/;"	v
est	unwind_bench	/^    if test "$thisdir" = "."; then$/;"	v
etext_	src/base/sysinfo.h	/^  char *etext_;       \/\/ end of text$/;"	m	class:ProcMapsIterator	access:private
evict_	src/profiledata.h	/^  Slot*         evict_;         \/\/ evicted entries$/;"	m	class:ProfileData	access:private
evictions_	src/profiledata.h	/^  int           evictions_;     \/\/ How many evictions$/;"	m	class:ProfileData	access:private
exists	INSTALL	/^`configure' looks for `PREFIX\/share\/config.site' if it exists, then$/;"	v
exit	README	/^      fork, and the child calls exit(), it may corrupt the profile$/;"	p	file:	signature:()
exit	compile	/^     exit 1;$/;"	v
exit	config.guess	/^	exit ;;$/;"	v
exit	config.guess	/^        exit ;;$/;"	v
exit	config.sub	/^		exit 1$/;"	v
exit	config.sub	/^       exit ;;$/;"	v
exit	config.sub	/^    exit 1;;$/;"	v
exit	depcomp	/^     exit 1;$/;"	v
exit	depcomp	/^  exit 1$/;"	v
exit	missing	/^    exit 1$/;"	v
expected_range	src/tests/stacktrace_unittest.cc	/^AddressRange expected_range[BACKTRACE_STEPS];$/;"	m	namespace:__anon52	file:
expected_type	src/tests/tcmalloc_unittest.cc	/^  base::MallocRange::Type expected_type;$/;"	m	struct:testing::__anon59::RangeCallbackState	file:	access:public
expr	config.status	/^	expr "X$arg" : "X\\\\(.*\\\\)$as_nl";$/;"	v
expr	configure	/^	expr "X$arg" : "X\\\\(.*\\\\)$as_nl";$/;"	v
expr	tags	/^expr	configure	\/^	expr "X$arg" : "X\\\\\\\\(.*\\\\\\\\)$as_nl";$\/;"	v$/;"	v
extra	src/static_vars.h	/^    uintptr_t extra;  \/\/ To force alignment$/;"	m	union:tcmalloc::Static::PageHeapStorage	access:public
extra_bytes_released_	src/tcmalloc.cc	/^  size_t extra_bytes_released_;$/;"	m	class:TCMallocImplementation	file:	access:private
f	src/tests/heap-checker_unittest.cc	/^  virtual void f() { }$/;"	f	class:ClassB	access:public	signature:()
f	src/tests/heap-checker_unittest.cc	/^  virtual void f() { }$/;"	f	class:ClassD	file:	access:private	signature:()
f	src/tests/heap-checker_unittest.cc	/^  virtual void f() { }$/;"	f	class:ClassD1	file:	access:private	signature:()
f	src/tests/heap-checker_unittest.cc	/^  virtual void f() { }$/;"	f	class:ClassMltD1	access:public	signature:()
f	src/tests/heap-checker_unittest.cc	/^  virtual void f() { }$/;"	f	class:ClassMltD2	access:public	signature:()
f1	benchmark/unwind_bench.cc	/^static int ATTRIBUTE_NOINLINE f1(int level, int maxlevel, int mode) {$/;"	f	file:	signature:(int level, int maxlevel, int mode)
f2	src/tests/heap-checker_unittest.cc	/^  virtual void f2() { }$/;"	f	class:ClassB2	access:public	signature:()
f2	src/tests/heap-checker_unittest.cc	/^  virtual void f2() { }$/;"	f	class:ClassD	file:	access:private	signature:()
f2	src/tests/heap-checker_unittest.cc	/^  virtual void f2() { }$/;"	f	class:ClassD2	file:	access:private	signature:()
fH	src/.libs/libtcmalloc_internal_la-thread_cache.o	/^/;"	v
fH	src/.libs/libtcmalloc_minimal_internal_la-thread_cache.o	/^/;"	v
f_	src/tests/heap-checker_unittest.cc	/^  FunctionSignature f_;$/;"	m	class:Callback0	file:	access:private
f_	src/tests/heap-checker_unittest.cc	/^  FunctionSignature f_;$/;"	m	class:Callback1	file:	access:private
f_	src/tests/heap-checker_unittest.cc	/^  FunctionSignature f_;$/;"	m	class:Callback2	file:	access:private
failed_	src/memfs_malloc.cc	/^  bool failed_;          \/\/ Whether failed to allocate memory.$/;"	m	class:HugetlbSysAllocator	file:	access:public
failed_	src/system-alloc.cc	/^  bool failed_[kMaxAllocators];$/;"	m	class:DefaultSysAllocator	file:	access:private
fallback_	src/memfs_malloc.cc	/^  SysAllocator* fallback_;  \/\/ Default system allocator to fall back to.$/;"	m	class:HugetlbSysAllocator	file:	access:private
fast_path_heap	src/thread_cache.h	/^    ThreadCache* fast_path_heap;$/;"	m	struct:tcmalloc::ThreadCache::ThreadLocalData	access:public
fd	src/heap-profile-table.h	/^    RawFD fd;  \/\/ file to write to$/;"	m	struct:HeapProfileTable::DumpArgs	access:public
fd_	src/base/sysinfo.h	/^  int fd_;            \/\/ filehandle on \/proc\/*\/maps$/;"	m	class:ProcMapsIterator	access:private
fd_	src/base/sysinfo.h	/^  int fd_;$/;"	m	class:ProcMapsIterator	access:private
fd_	src/tests/profiledata_unittest.cc	/^  const int fd_;$/;"	m	struct:__anon53::FileDescriptor	file:	access:public
fi	m4/libtool.m4	/^    fi$/;"	v
fi	m4/libtool.m4	/^  fi$/;"	v
fi	missing	/^    fi$/;"	v
field	README_windows.txt	/^   "Input".  Then, in the "Force Symbol References" field, enter the$/;"	v
file	binary_trees_shared	/^    file="$$-$program"$/;"	v
file	binary_trees_shared	/^    file=`$ECHO "X$file" | $Xsed -e 's%^.*\/%%'`$/;"	v
file	current_allocated_bytes_test	/^    file="$$-$program"$/;"	v
file	current_allocated_bytes_test	/^    file=`$ECHO "X$file" | $Xsed -e 's%^.*\/%%'`$/;"	v
file	debugallocation_test	/^    file="$$-$program"$/;"	v
file	debugallocation_test	/^    file=`$ECHO "X$file" | $Xsed -e 's%^.*\/%%'`$/;"	v
file	docs/heap_checker.html	/^referred to in this file, are declared in$/;"	v
file	frag_unittest	/^    file="$$-$program"$/;"	v
file	frag_unittest	/^    file=`$ECHO "X$file" | $Xsed -e 's%^.*\/%%'`$/;"	v
file	heap-checker_debug_unittest	/^    file="$$-$program"$/;"	v
file	heap-checker_debug_unittest	/^    file=`$ECHO "X$file" | $Xsed -e 's%^.*\/%%'`$/;"	v
file	heap-checker_unittest	/^    file="$$-$program"$/;"	v
file	heap-checker_unittest	/^    file=`$ECHO "X$file" | $Xsed -e 's%^.*\/%%'`$/;"	v
file	heap-profiler_debug_unittest	/^    file="$$-$program"$/;"	v
file	heap-profiler_debug_unittest	/^    file=`$ECHO "X$file" | $Xsed -e 's%^.*\/%%'`$/;"	v
file	heap-profiler_unittest	/^    file="$$-$program"$/;"	v
file	heap-profiler_unittest	/^    file=`$ECHO "X$file" | $Xsed -e 's%^.*\/%%'`$/;"	v
file	malloc_bench_shared	/^    file="$$-$program"$/;"	v
file	malloc_bench_shared	/^    file=`$ECHO "X$file" | $Xsed -e 's%^.*\/%%'`$/;"	v
file	malloc_bench_shared_full	/^    file="$$-$program"$/;"	v
file	malloc_bench_shared_full	/^    file=`$ECHO "X$file" | $Xsed -e 's%^.*\/%%'`$/;"	v
file	malloc_extension_c_test	/^    file="$$-$program"$/;"	v
file	malloc_extension_c_test	/^    file=`$ECHO "X$file" | $Xsed -e 's%^.*\/%%'`$/;"	v
file	malloc_extension_debug_test	/^    file="$$-$program"$/;"	v
file	malloc_extension_debug_test	/^    file=`$ECHO "X$file" | $Xsed -e 's%^.*\/%%'`$/;"	v
file	malloc_extension_test	/^    file="$$-$program"$/;"	v
file	malloc_extension_test	/^    file=`$ECHO "X$file" | $Xsed -e 's%^.*\/%%'`$/;"	v
file	malloc_hook_test	/^    file="$$-$program"$/;"	v
file	malloc_hook_test	/^    file=`$ECHO "X$file" | $Xsed -e 's%^.*\/%%'`$/;"	v
file	markidle_unittest	/^    file="$$-$program"$/;"	v
file	markidle_unittest	/^    file=`$ECHO "X$file" | $Xsed -e 's%^.*\/%%'`$/;"	v
file	memalign_debug_unittest	/^    file="$$-$program"$/;"	v
file	memalign_debug_unittest	/^    file=`$ECHO "X$file" | $Xsed -e 's%^.*\/%%'`$/;"	v
file	memalign_unittest	/^    file="$$-$program"$/;"	v
file	memalign_unittest	/^    file=`$ECHO "X$file" | $Xsed -e 's%^.*\/%%'`$/;"	v
file	missing	/^    file=`echo "$*" | sed -n "$sed_output"`$/;"	v
file	packed_cache_test	/^    file="$$-$program"$/;"	v
file	packed_cache_test	/^    file=`$ECHO "X$file" | $Xsed -e 's%^.*\/%%'`$/;"	v
file	page_heap_test	/^    file="$$-$program"$/;"	v
file	page_heap_test	/^    file=`$ECHO "X$file" | $Xsed -e 's%^.*\/%%'`$/;"	v
file	pagemap_unittest	/^    file="$$-$program"$/;"	v
file	pagemap_unittest	/^    file=`$ECHO "X$file" | $Xsed -e 's%^.*\/%%'`$/;"	v
file	profile_handler_unittest	/^    file="$$-$program"$/;"	v
file	profile_handler_unittest	/^    file=`$ECHO "X$file" | $Xsed -e 's%^.*\/%%'`$/;"	v
file	profiledata_unittest	/^    file="$$-$program"$/;"	v
file	profiledata_unittest	/^    file=`$ECHO "X$file" | $Xsed -e 's%^.*\/%%'`$/;"	v
file	profiler1_unittest	/^    file="$$-$program"$/;"	v
file	profiler1_unittest	/^    file=`$ECHO "X$file" | $Xsed -e 's%^.*\/%%'`$/;"	v
file	profiler2_unittest	/^    file="$$-$program"$/;"	v
file	profiler2_unittest	/^    file=`$ECHO "X$file" | $Xsed -e 's%^.*\/%%'`$/;"	v
file	profiler3_unittest	/^    file="$$-$program"$/;"	v
file	profiler3_unittest	/^    file=`$ECHO "X$file" | $Xsed -e 's%^.*\/%%'`$/;"	v
file	profiler4_unittest	/^    file="$$-$program"$/;"	v
file	profiler4_unittest	/^    file=`$ECHO "X$file" | $Xsed -e 's%^.*\/%%'`$/;"	v
file	raw_printer_test	/^    file="$$-$program"$/;"	v
file	raw_printer_test	/^    file=`$ECHO "X$file" | $Xsed -e 's%^.*\/%%'`$/;"	v
file	realloc_debug_unittest	/^    file="$$-$program"$/;"	v
file	realloc_debug_unittest	/^    file=`$ECHO "X$file" | $Xsed -e 's%^.*\/%%'`$/;"	v
file	realloc_unittest	/^    file="$$-$program"$/;"	v
file	realloc_unittest	/^    file=`$ECHO "X$file" | $Xsed -e 's%^.*\/%%'`$/;"	v
file	sampler_debug_test	/^    file="$$-$program"$/;"	v
file	sampler_debug_test	/^    file=`$ECHO "X$file" | $Xsed -e 's%^.*\/%%'`$/;"	v
file	sampler_test	/^    file="$$-$program"$/;"	v
file	sampler_test	/^    file=`$ECHO "X$file" | $Xsed -e 's%^.*\/%%'`$/;"	v
file	sampling_debug_test	/^    file="$$-$program"$/;"	v
file	sampling_debug_test	/^    file=`$ECHO "X$file" | $Xsed -e 's%^.*\/%%'`$/;"	v
file	sampling_test	/^    file="$$-$program"$/;"	v
file	sampling_test	/^    file=`$ECHO "X$file" | $Xsed -e 's%^.*\/%%'`$/;"	v
file	simple_compat_test	/^    file="$$-$program"$/;"	v
file	simple_compat_test	/^    file=`$ECHO "X$file" | $Xsed -e 's%^.*\/%%'`$/;"	v
file	stack_trace_table_test	/^    file="$$-$program"$/;"	v
file	stack_trace_table_test	/^    file=`$ECHO "X$file" | $Xsed -e 's%^.*\/%%'`$/;"	v
file	system_alloc_unittest	/^    file="$$-$program"$/;"	v
file	system_alloc_unittest	/^    file=`$ECHO "X$file" | $Xsed -e 's%^.*\/%%'`$/;"	v
file	tcmalloc_and_profiler_unittest	/^    file="$$-$program"$/;"	v
file	tcmalloc_and_profiler_unittest	/^    file=`$ECHO "X$file" | $Xsed -e 's%^.*\/%%'`$/;"	v
file	tcmalloc_both_unittest	/^    file="$$-$program"$/;"	v
file	tcmalloc_both_unittest	/^    file=`$ECHO "X$file" | $Xsed -e 's%^.*\/%%'`$/;"	v
file	tcmalloc_debug_unittest	/^    file="$$-$program"$/;"	v
file	tcmalloc_debug_unittest	/^    file=`$ECHO "X$file" | $Xsed -e 's%^.*\/%%'`$/;"	v
file	tcmalloc_large_heap_fragmentation_unittest	/^    file="$$-$program"$/;"	v
file	tcmalloc_large_heap_fragmentation_unittest	/^    file=`$ECHO "X$file" | $Xsed -e 's%^.*\/%%'`$/;"	v
file	tcmalloc_large_unittest	/^    file="$$-$program"$/;"	v
file	tcmalloc_large_unittest	/^    file=`$ECHO "X$file" | $Xsed -e 's%^.*\/%%'`$/;"	v
file	tcmalloc_minimal_debug_unittest	/^    file="$$-$program"$/;"	v
file	tcmalloc_minimal_debug_unittest	/^    file=`$ECHO "X$file" | $Xsed -e 's%^.*\/%%'`$/;"	v
file	tcmalloc_minimal_large_heap_fragmentation_unittest	/^    file="$$-$program"$/;"	v
file	tcmalloc_minimal_large_heap_fragmentation_unittest	/^    file=`$ECHO "X$file" | $Xsed -e 's%^.*\/%%'`$/;"	v
file	tcmalloc_minimal_large_unittest	/^    file="$$-$program"$/;"	v
file	tcmalloc_minimal_large_unittest	/^    file=`$ECHO "X$file" | $Xsed -e 's%^.*\/%%'`$/;"	v
file	tcmalloc_minimal_unittest	/^    file="$$-$program"$/;"	v
file	tcmalloc_minimal_unittest	/^    file=`$ECHO "X$file" | $Xsed -e 's%^.*\/%%'`$/;"	v
file	tcmalloc_unittest	/^    file="$$-$program"$/;"	v
file	tcmalloc_unittest	/^    file=`$ECHO "X$file" | $Xsed -e 's%^.*\/%%'`$/;"	v
file	thread_dealloc_unittest	/^    file="$$-$program"$/;"	v
file	thread_dealloc_unittest	/^    file=`$ECHO "X$file" | $Xsed -e 's%^.*\/%%'`$/;"	v
file	unwind_bench	/^    file="$$-$program"$/;"	v
file	unwind_bench	/^    file=`$ECHO "X$file" | $Xsed -e 's%^.*\/%%'`$/;"	v
file_magic_cmd	m4/libtool.m4	/^file_magic_cmd=$lt_cv_file_magic_cmd$/;"	v
filename	src/tests/profiledata_unittest.cc	/^  string filename() const { return filename_; }$/;"	f	class:__anon53::ProfileDataChecker	access:public	signature:() const
filename_	src/tests/profiledata_unittest.cc	/^  string filename_;$/;"	m	class:__anon53::ProfileDataChecker	file:	access:private
filename_prefix	src/heap-profiler.cc	/^static char* filename_prefix = NULL;  \/\/ Prefix used for profile file names$/;"	v	file:
files	missing	/^    files=`sed -n 's\/^[ ]*A[CM]_CONFIG_HEADER(\\([^)]*\\)).*\/\\1\/p' ${configure_ac}`$/;"	v
fill	src/tests/low_level_alloc_unittest.cc	/^  int fill;       \/\/ filled with data starting with this$/;"	m	struct:BlockDesc	file:	access:public
filter_	src/profiler.cc	/^  int           (*filter_)(void*);$/;"	m	class:CpuProfiler	file:	access:private
filter_arg_	src/profiler.cc	/^  void*         filter_arg_;$/;"	m	class:CpuProfiler	file:	access:private
filter_in_thread	src/gperftools/profiler.h	/^  int (*filter_in_thread)(void *arg);$/;"	m	struct:ProfilerOptions	access:public
filter_in_thread_arg	src/gperftools/profiler.h	/^  void *filter_in_thread_arg;$/;"	m	struct:ProfilerOptions	access:public
fine	README	/^2) On x86-64 64-bit systems, while tcmalloc itself works fine, the$/;"	v
firstarg	missing	/^	    firstarg=`echo "$firstarg" | sed s\/h\/\/`$/;"	v
firstarg	missing	/^	    firstarg=`echo "$firstarg" | sed s\/o\/\/`$/;"	v
firstarg	missing	/^    firstarg="$1"$/;"	v
flag_aux_	src/windows/mini_disassembler_types.h	/^  int flag_aux_;$/;"	m	struct:sidestep::SpecificOpcode	access:public
flag_aux_	src/windows/mini_disassembler_types.h	/^  unsigned flag_aux_;$/;"	m	struct:sidestep::Opcode	access:public
flag_dest_	src/windows/mini_disassembler_types.h	/^  int flag_dest_;$/;"	m	struct:sidestep::SpecificOpcode	access:public
flag_dest_	src/windows/mini_disassembler_types.h	/^  unsigned flag_dest_;$/;"	m	struct:sidestep::Opcode	access:public
flag_source_	src/windows/mini_disassembler_types.h	/^  int flag_source_;$/;"	m	struct:sidestep::SpecificOpcode	access:public
flag_source_	src/windows/mini_disassembler_types.h	/^  unsigned flag_source_;$/;"	m	struct:sidestep::Opcode	access:public
flags	m4/libtool.m4	/^	    continue # so that we can try to find one that supports BSD flags$/;"	v
flags	src/base/low_level_alloc.cc	/^  int32 flags;            \/\/ flags passed to NewArena (ro after init)$/;"	m	struct:LowLevelAlloc::Arena	file:	access:public
flags	src/windows/nm-pdb.c	/^  ULONG flags;$/;"	m	struct:__anon10	file:	access:public
flags_	src/base/sysinfo.h	/^  char flags_[10];$/;"	m	class:ProcMapsIterator	access:private
fname_	src/profiledata.h	/^  char*         fname_;         \/\/ Profile file name$/;"	m	class:ProfileData	access:private
fnord	depcomp	/^    *)  set fnord "$@" "$arg" ;;$/;"	v
foo	docs/heap_checker.html	/^  int* foo = new int [20];$/;"	v
force_frame	src/debugallocation.cc	/^static void force_frame() {$/;"	f	file:	signature:()
forced_malloc	src/tests/malloc_extension_c_test.c	/^void *forced_malloc(size_t size)$/;"	f	file:	signature:(size_t size)
fork	README	/^      fork, and the child calls exit(), it may corrupt the profile$/;"	v
format	tags	/^!_TAG_FILE_FORMAT	2	\/extended format; --format=1 will not append ;" to lines\/$/;"	v
forms	src/windows/shortproc.asm	/^; Redistribution and use in source and binary forms, with or without$/;"	v
fpr	src/base/elfcore.h	/^    double        fpr[32];	\/* Floating-Point Registers - f0-f31.        *\/$/;"	m	struct:ppc_regs	access:public
fraction	src/gperftools/malloc_extension.h	/^  double fraction;      \/\/ Fraction of range that is being used (0 if !INUSE)$/;"	m	struct:base::MallocRange	access:public
frame	src/stacktrace_instrument-inl.h	/^  void* frame[MAX_DEPTH];$/;"	m	struct:__anon30	access:public
frame_forcer	benchmark/unwind_bench.cc	/^static int ATTRIBUTE_NOINLINE frame_forcer(int rv) {$/;"	f	file:	signature:(int rv)
frame_forcer	src/debugallocation.cc	/^static int frame_forcer;$/;"	v	file:
frame_forcer	src/stacktrace.cc	/^static int ATTRIBUTE_NOINLINE frame_forcer(int rv) {$/;"	f	file:	signature:(int rv)
frames	benchmark/unwind_bench.cc	/^static void *frames[MAX_FRAMES];$/;"	v	file:
free	src/libc_override_redefine.h	/^  void  free(void* p)                            { tc_free(p);                }$/;"	f	signature:(void* p)
free	src/windows/override_functions.cc	92;"	d	file:
free_	src/addressmap-inl.h	/^  Entry*        free_;                   \/\/ Free list of unused Entry objects$/;"	m	class:AddressMap	access:private
free_	src/page_heap.h	/^  SpanList free_[kMaxPages];$/;"	m	class:tcmalloc::PageHeap	access:private
free_	src/windows/preamble_patcher.h	/^    void* free_;$/;"	m	struct:sidestep::PreamblePatcher::PreamblePage	access:public
free_area_	src/page_heap_allocator.h	/^  char* free_area_;$/;"	m	class:tcmalloc::PageHeapAllocator	access:private
free_avail_	src/page_heap_allocator.h	/^  size_t free_avail_;$/;"	m	class:tcmalloc::PageHeapAllocator	access:private
free_bytes	src/page_heap.h	/^    uint64_t free_bytes;      \/\/ Total bytes on normal freelists$/;"	m	struct:tcmalloc::PageHeap::Stats	access:public
free_fast_path	src/tcmalloc.cc	/^void free_fast_path(void *ptr) {$/;"	f	file:	signature:(void *ptr)
free_list_	src/page_heap_allocator.h	/^  void* free_list_;$/;"	m	class:tcmalloc::PageHeapAllocator	access:private
free_null_or_invalid	src/tcmalloc.cc	/^inline void free_null_or_invalid(void* ptr, void (*invalid_free_fn)(void*)) {$/;"	f	namespace:__anon3	signature:(void* ptr, void (*invalid_free_fn)(void*))
free_queue_	src/debugallocation.cc	/^  static FreeQueue<MallocBlockQueueEntry>* free_queue_;$/;"	m	class:MallocBlock	file:	access:private
free_queue_	src/debugallocation.cc	/^FreeQueue<MallocBlockQueueEntry>* MallocBlock::free_queue_ = NULL;$/;"	m	class:MallocBlock	file:
free_queue_lock_	src/debugallocation.cc	/^  static SpinLock free_queue_lock_;$/;"	m	class:MallocBlock	file:	access:private
free_queue_lock_	src/debugallocation.cc	/^SpinLock MallocBlock::free_queue_lock_(SpinLock::LINKER_INITIALIZED);$/;"	p	class:MallocBlock	file:	signature:(SpinLock::LINKER_INITIALIZED)
free_queue_size_	src/debugallocation.cc	/^  static size_t free_queue_size_;  \/\/ total size of blocks in free_queue_$/;"	m	class:MallocBlock	file:	access:private
free_queue_size_	src/debugallocation.cc	/^size_t MallocBlock::free_queue_size_ = 0;$/;"	m	class:MallocBlock	file:
free_size	src/heap-profile-stats.h	/^  int64 free_size;   \/\/ Total size of all freed objects so far.$/;"	m	struct:HeapProfileStats	access:public
freelist	src/base/low_level_alloc.cc	/^  AllocList freelist;     \/\/ head of free list; sorted by addr (under mu)$/;"	m	struct:LowLevelAlloc::Arena	file:	access:public
freelist_length	src/thread_cache.h	/^  int freelist_length(uint32 cl) const { return list_[cl].length(); }$/;"	f	class:tcmalloc::ThreadCache	access:public	signature:(uint32 cl) const
frees	src/heap-profile-stats.h	/^  int32 frees;       \/\/ Number of free calls.$/;"	m	struct:HeapProfileStats	access:public
frees	src/tests/low_level_alloc_unittest.cc	/^static int32 frees;$/;"	v	file:
frequency	src/profile-handler.h	/^  int32 frequency;  \/* Profiling frequency *\/$/;"	m	struct:ProfileHandlerState	access:public
frequency	src/profiledata.h	/^    int frequency() const {$/;"	f	class:ProfileData::Options	access:public	signature:() const
frequency_	src/profile-handler.cc	/^  int32 frequency_;$/;"	m	class:ProfileHandler	file:	access:private
frequency_	src/profiledata.h	/^    int      frequency_;                  \/\/ Sample frequency.$/;"	m	class:ProfileData::Options	access:private
from	src/windows/shortproc.asm	/^; contributors may be used to endorse or promote products derived from$/;"	v
fs	src/base/elfcore.h	/^    uint64_t  ds,es,fs,gs;$/;"	m	struct:i386_regs	access:public
fs_base	src/base/elfcore.h	/^    uint64_t  fs_base, gs_base;$/;"	m	struct:i386_regs	access:public
func_dirname	m4/libtool.m4	/^func_dirname ()$/;"	f	signature:()
function_info_	src/windows/patch_functions.cc	/^  static FunctionInfo function_info_[kNumFunctions];$/;"	m	class:__anon13::WindowsInfo	file:	access:private
function_info_	src/windows/patch_functions.cc	/^\/*static*\/ WindowsInfo::FunctionInfo WindowsInfo::function_info_[] = {$/;"	m	class:__anon13::WindowsInfo	file:
function_name	src/windows/patch_functions.cc	/^  static const char* const function_name(int ifunction) {$/;"	f	class:__anon13::LibcInfo	access:public	signature:(int ifunction)
function_name_	src/windows/patch_functions.cc	/^  static const char* const function_name_[kNumFunctions];$/;"	m	class:__anon13::LibcInfo	file:	access:protected
function_name_	src/windows/patch_functions.cc	/^const char* const LibcInfo::function_name_[] = {$/;"	m	class:__anon13::LibcInfo	file:
futex_private_flag	src/base/spinlock_linux-inl.h	/^static int futex_private_flag = FUTEX_PRIVATE_FLAG;$/;"	v
g	src/.libs/libtcmalloc_minimal_internal_la-internal_logging.o	/^/;"	v
g	src/base/thread_lister.o	/^/;"	v
g_array	src/tests/heap-profiler_unittest.cc	/^int* g_array[kMaxCount];              \/\/ an array of int-vectors$/;"	v
g_delete_hook_calls	src/tests/malloc_extension_c_test.c	/^static int g_delete_hook_calls = 0;$/;"	v	file:
g_have_exited_main	src/tests/heap-checker_unittest.cc	/^static bool g_have_exited_main = false;$/;"	v	file:
g_iters	src/tests/profiler_unittest.cc	/^static int g_iters = 0;   \/\/ argv[1]$/;"	v	file:
g_last_loaded	src/windows/patch_functions.cc	/^static std::set<HMODULE> *g_last_loaded;$/;"	m	namespace:__anon13	file:
g_module_libcs	src/windows/patch_functions.cc	/^static LibcInfo* g_module_libcs[] = {$/;"	m	namespace:__anon13	file:
g_new_hook_calls	src/tests/malloc_extension_c_test.c	/^static int g_new_hook_calls = 0;$/;"	v	file:
g_no_memory	src/tests/tcmalloc_unittest.cc	/^volatile bool g_no_memory = false;$/;"	m	namespace:testing	file:
g_old_handler	src/tests/tcmalloc_unittest.cc	/^std::new_handler g_old_handler = NULL;$/;"	m	namespace:testing	file:
g_pprof_path	src/symbolize.cc	/^static string* g_pprof_path = new string(FLAGS_symbolize_pprof);$/;"	v	file:
gccflag	depcomp	/^    gccflag=-MD,$/;"	v
gccflag	depcomp	/^  gccflag=-M$/;"	v
generated_by_libtool_version	binary_trees_shared	/^  generated_by_libtool_version='2.2.6b'$/;"	v
generated_by_libtool_version	current_allocated_bytes_test	/^  generated_by_libtool_version='2.2.6b'$/;"	v
generated_by_libtool_version	debugallocation_test	/^  generated_by_libtool_version='2.2.6b'$/;"	v
generated_by_libtool_version	frag_unittest	/^  generated_by_libtool_version='2.2.6b'$/;"	v
generated_by_libtool_version	heap-checker_debug_unittest	/^  generated_by_libtool_version='2.2.6b'$/;"	v
generated_by_libtool_version	heap-checker_unittest	/^  generated_by_libtool_version='2.2.6b'$/;"	v
generated_by_libtool_version	heap-profiler_debug_unittest	/^  generated_by_libtool_version='2.2.6b'$/;"	v
generated_by_libtool_version	heap-profiler_unittest	/^  generated_by_libtool_version='2.2.6b'$/;"	v
generated_by_libtool_version	malloc_bench_shared	/^  generated_by_libtool_version='2.2.6b'$/;"	v
generated_by_libtool_version	malloc_bench_shared_full	/^  generated_by_libtool_version='2.2.6b'$/;"	v
generated_by_libtool_version	malloc_extension_c_test	/^  generated_by_libtool_version='2.2.6b'$/;"	v
generated_by_libtool_version	malloc_extension_debug_test	/^  generated_by_libtool_version='2.2.6b'$/;"	v
generated_by_libtool_version	malloc_extension_test	/^  generated_by_libtool_version='2.2.6b'$/;"	v
generated_by_libtool_version	malloc_hook_test	/^  generated_by_libtool_version='2.2.6b'$/;"	v
generated_by_libtool_version	markidle_unittest	/^  generated_by_libtool_version='2.2.6b'$/;"	v
generated_by_libtool_version	memalign_debug_unittest	/^  generated_by_libtool_version='2.2.6b'$/;"	v
generated_by_libtool_version	memalign_unittest	/^  generated_by_libtool_version='2.2.6b'$/;"	v
generated_by_libtool_version	packed_cache_test	/^  generated_by_libtool_version='2.2.6b'$/;"	v
generated_by_libtool_version	page_heap_test	/^  generated_by_libtool_version='2.2.6b'$/;"	v
generated_by_libtool_version	pagemap_unittest	/^  generated_by_libtool_version='2.2.6b'$/;"	v
generated_by_libtool_version	profile_handler_unittest	/^  generated_by_libtool_version='2.2.6b'$/;"	v
generated_by_libtool_version	profiledata_unittest	/^  generated_by_libtool_version='2.2.6b'$/;"	v
generated_by_libtool_version	profiler1_unittest	/^  generated_by_libtool_version='2.2.6b'$/;"	v
generated_by_libtool_version	profiler2_unittest	/^  generated_by_libtool_version='2.2.6b'$/;"	v
generated_by_libtool_version	profiler3_unittest	/^  generated_by_libtool_version='2.2.6b'$/;"	v
generated_by_libtool_version	profiler4_unittest	/^  generated_by_libtool_version='2.2.6b'$/;"	v
generated_by_libtool_version	raw_printer_test	/^  generated_by_libtool_version='2.2.6b'$/;"	v
generated_by_libtool_version	realloc_debug_unittest	/^  generated_by_libtool_version='2.2.6b'$/;"	v
generated_by_libtool_version	realloc_unittest	/^  generated_by_libtool_version='2.2.6b'$/;"	v
generated_by_libtool_version	sampler_debug_test	/^  generated_by_libtool_version='2.2.6b'$/;"	v
generated_by_libtool_version	sampler_test	/^  generated_by_libtool_version='2.2.6b'$/;"	v
generated_by_libtool_version	sampling_debug_test	/^  generated_by_libtool_version='2.2.6b'$/;"	v
generated_by_libtool_version	sampling_test	/^  generated_by_libtool_version='2.2.6b'$/;"	v
generated_by_libtool_version	simple_compat_test	/^  generated_by_libtool_version='2.2.6b'$/;"	v
generated_by_libtool_version	stack_trace_table_test	/^  generated_by_libtool_version='2.2.6b'$/;"	v
generated_by_libtool_version	system_alloc_unittest	/^  generated_by_libtool_version='2.2.6b'$/;"	v
generated_by_libtool_version	tcmalloc_and_profiler_unittest	/^  generated_by_libtool_version='2.2.6b'$/;"	v
generated_by_libtool_version	tcmalloc_both_unittest	/^  generated_by_libtool_version='2.2.6b'$/;"	v
generated_by_libtool_version	tcmalloc_debug_unittest	/^  generated_by_libtool_version='2.2.6b'$/;"	v
generated_by_libtool_version	tcmalloc_large_heap_fragmentation_unittest	/^  generated_by_libtool_version='2.2.6b'$/;"	v
generated_by_libtool_version	tcmalloc_large_unittest	/^  generated_by_libtool_version='2.2.6b'$/;"	v
generated_by_libtool_version	tcmalloc_minimal_debug_unittest	/^  generated_by_libtool_version='2.2.6b'$/;"	v
generated_by_libtool_version	tcmalloc_minimal_large_heap_fragmentation_unittest	/^  generated_by_libtool_version='2.2.6b'$/;"	v
generated_by_libtool_version	tcmalloc_minimal_large_unittest	/^  generated_by_libtool_version='2.2.6b'$/;"	v
generated_by_libtool_version	tcmalloc_minimal_unittest	/^  generated_by_libtool_version='2.2.6b'$/;"	v
generated_by_libtool_version	tcmalloc_unittest	/^  generated_by_libtool_version='2.2.6b'$/;"	v
generated_by_libtool_version	thread_dealloc_unittest	/^  generated_by_libtool_version='2.2.6b'$/;"	v
generated_by_libtool_version	unwind_bench	/^  generated_by_libtool_version='2.2.6b'$/;"	v
generation	src/tests/tcmalloc_unittest.cc	/^    int         generation;             \/\/ Generation counter of object contents$/;"	m	struct:testing::TesterThread::Object	file:	access:public
get	src/gperftools/heap-checker.h	/^  T* get() const { return reinterpret_cast<T*>(masked_t_ ^ kHideMask); }$/;"	f	class:HiddenPointer	access:public	signature:() const
get	src/pagemap.h	/^  void* get(Number k) const {$/;"	f	class:TCMalloc_PageMap1	access:public	signature:(Number k) const
get	src/pagemap.h	/^  void* get(Number k) const {$/;"	f	class:TCMalloc_PageMap2	access:public	signature:(Number k) const
get	src/pagemap.h	/^  void* get(Number k) const {$/;"	f	class:TCMalloc_PageMap3	access:public	signature:(Number k) const
get	src/tests/profiledata_unittest.cc	/^  T* get() { return data_; }$/;"	f	class:__anon53::scoped_array	access:public	signature:()
get	src/tests/profiledata_unittest.cc	/^  int get() { return fd_; }$/;"	f	struct:__anon53::FileDescriptor	access:public	signature:()
get	src/tests/sampler_test.cc	/^  T* get() { return p_; }$/;"	f	class:__anon54::scoped_array	access:public	signature:()
get	src/tests/sampler_test.cc	/^  const T* get() const { return p_; }$/;"	f	class:__anon54::scoped_array	access:public	signature:() const
get_default_zone	src/libc_override_osx.h	/^static malloc_zone_t *get_default_zone() {$/;"	f	signature:()
get_stack_impl	src/stacktrace.cc	/^static GetStackImplementation *get_stack_impl = &impl__arm;$/;"	v	file:
get_stack_impl	src/stacktrace.cc	/^static GetStackImplementation *get_stack_impl = &impl__generic;$/;"	v	file:
get_stack_impl	src/stacktrace.cc	/^static GetStackImplementation *get_stack_impl = &impl__instrument;$/;"	v	file:
get_stack_impl	src/stacktrace.cc	/^static GetStackImplementation *get_stack_impl = &impl__libgcc;$/;"	v	file:
get_stack_impl	src/stacktrace.cc	/^static GetStackImplementation *get_stack_impl = &impl__libunwind;$/;"	v	file:
get_stack_impl	src/stacktrace.cc	/^static GetStackImplementation *get_stack_impl = &impl__ppc;$/;"	v	file:
get_stack_impl	src/stacktrace.cc	/^static GetStackImplementation *get_stack_impl = &impl__win32;$/;"	v	file:
get_stack_impl	src/stacktrace.cc	/^static GetStackImplementation *get_stack_impl = &impl__x86;$/;"	v	file:
get_stack_impl_inited	src/stacktrace.cc	/^static bool get_stack_impl_inited;$/;"	v	file:
get_test_sys_alloc	src/tests/tcmalloc_unittest.cc	/^static OOMAbleSysAlloc* get_test_sys_alloc() {$/;"	f	file:	signature:()
get_thread_disable_counter	src/heap-checker.cc	/^inline int get_thread_disable_counter() {$/;"	f	signature:()
getcontext_light	benchmark/getcontext_light.cc	/^extern "C" void getcontext_light(ucontext_t *ctx) {$/;"	f	signature:(ucontext_t *ctx)
getcontext_light	benchmark/getcontext_light.cc	/^extern "C" void getcontext_light(ucontext_t *ctx);$/;"	p	file:	signature:(ucontext_t *ctx)
getcontext_light	benchmark/unwind_bench.cc	/^extern "C" void getcontext_light(ucontext_t *ctx);$/;"	p	file:	signature:(ucontext_t *ctx)
getcontext_tramp	benchmark/getcontext_light.cc	/^void getcontext_tramp(ucontext_t *ctx) {$/;"	f	file:	signature:(ucontext_t *ctx)
getcwd	src/windows/port.h	/^inline char *getcwd(char *buf, size_t size) {$/;"	f	signature:(char *buf, size_t size)
getpagesize	src/windows/port.cc	/^int getpagesize() {$/;"	f	signature:()
getpagesize	src/windows/port.h	/^EXTERN_C PERFTOOLS_DLL_DECL int getpagesize();   \/* in port.cc *\/$/;"	p	signature:()
getpc_retval	src/tests/getpc_test.cc	/^static volatile void* getpc_retval = NULL;    \/\/ what GetPC returns$/;"	v	file:
getpid	src/windows/port.h	/^inline pid_t getpid(void) { return _getpid(); }$/;"	f	signature:(void)
getppid	src/windows/port.h	/^inline pid_t getppid(void) { return 0; }$/;"	f	signature:(void)
gettid	src/base/linux_syscall_support.h	/^  LSS_INLINE pid_t LSS_NAME(gettid)() {$/;"	f	signature:()
gettid	src/stacktrace_instrument-inl.h	56;"	d
global_nallocx	src/tests/tcmalloc_unittest.cc	/^} global_nallocx;$/;"	m	namespace:testing	typeref:struct:testing::GlobalNallocx	file:
global_profiler_buffer	src/heap-profiler.cc	/^static char* global_profiler_buffer = NULL;$/;"	v	file:
global_region_caller_ranges	src/heap-checker.cc	/^static GlobalRegionCallerRangeMap* global_region_caller_ranges = NULL;$/;"	v	file:
google_malloc	src/malloc_hook.cc	/^DECLARE_ATTRIBUTE_SECTION_VARS(google_malloc);$/;"	v
google_malloc	src/malloc_hook.cc	/^DEFINE_ATTRIBUTE_SECTION_VARS(google_malloc);$/;"	v
google_malloc	src/tcmalloc.cc	/^      ATTRIBUTE_SECTION(google_malloc);$/;"	v
got_66_prefix_	src/windows/mini_disassembler.h	/^  bool got_f2_prefix_, got_f3_prefix_, got_66_prefix_;$/;"	m	class:sidestep::MiniDisassembler	access:private
got_f2_prefix_	src/windows/mini_disassembler.h	/^  bool got_f2_prefix_, got_f3_prefix_, got_66_prefix_;$/;"	m	class:sidestep::MiniDisassembler	access:private
got_f3_prefix_	src/windows/mini_disassembler.h	/^  bool got_f2_prefix_, got_f3_prefix_, got_66_prefix_;$/;"	m	class:sidestep::MiniDisassembler	access:private
granularity_	src/windows/preamble_patcher.cc	/^long PreamblePatcher::granularity_ = 0;$/;"	m	class:sidestep::PreamblePatcher	file:
granularity_	src/windows/preamble_patcher.h	/^  static long granularity_;$/;"	m	class:sidestep::PreamblePatcher	access:private
growth_stacks	src/static_vars.h	/^  static StackTrace* growth_stacks() { return growth_stacks_; }$/;"	f	class:tcmalloc::Static	access:public	signature:()
growth_stacks_	src/static_vars.cc	/^StackTrace* Static::growth_stacks_ = NULL;$/;"	m	class:tcmalloc::Static	file:
growth_stacks_	src/static_vars.h	/^  ATTRIBUTE_HIDDEN static StackTrace* growth_stacks_;$/;"	m	class:tcmalloc::Static	access:private
grp	src/tests/heap-checker_unittest.cc	/^static struct group* grp = NULL;$/;"	v	typeref:struct:group	file:
gs	src/base/elfcore.h	/^    uint64_t  ds,es,fs,gs;$/;"	m	struct:i386_regs	access:public
gs_base	src/base/elfcore.h	/^    uint64_t  fs_base, gs_base;$/;"	m	struct:i386_regs	access:public
gt	docs/cpuprofile-fileformat.html	/^    <td>number of call chain PCs (num_pcs), must be &gt;= 1<\/td>$/;"	v
gt	docs/cpuprofile-fileformat.html	/^    <td>sample count, must be &gt;= 1<\/td>$/;"	v
gt	docs/heap_checker.html	/^<code>&lt;prefix&gt;.&lt;name&gt;-beg.heap<\/code> to a temporary$/;"	v
gt	docs/heap_checker.html	/^<code>&lt;prefix&gt;.&lt;name&gt;-end.heap<\/code>.$/;"	v
gt	docs/heapprofile.html	/^           &lt;prefix&gt;.0000.heap$/;"	v
gt	docs/heapprofile.html	/^           &lt;prefix&gt;.0001.heap$/;"	v
gt	docs/heapprofile.html	/^           &lt;prefix&gt;.0002.heap$/;"	v
gt	docs/heapprofile.html	/^<p>where <code>&lt;prefix&gt;<\/code> is the filename-prefix supplied$/;"	v
gt	docs/pprof_remote_servers.html	/^&lt;hex address&gt;&lt;tab&gt;&lt;function name&gt;$/;"	v
gt	docs/pprof_remote_servers.html	/^-n &lt;program name&gt;<\/code> to get the mappings at$/;"	v
gt	docs/tcmalloc.html	/^of pages of length &gt; <code>k<\/code>, the remainder of the$/;"	m	class:object	file:	access:private
h	benchmark/unwind_bench-getcontext_light.o	/^/;"	v
handle_oom	src/tcmalloc.cc	/^void* handle_oom(malloc_fn retry_fn,$/;"	f	namespace:__anon3	signature:(malloc_fn retry_fn, void* retry_arg, bool from_operator, bool nothrow)
has_called_before_constructors	src/heap-checker.cc	/^static bool has_called_before_constructors = false;$/;"	v	file:
has_checked_	src/gperftools/heap-checker.h	/^  bool has_checked_;  \/\/ if we have done the leak check, so these are ready:$/;"	m	class:HeapLeakChecker	access:private
has_cmpxchg16b	src/base/atomicops-internals-x86.h	/^  bool has_cmpxchg16b;      \/\/ Processor supports cmpxchg16b instruction.$/;"	m	struct:AtomicOps_x86CPUFeatureStruct	access:public
has_sse2	src/base/atomicops-internals-x86.h	/^  bool has_sse2;            \/\/ Processor has SSE2.$/;"	m	struct:AtomicOps_x86CPUFeatureStruct	access:public
hash	src/heap-profile-stats.h	/^  uintptr_t hash;           \/\/ Hash value of the stack trace.$/;"	m	struct:HeapProfileBucket	access:public
hash	src/stack_trace_table.h	/^    uintptr_t hash;$/;"	m	struct:tcmalloc::StackTraceTable::Bucket	access:public
hash_	src/base/elf_mem_image.h	/^  const ElfW(Word) *hash_;$/;"	m	class:base::ElfMemImage	access:private
hash_	src/profiledata.h	/^  Bucket*       hash_;          \/\/ hash table$/;"	m	class:ProfileData	access:private
hashtable_	src/addressmap-inl.h	/^  Cluster**     hashtable_;              \/\/ The hash-table$/;"	m	class:AddressMap	access:private
have_futex	src/base/spinlock_linux-inl.h	/^static bool have_futex;$/;"	v
have_modrm_	src/windows/mini_disassembler.h	/^  bool have_modrm_;$/;"	m	class:sidestep::MiniDisassembler	access:private
have_tls	src/thread_cache.h	/^  enum { have_tls = true };$/;"	e	enum:tcmalloc::ThreadCache::__anon31
hc_strstr	src/heap-checker.cc	/^static const char* hc_strstr(const char* s1, const char* s2) {$/;"	f	file:	signature:(const char* s1, const char* s2)
head	src/central_freelist.h	/^    void *head;  \/\/ Head of chain of objects.$/;"	m	struct:tcmalloc::CentralFreeList::TCEntry	access:public
header	src/base/low_level_alloc.cc	/^    } header;$/;"	m	struct:low_level_alloc_internal::AllocList	typeref:struct:low_level_alloc_internal::AllocList::Header	file:	access:public
heap	src/thread_cache.h	/^    ThreadCache* heap;$/;"	m	struct:tcmalloc::ThreadCache::ThreadLocalData	access:public
heap_	src/tests/tcmalloc_unittest.cc	/^  vector<Object>        heap_;          \/\/ This thread's heap$/;"	m	class:testing::TesterThread	file:	access:private
heap_check	src/tests/heap-checker_unittest.cc	/^DECLARE_string(heap_check);  \/\/ in heap-checker.cc$/;"	v
heap_check_max_pointer_offset	src/tests/heap-checker_unittest.cc	/^DECLARE_int64(heap_check_max_pointer_offset);   \/\/ heap-checker.cc$/;"	v
heap_checker_h	src/tests/simple_compat_test.cc	/^HeapLeakChecker::Disabler* heap_checker_h;$/;"	v
heap_checker_info_level	src/heap-checker.cc	/^static const int heap_checker_info_level = 0;$/;"	v	file:
heap_checker_lock	src/heap-checker.cc	/^static SpinLock heap_checker_lock(SpinLock::LINKER_INITIALIZED);$/;"	p	file:	signature:(SpinLock::LINKER_INITIALIZED)
heap_checker_on	src/heap-checker.cc	/^static bool heap_checker_on = false;$/;"	v	file:
heap_checker_pid	src/heap-checker.cc	/^static pid_t heap_checker_pid = 0;$/;"	v	file:
heap_cleanups_	src/gperftools/heap-checker.h	/^  static std::vector<void_function>* heap_cleanups_;$/;"	m	class:HeapCleaner	access:private
heap_cleanups_	src/heap-checker.cc	/^vector<HeapCleaner::void_function>* HeapCleaner::heap_cleanups_ = NULL;$/;"	m	class:HeapCleaner	file:
heap_key_	src/thread_cache.cc	/^pthread_key_t ThreadCache::heap_key_;$/;"	m	class:tcmalloc::ThreadCache	file:
heap_key_	src/thread_cache.h	/^  static pthread_key_t heap_key_;$/;"	m	class:tcmalloc::ThreadCache	access:private
heap_leak_checker_bcad_variable	src/heap-checker-bcad.cc	/^bool heap_leak_checker_bcad_variable;$/;"	v
heap_leak_checker_global_pre_post	src/heap-checker-bcad.cc	/^static const HeapLeakCheckerGlobalPrePost heap_leak_checker_global_pre_post;$/;"	v	file:
heap_lock	src/heap-profiler.cc	/^static SpinLock heap_lock(SpinLock::LINKER_INITIALIZED);$/;"	p	file:	signature:(SpinLock::LINKER_INITIALIZED)
heap_profile	src/heap-checker.cc	/^static HeapProfileTable* heap_profile = NULL;$/;"	v	file:
heap_profile	src/heap-profiler.cc	/^static HeapProfileTable* heap_profile = NULL;  \/\/ the heap profile table$/;"	v	file:
heap_profile_end_writer	src/heap-profiler.cc	/^static HeapProfileEndWriter heap_profile_end_writer;$/;"	v	file:
heap_profiler_h	src/tests/simple_compat_test.cc	/^void (*heap_profiler_h)(const char*) = &HeapProfilerStart;$/;"	v
heap_profiler_memory	src/heap-profiler.cc	/^static LowLevelAlloc::Arena *heap_profiler_memory;$/;"	v	file:
heap_size_	src/tests/tcmalloc_unittest.cc	/^  size_t                heap_size_;     \/\/ Current heap size$/;"	m	class:testing::TesterThread	file:	access:private
held_	src/central_freelist.cc	/^  SpinLock *held_, *temp_;$/;"	m	class:tcmalloc::__anon19::LockInverter	file:	access:private
hi	src/base/elfcore.h	/^    unsigned long hi;           \/* Used for multiplication and division.     *\/$/;"	m	struct:mips_regs	access:public
high_water_mark	src/heap-profiler.cc	/^static int64 high_water_mark = 0;     \/\/ In-use-bytes at last high-water dump$/;"	v	file:
history	src/span.h	/^  char history[64];$/;"	m	struct:tcmalloc::Span	access:public
hmodule	src/windows/patch_functions.cc	/^  HMODULE hmodule() const {$/;"	f	class:__anon13::LibcInfo	access:public	signature:() const
hook_	src/windows/auto_testing_hook.h	/^  AutoTestingHookBase* hook_;$/;"	m	class:sidestep::AutoTestingHookHolder	access:private
hooklist_spinlock	src/malloc_hook.cc	/^static SpinLock hooklist_spinlock(base::LINKER_INITIALIZED);$/;"	p	namespace:base::internal	file:	signature:(base::LINKER_INITIALIZED)
hugetlb_base_	src/memfs_malloc.cc	/^  off_t hugetlb_base_;$/;"	m	class:HugetlbSysAllocator	file:	access:private
hugetlb_fd_	src/memfs_malloc.cc	/^  int hugetlb_fd_;       \/\/ file descriptor for hugetlb$/;"	m	class:HugetlbSysAllocator	file:	access:private
hugetlb_space	src/memfs_malloc.cc	/^} hugetlb_space;$/;"	v	typeref:union:__anon5	file:
i	benchmark/binary_trees.cc	/^  int i;$/;"	m	struct:Node	file:	access:public
i0	src/tests/heap-checker_unittest.cc	/^  Inner i0;$/;"	m	struct:Nesting	file:	access:public
i1	src/tests/heap-checker_unittest.cc	/^  Inner i1;$/;"	m	struct:Nesting	file:	access:public
i2	src/tests/heap-checker_unittest.cc	/^  Inner i2;$/;"	m	struct:Nesting	file:	access:public
i3	src/tests/heap-checker_unittest.cc	/^  Inner i3;$/;"	m	struct:Nesting	file:	access:public
i386_regs	src/base/elfcore.h	/^  typedef struct i386_regs {    \/* Normal (non-FPU) CPU registers            *\/$/;"	s
i386_regs	src/base/elfcore.h	/^  } i386_regs;$/;"	t	typeref:struct:i386_regs
i386_regs::cs	src/base/elfcore.h	/^    uint64_t  rip,cs,eflags;$/;"	m	struct:i386_regs	access:public
i386_regs::ds	src/base/elfcore.h	/^    uint64_t  ds,es,fs,gs;$/;"	m	struct:i386_regs	access:public
i386_regs::eflags	src/base/elfcore.h	/^    uint64_t  rip,cs,eflags;$/;"	m	struct:i386_regs	access:public
i386_regs::es	src/base/elfcore.h	/^    uint64_t  ds,es,fs,gs;$/;"	m	struct:i386_regs	access:public
i386_regs::fs	src/base/elfcore.h	/^    uint64_t  ds,es,fs,gs;$/;"	m	struct:i386_regs	access:public
i386_regs::fs_base	src/base/elfcore.h	/^    uint64_t  fs_base, gs_base;$/;"	m	struct:i386_regs	access:public
i386_regs::gs	src/base/elfcore.h	/^    uint64_t  ds,es,fs,gs;$/;"	m	struct:i386_regs	access:public
i386_regs::gs_base	src/base/elfcore.h	/^    uint64_t  fs_base, gs_base;$/;"	m	struct:i386_regs	access:public
i386_regs::orig_rax	src/base/elfcore.h	/^    uint64_t  r9,r8,rax,rcx,rdx,rsi,rdi,orig_rax;$/;"	m	struct:i386_regs	access:public
i386_regs::r10	src/base/elfcore.h	/^    uint64_t  r15,r14,r13,r12,rbp,rbx,r11,r10;$/;"	m	struct:i386_regs	access:public
i386_regs::r11	src/base/elfcore.h	/^    uint64_t  r15,r14,r13,r12,rbp,rbx,r11,r10;$/;"	m	struct:i386_regs	access:public
i386_regs::r12	src/base/elfcore.h	/^    uint64_t  r15,r14,r13,r12,rbp,rbx,r11,r10;$/;"	m	struct:i386_regs	access:public
i386_regs::r13	src/base/elfcore.h	/^    uint64_t  r15,r14,r13,r12,rbp,rbx,r11,r10;$/;"	m	struct:i386_regs	access:public
i386_regs::r14	src/base/elfcore.h	/^    uint64_t  r15,r14,r13,r12,rbp,rbx,r11,r10;$/;"	m	struct:i386_regs	access:public
i386_regs::r15	src/base/elfcore.h	/^    uint64_t  r15,r14,r13,r12,rbp,rbx,r11,r10;$/;"	m	struct:i386_regs	access:public
i386_regs::r8	src/base/elfcore.h	/^    uint64_t  r9,r8,rax,rcx,rdx,rsi,rdi,orig_rax;$/;"	m	struct:i386_regs	access:public
i386_regs::r9	src/base/elfcore.h	/^    uint64_t  r9,r8,rax,rcx,rdx,rsi,rdi,orig_rax;$/;"	m	struct:i386_regs	access:public
i386_regs::rax	src/base/elfcore.h	/^    uint64_t  r9,r8,rax,rcx,rdx,rsi,rdi,orig_rax;$/;"	m	struct:i386_regs	access:public
i386_regs::rbp	src/base/elfcore.h	/^    uint64_t  r15,r14,r13,r12,rbp,rbx,r11,r10;$/;"	m	struct:i386_regs	access:public
i386_regs::rbx	src/base/elfcore.h	/^    uint64_t  r15,r14,r13,r12,rbp,rbx,r11,r10;$/;"	m	struct:i386_regs	access:public
i386_regs::rcx	src/base/elfcore.h	/^    uint64_t  r9,r8,rax,rcx,rdx,rsi,rdi,orig_rax;$/;"	m	struct:i386_regs	access:public
i386_regs::rdi	src/base/elfcore.h	/^    uint64_t  r9,r8,rax,rcx,rdx,rsi,rdi,orig_rax;$/;"	m	struct:i386_regs	access:public
i386_regs::rdx	src/base/elfcore.h	/^    uint64_t  r9,r8,rax,rcx,rdx,rsi,rdi,orig_rax;$/;"	m	struct:i386_regs	access:public
i386_regs::rip	src/base/elfcore.h	/^    uint64_t  rip,cs,eflags;$/;"	m	struct:i386_regs	access:public
i386_regs::rsi	src/base/elfcore.h	/^    uint64_t  r9,r8,rax,rcx,rdx,rsi,rdi,orig_rax;$/;"	m	struct:i386_regs	access:public
i386_regs::rsp	src/base/elfcore.h	/^    uint64_t  rsp,ss;$/;"	m	struct:i386_regs	access:public
i386_regs::ss	src/base/elfcore.h	/^    uint64_t  rsp,ss;$/;"	m	struct:i386_regs	access:public
ibuf_	src/base/sysinfo.h	/^  char *ibuf_;        \/\/ input buffer$/;"	m	class:ProcMapsIterator	access:private
id	src/addressmap-inl.h	/^    Number   id;                        \/\/ Cluster ID$/;"	m	struct:AddressMap::Cluster	access:public
id	src/tests/testutil.cc	/^  int id;$/;"	m	struct:FunctionAndId	file:	access:public
id_	src/tests/tcmalloc_unittest.cc	/^  int                   id_;            \/\/ My thread id$/;"	m	class:testing::TesterThread	file:	access:private
ignore	src/heap-profile-table.h	/^    bool ignore() const { return bucket_rep & kIgnore; }$/;"	f	struct:HeapProfileTable::AllocValue	access:public	signature:() const
ignored	src/heap-profile-table.h	/^    bool ignored;$/;"	m	struct:HeapProfileTable::AllocInfo	access:public
ignored_objects	src/heap-checker.cc	/^static IgnoredObjectsMap* ignored_objects = NULL;$/;"	v	file:
image_	src/base/elf_mem_image.h	/^    const void *const image_;$/;"	m	class:base::ElfMemImage::SymbolIterator	access:private
image_	src/base/vdso_support.h	/^  ElfMemImage image_;$/;"	m	class:base::VDSOSupport	access:private
implement	docs/pprof_remote_servers.html	/^<p>The other reason this is the most difficult request to implement,$/;"	v
implies	docs/heap_checker.html	/^<p>"Normal" mode, as the name implies, is the one used most often at$/;"	v
in	config.guess	/^case $CC_FOR_BUILD,$HOST_CC,$CC in$/;"	v
in	configure	/^    for cmd in 'sed 50q "$0"' 'sed 20q "$0"' 'sed 10q "$0"' 'sed 2q "$0"' 'echo test'; do$/;"	v
in	m4/libtool.m4	/^for ac_symprfx in "" "_"; do$/;"	v
in	tags	/^in	configure	\/^    for cmd in 'sed 50q "$0"' 'sed 20q "$0"' 'sed 10q "$0"' 'sed 2q "$0"' 'echo test'; do$\/;"	v$/;"	v
in_setspecific_	src/thread_cache.h	/^  bool          in_setspecific_;        \/\/ In call to pthread_setspecific?$/;"	m	class:tcmalloc::ThreadCache	access:private
index_	src/base/elf_mem_image.h	/^    int index_;$/;"	m	class:base::ElfMemImage::SymbolIterator	access:private
infile	missing	/^      infile=`echo "$*" | sed 's\/.* \\([^ ]*\\) *$\/\\1\/'`$/;"	v
info_	src/base/elf_mem_image.h	/^    SymbolInfo info_;$/;"	m	class:base::ElfMemImage::SymbolIterator	access:private
init_default_stack_impl	src/stacktrace.cc	/^static void init_default_stack_impl(void) {$/;"	f	file:	signature:(void)
init_default_stack_impl_inner	src/stacktrace.cc	/^static void init_default_stack_impl_inner(void) {$/;"	f	file:	signature:(void)
init_default_stack_impl_inner	src/stacktrace.cc	/^static void init_default_stack_impl_inner(void);$/;"	p	file:	signature:(void)
init_forcer	src/tests/heap-checker_unittest.cc	/^void (* volatile init_forcer)(...);$/;"	v
init_helper	src/base/spinlock.cc	/^static SpinLock_InitHelper init_helper;$/;"	m	namespace:__anon37	file:
init_module	src/base/spinlock_linux-inl.h	/^} init_module;$/;"	m	namespace:__anon45	typeref:struct:__anon45::InitModule
init_thread_disable_counter	src/heap-checker.cc	/^InitThreadDisableCounter init_thread_disable_counter;$/;"	v
inited_	src/static_vars.cc	/^bool Static::inited_;$/;"	m	class:tcmalloc::Static	file:
inited_	src/static_vars.h	/^  \/* ATTRIBUTE_HIDDEN *\/ static bool inited_;$/;"	m	class:tcmalloc::Static	access:private
initialized	src/tests/heap-checker_unittest.cc	/^static Initialized initialized;$/;"	v	file:
initialized_	src/sampler.h	/^  bool initialized_;$/;"	m	class:tcmalloc::Sampler	access:public
initialized_	src/windows/preamble_patcher.cc	/^bool PreamblePatcher::initialized_ = false;$/;"	m	class:sidestep::PreamblePatcher	file:
initialized_	src/windows/preamble_patcher.h	/^  static bool initialized_;$/;"	m	class:sidestep::PreamblePatcher	access:private
inline	src/config.h.in	299;"	d	file:
inline	src/windows/config.h	300;"	d
inline	src/windows/port.h	494;"	d
inline	src/windows/port.h	89;"	d
inline	src/windows/port.h	91;"	d
ins	src/getpc.h	/^  unsigned char ins[16];$/;"	m	struct:CallUnrollInfo	access:public
ins_size	src/getpc.h	/^  int ins_size;$/;"	m	struct:CallUnrollInfo	access:public
instance	src/gperftools/malloc_extension.h	/^  static MallocExtension* instance();$/;"	p	class:MallocExtension	access:public	signature:()
instance	src/malloc_extension.cc	/^MallocExtension* MallocExtension::instance() {$/;"	f	class:MallocExtension	signature:()
instance_	src/profile-handler.cc	/^  static ProfileHandler* instance_;$/;"	m	class:ProfileHandler	file:	access:private
instance_	src/profile-handler.cc	/^ProfileHandler* ProfileHandler::instance_ = NULL;$/;"	m	class:ProfileHandler	file:
instance_	src/profiler.cc	/^  static CpuProfiler instance_;$/;"	m	class:CpuProfiler	file:	access:public
instance_	src/profiler.cc	/^CpuProfiler CpuProfiler::instance_;$/;"	m	class:CpuProfiler	file:
instruction_type_	src/windows/mini_disassembler.h	/^  InstructionType instruction_type_;$/;"	m	class:sidestep::MiniDisassembler	access:private
instructions	README_windows.txt	/^instructions, for work with win64.  This work is preliminary, but the$/;"	v
int16	src/base/basictypes.h	/^typedef int16_t             int16;$/;"	t
int16_t	src/windows/port.h	/^typedef __int16 int16_t;$/;"	t
int32	src/base/basictypes.h	/^typedef int32_t             int32;$/;"	t
int32_t	src/windows/port.h	/^typedef __int32 int32_t;$/;"	t
int64	src/base/basictypes.h	/^typedef int64_t             int64;$/;"	t
int64_t	src/windows/port.h	/^typedef __int64 int64_t;$/;"	t
int8	src/base/basictypes.h	/^typedef int8_t              int8;$/;"	t
int8_t	src/windows/port.h	/^typedef __int8 int8_t;$/;"	t
internal	src/base/spinlock_internal.cc	/^namespace base { namespace internal { static int SuggestedDelayNS(int loop); }}$/;"	n	namespace:base	file:
internal	src/base/spinlock_internal.cc	/^namespace internal {$/;"	n	namespace:base	file:
internal	src/base/spinlock_internal.h	/^namespace internal {$/;"	n	namespace:base
internal	src/base/spinlock_linux-inl.h	/^namespace internal {$/;"	n	namespace:base
internal	src/base/spinlock_posix-inl.h	/^namespace internal {$/;"	n	namespace:base
internal	src/base/spinlock_win32-inl.h	/^namespace internal {$/;"	n	namespace:base
internal	src/malloc_hook-inl.h	/^namespace base { namespace internal {$/;"	n	namespace:base
internal	src/malloc_hook.cc	/^namespace base { namespace internal {$/;"	n	namespace:base	file:
internal_bench	benchmark/run_benchmark.c	/^struct internal_bench {$/;"	s	file:
internal_bench::body	benchmark/run_benchmark.c	/^  bench_body body;$/;"	m	struct:internal_bench	file:	access:public
internal_bench::param	benchmark/run_benchmark.c	/^  uintptr_t param;$/;"	m	struct:internal_bench	file:	access:public
internal_init_start_has_run	src/heap-checker.cc	/^static bool internal_init_start_has_run = false;$/;"	v	file:
interrupts	src/profile-handler.h	/^  int64 interrupts;  \/* Number of interrupts received *\/$/;"	m	struct:ProfileHandlerState	access:public
inuse	src/page_heap_allocator.h	/^  int inuse() const { return inuse_; }$/;"	f	class:tcmalloc::PageHeapAllocator	access:public	signature:() const
inuse_	src/page_heap_allocator.h	/^  int inuse_;$/;"	m	class:tcmalloc::PageHeapAllocator	access:private
inuse_allocs_increase_	src/gperftools/heap-checker.h	/^  ssize_t inuse_allocs_increase_;  \/\/ allocations-in-use increase$/;"	m	class:HeapLeakChecker	access:private
inuse_bytes_increase_	src/gperftools/heap-checker.h	/^  ssize_t inuse_bytes_increase_;  \/\/ bytes-in-use increase for this checker$/;"	m	class:HeapLeakChecker	access:private
invocation_name	src/heap-checker.cc	/^static const char* invocation_name() { return "<your binary>"; }$/;"	f	file:	signature:()
invocation_name	src/heap-checker.cc	/^static const char* invocation_name() { return program_invocation_short_name; }$/;"	f	file:	signature:()
invocation_path	src/heap-checker.cc	/^static string invocation_path() { return "<your binary>"; }$/;"	f	file:	signature:()
invocation_path	src/heap-checker.cc	/^static string invocation_path() { return program_invocation_name; }$/;"	f	file:	signature:()
invoke_hooks_and_free	src/tcmalloc.cc	/^void invoke_hooks_and_free(void *ptr) {$/;"	f	namespace:tcmalloc	signature:(void *ptr)
invoked_	src/tests/system-alloc_unittest.cc	/^  bool invoked_;$/;"	m	class:ArraySysAllocator	file:	access:public
is_encoded_in_instruction_	src/windows/mini_disassembler_types.h	/^  bool is_encoded_in_instruction_;$/;"	m	struct:sidestep::ModrmEntry	access:public
is_memalign_available	benchmark/malloc_bench.cc	/^static bool is_memalign_available(void)$/;"	f	file:	signature:(void)
is_on	src/heap-profiler.cc	/^static bool  is_on = false;           \/\/ If are on as a subsytem.$/;"	v	file:
is_prefix_dependent_	src/windows/mini_disassembler_types.h	/^  bool is_prefix_dependent_;$/;"	m	struct:sidestep::Opcode	access:public
is_safe_	src/base/simple_mutex.h	/^  volatile bool is_safe_;$/;"	m	class:MUTEX_NAMESPACE::Mutex	access:private
is_sized_free_available	benchmark/malloc_bench.cc	/^static bool is_sized_free_available(void)$/;"	f	file:	signature:(void)
is_stack	src/memory_region_map.h	/^    bool is_stack;  \/\/ does this region contain a thread's stack:$/;"	m	struct:MemoryRegionMap::Region	access:public
is_valid	src/windows/patch_functions.cc	/^  bool is_valid() const { return is_valid_; }$/;"	f	class:__anon13::LibcInfo	access:public	signature:() const
is_valid_	src/windows/patch_functions.cc	/^  bool is_valid_;$/;"	m	class:__anon13::LibcInfo	file:	access:protected
it	docs/heap_checker.html	/^from it (by following pointers), is ignored for the purposes of leak$/;"	p	file:	signature:(by following pointers)
it	docs/heap_checker.html	/^it, that will prompt a leak message in "strict" mode, though not in$/;"	v
it	docs/pprof_remote_servers.html	/^<p>The profiler output file is binary, but near the end of it, it$/;"	v
joinable_	src/tests/profile-handler_unittest.cc	/^  bool joinable_;$/;"	m	class:__anon56::Thread	file:	access:private
k	docs/tcmalloc.html	/^of pages of length &gt; <code>k<\/code>, the remainder of the$/;"	m	class:object	file:	access:private
k	src/.libs/libtcmalloc_internal_la-internal_logging.o	/^/;"	v
k	src/.libs/libtcmalloc_internal_la-raw_printer.o	/^/;"	v
k	src/libtcmalloc_minimal_internal_la-internal_logging.o	/^/;"	v
kAddressBits	src/common.h	/^static const int kAddressBits = (sizeof(void*) < 8 ? (8 * sizeof(void*)) : 48);$/;"	v
kAddressBits	src/common.h	/^static const int kAddressBits = 8 * sizeof(void*);$/;"	v
kAlignment	src/common.h	/^static const size_t kAlignment  = 8;$/;"	v
kAllocIncrement	src/page_heap_allocator.h	/^  static const int kAllocIncrement = 128 << 10;$/;"	m	class:tcmalloc::PageHeapAllocator	access:private
kAllocName	src/debugallocation.cc	/^  static const char* const kAllocName[];$/;"	m	class:MallocBlock	file:	access:private
kAllocName	src/debugallocation.cc	/^const char* const MallocBlock::kAllocName[] = {$/;"	m	class:MallocBlock	file:
kAllocTypeMask	src/debugallocation.cc	/^  static const int kAllocTypeMask = 0x3;$/;"	m	class:MallocBlock	file:	access:private
kArrayNewType	src/debugallocation.cc	/^  static const int kArrayNewType = 0xBCEADF72;$/;"	m	class:MallocBlock	file:	access:public
kArraySize	src/tests/system-alloc_unittest.cc	/^  static const int kArraySize = 8 * 1024 * 1024;$/;"	m	class:ArraySysAllocator	file:	access:private
kArraySize	src/tests/system-alloc_unittest.cc	/^const int ArraySysAllocator::kArraySize;$/;"	m	class:ArraySysAllocator	file:
kAssociativity	src/profiledata.cc	/^const int ProfileData::kAssociativity;$/;"	m	class:ProfileData	file:
kAssociativity	src/profiledata.h	/^  static const int kAssociativity = 4;          \/\/ For hashtable$/;"	m	class:ProfileData	access:private
kAsyncSignalSafe	src/base/low_level_alloc.h	/^    kAsyncSignalSafe = 0x0002,$/;"	e	enum:LowLevelAlloc::__anon44
kBlockBits	src/addressmap-inl.h	/^  static const int kBlockBits = 7;$/;"	m	class:AddressMap	access:private
kBlockSize	src/addressmap-inl.h	/^  static const int kBlockSize = 1 << kBlockBits;$/;"	m	class:AddressMap	access:private
kBuckets	src/profiledata.cc	/^const int ProfileData::kBuckets;$/;"	m	class:ProfileData	file:
kBuckets	src/profiledata.h	/^  static const int kBuckets = 1 << 10;          \/\/ For hashtable$/;"	m	class:ProfileData	access:private
kBufSize	src/base/sysinfo.h	/^    static const size_t kBufSize = 102400;$/;"	m	struct:ProcMapsIterator::Buffer	access:public
kBufSize	src/internal_logging.cc	/^  static const int kBufSize = 200;$/;"	m	class:tcmalloc::Logger	file:	access:public
kBufferLength	src/profiledata.cc	/^const int ProfileData::kBufferLength;$/;"	m	class:ProfileData	file:
kBufferLength	src/profiledata.h	/^  static const int kBufferLength = 1 << 18;     \/\/ For eviction buffer$/;"	m	class:ProfileData	access:private
kCallMallocHook	src/base/low_level_alloc.h	/^    kCallMallocHook = 0x0001,$/;"	e	enum:LowLevelAlloc::__anon44
kCalloc	src/windows/patch_functions.cc	/^    kMalloc, kFree, kRealloc, kCalloc,$/;"	e	enum:__anon13::LibcInfo::__anon14	file:
kClassArraySize	src/common.h	/^  static const size_t kClassArraySize =$/;"	m	class:tcmalloc::SizeMap	access:private
kClassSizesMax	src/common.h	/^static const size_t kClassSizesMax = 96;$/;"	v
kClusterBits	src/addressmap-inl.h	/^  static const int kClusterBits = 13;$/;"	m	class:AddressMap	access:private
kClusterBlocks	src/addressmap-inl.h	/^  static const int kClusterBlocks = 1 << kClusterBits;$/;"	m	class:AddressMap	access:private
kClusterSize	src/addressmap-inl.h	/^  static const Number kClusterSize = 1 << (kBlockBits + kClusterBits);$/;"	m	class:AddressMap	access:private
kCrash	src/internal_logging.h	/^  kCrash,                     \/\/ Print the message and crash$/;"	e	enum:tcmalloc::LogMode
kCrashWithStats	src/internal_logging.h	/^  kCrashWithStats             \/\/ Print the message, some stats, and crash$/;"	e	enum:tcmalloc::LogMode
kDeallocName	src/debugallocation.cc	/^  static const char* const kDeallocName[];$/;"	m	class:MallocBlock	file:	access:private
kDeallocName	src/debugallocation.cc	/^const char* const MallocBlock::kDeallocName[] = {$/;"	m	class:MallocBlock	file:
kDeallocatedTypeBit	src/debugallocation.cc	/^  static const int kDeallocatedTypeBit = 0x4;$/;"	m	class:MallocBlock	file:	access:private
kDebugMode	src/system-alloc.cc	/^static const bool kDebugMode = false;$/;"	v	file:
kDebugMode	src/system-alloc.cc	/^static const bool kDebugMode = true;$/;"	v	file:
kDefaultFrequency	src/profile-handler.cc	/^  static const int32 kDefaultFrequency = 100;$/;"	m	class:ProfileHandler	file:	access:private
kDefaultFrequency	src/profile-handler.cc	/^const int32 ProfileHandler::kDefaultFrequency;$/;"	m	class:ProfileHandler	file:
kDefaultLargeAllocReportThreshold	src/tcmalloc.cc	/^const int64 kDefaultLargeAllocReportThreshold = static_cast<int64>(1) << 30;$/;"	v
kDefaultLargeAllocReportThreshold	src/tcmalloc.cc	/^const int64 kDefaultLargeAllocReportThreshold = static_cast<int64>(1) << 62;$/;"	v
kDefaultOverallThreadCacheSize	src/common.h	/^static const size_t kDefaultOverallThreadCacheSize = 8u * kMaxThreadCacheSize;$/;"	v
kDefaultOverallThreadCacheSize	src/common.h	/^static const size_t kDefaultOverallThreadCacheSize = kMaxThreadCacheSize;$/;"	v
kDefaultReleaseDelay	src/page_heap.h	/^  static const int kDefaultReleaseDelay = 1 << 18;$/;"	m	class:tcmalloc::PageHeap	access:private
kDefaultTransferNumObjecs	src/common.cc	/^static const int32 kDefaultTransferNumObjecs = 32;$/;"	m	namespace:tcmalloc	file:
kDelete	src/windows/patch_functions.cc	/^    kNew, kNewArray, kDelete, kDeleteArray,$/;"	e	enum:__anon13::LibcInfo::__anon14	file:
kDeleteArray	src/windows/patch_functions.cc	/^    kNew, kNewArray, kDelete, kDeleteArray,$/;"	e	enum:__anon13::LibcInfo::__anon14	file:
kDeleteArrayNothrow	src/windows/patch_functions.cc	/^    kNewNothrow, kNewArrayNothrow, kDeleteNothrow, kDeleteArrayNothrow,$/;"	e	enum:__anon13::LibcInfo::__anon14	file:
kDeleteNothrow	src/windows/patch_functions.cc	/^    kNewNothrow, kNewArrayNothrow, kDeleteNothrow, kDeleteArrayNothrow,$/;"	e	enum:__anon13::LibcInfo::__anon14	file:
kElfClass	src/base/elf_mem_image.cc	/^  static const int kElfClass = -1;$/;"	m	class:base::__anon50::ElfClass	file:	access:public
kElfClass	src/base/elf_mem_image.cc	/^  static const int kElfClass = ELFCLASS32;$/;"	m	class:base::__anon50::ElfClass	file:	access:public
kElfClass	src/base/elf_mem_image.cc	/^  static const int kElfClass = ELFCLASS64;$/;"	m	class:base::__anon50::ElfClass	file:	access:public
kEmergencyArenaShift	src/emergency_malloc.h	/^  static const uintptr_t kEmergencyArenaShift = 20+4; \/\/ 16 megs$/;"	m	namespace:tcmalloc
kEmergencyArenaSize	src/emergency_malloc.h	/^  static const uintptr_t kEmergencyArenaSize = 1 << kEmergencyArenaShift;$/;"	m	namespace:tcmalloc
kEnd	src/internal_logging.h	/^    kEnd$/;"	e	enum:tcmalloc::LogItem::Tag
kFileExt	src/heap-profile-table.cc	/^const char HeapProfileTable::kFileExt[] = ".heap";$/;"	m	class:HeapProfileTable	file:
kFileExt	src/heap-profile-table.h	/^  static const char kFileExt[];$/;"	m	class:HeapProfileTable	access:public
kForcedCoalesceInterval	src/page_heap.cc	/^static const size_t kForcedCoalesceInterval = 128*1024*1024;$/;"	m	namespace:tcmalloc	file:
kFree	src/windows/patch_functions.cc	/^    kMalloc, kFree, kRealloc, kCalloc,$/;"	e	enum:__anon13::LibcInfo::__anon14	file:
kFreeBase	src/windows/patch_functions.cc	/^    k_CallocCrt, kFreeBase,$/;"	e	enum:__anon13::LibcInfo::__anon14	file:
kFreeLibrary	src/windows/patch_functions.cc	/^    kMapViewOfFileEx, kUnmapViewOfFile, kLoadLibraryExW, kFreeLibrary,$/;"	e	enum:__anon13::WindowsInfo::__anon15	file:
kFreeQueueSize	src/debugallocation.cc	/^  static const int kFreeQueueSize = 1024;$/;"	m	class:FreeQueue	file:	access:private
kHashBits	src/addressmap-inl.h	/^  static const int kHashBits = 12;$/;"	m	class:AddressMap	access:private
kHashMultiplier	src/addressmap-inl.h	/^  static const uint32_t kHashMultiplier = 2654435769u;$/;"	m	class:AddressMap	access:private
kHashSize	src/addressmap-inl.h	/^  static const int kHashSize = 1 << 12;$/;"	m	class:AddressMap	access:private
kHashTableSize	src/heap-profile-table.cc	/^static const int kHashTableSize = 179999;   \/\/ Size for bucket_table_.$/;"	v	file:
kHashTableSize	src/memory_region_map.h	/^  static const int kHashTableSize = 179999;$/;"	m	class:MemoryRegionMap	access:private
kHashTableSize	src/stack_trace_table.h	/^  static const int kHashTableSize = 1 << 14; \/\/ => table_ is 128k$/;"	m	class:tcmalloc::StackTraceTable	access:private
kHashbits	src/packed-cache-inl.h	/^  static const int kHashbits = 12;$/;"	m	class:PackedCache	access:public
kHashbits	src/packed-cache-inl.h	/^  static const int kHashbits = 16;$/;"	m	class:PackedCache	access:public
kHashbits	src/tests/packed-cache_test.cc	/^static const int kHashbits = PackedCache<20>::kHashbits;$/;"	v	file:
kHeapAlloc	src/windows/patch_functions.cc	/^    kHeapAlloc, kHeapFree, kVirtualAllocEx, kVirtualFreeEx,$/;"	e	enum:__anon13::WindowsInfo::__anon15	file:
kHeapCheckMaxPointerOffset	src/heap-checker.cc	/^static const int64 kHeapCheckMaxPointerOffset = 1024;$/;"	v	file:
kHeapFree	src/windows/patch_functions.cc	/^    kHeapAlloc, kHeapFree, kVirtualAllocEx, kVirtualFreeEx,$/;"	e	enum:__anon13::WindowsInfo::__anon15	file:
kHideMask	src/gperftools/heap-checker.h	/^  static const uintptr_t kHideMask =$/;"	m	class:HiddenPointer	access:private
kHideMask	src/tests/heap-checker_unittest.cc	/^static const uintptr_t kHideMask =$/;"	v	file:
kHookListCapacity	src/malloc_hook-inl.h	/^static const int kHookListCapacity = 8;$/;"	m	namespace:base::internal
kHookListMaxValues	src/malloc_hook-inl.h	/^static const int kHookListMaxValues = 7;$/;"	m	namespace:base::internal
kHookListSingularIdx	src/malloc_hook-inl.h	/^static const int kHookListSingularIdx = 7;$/;"	m	namespace:base::internal
kIgnore	src/heap-profile-table.h	/^    static const int kIgnore = 2;$/;"	m	struct:HeapProfileTable::AllocValue	access:private
kIllegalRawFD	src/base/logging.h	/^const RawFD kIllegalRawFD = -1;   \/\/ what open returns if it fails$/;"	v
kIllegalRawFD	src/base/logging.h	/^const RawFD kIllegalRawFD = INVALID_HANDLE_VALUE;$/;"	v
kInvalidBase	src/base/elf_mem_image.cc	/^const void *const ElfMemImage::kInvalidBase =$/;"	m	class:base::ElfMemImage	file:
kInvalidBase	src/base/elf_mem_image.h	/^  static const void *const kInvalidBase;$/;"	m	class:base::ElfMemImage	access:public
kInvalidMask	src/packed-cache-inl.h	/^  static const int kInvalidMask = 0x80;$/;"	m	class:PackedCache	access:public
kIs64BitBinary	src/windows/preamble_patcher.h	/^static const bool kIs64BitBinary = false;$/;"	v
kIs64BitBinary	src/windows/preamble_patcher.h	/^static const bool kIs64BitBinary = true;$/;"	v
kKeyMask	src/packed-cache-inl.h	/^  static const K kKeyMask = N_ONES_(K, kKeybits);$/;"	m	class:PackedCache	access:private
kKeys	src/tests/heap-checker_unittest.cc	/^static const int kKeys = 50;$/;"	v	file:
kLargeSizeClass	src/common.h	/^static const size_t kLargeSizeClass = 0;$/;"	v
kLive	src/heap-profile-table.h	/^    static const int kLive = 1;$/;"	m	struct:HeapProfileTable::AllocValue	access:private
kLoadLibraryExW	src/windows/patch_functions.cc	/^    kMapViewOfFileEx, kUnmapViewOfFile, kLoadLibraryExW, kFreeLibrary,$/;"	e	enum:__anon13::WindowsInfo::__anon15	file:
kLog	src/internal_logging.h	/^  kLog,                       \/\/ Just print the message$/;"	e	enum:tcmalloc::LogMode
kMagicAllocated	src/base/low_level_alloc.cc	/^static const intptr_t kMagicAllocated = 0x4c833e95;$/;"	v	file:
kMagicDeletedBuffer	src/debugallocation.cc	/^  static unsigned char kMagicDeletedBuffer[1024];$/;"	m	class:MallocBlock	file:	access:private
kMagicDeletedBuffer	src/debugallocation.cc	/^unsigned char MallocBlock::kMagicDeletedBuffer[1024];$/;"	m	class:MallocBlock	file:
kMagicDeletedByte	src/debugallocation.cc	/^  static const int kMagicDeletedByte = 0xCD;$/;"	m	class:MallocBlock	file:	access:private
kMagicDeletedSizeT	src/debugallocation.cc	/^  static const size_t kMagicDeletedSizeT =$/;"	m	class:MallocBlock	file:	access:private
kMagicMMap	src/debugallocation.cc	/^  static const size_t kMagicMMap = 0xABCDEFAB;$/;"	m	class:MallocBlock	file:	access:private
kMagicMMap	src/debugallocation.cc	/^const size_t MallocBlock::kMagicMMap;$/;"	m	class:MallocBlock	file:
kMagicMalloc	src/debugallocation.cc	/^  static const size_t kMagicMalloc = 0xDEADBEEF;$/;"	m	class:MallocBlock	file:	access:private
kMagicMalloc	src/debugallocation.cc	/^const size_t MallocBlock::kMagicMalloc;$/;"	m	class:MallocBlock	file:
kMagicUnallocated	src/base/low_level_alloc.cc	/^static const intptr_t kMagicUnallocated = ~kMagicAllocated;$/;"	v	file:
kMagicUninitializedByte	src/debugallocation.cc	/^  static const int kMagicUninitializedByte = 0xAB;$/;"	m	class:MallocBlock	file:	access:private
kMalloc	src/windows/patch_functions.cc	/^    kMalloc, kFree, kRealloc, kCalloc,$/;"	e	enum:__anon13::LibcInfo::__anon14	file:
kMallocExtensionHistogramSize	src/gperftools/malloc_extension_c.h	58;"	d
kMallocHistogramSize	src/gperftools/malloc_extension.h	/^static const int kMallocHistogramSize = 64;$/;"	v
kMallocType	src/debugallocation.cc	/^  static const int kMallocType = 0xEFCDAB90;$/;"	m	class:MallocBlock	file:	access:public
kMangledDelete	src/windows/patch_functions.cc	/^const char kMangledDelete[] = "??3@YAXPAX@Z";$/;"	v
kMangledDelete	src/windows/patch_functions.cc	/^const char kMangledDelete[] = "??3@YAXPEAX@Z";$/;"	v
kMangledDeleteArray	src/windows/patch_functions.cc	/^const char kMangledDeleteArray[] = "??_V@YAXPAX@Z";$/;"	v
kMangledDeleteArray	src/windows/patch_functions.cc	/^const char kMangledDeleteArray[] = "??_V@YAXPEAX@Z";$/;"	v
kMangledDeleteArrayNothrow	src/windows/patch_functions.cc	/^const char kMangledDeleteArrayNothrow[] = "??_V@YAXPAXABUnothrow_t@std@@@Z";$/;"	v
kMangledDeleteArrayNothrow	src/windows/patch_functions.cc	/^const char kMangledDeleteArrayNothrow[] = "??_V@YAXPEAXAEBUnothrow_t@std@@@Z";$/;"	v
kMangledDeleteNothrow	src/windows/patch_functions.cc	/^const char kMangledDeleteNothrow[] = "??3@YAXPAXABUnothrow_t@std@@@Z";$/;"	v
kMangledDeleteNothrow	src/windows/patch_functions.cc	/^const char kMangledDeleteNothrow[] = "??3@YAXPEAXAEBUnothrow_t@std@@@Z";$/;"	v
kMangledNew	src/windows/patch_functions.cc	/^const char kMangledNew[] = "??2@YAPAXI@Z";$/;"	v
kMangledNew	src/windows/patch_functions.cc	/^const char kMangledNew[] = "??2@YAPEAX_K@Z";$/;"	v
kMangledNewArray	src/windows/patch_functions.cc	/^const char kMangledNewArray[] = "??_U@YAPAXI@Z";$/;"	v
kMangledNewArray	src/windows/patch_functions.cc	/^const char kMangledNewArray[] = "??_U@YAPEAX_K@Z";$/;"	v
kMangledNewArrayNothrow	src/windows/patch_functions.cc	/^const char kMangledNewArrayNothrow[] = "??_U@YAPAXIABUnothrow_t@std@@@Z";$/;"	v
kMangledNewArrayNothrow	src/windows/patch_functions.cc	/^const char kMangledNewArrayNothrow[] = "??_U@YAPEAX_KAEBUnothrow_t@std@@@Z";$/;"	v
kMangledNewNothrow	src/windows/patch_functions.cc	/^const char kMangledNewNothrow[] = "??2@YAPAXIABUnothrow_t@std@@@Z";$/;"	v
kMangledNewNothrow	src/windows/patch_functions.cc	/^const char kMangledNewNothrow[] = "??2@YAPEAX_KAEBUnothrow_t@std@@@Z";$/;"	v
kMapViewOfFileEx	src/windows/patch_functions.cc	/^    kMapViewOfFileEx, kUnmapViewOfFile, kLoadLibraryExW, kFreeLibrary,$/;"	e	enum:__anon13::WindowsInfo::__anon15	file:
kMask	src/heap-profile-table.h	/^    static const int kMask = kLive | kIgnore;$/;"	m	struct:HeapProfileTable::AllocValue	access:private
kMaxAllocators	src/system-alloc.cc	/^  static const int kMaxAllocators = 2;$/;"	m	class:DefaultSysAllocator	file:	access:private
kMaxBytes	src/stacktrace_x86-inl.h	/^static const int kMaxBytes = 10;$/;"	v
kMaxCount	src/tests/heap-profiler_unittest.cc	/^static const int kMaxCount = 100000;$/;"	v	file:
kMaxDynamicFreeListLength	src/common.h	/^static const int kMaxDynamicFreeListLength = 8192;$/;"	v
kMaxFrequency	src/profile-handler.cc	/^  static const int32 kMaxFrequency = 4000;$/;"	m	class:ProfileHandler	file:	access:private
kMaxFrequency	src/profile-handler.cc	/^const int32 ProfileHandler::kMaxFrequency;$/;"	m	class:ProfileHandler	file:
kMaxLevel	src/base/low_level_alloc.cc	/^static const int kMaxLevel = 30;$/;"	v	file:
kMaxModules	src/windows/patch_functions.cc	/^const int kMaxModules = 8182;$/;"	v
kMaxNumTransferEntries	src/central_freelist.h	/^  static const int kMaxNumTransferEntries = 0;$/;"	m	class:tcmalloc::CentralFreeList	access:private
kMaxNumTransferEntries	src/central_freelist.h	/^  static const int kMaxNumTransferEntries = 64;$/;"	m	class:tcmalloc::CentralFreeList	access:private
kMaxOverages	src/common.h	/^static const int kMaxOverages = 3;$/;"	v
kMaxPages	src/common.h	/^static const size_t kMaxPages = 1 << (20 - kPageShift);$/;"	v
kMaxReleaseDelay	src/page_heap.h	/^  static const int kMaxReleaseDelay = 1 << 20;$/;"	m	class:tcmalloc::PageHeap	access:private
kMaxSignedSize	src/tests/tcmalloc_unittest.cc	/^static const size_t kMaxSignedSize = ((size_t(1) << (kSizeBits-1)) - 1);$/;"	m	namespace:testing	file:
kMaxSize	src/common.h	/^static const size_t kMaxSize    = 256 * 1024;$/;"	v
kMaxSize	src/tests/tcmalloc_unittest.cc	/^static const size_t kMaxSize = ~static_cast<size_t>(0);$/;"	m	namespace:testing	file:
kMaxSmallSize	src/common.h	/^  static const int kMaxSmallSize = 1024;$/;"	m	class:tcmalloc::SizeMap	access:private
kMaxStackDepth	src/common.h	/^static const int kMaxStackDepth = 31;$/;"	m	namespace:tcmalloc
kMaxStackDepth	src/heap-profile-stats.h	/^  static const int kMaxStackDepth = 32;$/;"	m	struct:HeapProfileBucket	access:public
kMaxStackDepth	src/heap-profile-table.cc	/^\/*static*\/ const int HeapProfileTable::kMaxStackDepth;$/;"	m	class:HeapProfileTable	file:
kMaxStackDepth	src/heap-profile-table.h	/^  static const int kMaxStackDepth = 32;$/;"	m	class:HeapProfileTable	access:public
kMaxStackDepth	src/memory_region_map.h	/^  static const int kMaxStackDepth = 32;$/;"	m	class:MemoryRegionMap	access:private
kMaxStackDepth	src/profiledata.cc	/^const int ProfileData::kMaxStackDepth;$/;"	m	class:ProfileData	file:
kMaxStackDepth	src/profiledata.h	/^  static const int kMaxStackDepth = 64;  \/\/ Max stack depth stored in profile$/;"	m	class:ProfileData	access:public
kMaxThreadCacheSize	src/common.h	/^static const size_t kMaxThreadCacheSize = 4 << 20;$/;"	v
kMaxValidPages	src/common.h	/^static const Length kMaxValidPages = (~static_cast<Length>(0)) >> kPageShift;$/;"	v
kMetadataAllignment	src/common.cc	/^static const size_t kMetadataAllignment = sizeof(MemoryAligner);$/;"	m	namespace:tcmalloc	file:
kMetadataAllocChunkSize	src/common.cc	/^static const size_t kMetadataAllocChunkSize = 8*1024*1024;$/;"	m	namespace:tcmalloc	file:
kMinAlign	src/common.h	/^static const size_t kMinAlign   = 16;$/;"	v
kMinAlign	src/common.h	/^static const size_t kMinAlign   = 8;$/;"	v
kMinSystemAlloc	src/page_heap.h	/^  static const int kMinSystemAlloc = kMaxPages;$/;"	m	class:tcmalloc::PageHeap	access:private
kMinThreadCacheSize	src/common.h	/^static const size_t kMinThreadCacheSize = kMaxSize * 2;$/;"	v
kMmapMagicFd	src/tests/malloc_hook_test.cc	/^const int kMmapMagicFd = 1;$/;"	m	namespace:__anon57	file:
kMmapMagicPointer	src/tests/malloc_hook_test.cc	/^void* const kMmapMagicPointer = reinterpret_cast<void*>(1);$/;"	m	namespace:__anon57	file:
kNew	src/windows/patch_functions.cc	/^    kNew, kNewArray, kDelete, kDeleteArray,$/;"	e	enum:__anon13::LibcInfo::__anon14	file:
kNewArray	src/windows/patch_functions.cc	/^    kNew, kNewArray, kDelete, kDeleteArray,$/;"	e	enum:__anon13::LibcInfo::__anon14	file:
kNewArrayNothrow	src/windows/patch_functions.cc	/^    kNewNothrow, kNewArrayNothrow, kDeleteNothrow, kDeleteArrayNothrow,$/;"	e	enum:__anon13::LibcInfo::__anon14	file:
kNewNothrow	src/windows/patch_functions.cc	/^    kNewNothrow, kNewArrayNothrow, kDeleteNothrow, kDeleteArrayNothrow,$/;"	e	enum:__anon13::LibcInfo::__anon14	file:
kNewType	src/debugallocation.cc	/^  static const int kNewType = 0xFEBADC81;$/;"	m	class:MallocBlock	file:	access:public
kNoError	src/tests/profiledata_unittest.cc	/^const char kNoError[] = "";$/;"	m	namespace:__anon53	file:
kNotOwned	src/gperftools/malloc_extension.h	/^    kNotOwned$/;"	e	enum:MallocExtension::Ownership
kNotTooBig	src/tests/tcmalloc_unittest.cc	/^static const size_t kNotTooBig = 100000;$/;"	m	namespace:testing	file:
kNumFunctions	src/windows/patch_functions.cc	/^    kNumFunctions$/;"	e	enum:__anon13::LibcInfo::__anon14	file:
kNumFunctions	src/windows/patch_functions.cc	/^    kNumFunctions$/;"	e	enum:__anon13::WindowsInfo::__anon15	file:
kNumObjects	src/tests/thread_dealloc_unittest.cc	/^static const int kNumObjects = 1024;$/;"	v	file:
kNumThreads	src/tests/thread_dealloc_unittest.cc	/^static const int kNumThreads = 1000;$/;"	v	file:
kOSSupportsMemalign	src/tests/tcmalloc_unittest.cc	/^static bool kOSSupportsMemalign = false;$/;"	v	file:
kOSSupportsMemalign	src/tests/tcmalloc_unittest.cc	/^static bool kOSSupportsMemalign = true;$/;"	v	file:
kObjectSize	src/tests/thread_dealloc_unittest.cc	/^static const int kObjectSize = 1024;$/;"	v	file:
kOwned	src/gperftools/malloc_extension.h	/^    kOwned,$/;"	e	enum:MallocExtension::Ownership
kPageMapBigAllocationThreshold	src/page_heap.h	/^  static const size_t kPageMapBigAllocationThreshold = 128 << 20;$/;"	m	class:tcmalloc::PageHeap	access:private
kPageShift	src/common.h	/^static const size_t kPageShift  = 13;$/;"	v
kPageShift	src/common.h	/^static const size_t kPageShift  = 15;$/;"	v
kPageShift	src/common.h	/^static const size_t kPageShift  = 16;$/;"	v
kPageSize	src/common.h	/^static const size_t kPageSize   = 1 << kPageShift;$/;"	v
kPointerSourceAlignment	src/heap-checker.cc	/^static const size_t kPointerSourceAlignment = sizeof(void*);$/;"	v	file:
kPreamblePageMagic	src/windows/preamble_patcher.cc	/^static const unsigned int kPreamblePageMagic = 0x4347414D; \/\/ "MAGC"$/;"	m	namespace:sidestep	file:
kProcSelfMapsHeader	src/heap-profile-table.cc	/^static const char kProcSelfMapsHeader[] = "\\nMAPPED_LIBRARIES:\\n";$/;"	v	file:
kProfileBufferSize	src/heap-profiler.cc	/^static const int kProfileBufferSize = 1 << 20;$/;"	v	file:
kProfileHeader	src/heap-profile-table.cc	/^static const char kProfileHeader[] = "heap profile: ";$/;"	v	file:
kPtr	src/internal_logging.h	/^    kPtr,$/;"	e	enum:tcmalloc::LogItem::Tag
kRealloc	src/windows/patch_functions.cc	/^    kMalloc, kFree, kRealloc, kCalloc,$/;"	e	enum:__anon13::LibcInfo::__anon14	file:
kRoutineSize	src/tests/getpc_test.cc	/^const int kRoutineSize = 512 * sizeof(void*)\/4;    \/\/ allow 1024 for 64-bit$/;"	v
kSamplingInterval	src/tests/sampler_test.cc	/^static const size_t kSamplingInterval = 512*1024;$/;"	v	file:
kSigmas	src/tests/sampler_test.cc	/^static const double kSigmas = 4;$/;"	v	file:
kSigned	src/internal_logging.h	/^    kSigned,$/;"	e	enum:tcmalloc::LogItem::Tag
kSizeBits	src/tests/tcmalloc_unittest.cc	/^static const int kSizeBits = 8 * sizeof(size_t);$/;"	m	namespace:testing	file:
kSleepInterval	src/tests/profile-handler_unittest.cc	/^int kSleepInterval = 200000000;$/;"	m	namespace:__anon56	file:
kSpinLockFree	src/base/spinlock.h	/^  enum { kSpinLockFree = 0 };$/;"	e	enum:SpinLock::__anon41
kSpinLockHeld	src/base/spinlock.h	/^  enum { kSpinLockHeld = 1 };$/;"	e	enum:SpinLock::__anon42
kSpinLockSleeper	src/base/spinlock.h	/^  enum { kSpinLockSleeper = 2 };$/;"	e	enum:SpinLock::__anon43
kStatsBufferSize	src/internal_logging.cc	/^static const int kStatsBufferSize = 16 << 10;$/;"	v	file:
kStealAmount	src/common.h	/^static const size_t kStealAmount = 1 << 16;$/;"	v
kStr	src/internal_logging.h	/^    kStr,$/;"	e	enum:tcmalloc::LogItem::Tag
kStripFrames	src/heap-profile-table.cc	/^static const int kStripFrames = 2;$/;"	v	file:
kStripFrames	src/heap-profile-table.cc	/^static const int kStripFrames = 3;$/;"	v	file:
kStripFrames	src/memory_region_map.cc	/^static const int kStripFrames = 1;$/;"	v	file:
kStripFrames	src/memory_region_map.cc	/^static const int kStripFrames = 3;$/;"	v	file:
kSymbolSize	src/symbolize.h	/^  static const int kSymbolSize = 1024;$/;"	m	class:SymbolTable	access:private
kTimerResetInterval	src/tests/profile-handler_unittest.cc	/^int kTimerResetInterval = 5000000;$/;"	m	namespace:__anon56	file:
kTooBig	src/tests/tcmalloc_unittest.cc	/^static const size_t kTooBig = kMaxSize - 100000;$/;"	m	namespace:testing	file:
kUnknownOwnership	src/gperftools/malloc_extension.h	/^    kUnknownOwnership = 0,$/;"	e	enum:MallocExtension::Ownership
kUnmapViewOfFile	src/windows/patch_functions.cc	/^    kMapViewOfFileEx, kUnmapViewOfFile, kLoadLibraryExW, kFreeLibrary,$/;"	e	enum:__anon13::WindowsInfo::__anon15	file:
kUnnamedProcSelfMapEntry	src/heap-checker.cc	/^static const char kUnnamedProcSelfMapEntry[] = "UNNAMED";$/;"	v	file:
kUnsigned	src/internal_logging.h	/^    kUnsigned,$/;"	e	enum:tcmalloc::LogItem::Tag
kValueMask	src/packed-cache-inl.h	/^  static const V kValueMask = N_ONES_(V, kValuebits);$/;"	m	class:PackedCache	access:private
kValuebits	src/packed-cache-inl.h	/^  static const int kValuebits = 7;$/;"	m	class:PackedCache	access:public
kVirtualAllocEx	src/windows/patch_functions.cc	/^    kHeapAlloc, kHeapFree, kVirtualAllocEx, kVirtualFreeEx,$/;"	e	enum:__anon13::WindowsInfo::__anon15	file:
kVirtualFreeEx	src/windows/patch_functions.cc	/^    kHeapAlloc, kHeapFree, kVirtualAllocEx, kVirtualFreeEx,$/;"	e	enum:__anon13::WindowsInfo::__anon15	file:
k_CallocCrt	src/windows/patch_functions.cc	/^    k_CallocCrt, kFreeBase,$/;"	e	enum:__anon13::LibcInfo::__anon14	file:
k_Expand	src/windows/patch_functions.cc	/^    k_Msize, k_Expand,$/;"	e	enum:__anon13::LibcInfo::__anon14	file:
k_Msize	src/windows/patch_functions.cc	/^    k_Msize, k_Expand,$/;"	e	enum:__anon13::LibcInfo::__anon14	file:
keep_profiles_	src/gperftools/heap-checker.h	/^  bool keep_profiles_;  \/\/ iff we should keep the heap profiles we've made$/;"	m	class:HeapLeakChecker	access:private
kernel_dirent	src/base/linux_syscall_support.h	/^struct kernel_dirent {$/;"	s
kernel_dirent64	src/base/linux_syscall_support.h	/^struct kernel_dirent64 {$/;"	s
kernel_dirent64::d_ino	src/base/linux_syscall_support.h	/^  unsigned long long d_ino;$/;"	m	struct:kernel_dirent64	access:public
kernel_dirent64::d_name	src/base/linux_syscall_support.h	/^  char               d_name[256];$/;"	m	struct:kernel_dirent64	access:public
kernel_dirent64::d_off	src/base/linux_syscall_support.h	/^  long long          d_off;$/;"	m	struct:kernel_dirent64	access:public
kernel_dirent64::d_reclen	src/base/linux_syscall_support.h	/^  unsigned short     d_reclen;$/;"	m	struct:kernel_dirent64	access:public
kernel_dirent64::d_type	src/base/linux_syscall_support.h	/^  unsigned char      d_type;$/;"	m	struct:kernel_dirent64	access:public
kernel_dirent::d_ino	src/base/linux_syscall_support.h	/^  long               d_ino;$/;"	m	struct:kernel_dirent	access:public
kernel_dirent::d_name	src/base/linux_syscall_support.h	/^  char               d_name[256];$/;"	m	struct:kernel_dirent	access:public
kernel_dirent::d_off	src/base/linux_syscall_support.h	/^  long               d_off;$/;"	m	struct:kernel_dirent	access:public
kernel_dirent::d_reclen	src/base/linux_syscall_support.h	/^  unsigned short     d_reclen;$/;"	m	struct:kernel_dirent	access:public
kernel_old_sigaction	src/base/linux_syscall_support.h	/^struct kernel_old_sigaction {$/;"	s
kernel_old_sigaction	src/base/linux_syscall_support.h	266;"	d
kernel_old_sigaction::__anon48::sa_handler_	src/base/linux_syscall_support.h	/^    void             (*sa_handler_)(int);$/;"	m	union:kernel_old_sigaction::__anon48	access:public
kernel_old_sigaction::__anon48::sa_sigaction_	src/base/linux_syscall_support.h	/^    void             (*sa_sigaction_)(int, siginfo_t *, void *);$/;"	m	union:kernel_old_sigaction::__anon48	access:public
kernel_old_sigaction::sa_flags	src/base/linux_syscall_support.h	/^  unsigned long      sa_flags;$/;"	m	struct:kernel_old_sigaction	access:public
kernel_old_sigaction::sa_mask	src/base/linux_syscall_support.h	/^  unsigned long      sa_mask;$/;"	m	struct:kernel_old_sigaction	access:public
kernel_old_sigaction::sa_restorer	src/base/linux_syscall_support.h	/^  void               (*sa_restorer)(void);$/;"	m	struct:kernel_old_sigaction	access:public
kernel_rusage	src/base/linux_syscall_support.h	/^struct kernel_rusage {$/;"	s
kernel_rusage::ru_idrss	src/base/linux_syscall_support.h	/^  long               ru_idrss;$/;"	m	struct:kernel_rusage	access:public
kernel_rusage::ru_inblock	src/base/linux_syscall_support.h	/^  long               ru_inblock;$/;"	m	struct:kernel_rusage	access:public
kernel_rusage::ru_isrss	src/base/linux_syscall_support.h	/^  long               ru_isrss;$/;"	m	struct:kernel_rusage	access:public
kernel_rusage::ru_ixrss	src/base/linux_syscall_support.h	/^  long               ru_ixrss;$/;"	m	struct:kernel_rusage	access:public
kernel_rusage::ru_majflt	src/base/linux_syscall_support.h	/^  long               ru_majflt;$/;"	m	struct:kernel_rusage	access:public
kernel_rusage::ru_maxrss	src/base/linux_syscall_support.h	/^  long               ru_maxrss;$/;"	m	struct:kernel_rusage	access:public
kernel_rusage::ru_minflt	src/base/linux_syscall_support.h	/^  long               ru_minflt;$/;"	m	struct:kernel_rusage	access:public
kernel_rusage::ru_msgrcv	src/base/linux_syscall_support.h	/^  long               ru_msgrcv;$/;"	m	struct:kernel_rusage	access:public
kernel_rusage::ru_msgsnd	src/base/linux_syscall_support.h	/^  long               ru_msgsnd;$/;"	m	struct:kernel_rusage	access:public
kernel_rusage::ru_nivcsw	src/base/linux_syscall_support.h	/^  long               ru_nivcsw;$/;"	m	struct:kernel_rusage	access:public
kernel_rusage::ru_nsignals	src/base/linux_syscall_support.h	/^  long               ru_nsignals;$/;"	m	struct:kernel_rusage	access:public
kernel_rusage::ru_nswap	src/base/linux_syscall_support.h	/^  long               ru_nswap;$/;"	m	struct:kernel_rusage	access:public
kernel_rusage::ru_nvcsw	src/base/linux_syscall_support.h	/^  long               ru_nvcsw;$/;"	m	struct:kernel_rusage	access:public
kernel_rusage::ru_oublock	src/base/linux_syscall_support.h	/^  long               ru_oublock;$/;"	m	struct:kernel_rusage	access:public
kernel_rusage::ru_stime	src/base/linux_syscall_support.h	/^  struct kernel_timeval ru_stime;$/;"	m	struct:kernel_rusage	typeref:struct:kernel_rusage::kernel_timeval	access:public
kernel_rusage::ru_utime	src/base/linux_syscall_support.h	/^  struct kernel_timeval ru_utime;$/;"	m	struct:kernel_rusage	typeref:struct:kernel_rusage::kernel_timeval	access:public
kernel_sigaction	src/base/linux_syscall_support.h	/^struct kernel_sigaction {$/;"	s
kernel_sigaction::__anon49::sa_handler_	src/base/linux_syscall_support.h	/^    void             (*sa_handler_)(int);$/;"	m	union:kernel_sigaction::__anon49	access:public
kernel_sigaction::__anon49::sa_sigaction_	src/base/linux_syscall_support.h	/^    void             (*sa_sigaction_)(int, siginfo_t *, void *);$/;"	m	union:kernel_sigaction::__anon49	access:public
kernel_sigaction::sa_flags	src/base/linux_syscall_support.h	/^  unsigned long      sa_flags;$/;"	m	struct:kernel_sigaction	access:public
kernel_sigaction::sa_mask	src/base/linux_syscall_support.h	/^  struct kernel_sigset_t sa_mask;$/;"	m	struct:kernel_sigaction	typeref:struct:kernel_sigaction::kernel_sigset_t	access:public
kernel_sigset_t	src/base/linux_syscall_support.h	/^struct kernel_sigset_t {$/;"	s
kernel_sigset_t::sig	src/base/linux_syscall_support.h	/^  unsigned long sig[(KERNEL_NSIG + 8*sizeof(unsigned long) - 1)\/$/;"	m	struct:kernel_sigset_t	access:public
kernel_stat	src/base/linux_syscall_support.h	/^struct kernel_stat {$/;"	s
kernel_stat64	src/base/linux_syscall_support.h	/^struct kernel_stat64 {$/;"	s
kernel_stat64::__pad0	src/base/linux_syscall_support.h	/^  unsigned char      __pad0[4];$/;"	m	struct:kernel_stat64	access:public
kernel_stat64::__pad2	src/base/linux_syscall_support.h	/^  int                __pad2;$/;"	m	struct:kernel_stat64	access:public
kernel_stat64::__pad3	src/base/linux_syscall_support.h	/^  unsigned char      __pad3[4];$/;"	m	struct:kernel_stat64	access:public
kernel_stat64::__st_ino	src/base/linux_syscall_support.h	/^  unsigned           __st_ino;$/;"	m	struct:kernel_stat64	access:public
kernel_stat64::__unused4	src/base/linux_syscall_support.h	/^  unsigned long      __unused4;$/;"	m	struct:kernel_stat64	access:public
kernel_stat64::__unused5	src/base/linux_syscall_support.h	/^  unsigned long      __unused5;$/;"	m	struct:kernel_stat64	access:public
kernel_stat64::__unused6	src/base/linux_syscall_support.h	/^  unsigned long      __unused6;$/;"	m	struct:kernel_stat64	access:public
kernel_stat64::st_atim	src/base/linux_syscall_support.h	/^  kernel_timespec    st_atim;$/;"	m	struct:kernel_stat64	access:public
kernel_stat64::st_atime_	src/base/linux_syscall_support.h	/^  unsigned           st_atime_;$/;"	m	struct:kernel_stat64	access:public
kernel_stat64::st_atime_nsec_	src/base/linux_syscall_support.h	/^  unsigned           st_atime_nsec_;$/;"	m	struct:kernel_stat64	access:public
kernel_stat64::st_blksize	src/base/linux_syscall_support.h	/^  long long          st_blksize;$/;"	m	struct:kernel_stat64	access:public
kernel_stat64::st_blksize	src/base/linux_syscall_support.h	/^  unsigned           st_blksize;$/;"	m	struct:kernel_stat64	access:public
kernel_stat64::st_blocks	src/base/linux_syscall_support.h	/^  long long          st_blocks;$/;"	m	struct:kernel_stat64	access:public
kernel_stat64::st_blocks	src/base/linux_syscall_support.h	/^  unsigned long long st_blocks;$/;"	m	struct:kernel_stat64	access:public
kernel_stat64::st_ctim	src/base/linux_syscall_support.h	/^  kernel_timespec    st_ctim;$/;"	m	struct:kernel_stat64	access:public
kernel_stat64::st_ctime_	src/base/linux_syscall_support.h	/^  unsigned           st_ctime_;$/;"	m	struct:kernel_stat64	access:public
kernel_stat64::st_ctime_nsec_	src/base/linux_syscall_support.h	/^  unsigned           st_ctime_nsec_;$/;"	m	struct:kernel_stat64	access:public
kernel_stat64::st_dev	src/base/linux_syscall_support.h	/^  unsigned long long st_dev;$/;"	m	struct:kernel_stat64	access:public
kernel_stat64::st_gid	src/base/linux_syscall_support.h	/^  unsigned           st_gid;$/;"	m	struct:kernel_stat64	access:public
kernel_stat64::st_ino	src/base/linux_syscall_support.h	/^  unsigned long long st_ino;$/;"	m	struct:kernel_stat64	access:public
kernel_stat64::st_mode	src/base/linux_syscall_support.h	/^  unsigned           st_mode;$/;"	m	struct:kernel_stat64	access:public
kernel_stat64::st_mtim	src/base/linux_syscall_support.h	/^  kernel_timespec    st_mtim;$/;"	m	struct:kernel_stat64	access:public
kernel_stat64::st_mtime_	src/base/linux_syscall_support.h	/^  unsigned           st_mtime_;$/;"	m	struct:kernel_stat64	access:public
kernel_stat64::st_mtime_nsec_	src/base/linux_syscall_support.h	/^  unsigned           st_mtime_nsec_;$/;"	m	struct:kernel_stat64	access:public
kernel_stat64::st_nlink	src/base/linux_syscall_support.h	/^  unsigned           st_nlink;$/;"	m	struct:kernel_stat64	access:public
kernel_stat64::st_rdev	src/base/linux_syscall_support.h	/^  unsigned long long st_rdev;$/;"	m	struct:kernel_stat64	access:public
kernel_stat64::st_size	src/base/linux_syscall_support.h	/^  long long          st_size;$/;"	m	struct:kernel_stat64	access:public
kernel_stat64::st_uid	src/base/linux_syscall_support.h	/^  unsigned           st_uid;$/;"	m	struct:kernel_stat64	access:public
kernel_stat::__pad0	src/base/linux_syscall_support.h	/^  unsigned           __pad0;$/;"	m	struct:kernel_stat	access:public
kernel_stat::__pad0	src/base/linux_syscall_support.h	/^  unsigned           __pad0[3];$/;"	m	struct:kernel_stat	access:public
kernel_stat::__pad1	src/base/linux_syscall_support.h	/^  unsigned           __pad1[3];$/;"	m	struct:kernel_stat	access:public
kernel_stat::__pad1	src/base/linux_syscall_support.h	/^  unsigned int       __pad1;$/;"	m	struct:kernel_stat	access:public
kernel_stat::__pad1	src/base/linux_syscall_support.h	/^  unsigned long      __pad1;$/;"	m	struct:kernel_stat	access:public
kernel_stat::__pad1	src/base/linux_syscall_support.h	/^  unsigned short     __pad1;$/;"	m	struct:kernel_stat	access:public
kernel_stat::__pad2	src/base/linux_syscall_support.h	/^  int                __pad2;$/;"	m	struct:kernel_stat	access:public
kernel_stat::__pad2	src/base/linux_syscall_support.h	/^  unsigned           __pad2;$/;"	m	struct:kernel_stat	access:public
kernel_stat::__pad2	src/base/linux_syscall_support.h	/^  unsigned short     __pad2;$/;"	m	struct:kernel_stat	access:public
kernel_stat::__unused	src/base/linux_syscall_support.h	/^  int64_t            __unused[3];$/;"	m	struct:kernel_stat	access:public
kernel_stat::__unused	src/base/linux_syscall_support.h	/^  unsigned long      __unused[3];$/;"	m	struct:kernel_stat	access:public
kernel_stat::__unused4	src/base/linux_syscall_support.h	/^  unsigned           __unused4;$/;"	m	struct:kernel_stat	access:public
kernel_stat::__unused4	src/base/linux_syscall_support.h	/^  unsigned int       __unused4;$/;"	m	struct:kernel_stat	access:public
kernel_stat::__unused4	src/base/linux_syscall_support.h	/^  unsigned long      __unused4;$/;"	m	struct:kernel_stat	access:public
kernel_stat::__unused5	src/base/linux_syscall_support.h	/^  unsigned           __unused5;$/;"	m	struct:kernel_stat	access:public
kernel_stat::__unused5	src/base/linux_syscall_support.h	/^  unsigned int       __unused5;$/;"	m	struct:kernel_stat	access:public
kernel_stat::__unused5	src/base/linux_syscall_support.h	/^  unsigned long      __unused5;$/;"	m	struct:kernel_stat	access:public
kernel_stat::__unused6	src/base/linux_syscall_support.h	/^  unsigned long      __unused6;$/;"	m	struct:kernel_stat	access:public
kernel_stat::pad1	src/base/linux_syscall_support.h	/^  short              pad1;$/;"	m	struct:kernel_stat	access:public
kernel_stat::pad2	src/base/linux_syscall_support.h	/^  short              pad2;$/;"	m	struct:kernel_stat	access:public
kernel_stat::st_atim	src/base/linux_syscall_support.h	/^  kernel_timespec    st_atim;$/;"	m	struct:kernel_stat	access:public
kernel_stat::st_atime_	src/base/linux_syscall_support.h	/^  long               st_atime_;$/;"	m	struct:kernel_stat	access:public
kernel_stat::st_atime_	src/base/linux_syscall_support.h	/^  uint64_t           st_atime_;$/;"	m	struct:kernel_stat	access:public
kernel_stat::st_atime_	src/base/linux_syscall_support.h	/^  unsigned           st_atime_;$/;"	m	struct:kernel_stat	access:public
kernel_stat::st_atime_	src/base/linux_syscall_support.h	/^  unsigned long      st_atime_;$/;"	m	struct:kernel_stat	access:public
kernel_stat::st_atime_nsec_	src/base/linux_syscall_support.h	/^  long               st_atime_nsec_;$/;"	m	struct:kernel_stat	access:public
kernel_stat::st_atime_nsec_	src/base/linux_syscall_support.h	/^  uint64_t           st_atime_nsec_;$/;"	m	struct:kernel_stat	access:public
kernel_stat::st_atime_nsec_	src/base/linux_syscall_support.h	/^  unsigned           st_atime_nsec_;$/;"	m	struct:kernel_stat	access:public
kernel_stat::st_atime_nsec_	src/base/linux_syscall_support.h	/^  unsigned long      st_atime_nsec_;$/;"	m	struct:kernel_stat	access:public
kernel_stat::st_blksize	src/base/linux_syscall_support.h	/^  int                st_blksize;$/;"	m	struct:kernel_stat	access:public
kernel_stat::st_blksize	src/base/linux_syscall_support.h	/^  int64_t            st_blksize;$/;"	m	struct:kernel_stat	access:public
kernel_stat::st_blksize	src/base/linux_syscall_support.h	/^  unsigned           st_blksize;$/;"	m	struct:kernel_stat	access:public
kernel_stat::st_blksize	src/base/linux_syscall_support.h	/^  unsigned long      st_blksize;$/;"	m	struct:kernel_stat	access:public
kernel_stat::st_blocks	src/base/linux_syscall_support.h	/^  int                st_blocks;$/;"	m	struct:kernel_stat	access:public
kernel_stat::st_blocks	src/base/linux_syscall_support.h	/^  int64_t            st_blocks;$/;"	m	struct:kernel_stat	access:public
kernel_stat::st_blocks	src/base/linux_syscall_support.h	/^  long               st_blocks;$/;"	m	struct:kernel_stat	access:public
kernel_stat::st_blocks	src/base/linux_syscall_support.h	/^  unsigned           st_blocks;$/;"	m	struct:kernel_stat	access:public
kernel_stat::st_blocks	src/base/linux_syscall_support.h	/^  unsigned long      st_blocks;$/;"	m	struct:kernel_stat	access:public
kernel_stat::st_blocks	src/base/linux_syscall_support.h	/^  unsigned long long st_blocks;$/;"	m	struct:kernel_stat	access:public
kernel_stat::st_ctim	src/base/linux_syscall_support.h	/^  kernel_timespec    st_ctim;$/;"	m	struct:kernel_stat	access:public
kernel_stat::st_ctime_	src/base/linux_syscall_support.h	/^  long               st_ctime_;$/;"	m	struct:kernel_stat	access:public
kernel_stat::st_ctime_	src/base/linux_syscall_support.h	/^  uint64_t           st_ctime_;$/;"	m	struct:kernel_stat	access:public
kernel_stat::st_ctime_	src/base/linux_syscall_support.h	/^  unsigned           st_ctime_;$/;"	m	struct:kernel_stat	access:public
kernel_stat::st_ctime_	src/base/linux_syscall_support.h	/^  unsigned long      st_ctime_;$/;"	m	struct:kernel_stat	access:public
kernel_stat::st_ctime_nsec_	src/base/linux_syscall_support.h	/^  long               st_ctime_nsec_;$/;"	m	struct:kernel_stat	access:public
kernel_stat::st_ctime_nsec_	src/base/linux_syscall_support.h	/^  uint64_t           st_ctime_nsec_;$/;"	m	struct:kernel_stat	access:public
kernel_stat::st_ctime_nsec_	src/base/linux_syscall_support.h	/^  unsigned           st_ctime_nsec_;$/;"	m	struct:kernel_stat	access:public
kernel_stat::st_ctime_nsec_	src/base/linux_syscall_support.h	/^  unsigned long      st_ctime_nsec_;$/;"	m	struct:kernel_stat	access:public
kernel_stat::st_dev	src/base/linux_syscall_support.h	/^  uint64_t           st_dev;$/;"	m	struct:kernel_stat	access:public
kernel_stat::st_dev	src/base/linux_syscall_support.h	/^  unsigned           st_dev;$/;"	m	struct:kernel_stat	access:public
kernel_stat::st_dev	src/base/linux_syscall_support.h	/^  unsigned long      st_dev;$/;"	m	struct:kernel_stat	access:public
kernel_stat::st_dev	src/base/linux_syscall_support.h	/^  unsigned long long st_dev;$/;"	m	struct:kernel_stat	access:public
kernel_stat::st_dev	src/base/linux_syscall_support.h	/^  unsigned short     st_dev;$/;"	m	struct:kernel_stat	access:public
kernel_stat::st_gid	src/base/linux_syscall_support.h	/^  unsigned           st_gid;$/;"	m	struct:kernel_stat	access:public
kernel_stat::st_gid	src/base/linux_syscall_support.h	/^  unsigned int       st_gid;$/;"	m	struct:kernel_stat	access:public
kernel_stat::st_gid	src/base/linux_syscall_support.h	/^  unsigned short     st_gid;$/;"	m	struct:kernel_stat	access:public
kernel_stat::st_ino	src/base/linux_syscall_support.h	/^  uint64_t           st_ino;$/;"	m	struct:kernel_stat	access:public
kernel_stat::st_ino	src/base/linux_syscall_support.h	/^  unsigned           st_ino;$/;"	m	struct:kernel_stat	access:public
kernel_stat::st_ino	src/base/linux_syscall_support.h	/^  unsigned long      st_ino;$/;"	m	struct:kernel_stat	access:public
kernel_stat::st_ino	src/base/linux_syscall_support.h	/^  unsigned long long st_ino;$/;"	m	struct:kernel_stat	access:public
kernel_stat::st_mode	src/base/linux_syscall_support.h	/^  unsigned           st_mode;$/;"	m	struct:kernel_stat	access:public
kernel_stat::st_mode	src/base/linux_syscall_support.h	/^  unsigned int       st_mode;$/;"	m	struct:kernel_stat	access:public
kernel_stat::st_mode	src/base/linux_syscall_support.h	/^  unsigned long      st_mode;$/;"	m	struct:kernel_stat	access:public
kernel_stat::st_mode	src/base/linux_syscall_support.h	/^  unsigned short     st_mode;$/;"	m	struct:kernel_stat	access:public
kernel_stat::st_mtim	src/base/linux_syscall_support.h	/^  kernel_timespec    st_mtim;$/;"	m	struct:kernel_stat	access:public
kernel_stat::st_mtime_	src/base/linux_syscall_support.h	/^  long               st_mtime_;$/;"	m	struct:kernel_stat	access:public
kernel_stat::st_mtime_	src/base/linux_syscall_support.h	/^  uint64_t           st_mtime_;$/;"	m	struct:kernel_stat	access:public
kernel_stat::st_mtime_	src/base/linux_syscall_support.h	/^  unsigned           st_mtime_;$/;"	m	struct:kernel_stat	access:public
kernel_stat::st_mtime_	src/base/linux_syscall_support.h	/^  unsigned long      st_mtime_;$/;"	m	struct:kernel_stat	access:public
kernel_stat::st_mtime_nsec_	src/base/linux_syscall_support.h	/^  long               st_mtime_nsec_;$/;"	m	struct:kernel_stat	access:public
kernel_stat::st_mtime_nsec_	src/base/linux_syscall_support.h	/^  uint64_t           st_mtime_nsec_;$/;"	m	struct:kernel_stat	access:public
kernel_stat::st_mtime_nsec_	src/base/linux_syscall_support.h	/^  unsigned           st_mtime_nsec_;$/;"	m	struct:kernel_stat	access:public
kernel_stat::st_mtime_nsec_	src/base/linux_syscall_support.h	/^  unsigned long      st_mtime_nsec_;$/;"	m	struct:kernel_stat	access:public
kernel_stat::st_nlink	src/base/linux_syscall_support.h	/^  uint64_t           st_nlink;$/;"	m	struct:kernel_stat	access:public
kernel_stat::st_nlink	src/base/linux_syscall_support.h	/^  unsigned           st_nlink;$/;"	m	struct:kernel_stat	access:public
kernel_stat::st_nlink	src/base/linux_syscall_support.h	/^  unsigned int       st_nlink;$/;"	m	struct:kernel_stat	access:public
kernel_stat::st_nlink	src/base/linux_syscall_support.h	/^  unsigned long      st_nlink;$/;"	m	struct:kernel_stat	access:public
kernel_stat::st_nlink	src/base/linux_syscall_support.h	/^  unsigned short     st_nlink;$/;"	m	struct:kernel_stat	access:public
kernel_stat::st_pad1	src/base/linux_syscall_support.h	/^  int                st_pad1[3];$/;"	m	struct:kernel_stat	access:public
kernel_stat::st_pad2	src/base/linux_syscall_support.h	/^  int                st_pad2[2];$/;"	m	struct:kernel_stat	access:public
kernel_stat::st_pad3	src/base/linux_syscall_support.h	/^  int                st_pad3;$/;"	m	struct:kernel_stat	access:public
kernel_stat::st_pad4	src/base/linux_syscall_support.h	/^  int                st_pad4[14];$/;"	m	struct:kernel_stat	access:public
kernel_stat::st_rdev	src/base/linux_syscall_support.h	/^  uint64_t           st_rdev;$/;"	m	struct:kernel_stat	access:public
kernel_stat::st_rdev	src/base/linux_syscall_support.h	/^  unsigned           st_rdev;$/;"	m	struct:kernel_stat	access:public
kernel_stat::st_rdev	src/base/linux_syscall_support.h	/^  unsigned long      st_rdev;$/;"	m	struct:kernel_stat	access:public
kernel_stat::st_rdev	src/base/linux_syscall_support.h	/^  unsigned long long st_rdev;$/;"	m	struct:kernel_stat	access:public
kernel_stat::st_rdev	src/base/linux_syscall_support.h	/^  unsigned short     st_rdev;$/;"	m	struct:kernel_stat	access:public
kernel_stat::st_size	src/base/linux_syscall_support.h	/^  int64_t            st_size;$/;"	m	struct:kernel_stat	access:public
kernel_stat::st_size	src/base/linux_syscall_support.h	/^  long               st_size;$/;"	m	struct:kernel_stat	access:public
kernel_stat::st_size	src/base/linux_syscall_support.h	/^  long long          st_size;$/;"	m	struct:kernel_stat	access:public
kernel_stat::st_size	src/base/linux_syscall_support.h	/^  unsigned           st_size;$/;"	m	struct:kernel_stat	access:public
kernel_stat::st_size	src/base/linux_syscall_support.h	/^  unsigned long      st_size;$/;"	m	struct:kernel_stat	access:public
kernel_stat::st_uid	src/base/linux_syscall_support.h	/^  unsigned           st_uid;$/;"	m	struct:kernel_stat	access:public
kernel_stat::st_uid	src/base/linux_syscall_support.h	/^  unsigned int       st_uid;$/;"	m	struct:kernel_stat	access:public
kernel_stat::st_uid	src/base/linux_syscall_support.h	/^  unsigned short     st_uid;$/;"	m	struct:kernel_stat	access:public
kernel_timespec	src/base/linux_syscall_support.h	/^struct kernel_timespec {$/;"	s
kernel_timespec::tv_nsec	src/base/linux_syscall_support.h	/^  long               tv_nsec;$/;"	m	struct:kernel_timespec	access:public
kernel_timespec::tv_sec	src/base/linux_syscall_support.h	/^  long               tv_sec;$/;"	m	struct:kernel_timespec	access:public
kernel_timeval	src/base/linux_syscall_support.h	/^struct kernel_timeval {$/;"	s
kernel_timeval::tv_sec	src/base/linux_syscall_support.h	/^  long               tv_sec;$/;"	m	struct:kernel_timeval	access:public
kernel_timeval::tv_usec	src/base/linux_syscall_support.h	/^  long               tv_usec;$/;"	m	struct:kernel_timeval	access:public
key	src/addressmap-inl.h	/^    Key    key;$/;"	m	struct:AddressMap::Entry	access:public
key	src/tests/heap-checker_unittest.cc	/^static pthread_key_t key[kKeys];$/;"	v	file:
key_for_destr_fn_arg	src/windows/port.cc	/^  pthread_key_t key_for_destr_fn_arg;$/;"	m	struct:DestrFnClosure	file:	access:public
key_init_has_run	src/tests/heap-checker_unittest.cc	/^static bool key_init_has_run = false;$/;"	v	file:
kint16max	src/base/basictypes.h	/^const  int16 kint16max  = (   ( int16) 0x7FFF);$/;"	v
kint16min	src/base/basictypes.h	/^const  int16 kint16min  = (   ( int16) 0x8000);$/;"	v
kint32max	src/base/basictypes.h	/^const  int32 kint32max  = (   ( int32) 0x7FFFFFFF);$/;"	v
kint32min	src/base/basictypes.h	/^const  int32 kint32min  = (   ( int32) 0x80000000);$/;"	v
kint64max	src/base/basictypes.h	/^const  int64 kint64max =  ( ((( int64) kint32max) << 32) | kuint32max );$/;"	v
kint64min	src/base/basictypes.h	/^const  int64 kint64min =  ( (((uint64) kint32min) << 32) | 0 );$/;"	v
kint8max	src/base/basictypes.h	/^const  int8  kint8max   = (   (  int8) 0x7F);$/;"	v
kint8min	src/base/basictypes.h	/^const  int8  kint8min   = (   (  int8) 0x80);$/;"	v
kuint16max	src/base/basictypes.h	/^const uint16 kuint16max = (   (uint16) 0xFFFF);$/;"	v
kuint32max	src/base/basictypes.h	/^const uint32 kuint32max = (   (uint32) 0xFFFFFFFF);$/;"	v
kuint64max	src/base/basictypes.h	/^const uint64 kuint64max = ( (((uint64) kuint32max) << 32) | kuint32max );$/;"	v
l	benchmark/binary_trees.cc	/^  Node *l, *r;$/;"	m	struct:Node	file:	access:public
l	src/tests/markidle_unittest-testutil.o	/^/;"	v
l	src/tests/memalign_debug_unittest-testutil.o	/^/;"	v
l	src/tests/memalign_unittest-testutil.o	/^/;"	v
l	src/tests/tcmalloc_and_profiler_unittest-testutil.o	/^/;"	v
l	src/tests/tcmalloc_both_unittest-testutil.o	/^/;"	v
l	src/tests/tcmalloc_debug_unittest-testutil.o	/^/;"	v
l	src/tests/tcmalloc_minimal_debug_unittest-testutil.o	/^/;"	v
l	src/tests/tcmalloc_minimal_unittest-testutil.o	/^/;"	v
l	src/tests/tcmalloc_unittest-testutil.o	/^/;"	v
l	src/tests/thread_dealloc_unittest-testutil.o	/^/;"	v
large_	src/page_heap.h	/^  SpanList large_;$/;"	m	class:tcmalloc::PageHeap	access:private
large_alloc_threshold	src/tcmalloc.cc	/^static int64_t large_alloc_threshold =$/;"	m	namespace:__anon3	file:
last_dump_alloc	src/heap-profiler.cc	/^static int64 last_dump_alloc = 0;     \/\/ alloc_size when did we last dump$/;"	v	file:
last_dump_free	src/heap-profiler.cc	/^static int64 last_dump_free = 0;      \/\/ free_size when did we last dump$/;"	v	file:
last_dump_time	src/heap-profiler.cc	/^static int64 last_dump_time = 0;      \/\/ The time of the last dump$/;"	v	file:
later	docs/pprof_remote_servers.html	/^some number of seconds later, call <code>GetHeapProfile()<\/code>$/;"	v
later	docs/pprof_remote_servers.html	/^then, XX seconds later, calling <code>ProfilerStop()<\/code>.  (These$/;"	v
layout_ppc	src/stacktrace_powerpc-inl.h	/^struct layout_ppc {$/;"	s
layout_ppc	src/stacktrace_powerpc-linux-inl.h	/^struct layout_ppc {$/;"	s
layout_ppc::condition_register	src/stacktrace_powerpc-inl.h	/^  long condition_register;$/;"	m	struct:layout_ppc	access:public
layout_ppc::condition_register	src/stacktrace_powerpc-linux-inl.h	/^  long condition_register;$/;"	m	struct:layout_ppc	access:public
layout_ppc::next	src/stacktrace_powerpc-inl.h	/^  struct layout_ppc *next;$/;"	m	struct:layout_ppc	typeref:struct:layout_ppc::layout_ppc	access:public
layout_ppc::next	src/stacktrace_powerpc-linux-inl.h	/^  struct layout_ppc *next;$/;"	m	struct:layout_ppc	typeref:struct:layout_ppc::layout_ppc	access:public
layout_ppc::return_addr	src/stacktrace_powerpc-inl.h	/^  void *return_addr;$/;"	m	struct:layout_ppc	access:public
layout_ppc::return_addr	src/stacktrace_powerpc-linux-inl.h	/^  void *return_addr;$/;"	m	struct:layout_ppc	access:public
left_	src/base/low_level_alloc.cc	/^        : left_(false), mask_valid_(false), arena_(arena) {$/;"	p	class:__anon39::ArenaLock	file:	access:public	signature:(false)
left_	src/base/low_level_alloc.cc	/^    bool left_;       \/\/ whether left region$/;"	m	class:__anon39::ArenaLock	file:	access:private
left_	src/internal_logging.h	/^  int   left_;          \/\/ Space left in buffer (including space for \\0)$/;"	m	class:TCMalloc_Printer	access:private
len	src/tests/low_level_alloc_unittest.cc	/^  int len;        \/\/ number of bytes$/;"	m	struct:BlockDesc	file:	access:public
length	src/central_freelist.h	/^  int length() {$/;"	f	class:tcmalloc::CentralFreeList	access:public	signature:()
length	src/gperftools/malloc_extension.h	/^  size_t length;        \/\/ Byte length of range$/;"	m	struct:base::MallocRange	access:public
length	src/raw_printer.h	/^  int length() const { return (ptr_ - base_); }$/;"	f	class:base::RawPrinter	access:public	signature:() const
length	src/span.h	/^  Length        length;         \/\/ Number of pages in span$/;"	m	struct:tcmalloc::Span	access:public
length	src/thread_cache.h	/^    size_t length() const {$/;"	f	class:tcmalloc::ThreadCache::FreeList	access:public	signature:() const
length_	src/thread_cache.h	/^    uint16_t length_;$/;"	m	class:tcmalloc::ThreadCache::FreeList	access:private
length_	src/thread_cache.h	/^    uint32_t length_;      \/\/ Current length.$/;"	m	class:tcmalloc::ThreadCache::FreeList	access:private
length_overages	src/thread_cache.h	/^    size_t length_overages() const {$/;"	f	class:tcmalloc::ThreadCache::FreeList	access:public	signature:() const
length_overages_	src/thread_cache.h	/^    uint16_t length_overages_;$/;"	m	class:tcmalloc::ThreadCache::FreeList	access:private
length_overages_	src/thread_cache.h	/^    uint32_t length_overages_;$/;"	m	class:tcmalloc::ThreadCache::FreeList	access:private
levels	src/base/low_level_alloc.cc	/^    int levels;           \/\/ levels in skiplist used$/;"	m	struct:low_level_alloc_internal::AllocList	file:	access:public
libaries	TODO	/^   shared libaries(), and get rid of the profile-naming hack once we$/;"	p	file:	signature:()
libaries	TODO	/^   shared libaries, and get rid of the profile-naming hack once we$/;"	v
libc	README_windows.txt	/^libc, and replace its malloc with tcmalloc' approach, mentioned above,$/;"	v
libc	README_windows.txt	/^with libc, and then replace its malloc with tcmalloc.  This allows you$/;"	v
libc1	src/windows/patch_functions.cc	/^static LibcInfoWithPatchFunctions<1> libc1;$/;"	m	namespace:__anon13	file:
libc2	src/windows/patch_functions.cc	/^static LibcInfoWithPatchFunctions<2> libc2;$/;"	m	namespace:__anon13	file:
libc3	src/windows/patch_functions.cc	/^static LibcInfoWithPatchFunctions<3> libc3;$/;"	m	namespace:__anon13	file:
libc4	src/windows/patch_functions.cc	/^static LibcInfoWithPatchFunctions<4> libc4;$/;"	m	namespace:__anon13	file:
libc5	src/windows/patch_functions.cc	/^static LibcInfoWithPatchFunctions<5> libc5;$/;"	m	namespace:__anon13	file:
libc6	src/windows/patch_functions.cc	/^static LibcInfoWithPatchFunctions<6> libc6;$/;"	m	namespace:__anon13	file:
libc7	src/windows/patch_functions.cc	/^static LibcInfoWithPatchFunctions<7> libc7;$/;"	m	namespace:__anon13	file:
libc8	src/windows/patch_functions.cc	/^static LibcInfoWithPatchFunctions<8> libc8;$/;"	m	namespace:__anon13	file:
libgcc_backtrace_data	src/stacktrace_libgcc-inl.h	/^struct libgcc_backtrace_data {$/;"	s
libgcc_backtrace_data::array	src/stacktrace_libgcc-inl.h	/^  void **array;$/;"	m	struct:libgcc_backtrace_data	access:public
libgcc_backtrace_data::limit	src/stacktrace_libgcc-inl.h	/^  int limit;$/;"	m	struct:libgcc_backtrace_data	access:public
libgcc_backtrace_data::pos	src/stacktrace_libgcc-inl.h	/^  int pos;$/;"	m	struct:libgcc_backtrace_data	access:public
libgcc_backtrace_data::skip	src/stacktrace_libgcc-inl.h	/^  int skip;$/;"	m	struct:libgcc_backtrace_data	access:public
libgcc_backtrace_helper	src/stacktrace_libgcc-inl.h	/^static _Unwind_Reason_Code libgcc_backtrace_helper(struct _Unwind_Context *ctx,$/;"	f	signature:(struct _Unwind_Context *ctx, void *_data)
libname_spec	m4/libtool.m4	/^  libname_spec='$name'$/;"	v
libprofiler	docs/cpuprofile.html	/^       <code>\/bin\/ls<\/code> that had been linked against libprofiler,$/;"	v
libprofiler	docs/cpuprofile.html	/^       been linked against libprofiler, you could run:<\/p>$/;"	v
libpthread_initialized	src/memory_region_map.cc	/^static bool libpthread_initialized = false;$/;"	v	file:
library	README	/^Instead, use the special libtcmalloc_and_profiler library, which we$/;"	v	file:
library	README	/^library, this two-library linking won't work:$/;"	v	file:
library_live_objects	src/heap-checker.cc	/^static LibraryLiveObjectsStacks* library_live_objects = NULL;$/;"	v	file:
library_names_spec	m4/libtool.m4	/^      library_names_spec='`echo ${libname} | sed -e 's\/^lib\/pw\/'``echo ${release} | $SED -e 's\/[[.]]\/-\/g'`${versuffix}${shared_ext}'$/;"	v
library_names_spec	m4/libtool.m4	/^    library_names_spec='$libname.dll.a'$/;"	v
library_names_spec	m4/libtool.m4	/^    library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${shared_ext}$versuffix'$/;"	v
library_names_spec	m4/libtool.m4	/^  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${shared_ext}$versuffix'$/;"	v
library_names_spec	m4/libtool.m4	/^  library_names_spec='${libname}${shared_ext}'$/;"	v
libunwind	INSTALL	/^There have been reports of crashes with libunwind 0.99 (see$/;"	p	file:	signature:(see http: Alternately, you can use a more recent libunwind (e.g. 1.0.1) at the cost of adding a bit of boilerplate to your code. For details, see http: CAUTION: if you install libunwind from the url above, be aware that you may have trouble if you try to statically link your binary with perftools: that is, if you link with Ã. This is because both libunwind and libgcc implement the same C++ exception handling APIs, but they implement them differently on some platforms. This is not likely to be a problem on ia64, but may be on x86-64. Also, if you link binaries statically, make sure that you add -Wl,--eh-frame-hdr to your linker options. This is required so that libunwind can find the information generated by the compiler required for stack unwinding. Using -static is rare, though, so unless you know this will affect you it probably wonÃ If you cannot or do not wish to install libunwind, you can still try to use the built-in stack unwinder. The built-in stack unwinder requires that your application, the tcmalloc library, and system libraries like libc, all be compiled with a frame pointer. This is *not* the default for x86-64. If you are on x86-64 system, know that you have a set of system libraries with frame-pointers enabled, and compile all your applications with -fno-omit-frame-pointer, then you can enable the built-in perftools stack unwinder by passing the --enable-frame-pointers flag to configure. Even with the use of libunwind, there are still known problems with stack unwinding on 64-bit systems, particularly x86-64. See the Ó section in README. If you encounter problems, try compiling perftools with Ã --enable-frame-pointersÃ application with frame pointers (via Ã ...Ã *** TCMALLOC LARGE PAGES: TRADING TIME FOR SPACE You can set a compiler directive that makes tcmalloc faster, at the cost of using more space (due to internal fragmentation). Internally, tcmalloc divides its memory into Ó The default page size is chosen to minimize memory use by reducing fragmentation. The cost is that keeping track of these pages can cost tcmalloc time. WeÃ In general, this will increase the memory needs of applications using tcmalloc. However, in many cases it will speed up the applications as well, particularly if they allocate and free a lot of memory. WeÃ seen average speedups of 3-5% on Google applications. To build libtcmalloc with large pages you need to use the --with-tcmalloc-pagesize=ARG configure flag, e.g.: ./configure <other flags> --with-tcmalloc-pagesize=32 The ARG argument can be 8, 32 or 64 which sets the internal page size to 8K, 32K and 64K repectively. The default is 8K. *** SMALL TCMALLOC CACHES: TRADING SPACE FOR TIME You can set a compiler directive that makes tcmalloc use less memory for overhead, at the cost of some time. Internally, tcmalloc keeps information about some of its internal data structures in a cache. This speeds memory operations that need to access this internal data. WeÃ tcmalloc that reduces the size of this cache, decresaing the memory needs of applications using tcmalloc. This feature is still very experimental; itÃ flag yet. To build libtcmalloc with smaller internal caches, run ./configure <normal flags> CXXFLAGS=-DTCMALLOC_SMALL_BUT_SLOW (or add -DTCMALLOC_SMALL_BUT_SLOW to your existing CXXFLAGS argument). *** NOTE FOR ___tls_get_addr ERROR When compiling perftools on some old systems, like RedHat 8, you may get an error like this: ___tls_get_addr: symbol not found This means that you have a system where some parts are updated enough to support Thread Local Storage, but others are not. The perftools configure script canÃ that error. To fix it, just comment out the line in your config.h file before building. *** TCMALLOC AND DLOPEN To improve performance, we use the Ó model of Thread Local Storage in tcmalloc. The price for this is the library will not work correctly if it is loaded via dlopen(). This should not be a problem, since loading a malloc-replacement library via dlopen is asking for trouble in any case: some data will be allocated with one malloc, some with another. If, for some reason, you *do* need to use dlopen on tcmalloc, the easiest way is to use a version of tcmalloc with TLS turned off; see the ___tls_get_addr note above. *** COMPILING ON NON-LINUX SYSTEMS Perftools has been tested on the following systems: FreeBSD 6.0 (x86) FreeBSD 8.1 (x86_64) Linux CentOS 5.5 (x86_64) Linux Debian 4.0 (PPC) Linux Debian 5.0 (x86) Linux Fedora Core 3 (x86) Linux Fedora Core 4 (x86) Linux Fedora Core 5 (x86) Linux Fedora Core 6 (x86) Linux Fedora Core 13 (x86_64) Linux Fedora Core 14 (x86_64) Linux RedHat 9 (x86) Linux Slackware 13 (x86_64) Linux Ubuntu 6.06.1 (x86) Linux Ubuntu 6.06.1 (x86_64) Linux Ubuntu 10.04 (x86) Linux Ubuntu 10.10 (x86_64) Mac OS X 10.3.9 (Panther) (PowerPC) Mac OS X 10.4.8 (Tiger) (PowerPC) Mac OS X 10.4.8 (Tiger) (x86) Mac OS X 10.5 (Leopard) (x86) Mac OS X 10.6 (Snow Leopard) (x86) Solaris 10 (x86_64) Windows XP, Visual Studio 2003 (VC++ 7.1) (x86) Windows XP, Visual Studio 2005 (VC++ 8) (x86) Windows XP, Visual Studio 2005 (VC++ 9) (x86) Windows XP, Visual Studio 2005 (VC++ 10) (x86) Windows XP, MinGW 5.1.3 (x86) Windows XP, Cygwin 5.1 (x86) It works in its full generality on the Linux systems tested (though see 64-bit notes above). Portions of perftools work on the other systems. The basic memory-allocation library, tcmalloc_minimal, works on all systems. The cpu-profiler also works fairly widely. However, the heap-profiler and heap-checker are not yet as widely supported. In general, the Ã script will detect what OS you are building for, and only build the components that work on that OS. Note that tcmalloc_minimal is perfectly usable as a malloc/new replacement, so it is possible to use tcmalloc on all the systems above, by linking in libtcmalloc_minimal. ** FreeBSD: The following binaries build and run successfully (creating libtcmalloc_minimal.so and libprofile.so in the process): % ./configure % make tcmalloc_minimal_unittest tcmalloc_minimal_large_unittest \ addressmap_unittest atomicops_unittest frag_unittest \ low_level_alloc_unittest markidle_unittest memalign_unittest \ packed_cache_test stacktrace_unittest system_alloc_unittest \ thread_dealloc_unittest profiler_unittest.sh % ./tcmalloc_minimal_unittest # to run this test % [etc] # to run other tests Three caveats: first, frag_unittest tries to allocate 400M of memory, and if you have less virtual memory on your system, the test may fail with a bad_alloc exception. Second, profiler_unittest.sh sometimes fails in the Ó test. This is because stray SIGPROF signals from the parent process are making their way into the child process. (This may be a kernel bug that only exists in older kernels.) The profiling code itself is working fine. This only affects programs that call fork(); for most programs, the cpu profiler is entirely safe to use. Third, perftools depends on /proc to get shared library information. If you are running a FreeBSD system without proc, perftools will not be able to map addresses to functions. Some unittests will fail as a result. Finally, the new test introduced in perftools-1.2, profile_handler_unittest, fails on FreeBSD. It has something to do with how the itimer works. The cpu profiler test passes, so I believe the functionality is correct and the issue is with the test somehow. If anybody is an expert on itimers and SIGPROF in FreeBSD, and would like to debug this, IÃ be glad to hear the results! libtcmalloc.so successfully builds, and the Ó tcmalloc functionality all works except for the leak-checker, which has Linux-specific code: % make heap-profiler_unittest.sh maybe_threads_unittest.sh \ tcmalloc_unittest tcmalloc_both_unittest \ tcmalloc_large_unittest # THESE WORK % make -k heap-checker_unittest.sh \ heap-checker-death_unittest.sh # THESE DO NOT Note that unless you specify --enable-heap-checker explicitly, Ã will not build the heap-checker unittests on a FreeBSD system. I have not tested other *BSD systems, but they are probably similar. ** Mac OS X: IÃ [Panther] on both intel (x86) and PowerPC systems. For Panther systems, perftools does not work at all: it depends on a header file, OSAtomic.h, which is new in 10.4. (ItÃ code working for Panther/i386 without too much work; if youÃ interested in exploring this, drop an e-mail.) For the other seven systems, the binaries and libraries that successfully build are exactly the same as for FreeBSD. See that section for a list of binaries and instructions on building them. In addition, it appears OS X regularly fails profiler_unittest.sh in the Ó test (in addition to occassionally failing in the Ó test). It looks like OS X often delivers the profiling signal to the main thread, even when itÃ spawned threads that are doing actual work. If anyone knows details of how OS X handles SIGPROF (via setitimer()) events with threads, and has insight into this problem, please send mail to google-perftools@googlegroups.com. ** Solaris 10 x86: IÃ compiler. Using g++ requires setting the PATH appropriately when configuring. % PATH=${PATH}:/usr/sfw/bin/:/usr/ccs/bin ./configure % PATH=${PATH}:/usr/sfw/bin/:/usr/ccs/bin make [...] Again, the binaries and libraries that successfully build are exactly the same as for FreeBSD. (However, while libprofiler.so can be used to generate profiles, pprof is not very successful at reading them -- necessary helper programs like nm donÃ to be installed by default on Solaris, or perhaps are only installed as part of the Sun C++ compiler package.) See that section for a list of binaries, and instructions on building them. ** Windows (MSVC, Cygwin, and MinGW): Work on Windows is rather preliminary: only tcmalloc_minimal is supported. We havenÃ windows (that is, when FPO is enabled), so the heap profiling may not be reliable in that case. Also, heap-checking and CPU profiling do not yet work at all. But as in other ports, the basic tcmalloc library functionality, overriding malloc and new and such (and even windows-specific functions like _aligned_malloc!), is working fine, at least with VC++ 7.1 (Visual Studio 2003) through VC++ 10.0, in both debug and release modes. See README.windows for instructions on how to install on Windows using Visual Studio. Cygwin can compile some but not all of perftools. Furthermore, there is a problem with exception-unwinding in cygwin (it can call malloc, which can call the exception-unwinding-setup code, which can lead to an infinite loop). IÃ exception unwinding problem, but it only works in debug mode and when statically linking in tcmalloc. I hope to have a more proper fix in a later release. To configure under cygwin, run ./configure --disable-shared CXXFLAGS=-g && make Most of cygwin will compile (cygwin doesnÃ the heap-checker and a few other pieces of functionality will not compile). Ã will compile those libraries and tests that can be compiled. You can run Ã to make sure the basic functionality is working. IÃ cygwin fail calls to pthread_join() with EINVAL, causing several tests to fail. If you have any insight into this, please mail google-perftools@googlegroups.com. This Windows functionality is also available using MinGW and Msys, In this case, you can use the regular Ã process. Ã should also work. The Makefile will limit itself to those libraries and binaries that work on windows. Basic Installation ================== These are generic installation instructions. The `configureÃ various system-dependent variables used during compilation. It uses those values to create a `MakefileÃ It may also create one or more `.hÃ definitions. Finally, it creates a shell script `config.statusÃ you can run in the future to recreate the current configuration, and a file `config.logÃ debugging `configureÃ It can also use an optional file (typically called `config.cacheÃ and enabled with `--cache-file=config.cacheÃ) that saves the results of its tests to speed up reconfiguring. (Caching is disabled by default to prevent problems with accidental use of stale cache files.) If you need to do unusual things to compile the package, please try to figure out how `configureÃ diffs or instructions to the address given in the `READMEÃ be considered for the next release. If you are using the cache, and at some point `config.cacheÃt want to keep, you may remove or edit it. The file `configure.acÃ) is used to create `configureÃ. You only need `configure.acÃ using a newer version of `autoconfÃ The simplest way to compile this package is: 1. `cdÃs source code and type `./configureÃre using `cshÃ `sh ./configureÃ from trying to execute `configureÃ Running `configureÃ messages telling which features it is checking for. 2. Type `makeÃ 3. Optionally, type `make checkÃ the package. 4. Type `make installÃ documentation. 5. You can remove the program binaries and object files from the source code directory by typing `make cleanÃ files that `configureÃ a different kind of computer)
lie	m4/libtool.m4	/^	  _LT_TAGVAR(hardcode_direct, $1)=no #Motorola manual says yes, but my tests say they lie$/;"	v
limit	src/stacktrace_libgcc-inl.h	/^  int limit;$/;"	m	struct:libgcc_backtrace_data	access:public
limit_	src/raw_printer.h	/^  char* limit_;         \/\/ One past last non-\\0 char we can write$/;"	m	class:base::RawPrinter	access:private
link_base_	src/base/elf_mem_image.h	/^  ElfW(Addr) link_base_;     \/\/ Link-time base (p_vaddr of first PT_LOAD).$/;"	m	class:base::ElfMemImage	access:private
linux_per_thread_timers_mode_	src/tests/profile-handler_unittest.cc	/^static bool linux_per_thread_timers_mode_ = false;$/;"	m	namespace:__anon56	file:
list	docs/tcmalloc.html	/^    fetch min(max_length, num_objects_to_move) from central list;$/;"	m	class:object	file:	access:private
list	docs/tcmalloc.html	/^in the next free list, and so forth.  Eventually, we look in the last$/;"	m	class:object	file:	access:private
list	src/tests/malloc_hook_test.cc	/^static TestHookList list = INIT_HOOK_LIST(69);$/;"	m	namespace:__anon57	file:
list_	src/thread_cache.h	/^    void*    list_;       \/\/ Linked list of nodes$/;"	m	class:tcmalloc::ThreadCache::FreeList	access:private
list_	src/thread_cache.h	/^  FreeList      list_[kClassSizesMax];     \/\/ Array indexed by size-class$/;"	m	class:tcmalloc::ThreadCache	access:private
live	src/heap-profile-table.h	/^    bool live() const { return bucket_rep & kLive; }$/;"	f	struct:HeapProfileTable::AllocValue	access:public	signature:() const
live	src/heap-profile-table.h	/^    bool live;$/;"	m	struct:HeapProfileTable::AllocInfo	access:public
live_bytes_total	src/heap-checker.cc	/^static int64 live_bytes_total;$/;"	v	file:
live_leak_const_set	src/tests/heap-checker_unittest.cc	/^static const set<int> live_leak_const_set(set_data, set_data+14);$/;"	p	file:	signature:(set_data, set_data+14)
live_leak_set	src/tests/heap-checker_unittest.cc	/^static set<int> live_leak_set(set_data, set_data+7);$/;"	p	file:	signature:(set_data, set_data+7)
live_objects	src/heap-checker.cc	/^static LiveObjectsStack* live_objects = NULL;$/;"	v	file:
live_objects	src/tests/heap-checker_unittest.cc	/^static list<void*>* live_objects = new list<void*>;$/;"	v	file:
live_objects_total	src/heap-checker.cc	/^static int64 live_objects_total;$/;"	v	file:
lm	docs/cpuprofile-fileformat.html	/^    var lm = new Date(document.lastModified);$/;"	v
lm	docs/cpuprofile.html	/^    var lm = new Date(document.lastModified);$/;"	v
lm	docs/heap_checker.html	/^    var lm = new Date(document.lastModified);$/;"	v
lm	docs/heapprofile.html	/^    var lm = new Date(document.lastModified);$/;"	v
lo	src/base/elfcore.h	/^    unsigned long lo;$/;"	m	struct:mips_regs	access:public
local_atoi	src/base/linuxthreads.cc	/^static int local_atoi(const char *s) {$/;"	f	file:	signature:(const char *s)
local_clone	src/base/linuxthreads.cc	/^static int local_clone (int (*fn)(void *), void *arg, ...) {$/;"	f	file:	signature:(int (*fn)(void *), void *arg, ...)
local_clone	src/base/linuxthreads.cc	/^static int local_clone (int (*fn)(void *), void *arg, ...)$/;"	p	file:	signature:(int (*fn)(void *), void *arg, ...)
local_itoa	src/base/linuxthreads.cc	/^static char *local_itoa(char *buf, int i) {$/;"	f	file:	signature:(char *buf, int i)
location	src/span.h	/^  unsigned int  location : 2;   \/\/ Is the span on a freelist, and if so, which?$/;"	m	struct:tcmalloc::Span	access:public
lock	src/base/linuxthreads.cc	/^  sem_t       *lock;$/;"	m	struct:ListerParams	file:	access:public
lock_	src/base/spinlock.h	/^  SpinLock* lock_;$/;"	m	class:SpinLockHolder	access:private
lock_	src/central_freelist.h	/^  SpinLock lock_;$/;"	m	class:tcmalloc::CentralFreeList	access:private
lock_	src/gperftools/heap-checker.h	/^  class SpinLock* lock_;  \/\/ to make HeapLeakChecker objects thread-safe$/;"	m	class:HeapLeakChecker	typeref:class:HeapLeakChecker::SpinLock	access:private
lock_	src/memory_region_map.cc	/^SpinLock MemoryRegionMap::lock_(SpinLock::LINKER_INITIALIZED);$/;"	p	class:MemoryRegionMap	file:	signature:(SpinLock::LINKER_INITIALIZED)
lock_	src/memory_region_map.h	/^  static SpinLock lock_;$/;"	m	class:MemoryRegionMap	access:private
lock_	src/profiler.cc	/^  SpinLock      lock_;$/;"	m	class:CpuProfiler	file:	access:private
lock_	src/tests/tcmalloc_unittest.cc	/^  Mutex                 lock_;          \/\/ For passing in another thread's obj$/;"	m	class:testing::TesterThread	file:	access:private
lock_owner_tid_	src/memory_region_map.cc	/^pthread_t MemoryRegionMap::lock_owner_tid_;  \/\/ GUARDED_BY(owner_lock_)$/;"	m	class:MemoryRegionMap	file:
lock_owner_tid_	src/memory_region_map.h	/^  static pthread_t lock_owner_tid_;$/;"	m	class:MemoryRegionMap	access:private
locks_failed_	src/tests/tcmalloc_unittest.cc	/^  int                   locks_failed_;  \/\/ Number of failed TryLock() ops$/;"	m	class:testing::TesterThread	file:	access:private
locks_ok_	src/tests/tcmalloc_unittest.cc	/^  int                   locks_ok_;      \/\/ Number of OK TryLock() ops$/;"	m	class:testing::TesterThread	file:	access:private
lockword_	src/base/spinlock.h	/^  volatile Atomic32 lockword_;$/;"	m	class:SpinLock	access:private
log_message_writer	src/internal_logging.cc	/^void (*log_message_writer)(const char* msg, int length) = WriteMessage;$/;"	m	namespace:tcmalloc	file:
low_level_alloc_internal	src/base/low_level_alloc.cc	/^namespace low_level_alloc_internal {$/;"	n	file:
low_level_alloc_internal::AllocList	src/base/low_level_alloc.cc	/^  struct AllocList {$/;"	s	namespace:low_level_alloc_internal	file:
low_level_alloc_internal::AllocList::Header	src/base/low_level_alloc.cc	/^    struct Header {$/;"	s	struct:low_level_alloc_internal::AllocList	file:	access:public
low_level_alloc_internal::AllocList::Header::arena	src/base/low_level_alloc.cc	/^      LowLevelAlloc::Arena *arena; \/\/ pointer to parent arena$/;"	m	struct:low_level_alloc_internal::AllocList::Header	file:	access:public
low_level_alloc_internal::AllocList::Header::dummy_for_alignment	src/base/low_level_alloc.cc	/^      void *dummy_for_alignment;   \/\/ aligns regions to 0 mod 2*sizeof(void*)$/;"	m	struct:low_level_alloc_internal::AllocList::Header	file:	access:public
low_level_alloc_internal::AllocList::Header::magic	src/base/low_level_alloc.cc	/^      intptr_t magic; \/\/ kMagicAllocated or kMagicUnallocated xor this$/;"	m	struct:low_level_alloc_internal::AllocList::Header	file:	access:public
low_level_alloc_internal::AllocList::Header::size	src/base/low_level_alloc.cc	/^      intptr_t size;  \/\/ size of entire region, including this field. Must be$/;"	m	struct:low_level_alloc_internal::AllocList::Header	file:	access:public
low_level_alloc_internal::AllocList::header	src/base/low_level_alloc.cc	/^    } header;$/;"	m	struct:low_level_alloc_internal::AllocList	typeref:struct:low_level_alloc_internal::AllocList::Header	file:	access:public
low_level_alloc_internal::AllocList::levels	src/base/low_level_alloc.cc	/^    int levels;           \/\/ levels in skiplist used$/;"	m	struct:low_level_alloc_internal::AllocList	file:	access:public
low_level_alloc_internal::AllocList::next	src/base/low_level_alloc.cc	/^    AllocList *next[kMaxLevel];   \/\/ actually has levels elements.$/;"	m	struct:low_level_alloc_internal::AllocList	file:	access:public
lowater_	src/thread_cache.h	/^    uint16_t lowater_;$/;"	m	class:tcmalloc::ThreadCache::FreeList	access:private
lowater_	src/thread_cache.h	/^    uint32_t lowater_;     \/\/ Low water mark for list length.$/;"	m	class:tcmalloc::ThreadCache::FreeList	access:private
lowwatermark	src/thread_cache.h	/^    int lowwatermark() const { return lowater_; }$/;"	f	class:tcmalloc::ThreadCache::FreeList	access:public	signature:() const
lr	src/base/elfcore.h	/^    unsigned long lr;$/;"	m	struct:ppc_regs	access:public
lseek	src/base/linux_syscall_support.h	/^    LSS_INLINE off_t LSS_NAME(lseek)(int f, off_t o, int w) {$/;"	f	signature:(int f, off_t o, int w)
lseek	src/windows/port.h	/^inline off_t lseek(int fd, off_t offset, int whence) {$/;"	f	signature:(int fd, off_t offset, int whence)
lt	docs/heap_checker.html	/^<code>&lt;gperftools\/heap-checker.h&gt;<\/code>.$/;"	v
lt	docs/heap_checker.html	/^<code>&lt;prefix&gt;.&lt;name&gt;-end.heap<\/code>.$/;"	v
lt_SP2NL	m4/libtool.m4	/^  lt_SP2NL='tr \\100 \\n'$/;"	v
lt_cv_deplibs_check_method	m4/libtool.m4	/^      lt_cv_deplibs_check_method='file_magic (FreeBSD|OpenBSD|DragonFly)\/i[[3-9]]86 (compact )?demand paged shared library'$/;"	v
lt_cv_deplibs_check_method	m4/libtool.m4	/^    lt_cv_deplibs_check_method='file_magic ^x86 archive import|^x86 DLL'$/;"	v
lt_cv_deplibs_check_method	m4/libtool.m4	/^    lt_cv_deplibs_check_method='match_pattern \/lib[[^\/]]+(\\.so\\.[[0-9]]+\\.[[0-9]]+|\\.so|_pic\\.a)$'$/;"	v
lt_cv_deplibs_check_method	m4/libtool.m4	/^    lt_cv_deplibs_check_method='match_pattern \/lib[[^\/]]+(\\.so\\.[[0-9]]+\\.[[0-9]]+|_pic\\.a)$'$/;"	v
lt_cv_deplibs_check_method	m4/libtool.m4	/^    lt_cv_deplibs_check_method=pass_all$/;"	v
lt_cv_deplibs_check_method	m4/libtool.m4	/^  lt_cv_deplibs_check_method='file_magic ELF [[0-9]][[0-9]]*-bit [[ML]]SB (executable|dynamic lib)'$/;"	v
lt_cv_deplibs_check_method	m4/libtool.m4	/^  lt_cv_deplibs_check_method='file_magic ELF [[0-9]][[0-9]]*-bit [[ML]]SB (shared object|dynamic lib)'$/;"	v
lt_cv_deplibs_check_method	m4/libtool.m4	/^  lt_cv_deplibs_check_method='file_magic ^x86 archive import|^x86 DLL'$/;"	v
lt_cv_deplibs_check_method	m4/libtool.m4	/^  lt_cv_deplibs_check_method='file_magic file format pe-arm-.*little(.*architecture: arm)?'$/;"	v
lt_cv_deplibs_check_method	m4/libtool.m4	/^  lt_cv_deplibs_check_method='match_pattern \/lib[[^\/]]+(\\.so|\\.a)$'$/;"	v
lt_cv_deplibs_check_method	m4/libtool.m4	/^  lt_cv_deplibs_check_method=pass_all$/;"	v
lt_cv_dlopen	m4/libtool.m4	/^    lt_cv_dlopen="LoadLibrary"$/;"	v
lt_cv_dlopen	m4/libtool.m4	/^    lt_cv_dlopen="dlopen"$/;"	v
lt_cv_file_magic_cmd	m4/libtool.m4	/^    lt_cv_file_magic_cmd='\/bin\/file'$/;"	v
lt_cv_file_magic_test_file	m4/libtool.m4	/^    lt_cv_file_magic_test_file=\/usr\/lib\/pa20_64\/libc.sl$/;"	v
lt_cv_sys_global_symbol_pipe	m4/libtool.m4	/^    lt_cv_sys_global_symbol_pipe="$AWK ['"\\$/;"	v
lt_cv_sys_global_symbol_pipe	m4/libtool.m4	/^    lt_cv_sys_global_symbol_pipe=$/;"	v
lt_cv_sys_global_symbol_to_c_name_address	config.status	/^lt_cv_sys_global_symbol_to_c_name_address='sed -n -e '\\''s\/^: \\([^ ]*\\) $\/  {\\"\\1\\", (void *) 0},\/p'\\'' -e '\\''s\/^[ABCDGIRSTW]* \\([^ ]*\\) \\([^ ]*\\)$\/  {"\\2", (void *) \\&\\2},\/p'\\'''$/;"	v
lt_cv_sys_global_symbol_to_cdecl	m4/libtool.m4	/^  lt_cv_sys_global_symbol_to_cdecl=$/;"	v
lt_cv_sys_global_symbol_to_cdecl	m4/libtool.m4	/^lt_cv_sys_global_symbol_to_cdecl="sed -n -e 's\/^T .* \\(.*\\)$\/extern int \\1();\/p' -e 's\/^$symcode* .* \\(.*\\)$\/extern char \\1;\/p'"$/;"	v
lt_cv_sys_max_cmd_len	m4/libtool.m4	/^      lt_cv_sys_max_cmd_len=`\/sbin\/sysctl -n kern.argmax`$/;"	v
lt_cv_sys_max_cmd_len	m4/libtool.m4	/^      lt_cv_sys_max_cmd_len=`\/usr\/sbin\/sysctl -n kern.argmax`$/;"	v
lt_cv_sys_max_cmd_len	m4/libtool.m4	/^      lt_cv_sys_max_cmd_len=`echo $kargmax | sed 's\/.*[[	 ]]\/\/'`$/;"	v
lt_cv_sys_max_cmd_len	m4/libtool.m4	/^      lt_cv_sys_max_cmd_len=`expr $lt_cv_sys_max_cmd_len \\\/ 4`$/;"	v
lt_cv_sys_max_cmd_len	m4/libtool.m4	/^    lt_cv_sys_max_cmd_len=16384$/;"	v
lt_cv_sys_max_cmd_len	m4/libtool.m4	/^    lt_cv_sys_max_cmd_len=196608$/;"	v
lt_cv_sys_max_cmd_len	m4/libtool.m4	/^    lt_cv_sys_max_cmd_len=8192;$/;"	v
lt_ld_extra	m4/libtool.m4	/^    lt_ld_extra=`awk '\/^include \/ { system(sprintf("cd \/etc; cat %s 2>\/dev\/null", \\[$]2)); skip = 1; } { if (!skip) print \\[$]0; skip = 0; }' < \/etc\/ld.so.conf | $SED -e 's\/#.*\/\/;\/^[	 ]*hwcap[	 ]\/d;s\/[:,	]\/ \/g;s\/=[^=]*$\/\/;s\/=[^= ]* \/ \/g;\/^$\/d' | tr '\\n' ' '`$/;"	v
lt_preloaded_setup	m4/libtool.m4	/^static const void *lt_preloaded_setup() {$/;"	f	file:	signature:()
lt_user_locale	ltmain.sh	/^lt_user_locale=$/;"	v
m	src/windows/get_mangled_names.cc	/^static char m;   \/\/ some dummy memory so new doesn't return NULL.$/;"	v	file:
m4_defn	aclocal.m4	/^m4_if(m4_defn([AC_AUTOCONF_VERSION]), [2.63],,$/;"	p	file:	signature:([AC_AUTOCONF_VERSION])
m4_if	m4/libtool.m4	/^      m4_if([$1], [GCJ], [],$/;"	p	file:	signature:([$1], [GCJ], [], [_LT_TAGVAR(lt_prog_compiler_pic, $1)=Ã])
m4_if	m4/libtool.m4	/^])dnl \/m4_if$/;"	v
machine	config.guess	/^	    arm*) machine=arm-unknown ;;$/;"	v
machine	config.guess	/^	    sh3eb) machine=sh-unknown ;;$/;"	v
machine	config.guess	/^	    sh3el) machine=shl-unknown ;;$/;"	v
machine	config.guess	/^	    sh5el) machine=sh5le-unknown ;;$/;"	v
madvise	src/system-alloc.cc	/^  extern "C" { extern int madvise(caddr_t, size_t, int); }$/;"	p	file:	signature:(caddr_t, size_t, int)
magic	src/base/low_level_alloc.cc	/^      intptr_t magic; \/\/ kMagicAllocated or kMagicUnallocated xor this$/;"	m	struct:low_level_alloc_internal::AllocList::Header	file:	access:public
magic1_	src/debugallocation.cc	/^  size_t magic1_;$/;"	m	class:MallocBlock	file:	access:private
magic2_	src/debugallocation.cc	/^  size_t magic2_;$/;"	m	class:MallocBlock	file:	access:private
magic2_addr	src/debugallocation.cc	/^  const size_t* magic2_addr() const { return (const size_t*)(size2_addr() + 1); }$/;"	f	class:MallocBlock	file:	access:private	signature:() const
magic2_addr	src/debugallocation.cc	/^  size_t* magic2_addr() { return (size_t*)(size2_addr() + 1); }$/;"	f	class:MallocBlock	file:	access:private	signature:()
magic_	src/windows/preamble_patcher.h	/^    unsigned int magic_;$/;"	m	struct:sidestep::PreamblePatcher::PreamblePage	access:public
main	benchmark/binary_trees.cc	/^int main(int argc, char *argv[]) {$/;"	f	signature:(int argc, char *argv[])
main	benchmark/malloc_bench.cc	/^int main(void)$/;"	f	signature:(void)
main	benchmark/unwind_bench.cc	/^int main(void) {$/;"	f	signature:(void)
main	config.guess	/^		main()$/;"	f	signature:()
main	config.guess	/^	int main (int argc, char *argv[]) {$/;"	f	signature:(int argc, char *argv[])
main	config.guess	/^	main ()$/;"	f	signature:()
main	config.guess	/^              int main ()$/;"	f	signature:()
main	config.guess	/^main ()$/;"	f	signature:()
main	demo.cc	/^int  main()$/;"	f	signature:()
main	src/tests/addressmap_unittest.cc	/^int main(int argc, char** argv) {$/;"	f	signature:(int argc, char** argv)
main	src/tests/atomicops_unittest.cc	/^int main(int argc, char** argv) {$/;"	f	signature:(int argc, char** argv)
main	src/tests/current_allocated_bytes_test.cc	/^int main() {$/;"	f	signature:()
main	src/tests/debugallocation_test.cc	/^int main(int argc, char** argv) {$/;"	f	signature:(int argc, char** argv)
main	src/tests/frag_unittest.cc	/^int main(int argc, char** argv) {$/;"	f	signature:(int argc, char** argv)
main	src/tests/getpc_test.cc	/^int main(int argc, char** argv) {$/;"	f	signature:(int argc, char** argv)
main	src/tests/heap-checker_unittest.cc	/^int main(int argc, char** argv) {$/;"	f	signature:(int argc, char** argv)
main	src/tests/heap-profiler_unittest.cc	/^int main(int argc, char** argv) {$/;"	f	signature:(int argc, char** argv)
main	src/tests/large_heap_fragmentation_unittest.cc	/^int main (int argc, char** argv) {$/;"	f	signature:(int argc, char** argv)
main	src/tests/low_level_alloc_unittest.cc	/^int main(int argc, char *argv[]) {$/;"	f	signature:(int argc, char *argv[])
main	src/tests/malloc_extension_c_test.c	/^int main(int argc, char** argv) {$/;"	f	signature:(int argc, char** argv)
main	src/tests/malloc_extension_test.cc	/^int main(int argc, char** argv) {$/;"	f	signature:(int argc, char** argv)
main	src/tests/malloc_hook_test.cc	/^int main(int argc, char** argv) {$/;"	f	signature:(int argc, char** argv)
main	src/tests/markidle_unittest.cc	/^int main(int argc, char** argv) {$/;"	f	signature:(int argc, char** argv)
main	src/tests/memalign_unittest.cc	/^int main(int argc, char** argv) {$/;"	f	signature:(int argc, char** argv)
main	src/tests/packed-cache_test.cc	/^int main(int argc, char **argv) {$/;"	f	signature:(int argc, char **argv)
main	src/tests/page_heap_test.cc	/^int main(int argc, char **argv) {$/;"	f	signature:(int argc, char **argv)
main	src/tests/pagemap_unittest.cc	/^int main(int argc, char** argv) {$/;"	f	signature:(int argc, char** argv)
main	src/tests/profile-handler_unittest.cc	/^int main(int argc, char** argv) {$/;"	f	signature:(int argc, char** argv)
main	src/tests/profiledata_unittest.cc	/^int main(int argc, char** argv) {$/;"	f	signature:(int argc, char** argv)
main	src/tests/profiler_unittest.cc	/^int main(int argc, char** argv) {$/;"	f	signature:(int argc, char** argv)
main	src/tests/raw_printer_test.cc	/^int main(int argc, char **argv) {$/;"	f	signature:(int argc, char **argv)
main	src/tests/realloc_unittest.cc	/^int main(int argc, char** argv) {$/;"	f	signature:(int argc, char** argv)
main	src/tests/sampler_test.cc	/^int main(int argc, char **argv) {$/;"	f	signature:(int argc, char **argv)
main	src/tests/sampling_test.cc	/^int main(int argc, char** argv) {$/;"	f	signature:(int argc, char** argv)
main	src/tests/simple_compat_test.cc	/^int main(int argc, char** argv) {$/;"	f	signature:(int argc, char** argv)
main	src/tests/stack_trace_table_test.cc	/^int main(int argc, char **argv) {$/;"	f	signature:(int argc, char **argv)
main	src/tests/stacktrace_unittest.cc	/^int main(int argc, char ** argv) {$/;"	f	signature:(int argc, char ** argv)
main	src/tests/system-alloc_unittest.cc	/^int main(int argc, char** argv) {$/;"	f	signature:(int argc, char** argv)
main	src/tests/tcmalloc_large_unittest.cc	/^int main (int argc, char** argv) {$/;"	f	signature:(int argc, char** argv)
main	src/tests/tcmalloc_unittest.cc	/^int main(int argc, char** argv) {$/;"	f	signature:(int argc, char** argv)
main	src/tests/thread_dealloc_unittest.cc	/^int main(int argc, char** argv) {$/;"	f	signature:(int argc, char** argv)
main	src/windows/addr2line-pdb.c	/^int main(int argc, char *argv[]) {$/;"	f	signature:(int argc, char *argv[])
main	src/windows/nm-pdb.c	/^int main(int argc, char *argv[]) {$/;"	f	signature:(int argc, char *argv[])
main_executable	src/windows/patch_functions.cc	/^static LibcInfoWithPatchFunctions<0> main_executable;$/;"	m	namespace:__anon13	file:
main_executable_windows	src/windows/patch_functions.cc	/^static WindowsInfo main_executable_windows;$/;"	m	namespace:__anon13	file:
main_heap_checker	src/heap-checker.cc	/^static HeapLeakChecker* main_heap_checker = NULL;$/;"	v	file:
main_thread_counter	src/heap-checker.cc	/^static int main_thread_counter;   \/\/ storage for use before main()$/;"	v	file:
main_thread_pid	src/heap-checker.cc	/^static int32 main_thread_pid = getpid();$/;"	v	file:
make	benchmark/binary_trees.cc	/^Node *make(int i, int d) {$/;"	f	signature:(int i, int d)
mallinfo	src/libc_override_redefine.h	/^  struct mallinfo mallinfo(void)                 { return tc_mallinfo();      }$/;"	f	signature:(void)
malloc	docs/heapprofile.html	/^    <code>malloc<\/code>, <code>calloc<\/code>, <code>realloc<\/code>,$/;"	v
malloc	docs/heapprofile.html	/^    to <code>malloc<\/code>, <code>calloc<\/code>, <code>realloc<\/code>,$/;"	v
malloc	src/libc_override_redefine.h	/^  void* malloc(size_t s)                         { return tc_malloc(s);       }$/;"	f	signature:(size_t s)
malloc	src/windows/override_functions.cc	91;"	d	file:
malloc_extension_c_h	src/tests/simple_compat_test.cc	/^MallocExtension_Ownership malloc_extension_c_h;$/;"	v
malloc_extension_h	src/tests/simple_compat_test.cc	/^MallocExtension::Ownership malloc_extension_h;$/;"	v
malloc_fast_path	src/tcmalloc.cc	/^static void * malloc_fast_path(size_t size) {$/;"	f	file:	signature:(size_t size)
malloc_fn	src/tcmalloc.cc	/^typedef void* (*malloc_fn)(void *arg);$/;"	t	namespace:__anon3	file:
malloc_hook	src/malloc_hook.cc	/^DECLARE_ATTRIBUTE_SECTION_VARS(malloc_hook);$/;"	v
malloc_hook	src/malloc_hook.cc	/^DEFINE_ATTRIBUTE_SECTION_VARS(malloc_hook);$/;"	v
malloc_hook_c_h	src/tests/simple_compat_test.cc	/^MallocHook_NewHook* malloc_hook_c_h;$/;"	v
malloc_hook_h	src/tests/simple_compat_test.cc	/^MallocHook::NewHook* malloc_hook_h;$/;"	v
malloc_oom	src/tcmalloc.cc	/^void* malloc_oom(size_t size) {$/;"	f	namespace:tcmalloc	signature:(size_t size)
malloc_size	src/libc_override_redefine.h	/^  size_t malloc_size(void* p)                    { return tc_malloc_size(p); }$/;"	f	signature:(void* p)
malloc_stats	src/libc_override_osx.h	/^  void malloc_stats(void)                { tc_malloc_stats();         }$/;"	f	signature:(void)
malloc_stats	src/libc_override_redefine.h	/^  void malloc_stats(void)                        { tc_malloc_stats();         }$/;"	f	signature:(void)
malloc_trace_lock	src/debugallocation.cc	/^static SpinLock malloc_trace_lock(SpinLock::LINKER_INITIALIZED);$/;"	p	file:	signature:(SpinLock::LINKER_INITIALIZED)
malloc_usable_size	src/libc_override_osx.h	/^  size_t malloc_usable_size(void* p)     { return tc_malloc_size(p); }$/;"	f	signature:(void* p)
malloc_usable_size	src/libc_override_redefine.h	/^  size_t malloc_usable_size(void* p)             { return tc_malloc_size(p); }$/;"	f	signature:(void* p)
mallocer_addr	src/tests/heap-checker_unittest.cc	/^static void* (* volatile mallocer_addr)(uintptr_t* addr) = &Mallocer;$/;"	v	file:
mallopt	src/libc_override_osx.h	/^  int mallopt(int cmd, int v)            { return tc_mallopt(cmd, v); }$/;"	f	signature:(int cmd, int v)
mallopt	src/libc_override_redefine.h	/^  int mallopt(int cmd, int v)                    { return tc_mallopt(cmd, v); }$/;"	f	signature:(int cmd, int v)
manually	docs/heap_checker.html	/^you can call <code>NoGlobalLeaks()<\/code> manually, near the end of$/;"	v
map_	src/heap-profile-table.h	/^  AllocationMap map_;$/;"	m	class:HeapProfileTable::Snapshot	access:private
map_size_	src/memory_region_map.cc	/^int64 MemoryRegionMap::map_size_ = 0;$/;"	m	class:MemoryRegionMap	file:
map_size_	src/memory_region_map.h	/^  static int64 map_size_;$/;"	m	class:MemoryRegionMap	access:private
mask_	src/windows/mini_disassembler_types.h	/^  unsigned char mask_;$/;"	m	struct:sidestep::OpcodeTable	access:public
mask_valid_	src/base/low_level_alloc.cc	/^        : left_(false), mask_valid_(false), arena_(arena) {$/;"	p	class:__anon39::ArenaLock	file:	access:public	signature:(false)
mask_valid_	src/base/low_level_alloc.cc	/^    bool mask_valid_;$/;"	m	class:__anon39::ArenaLock	file:	access:private
masked_t_	src/gperftools/heap-checker.h	/^  uintptr_t masked_t_;$/;"	m	class:HiddenPointer	access:private
matched	src/tests/tcmalloc_unittest.cc	/^  bool matched;$/;"	m	struct:testing::__anon59::RangeCallbackState	file:	access:public
max	src/heap-checker.cc	66;"	d	file:
max_cache_size_	src/central_freelist.h	/^  int32_t max_cache_size_;$/;"	m	class:tcmalloc::CentralFreeList	access:private
max_cmd_len	m4/libtool.m4	/^max_cmd_len=$lt_cv_sys_max_cmd_len$/;"	v
max_depth	src/heap-checker.cc	/^  int       max_depth;      \/\/ the maximal stack depth to disable at$/;"	m	struct:HeapLeakChecker::RangeValue	file:	access:public
max_free_queue_size	src/tests/debugallocation_test.cc	/^DECLARE_int32(max_free_queue_size);$/;"	v
max_free_queue_size	src/tests/tcmalloc_unittest.cc	/^DECLARE_int32(max_free_queue_size);     \/\/ in debugallocation.cc$/;"	v
max_heap_address	src/heap-checker.cc	/^static uintptr_t max_heap_address = 0;$/;"	v	file:
max_heap_object_size	src/heap-checker.cc	/^static size_t max_heap_object_size = 0;$/;"	v	file:
max_length	docs/tcmalloc.html	/^    max_length = max(max_length - num_objects_to_move, num_objects_to_move)$/;"	m	class:object::structure	file:	access:private
max_length	src/thread_cache.h	/^    size_t max_length() const {$/;"	f	class:tcmalloc::ThreadCache::FreeList	access:public	signature:() const
max_length_	src/thread_cache.h	/^    uint16_t max_length_;$/;"	m	class:tcmalloc::ThreadCache::FreeList	access:private
max_length_	src/thread_cache.h	/^    uint32_t max_length_;  \/\/ Dynamic max list length based on usage.$/;"	m	class:tcmalloc::ThreadCache::FreeList	access:private
max_lim_	src/windows/mini_disassembler_types.h	/^  unsigned char max_lim_;$/;"	m	struct:sidestep::OpcodeTable	access:public
max_object_size	src/gperftools/malloc_extension.h	/^    size_t max_object_size;$/;"	m	struct:MallocExtension::FreeListInfo	access:public
max_size	src/base/stl_allocator.h	/^  size_type max_size() const { return size_t(-1) \/ sizeof(T); }$/;"	f	class:STL_Allocator	access:public	signature:() const
max_size_	src/thread_cache.h	/^  int32         max_size_;                 \/\/ size_ > max_size_ --> Scavenge()$/;"	m	class:tcmalloc::ThreadCache	access:private
max_stack_depth_	src/memory_region_map.cc	/^int MemoryRegionMap::max_stack_depth_ = 0;$/;"	m	class:MemoryRegionMap	file:
max_stack_depth_	src/memory_region_map.h	/^  static int max_stack_depth_;$/;"	m	class:MemoryRegionMap	access:private
maybe_os	config.sub	/^maybe_os=`echo $1 | sed 's\/^\\(.*\\)-\\([^-]*-[^-]*\\)$\/\\2\/'`$/;"	v
measure_mode	benchmark/unwind_bench.cc	/^enum measure_mode {$/;"	g	file:
measure_once	benchmark/run_benchmark.c	/^static double measure_once(struct internal_bench *b, long iterations)$/;"	f	file:	signature:(struct internal_bench *b, long iterations)
measure_unwind	benchmark/unwind_bench.cc	/^static int ATTRIBUTE_NOINLINE measure_unwind(int maxlevel, int mode) {$/;"	f	file:	signature:(int maxlevel, int mode)
memalign	src/libc_override_redefine.h	/^  void* memalign(size_t a, size_t s)             { return tc_memalign(a, s);  }$/;"	f	signature:(size_t a, size_t s)
memalign_fast_path	src/tcmalloc.cc	/^static void* memalign_fast_path(size_t align, size_t size) {$/;"	f	file:	signature:(size_t align, size_t size)
memalign_fraction_	src/tests/tcmalloc_unittest.cc	/^  double memalign_fraction_;$/;"	m	class:testing::AllocatorState	file:	access:private
memalign_pages	src/tcmalloc.cc	/^void* memalign_pages(size_t align, size_t size,$/;"	f	namespace:tcmalloc	signature:(size_t align, size_t size, bool from_operator, bool nothrow)
memalign_retry_data	src/debugallocation.cc	/^struct memalign_retry_data {$/;"	s	file:
memalign_retry_data::align	src/debugallocation.cc	/^  size_t align;$/;"	m	struct:memalign_retry_data	file:	access:public
memalign_retry_data::size	src/debugallocation.cc	/^  size_t size;$/;"	m	struct:memalign_retry_data	file:	access:public
memalign_retry_data::type	src/debugallocation.cc	/^  int type;$/;"	m	struct:memalign_retry_data	file:	access:public
memcpy_cast	src/maybe_threads.cc	/^static T2 memcpy_cast(const T1 &input) {$/;"	f	file:	signature:(const T1 &input)
memory	src/static_vars.h	/^    char memory[sizeof(PageHeap)];$/;"	m	union:tcmalloc::Static::PageHeapStorage	access:public
metadata_alloc_lock	src/common.cc	/^static SpinLock metadata_alloc_lock(SpinLock::LINKER_INITIALIZED);$/;"	p	namespace:tcmalloc	file:	signature:(SpinLock::LINKER_INITIALIZED)
metadata_bytes	src/tcmalloc.cc	/^  uint64_t metadata_bytes;    \/\/ Bytes alloced for metadata$/;"	m	struct:TCMallocStats	file:	access:public
metadata_chunk_alloc_	src/common.cc	/^static char *metadata_chunk_alloc_;$/;"	m	namespace:tcmalloc	file:
metadata_chunk_avail_	src/common.cc	/^static size_t metadata_chunk_avail_;$/;"	m	namespace:tcmalloc	file:
metadata_system_bytes	src/common.cc	/^uint64_t metadata_system_bytes() { return metadata_system_bytes_; }$/;"	f	namespace:tcmalloc	signature:()
metadata_system_bytes	src/common.h	/^uint64_t metadata_system_bytes();$/;"	p	namespace:tcmalloc	signature:()
metadata_system_bytes_	src/common.cc	/^static uint64_t metadata_system_bytes_ = 0;$/;"	m	namespace:tcmalloc	file:
mi_check	src/libc_override_osx.h	/^boolean_t mi_check(malloc_zone_t *zone) {$/;"	f	namespace:__anon7	signature:(malloc_zone_t *zone)
mi_enumerator	src/libc_override_osx.h	/^kern_return_t mi_enumerator(task_t task, void *,$/;"	f	namespace:__anon7	signature:(task_t task, void *, unsigned type_mask, vm_address_t zone_address, memory_reader_t reader, vm_range_recorder_t recorder)
mi_force_lock	src/libc_override_osx.h	/^void mi_force_lock(malloc_zone_t *zone) {$/;"	f	namespace:__anon7	signature:(malloc_zone_t *zone)
mi_force_unlock	src/libc_override_osx.h	/^void mi_force_unlock(malloc_zone_t *zone) {$/;"	f	namespace:__anon7	signature:(malloc_zone_t *zone)
mi_good_size	src/libc_override_osx.h	/^size_t mi_good_size(malloc_zone_t *zone, size_t size) {$/;"	f	namespace:__anon7	signature:(malloc_zone_t *zone, size_t size)
mi_log	src/libc_override_osx.h	/^void mi_log(malloc_zone_t *zone, void *address) {$/;"	f	namespace:__anon7	signature:(malloc_zone_t *zone, void *address)
mi_print	src/libc_override_osx.h	/^void mi_print(malloc_zone_t *zone, boolean_t verbose) {$/;"	f	namespace:__anon7	signature:(malloc_zone_t *zone, boolean_t verbose)
mi_statistics	src/libc_override_osx.h	/^void mi_statistics(malloc_zone_t *zone, malloc_statistics_t *stats) {$/;"	f	namespace:__anon7	signature:(malloc_zone_t *zone, malloc_statistics_t *stats)
mi_zone_locked	src/libc_override_osx.h	/^boolean_t mi_zone_locked(malloc_zone_t *zone) {$/;"	f	namespace:__anon7	signature:(malloc_zone_t *zone)
min	src/heap-checker.cc	67;"	d	file:
min_heap_address	src/heap-checker.cc	/^static uintptr_t min_heap_address = uintptr_t(-1LL);$/;"	v	file:
min_lim_	src/windows/mini_disassembler_types.h	/^  unsigned char min_lim_;$/;"	m	struct:sidestep::OpcodeTable	access:public
min_object_size	src/gperftools/malloc_extension.h	/^    size_t min_object_size;$/;"	m	struct:MallocExtension::FreeListInfo	access:public
min_size	src/base/low_level_alloc.cc	/^  size_t min_size;        \/\/ smallest allocation block size$/;"	m	struct:LowLevelAlloc::Arena	file:	access:public
min_size	src/tests/tcmalloc_unittest.cc	/^  size_t min_size;$/;"	m	struct:testing::__anon59::RangeCallbackState	file:	access:public
mips_regs	src/base/elfcore.h	/^    struct mips_regs mips_regs;$/;"	m	struct:Frame	typeref:struct:Frame::mips_regs	access:public
mips_regs	src/base/elfcore.h	/^  typedef struct mips_regs {$/;"	s
mips_regs	src/base/elfcore.h	/^  } mips_regs;$/;"	t	typeref:struct:mips_regs
mips_regs::cp0_badvaddr	src/base/elfcore.h	/^    unsigned long cp0_badvaddr;$/;"	m	struct:mips_regs	access:public
mips_regs::cp0_cause	src/base/elfcore.h	/^    unsigned long cp0_cause;$/;"	m	struct:mips_regs	access:public
mips_regs::cp0_epc	src/base/elfcore.h	/^    unsigned long cp0_epc;      \/* Program counter.                          *\/$/;"	m	struct:mips_regs	access:public
mips_regs::cp0_status	src/base/elfcore.h	/^    unsigned long cp0_status;$/;"	m	struct:mips_regs	access:public
mips_regs::hi	src/base/elfcore.h	/^    unsigned long hi;           \/* Used for multiplication and division.     *\/$/;"	m	struct:mips_regs	access:public
mips_regs::lo	src/base/elfcore.h	/^    unsigned long lo;$/;"	m	struct:mips_regs	access:public
mips_regs::pad	src/base/elfcore.h	/^    unsigned long pad[6];       \/* Unused padding to match kernel structures *\/$/;"	m	struct:mips_regs	access:public
mips_regs::unused	src/base/elfcore.h	/^    unsigned long unused;$/;"	m	struct:mips_regs	access:public
mips_regs::uregs	src/base/elfcore.h	/^    unsigned long uregs[32];    \/* General purpose registers.                *\/$/;"	m	struct:mips_regs	access:public
mkdir	src/windows/port.h	/^inline int mkdir(const char *pathname, int) {$/;"	f	signature:(const char *pathname, int)
mmap	docs/heapprofile.html	/^    Profile <code>mmap<\/code>, <code>mremap<\/code> and <code>sbrk<\/code>$/;"	v
mmap	src/base/linux_syscall_support.h	/^    LSS_INLINE void* LSS_NAME(mmap)(void *s, size_t l, int p, int f, int d,$/;"	f	signature:(void *s, size_t l, int p, int f, int d, int64_t o)
mmap	src/malloc_hook_mmap_freebsd.h	46;"	d
mmap	src/malloc_hook_mmap_linux.h	141;"	d
mmap	src/windows/port.h	/^inline void *mmap(void *addr, size_t length, int prot, int flags,$/;"	f	signature:(void *addr, size_t length, int prot, int flags, int fd, off_t offset)
mmap_calls	src/tests/malloc_hook_test.cc	/^int mmap_calls = 0;$/;"	m	namespace:__anon57	file:
mmap_hooks_	src/malloc_hook.cc	/^HookList<MallocHook::MmapHook> mmap_hooks_ = INIT_HOOK_LIST;$/;"	m	namespace:base::internal	file:
mmap_matching_calls	src/tests/malloc_hook_test.cc	/^int mmap_matching_calls = 0;$/;"	m	namespace:__anon57	file:
mmap_name	src/system-alloc.cc	/^static const char mmap_name[] = "MmapSysAllocator";$/;"	v	file:
mmap_replacement_	src/malloc_hook.cc	/^HookList<MallocHook::MmapReplacement> mmap_replacement_ = { 0 };$/;"	m	namespace:base::internal	file:
mmap_space	src/system-alloc.cc	/^} mmap_space;$/;"	v	typeref:union:__anon34	file:
mmapper_addr	src/tests/heap-checker_unittest.cc	/^static void* (*mmapper_addr)(uintptr_t* addr) = &Mmapper;$/;"	v	file:
mnemonic_	src/windows/mini_disassembler_types.h	/^  const char* mnemonic_;$/;"	m	struct:sidestep::Opcode	access:public
mnemonic_	src/windows/mini_disassembler_types.h	/^  const char* mnemonic_;$/;"	m	struct:sidestep::SpecificOpcode	access:public
modBaseAddr	src/windows/patch_functions.cc	/^  LPVOID  modBaseAddr;     \/\/ the same as hmodule$/;"	m	struct:__anon13::ModuleEntryCopy	file:	access:public
modBaseSize	src/windows/patch_functions.cc	/^  DWORD   modBaseSize;$/;"	m	struct:__anon13::ModuleEntryCopy	file:	access:public
mode	docs/heap_checker.html	/^"draconian" mode, consider using <A$/;"	v
mode	docs/heap_checker.html	/^<p>"Normal" mode, as the name implies, is the one used most often at$/;"	v
mode	docs/heap_checker.html	/^it, that will prompt a leak message in "strict" mode, though not in$/;"	v
modification	COPYING	/^modification, are permitted provided that the following conditions are$/;"	v
modification	packages/deb/copyright	/^modification, are permitted provided that the following conditions are$/;"	v
module_	src/base/sysinfo.h	/^  MODULEENTRY32 module_;   \/\/ info about current dll (and dll iterator)$/;"	m	class:ProcMapsIterator	access:private
module_base	src/windows/nm-pdb.c	/^  ULONG64 module_base;$/;"	m	struct:__anon11	file:	access:public
module_base_address_	src/windows/patch_functions.cc	/^  const void *module_base_address_;$/;"	m	class:__anon13::LibcInfo	file:	access:protected
module_base_size_	src/windows/patch_functions.cc	/^  size_t module_base_size_;$/;"	m	class:__anon13::LibcInfo	file:	access:protected
module_enter_exit_hook	src/tcmalloc.cc	/^static TCMallocGuard module_enter_exit_hook;$/;"	v	file:
modules	docs/pprof_remote_servers.html	/^<p>We do not currently have infrastructure, such as apache modules,$/;"	v
mq	src/base/elfcore.h	/^    unsigned long mq;$/;"	m	struct:ppc_regs	access:public
mremap	docs/heapprofile.html	/^    Only profile <code>mmap<\/code>, <code>mremap<\/code>, and <code>sbrk<\/code>$/;"	v
mremap	src/base/linux_syscall_support.h	/^  LSS_INLINE void *LSS_NAME(mremap)(void *old_address, size_t old_size,$/;"	f	signature:(void *old_address, size_t old_size, size_t new_size, int flags, ...)
mremap	src/malloc_hook.cc	40;"	d	file:
mremap	src/malloc_hook.cc	42;"	d	file:
mremap_hooks_	src/malloc_hook.cc	/^HookList<MallocHook::MremapHook> mremap_hooks_ = INIT_HOOK_LIST;$/;"	m	namespace:base::internal	file:
msr	src/base/elfcore.h	/^    unsigned long msr;$/;"	m	struct:ppc_regs	access:public
mu	src/base/low_level_alloc.cc	/^  SpinLock mu;            \/\/ protects freelist, allocation_count,$/;"	m	struct:LowLevelAlloc::Arena	file:	access:public
mu_	src/base/simple_mutex.h	/^  Mutex * const mu_;$/;"	m	class:MUTEX_NAMESPACE::MutexLock	access:private
mu_	src/base/simple_mutex.h	/^  Mutex * const mu_;$/;"	m	class:MUTEX_NAMESPACE::ReaderMutexLock	access:private
mu_	src/base/simple_mutex.h	/^  Mutex * const mu_;$/;"	m	class:MUTEX_NAMESPACE::WriterMutexLock	access:private
mu_	src/tests/profile-handler_unittest.cc	/^  Mutex mu_;$/;"	m	class:__anon56::BusyThread	file:	access:private
munmap	src/windows/port.h	/^inline int munmap(void *addr, size_t length) {$/;"	f	signature:(void *addr, size_t length)
munmap_calls	src/tests/malloc_hook_test.cc	/^int munmap_calls = 0;$/;"	m	namespace:__anon57	file:
munmap_hooks_	src/malloc_hook.cc	/^HookList<MallocHook::MunmapHook> munmap_hooks_ = INIT_HOOK_LIST;$/;"	m	namespace:base::internal	file:
munmap_matching_calls	src/tests/malloc_hook_test.cc	/^int munmap_matching_calls = 0;$/;"	m	namespace:__anon57	file:
munmap_replacement_	src/malloc_hook.cc	/^HookList<MallocHook::MunmapReplacement> munmap_replacement_ = { 0 };$/;"	m	namespace:base::internal	file:
mutex	src/tests/profiler_unittest.cc	/^Mutex mutex(Mutex::LINKER_INITIALIZED);$/;"	p	file:	signature:(Mutex::LINKER_INITIALIZED)
mutex_	src/base/simple_mutex.h	/^  MutexType mutex_;$/;"	m	class:MUTEX_NAMESPACE::Mutex	access:private
my_errno	src/base/linuxthreads.cc	/^    int my_errno;$/;"	m	class:__anon36::SysCalls	file:	access:public
mz_calloc	src/libc_override_osx.h	/^void* mz_calloc(malloc_zone_t* zone, size_t num_items, size_t size) {$/;"	f	namespace:__anon7	signature:(malloc_zone_t* zone, size_t num_items, size_t size)
mz_destroy	src/libc_override_osx.h	/^void mz_destroy(malloc_zone_t* zone) {$/;"	f	namespace:__anon7	signature:(malloc_zone_t* zone)
mz_free	src/libc_override_osx.h	/^void mz_free(malloc_zone_t* zone, void* ptr) {$/;"	f	namespace:__anon7	signature:(malloc_zone_t* zone, void* ptr)
mz_malloc	src/libc_override_osx.h	/^void* mz_malloc(malloc_zone_t* zone, size_t size) {$/;"	f	namespace:__anon7	signature:(malloc_zone_t* zone, size_t size)
mz_memalign	src/libc_override_osx.h	/^void* mz_memalign(malloc_zone_t* zone, size_t align, size_t size) {$/;"	f	namespace:__anon7	signature:(malloc_zone_t* zone, size_t align, size_t size)
mz_realloc	src/libc_override_osx.h	/^void* mz_realloc(malloc_zone_t* zone, void* ptr, size_t size) {$/;"	f	namespace:__anon7	signature:(malloc_zone_t* zone, void* ptr, size_t size)
mz_size	src/libc_override_osx.h	/^size_t mz_size(malloc_zone_t* zone, const void* ptr) {$/;"	f	namespace:__anon7	signature:(malloc_zone_t* zone, const void* ptr)
mz_valloc	src/libc_override_osx.h	/^void* mz_valloc(malloc_zone_t* zone, size_t size) {$/;"	f	namespace:__anon7	signature:(malloc_zone_t* zone, size_t size)
n	src/.libs/libtcmalloc_internal_la-internal_logging.o	/^/;"	v
n	src/.libs/libtcmalloc_internal_la-raw_printer.o	/^:n/;"	v
n	src/.libs/libtcmalloc_minimal_internal_la-internal_logging.o	/^/;"	v
n	src/libtcmalloc_internal_la-raw_printer.o	/^:n/;"	v
n	src/maybe_threads.o	/^/;"	v
n	src/tcm_min_asserts_unittest-thread_cache.o	/^/;"	v
n	src/tests/packed_cache_test-packed-cache_test.o	/^/;"	v
n1	src/tests/heap-checker_unittest.cc	/^  char n1[5];$/;"	m	struct:Nesting	file:	access:public
n2	src/tests/heap-checker_unittest.cc	/^  char n2[11];$/;"	m	struct:Nesting	file:	access:public
n3	src/tests/heap-checker_unittest.cc	/^  char n3[27];$/;"	m	struct:Nesting	file:	access:public
nallocx	src/gperftools/nallocx.h	/^PERFTOOLS_DLL_DECL size_t nallocx(size_t size, int flags);$/;"	p	signature:(size_t size, int flags)
nallocx_slow	src/tcmalloc.cc	/^static ATTRIBUTE_NOINLINE size_t nallocx_slow(size_t size, int flags) {$/;"	f	file:	signature:(size_t size, int flags)
name	m4/libtool.m4	/^  const char *name;$/;"	m	struct:__anon1	file:	access:public
name	src/base/elf_mem_image.h	/^    const char      *name;      \/\/ E.g. "__vdso_getcpu"$/;"	m	struct:base::ElfMemImage::SymbolInfo	access:public
name	src/stacktrace.cc	/^  const char *name;$/;"	m	struct:GetStackImplementation	file:	access:public
name	src/tests/tcmalloc_unittest.cc	/^    string      name;$/;"	m	struct:testing::TestHarness::Type	file:	access:public
name	src/windows/nm-pdb.c	/^  char *name;$/;"	m	struct:__anon10	file:	access:public
name	src/windows/patch_functions.cc	/^    const char* const name;          \/\/ name of fn in a module (eg "malloc")$/;"	m	struct:__anon13::WindowsInfo::FunctionInfo	file:	access:public
name_	src/base/googleinit.h	/^  const char* const name_;$/;"	m	class:GoogleInitializer	access:private
name_	src/gperftools/heap-checker.h	/^  const char* name_;  \/\/ our remembered name (we own it)$/;"	m	class:HeapLeakChecker	access:private
names_	src/system-alloc.cc	/^  const char* names_[kMaxAllocators];$/;"	m	class:DefaultSysAllocator	file:	access:private
nanosleep	src/windows/port.h	/^inline int nanosleep(const struct timespec *req, struct timespec *rem) {$/;"	f	signature:(const struct timespec *req, struct timespec *rem)
nbsp	docs/cpuprofile-fileformat.html	/^    <td><tt>0x00000&nbsp;0x00000<\/tt><\/td>$/;"	v
nbsp	docs/cpuprofile-fileformat.html	/^    <td><tt>0x00003&nbsp;0x00000<\/tt><\/td>$/;"	v
nbsp	docs/cpuprofile-fileformat.html	/^    <td><tt>0x02710&nbsp;0x00000<\/tt><\/td>$/;"	v
need_lib_prefix	m4/libtool.m4	/^      need_lib_prefix=no$/;"	v
need_lib_prefix	m4/libtool.m4	/^    need_lib_prefix=no$/;"	v
need_lib_prefix	m4/libtool.m4	/^  need_lib_prefix=no$/;"	v
need_locks	m4/libtool.m4	/^need_locks="$enable_libtool_lock"$/;"	v
new_hooks_	src/malloc_hook.cc	/^HookList<MallocHook::NewHook> new_hooks_ =$/;"	m	namespace:base::internal	file:
new_type	src/debugallocation.cc	/^  int new_type;$/;"	m	struct:debug_alloc_retry_data	file:	access:public
newlines	docs/pprof_remote_servers.html	/^characters to newlines, and sending the result back as an HTTP$/;"	v
news_handled	src/tests/tcmalloc_unittest.cc	/^static int news_handled = 0;$/;"	m	namespace:testing	file:
next	src/addressmap-inl.h	/^    Cluster* next;                      \/\/ Next cluster in hash table chain$/;"	m	struct:AddressMap::Cluster	access:public
next	src/addressmap-inl.h	/^    Entry* next;$/;"	m	struct:AddressMap::Entry	access:public
next	src/addressmap-inl.h	/^    Object* next;$/;"	m	struct:AddressMap::Object	access:public
next	src/base/low_level_alloc.cc	/^    AllocList *next[kMaxLevel];   \/\/ actually has levels elements.$/;"	m	struct:low_level_alloc_internal::AllocList	file:	access:public
next	src/heap-profile-stats.h	/^  HeapProfileBucket* next;  \/\/ Next entry in hash-table.$/;"	m	struct:HeapProfileBucket	access:public
next	src/span.h	/^  Span*         next;           \/\/ Used when in link list$/;"	m	struct:tcmalloc::Span	access:public
next	src/stack_trace_table.h	/^    Bucket* next;$/;"	m	struct:tcmalloc::StackTraceTable::Bucket	access:public
next	src/stacktrace_powerpc-inl.h	/^  struct layout_ppc *next;$/;"	m	struct:layout_ppc	typeref:struct:layout_ppc::layout_ppc	access:public
next	src/stacktrace_powerpc-linux-inl.h	/^  struct layout_ppc *next;$/;"	m	struct:layout_ppc	typeref:struct:layout_ppc::layout_ppc	access:public
next_	src/thread_cache.h	/^  ThreadCache* next_;$/;"	m	class:tcmalloc::ThreadCache	access:public
next_	src/windows/preamble_patcher.h	/^    PreamblePage* next_;$/;"	m	struct:sidestep::PreamblePatcher::PreamblePage	access:public
next_key	src/maybe_threads.cc	/^static int next_key;$/;"	v	file:
next_memory_steal_	src/thread_cache.cc	/^ThreadCache* ThreadCache::next_memory_steal_ = NULL;$/;"	m	class:tcmalloc::ThreadCache	file:
next_memory_steal_	src/thread_cache.h	/^  static ThreadCache* next_memory_steal_;$/;"	m	class:tcmalloc::ThreadCache	access:private
nexthistory	src/span.h	/^  int nexthistory;$/;"	m	struct:tcmalloc::Span	access:public
nextline_	src/base/sysinfo.h	/^  char *nextline_;    \/\/ start of next line$/;"	m	class:ProcMapsIterator	access:private
nl	install-sh	/^nl='$/;"	v
nlist	m4/libtool.m4	/^    nlist=conftest.nm$/;"	v
nonempty_	src/central_freelist.h	/^  Span     nonempty_;       \/\/ Dummy header for list of non-empty spans$/;"	m	class:tcmalloc::CentralFreeList	access:private
nop_oom_handler	src/tcmalloc.cc	/^static void *nop_oom_handler(size_t size) {$/;"	f	namespace:__anon3	signature:(size_t size)
normal	src/page_heap.h	/^    Span        normal;$/;"	m	struct:tcmalloc::PageHeap::SpanList	access:public
normal_length	src/page_heap.h	/^    int64 normal_length[kMaxPages];$/;"	m	struct:tcmalloc::PageHeap::SmallSpanStats	access:public
normal_pages	src/page_heap.h	/^    int64 normal_pages;    \/\/ Combined page length of normal large spans$/;"	m	struct:tcmalloc::PageHeap::LargeSpanStats	access:public
not_implemented	src/stacktrace_win32-inl.h	/^static int not_implemented(void) {$/;"	f	signature:(void)
notice	COPYING	/^notice, this list of conditions and the following disclaimer.$/;"	v
notice	packages/deb/copyright	/^notice, this list of conditions and the following disclaimer.$/;"	v
notice	src/windows/shortproc.asm	/^; copyright notice, this list of conditions and the following disclaimer$/;"	v
nraddr	src/third_party/valgrind.h	/^      unsigned int nraddr; \/* where's the code? *\/$/;"	m	struct:__anon22	access:public
nraddr	src/third_party/valgrind.h	/^      unsigned int nraddr; \/* where's the code? *\/$/;"	m	struct:__anon24	access:public
nraddr	src/third_party/valgrind.h	/^      unsigned int nraddr; \/* where's the code? *\/$/;"	m	struct:__anon26	access:public
nraddr	src/third_party/valgrind.h	/^      unsigned long long int nraddr; \/* where's the code? *\/$/;"	m	struct:__anon23	access:public
nraddr	src/third_party/valgrind.h	/^      unsigned long long int nraddr; \/* where's the code? *\/$/;"	m	struct:__anon25	access:public
nraddr	src/third_party/valgrind.h	/^      unsigned long long int nraddr; \/* where's the code? *\/$/;"	m	struct:__anon27	access:public
null	compile	/^  if mkdir "$lockdir" >\/dev\/null 2>&1; then$/;"	v
null	config.guess	/^	  if ($c -c -o $dummy.o $dummy.c) >\/dev\/null 2>&1 ; then$/;"	v
null	config.guess	/^if (test -f \/.attbin\/uname) >\/dev\/null 2>&1 ; then$/;"	v
null	config.status	/^if test -n "${ZSH_VERSION+set}" && (emulate sh) >\/dev\/null 2>&1; then$/;"	v
null	configure	/^  if (eval ":") 2>\/dev\/null; then$/;"	v
null	configure	/^if test -n "${ZSH_VERSION+set}" && (emulate sh) >\/dev\/null 2>&1; then$/;"	v
null	m4/libtool.m4	/^	if $GREP ' nm_test_func$' "$nlist" >\/dev\/null; then$/;"	v
null	m4/libtool.m4	/^  if ( file \/ ) >\/dev\/null 2>&1; then$/;"	v
null	missing	/^    if test -z "$run" && ($1 --version) > \/dev\/null 2>&1; then$/;"	v
num_buckets_	src/heap-profile-table.h	/^  int num_buckets_;$/;"	m	class:HeapProfileTable	access:private
num_buckets_	src/memory_region_map.cc	/^int MemoryRegionMap::num_buckets_ = 0;  \/\/ GUARDED_BY(lock_)$/;"	m	class:MemoryRegionMap	file:
num_deleter_pcs	src/debugallocation.cc	/^  int num_deleter_pcs;$/;"	m	struct:MallocBlockQueueEntry	file:	access:public
num_evicted_	src/profiledata.h	/^  int           num_evicted_;   \/\/ how many evicted entries?$/;"	m	class:ProfileData	access:private
num_failures	debugallocation_test.sh	/^  num_failures=`expr $num_failures + 1`$/;"	v
num_failures	src/tests/debugallocation_test.sh	/^  num_failures=`expr $num_failures + 1`$/;"	v
num_objects_to_move	src/common.h	/^  inline int num_objects_to_move(uint32 cl) {$/;"	f	class:tcmalloc::SizeMap	access:public	signature:(uint32 cl)
num_objects_to_move_	src/common.h	/^  int num_objects_to_move_[kClassSizesMax];$/;"	m	class:tcmalloc::SizeMap	access:private
num_pcs	docs/cpuprofile-fileformat.html	/^record with sample count = 0, num_pcs = 1, and a one-element call$/;"	v
num_size_classes	src/common.h	/^  size_t num_size_classes;$/;"	m	class:tcmalloc::SizeMap	access:public
num_size_classes	src/static_vars.h	/^  static unsigned num_size_classes() { return sizemap_.num_size_classes; }$/;"	f	class:tcmalloc::Static	access:public	signature:()
num_spans_	src/central_freelist.h	/^  size_t   num_spans_;      \/\/ Number of spans in empty_ plus nonempty_$/;"	m	class:tcmalloc::CentralFreeList	access:private
num_tests_	src/tests/tcmalloc_unittest.cc	/^  int                   num_tests_;     \/\/ Num tests run so far$/;"	m	class:testing::TestHarness	file:	access:private
num_threads_remaining	src/tests/malloc_hook_test.cc	/^static volatile int num_threads_remaining;$/;"	m	namespace:__anon57	file:
obj_makers	src/tests/heap-checker_unittest.cc	/^static list<ObjMakerFunc> obj_makers;  \/\/ list of registered object makers$/;"	v	file:
obj_tool_map	src/pprof	/^my %obj_tool_map = ($/;"	v
object	docs/tcmalloc.html	/^<p>When allocating a small object: (1) We map its size to the$/;"	c	file:	inherits:Wemapitssizetothecorrespondingsize,Lookinthecorrespondingfreelistinthethreadcache,thecurrentthread,Ifthefreelistisnotempty,weremovethefirstobjectfromthelistand,it,Whenfollowing,fastpath,TCMallocacquiresnolocksatall,Thishelpsspeed,upallocationsignificantlybecausealock,unlockpairtakesapproximately,nanosecondsona,GHzXeon,Ifthefreelistisempty:,Wefetchabunchofobjectsfromacentralfreelist,size,thecentralfreelistissharedbyallthreads,Placetheminthethread,localfreelist,Returnoneofthenewlyfetchedobjectstotheapplications,Ifthecentralfreelistisalsoempty:,Weallocatearunofpagesfromthecentralpageallocator,Splittherunintoasetofobjectsof,size,Placethe,objectsonthecentralfreelist,Asbefore,movesomeoftheseobjectstothethread,localfreelist,SizingThreadCacheFreeListsItisimportanttosizethethreadcachefreelistscorrectly,Ifthefreelististoosmall,we,toooften,Ifthefreelististoobig,we,sitidleinthefreelist,Notethatthethreadcachesarejustasimportant,deallocationastheyare,allocation,Withoutacache,eachdeallocationwouldrequiremovingthememorytothecentralfreelist,Also,somethreadshaveasymmetricalloc,freebehavior,e,g,producerandconsumerthreads,sosizingthefreelistcorrectlygetstrickier,Tosizethefreelistsappropriately,weuseaslow,startalgorithmtodeterminethemaximumlengthofeachindividualfreelist,Asthefreelistisusedmorefrequently,itsmaximumlengthgrows,However,afreelistisusedmore,deallocationthanallocation,itsmaximumlengthwillgrowonlyuptoapointwherethewholelistcanbeefficientlymovedtothecentralfreelistatonce,Thepsuedo,codebelowillustrates,slow,startalgorithm,Notethatnum_objects_to_moveisspecifictoeachsize,Bymovingalistofobjectswithawell,knownlength,thecentralcachecanefficientlypasstheselistsbetweenthreadcaches,Ifathreadcachewantsfewerthannum_objects_to_move,theoperationonthecentralfreelisthaslineartimecomplexity,Thedownsideofalways,num_objects_to_moveasthenumberofobjectstotransfertoandfromthecentralcacheisthatitwastesmemoryinthreadsthatdon,Starteachfreelistmax_lengthat,Allocation,freelistempty
object::application	docs/tcmalloc.html	/^either a large object that has been handed off to the application, or$/;"	m	class:object	file:	access:private
object::array	docs/tcmalloc.html	/^central array, which seems acceptable.<\/p>$/;"	m	class:object	file:	access:private
object::gt	docs/tcmalloc.html	/^of pages of length &gt; <code>k<\/code>, the remainder of the$/;"	m	class:object	file:	access:private
object::k	docs/tcmalloc.html	/^of pages of length &gt; <code>k<\/code>, the remainder of the$/;"	m	class:object	file:	access:private
object::list	docs/tcmalloc.html	/^    fetch min(max_length, num_objects_to_move) from central list;$/;"	m	class:object	file:	access:private
object::list	docs/tcmalloc.html	/^in the next free list, and so forth.  Eventually, we look in the last$/;"	m	class:object	file:	access:private
object::page	docs/tcmalloc.html	/^pages, span <em>b<\/em> occupies 1 page, span <em>c<\/em> occupies 5$/;"	m	class:object	typeref:class:object::occupies	file:	access:private
object::pages	docs/tcmalloc.html	/^pages, span <em>b<\/em> occupies 1 page, span <em>c<\/em> occupies 5$/;"	m	class:object	typeref:class:object::occupies	file:	access:private
object::structure	docs/tcmalloc.html	/^structure: a set of spans, and a linked list of free objects per$/;"	c	class:object	file:	inherits:asetofspans,andalinkedlistoffreeobjectsperspan,Anobjectisallocatedfromacentralfreelistbyremovingthefirstentryfromthelinkedlistofsomespan,Ifallspanshaveemptylinkedlists,asuitablysizedspanisfirstallocatedfromthecentralpageheap,Anobjectisreturnedtoacentralfreelistbyaddingittothelinkedlistofitscontainingspan,Ifthelinkedlistlengthnowequalsthetotalnumberofsmallobjectsinthespan,spanisnowcompletelyfreeandisreturnedtothepageheap,GarbageCollectionofThreadCachesGarbagecollectingobjectsfromathreadcachekeepsthesizeofthecacheundercontrolandreturnsunusedobjectstothecentralfreelists,Somethreadsneedlargecachestoperformwell,otherscangetbywithlittleornocacheatall,Whenathreadcachegoesoveritsmax_size,garbagecollectionkicksinandthenthethreadcompeteswiththeotherthreads,alargercache,Garbagecollectionisrunonlyduringadeallocation,Wewalkoverallfreelistsinthecacheandmovesomenumberofobjectsfromthefreelisttothecorrespondingcentrallist,Thenumberofobjectstobemovedfromafreelistisdetermined,aper,listlow,water,markL,Lrecordstheminimumlengthofthelistsincethelastgarbagecollection,NotethatwecouldhaveshortenedthelistbyLobjectsatthelastgarbagecollectionwithoutrequiringanyextraaccessestothecentrallist,Weuse,pasthistoryasapredictoroffutureaccessesandmoveL,objectsfromthethreadcachefreelisttothecorrespondingcentralfreelist,Thisalgorithmhasthenicepropertythat,athreadstops,aparticularsize,allobjectsofthatsizewillquicklymovefromthethreadcachetothecentralfreelistwheretheycanbeusedbyotherthreads,Ifathreadconsistentlydeallocatesmoreobjectsofacertainsizethanitallocates,L,behaviorwillcauseatleastL,objectstoalwayssitinthefreelist,Toavoidwastingmemory,way,weshrinkthemaximumlengthofthefreelisttoconvergeonnum_objects_to_move,seealsoSizingThreadCacheFreeLists,GarbageCollection,L,max_length,num_objects_to_move	access:private
object::structure::GetNumericProperty	docs/tcmalloc.html	/^   MallocExtension::instance()->GetNumericProperty(property_name, &value);$/;"	p	class:object::structure	file:	access:private	signature:(property_name, &value)
object::structure::GetStats	docs/tcmalloc.html	/^   MallocExtension::instance()->GetStats(buffer, buffer_length);$/;"	p	class:object::structure	file:	access:private	signature:(buffer, buffer_length)
object::structure::K	docs/tcmalloc.html	/^efficient than PTMalloc2. For max allocation sizes &lt;32K, TCMalloc$/;"	m	class:object::structure	file:	access:private
object::structure::OS	docs/tcmalloc.html	/^    OS, typically do not count towards physical memory usage.$/;"	m	class:object::structure	file:	access:private
object::structure::OS	docs/tcmalloc.html	/^    swapped out by the OS, they also count towards physical memory$/;"	m	class:object::structure	file:	access:private
object::structure::SetNumericProperty	docs/tcmalloc.html	/^   MallocExtension::instance()->SetNumericProperty(property_name, value);$/;"	p	class:object::structure	file:	access:private	signature:(property_name, value)
object::structure::code	docs/tcmalloc.html	/^    <code>madvise(MADV_DONTNEED)<\/code>, on systems that support$/;"	m	class:object::structure	file:	access:private
object::structure::max_length	docs/tcmalloc.html	/^    max_length = max(max_length - num_objects_to_move, num_objects_to_move)$/;"	m	class:object::structure	file:	access:private
object::structure::properties	docs/tcmalloc.html	/^<p>It is possible for an application to set and get these properties,$/;"	m	class:object::structure	file:	access:private
object::structure::runtime	docs/tcmalloc.html	/^<code>tcmalloc_release_rate<\/code> value at runtime, or$/;"	m	class:object::structure	file:	access:private
object::structure::string	docs/tcmalloc.html	/^   MallocExtension::instance()->GetHeapGrowthStacks(&string);$/;"	m	class:object::structure	file:	access:private
object::structure::string	docs/tcmalloc.html	/^   MallocExtension::instance()->GetHeapSample(&string);$/;"	m	class:object::structure	file:	access:private
object::structure::threads	docs/tcmalloc.html	/^threads, for max allocation size 64 bytes - 128 Kbytes.<\/p>$/;"	m	class:object::structure	file:	access:private
object_size	src/heap-profile-table.h	/^    size_t object_size;  \/\/ size of the allocation$/;"	m	struct:HeapProfileTable::AllocInfo	access:public
object_size	src/thread_cache.h	/^    int32_t object_size() const {$/;"	f	class:tcmalloc::ThreadCache::FreeList	access:public	signature:() const
objects	src/span.h	/^  void*         objects;        \/\/ Linked list of free objects$/;"	m	struct:tcmalloc::Span	access:public
objformat	m4/libtool.m4	/^    objformat=`\/usr\/bin\/objformat`$/;"	v
off_t	ChangeLog.old	/^	* BUGFIX: mmap2 on i386 takes an off_t, not off64_t (csilvers)$/;"	v
off_t	src/windows/port.h	/^typedef _off_t off_t;$/;"	t
offset_	src/debugallocation.cc	/^  size_t offset_;   \/\/ normally 0 unless memaligned memory$/;"	m	class:MallocBlock	file:	access:private
ofile	compile	/^ofile=$/;"	v
old_archive_cmds	m4/libtool.m4	/^  old_archive_cmds="$old_archive_cmds~\\$RANLIB \\$oldlib"$/;"	v
old_value_	src/tests/tcmalloc_unittest.cc	/^  size_t old_value_;$/;"	m	class:testing::AggressiveDecommitChanger	file:	access:private
on_process_term	src/windows/port.cc	/^static int on_process_term(void) {$/;"	f	file:	signature:(void)
on_tls_callback	src/windows/port.cc	/^static void NTAPI on_tls_callback(HINSTANCE h, DWORD dwReason, PVOID pv) {$/;"	f	file:	signature:(HINSTANCE h, DWORD dwReason, PVOID pv)
once	src/malloc_hook.cc	/^pthread_once_t once = PTHREAD_ONCE_INIT;$/;"	m	namespace:__anon51	file:
once_	src/profile-handler.cc	/^  static pthread_once_t once_;$/;"	m	class:ProfileHandler	file:	access:private
once_	src/profile-handler.cc	/^pthread_once_t ProfileHandler::once_ = PTHREAD_ONCE_INIT;$/;"	m	class:ProfileHandler	file:
oom_test_last_ptr	src/tests/tcmalloc_unittest.cc	/^static void* volatile oom_test_last_ptr;$/;"	m	namespace:testing	file:
opcode_if_66_prefix_	src/windows/mini_disassembler_types.h	/^  SpecificOpcode opcode_if_66_prefix_;$/;"	m	struct:sidestep::Opcode	access:public
opcode_if_f2_prefix_	src/windows/mini_disassembler_types.h	/^  SpecificOpcode opcode_if_f2_prefix_;$/;"	m	struct:sidestep::Opcode	access:public
opcode_if_f3_prefix_	src/windows/mini_disassembler_types.h	/^  SpecificOpcode opcode_if_f3_prefix_;$/;"	m	struct:sidestep::Opcode	access:public
open	src/base/linux_syscall_support.h	/^    LSS_INLINE int LSS_NAME(open)(const char* p, int f, int m) {$/;"	f	signature:(const char* p, int f, int m)
open	src/windows/port.h	/^inline int open(const char *pathname, int flags, int mode = 0) {$/;"	f	signature:(const char *pathname, int flags, int mode = 0)
operand_bytes_	src/windows/mini_disassembler.h	/^  unsigned int operand_bytes_;$/;"	m	class:sidestep::MiniDisassembler	access:private
operand_default_is_32_bits_	src/windows/mini_disassembler.h	/^  bool operand_default_is_32_bits_;$/;"	m	class:sidestep::MiniDisassembler	access:private
operand_default_support_64_bits_	src/windows/mini_disassembler.h	/^  bool operand_default_support_64_bits_;$/;"	m	class:sidestep::MiniDisassembler	access:private
operand_is_32_bits_	src/windows/mini_disassembler.h	/^  bool operand_is_32_bits_;$/;"	m	class:sidestep::MiniDisassembler	access:private
operand_is_64_bits_	src/windows/mini_disassembler.h	/^  bool operand_is_64_bits_;$/;"	m	class:sidestep::MiniDisassembler	access:private
operand_size_	src/windows/mini_disassembler_types.h	/^  OperandSize operand_size_;$/;"	m	struct:sidestep::ModrmEntry	access:public
operator !=	src/base/elf_mem_image.cc	/^bool ElfMemImage::SymbolIterator::operator!=(const SymbolIterator &rhs) const {$/;"	f	class:base::ElfMemImage::SymbolIterator	signature:(const SymbolIterator &rhs) const
operator !=	src/base/elf_mem_image.h	/^    bool operator!=(const SymbolIterator &rhs) const;$/;"	p	class:base::ElfMemImage::SymbolIterator	access:public	signature:(const SymbolIterator &rhs) const
operator ()	src/memory_region_map.h	/^    bool operator()(const Region& x, const Region& y) const {$/;"	f	struct:MemoryRegionMap::RegionCmp	access:public	signature:(const Region& x, const Region& y) const
operator *	src/base/elf_mem_image.cc	/^const ElfMemImage::SymbolInfo& ElfMemImage::SymbolIterator::operator*() const {$/;"	f	class:base::ElfMemImage::SymbolIterator	signature:() const
operator *	src/base/elf_mem_image.h	/^    const SymbolInfo &operator*() const;$/;"	p	class:base::ElfMemImage::SymbolIterator	access:public	signature:() const
operator ++	src/base/elf_mem_image.cc	/^ElfMemImage::SymbolIterator &ElfMemImage::SymbolIterator::operator++() {$/;"	f	class:base::ElfMemImage::SymbolIterator	signature:()
operator ++	src/base/elf_mem_image.h	/^    SymbolIterator& operator++();$/;"	p	class:base::ElfMemImage::SymbolIterator	access:public	signature:()
operator ->	src/base/elf_mem_image.cc	/^const ElfMemImage::SymbolInfo *ElfMemImage::SymbolIterator::operator->() const {$/;"	f	class:base::ElfMemImage::SymbolIterator	signature:() const
operator ->	src/base/elf_mem_image.h	/^    const SymbolInfo *operator->() const;$/;"	p	class:base::ElfMemImage::SymbolIterator	access:public	signature:() const
operator <	src/heap-profile-table.cc	/^  bool operator<(const Entry& x) const {$/;"	f	struct:HeapProfileTable::Snapshot::Entry	access:public	signature:(const Entry& x) const
operator =	src/base/simple_mutex.h	/^  void operator=(const Mutex&);$/;"	p	class:MUTEX_NAMESPACE::Mutex	access:private	signature:(const Mutex&)
operator =	src/base/simple_mutex.h	/^  void operator=(const MutexLock&);$/;"	p	class:MUTEX_NAMESPACE::MutexLock	access:private	signature:(const MutexLock&)
operator =	src/base/simple_mutex.h	/^  void operator=(const ReaderMutexLock&);$/;"	p	class:MUTEX_NAMESPACE::ReaderMutexLock	access:private	signature:(const ReaderMutexLock&)
operator =	src/base/simple_mutex.h	/^  void operator=(const WriterMutexLock&);$/;"	p	class:MUTEX_NAMESPACE::WriterMutexLock	access:private	signature:(const WriterMutexLock&)
operator =	src/gperftools/heap-checker.h	/^    void operator=(const Disabler&);  \/\/ and assign$/;"	p	class:HeapLeakChecker::Disabler	access:private	signature:(const Disabler&)
operator =	src/gperftools/heap-checker.h	/^  void operator=(const HeapLeakChecker&);$/;"	p	class:HeapLeakChecker	access:private	signature:(const HeapLeakChecker&)
operator =	src/tests/heap-checker_unittest.cc	/^  void operator=(const Array& x) {$/;"	f	struct:Array	access:public	signature:(const Array& x)
operator ==	src/base/elf_mem_image.cc	/^bool ElfMemImage::SymbolIterator::operator==(const SymbolIterator &rhs) const {$/;"	f	class:base::ElfMemImage::SymbolIterator	signature:(const SymbolIterator &rhs) const
operator ==	src/base/elf_mem_image.h	/^    bool operator==(const SymbolIterator &rhs) const;$/;"	p	class:base::ElfMemImage::SymbolIterator	access:public	signature:(const SymbolIterator &rhs) const
operator ==	src/base/stl_allocator.h	/^  bool operator==(const STL_Allocator&) const { return true; }$/;"	f	class:STL_Allocator	access:public	signature:(const STL_Allocator&) const
operator []	src/tests/profiledata_unittest.cc	/^  T& operator[](int i) { return data_[i]; }$/;"	f	class:__anon53::scoped_array	access:public	signature:(int i)
operator []	src/tests/sampler_test.cc	/^  T& operator[](int i) { return p_[i]; }$/;"	f	class:__anon54::scoped_array	access:public	signature:(int i)
operator delete	src/windows/get_mangled_names.cc	/^void operator delete(void* p) throw() { }$/;"	f	signature:(void* p)
operator delete	src/windows/get_mangled_names.cc	/^void operator delete(void* p, const std::nothrow_t&) throw() { }$/;"	f	signature:(void* p, const std::nothrow_t&)
operator delete[]	src/windows/get_mangled_names.cc	/^void operator delete[](void* p) throw() { }$/;"	f	signature:(void* p)
operator delete[]	src/windows/get_mangled_names.cc	/^void operator delete[](void* p, const std::nothrow_t&) throw() { }$/;"	f	signature:(void* p, const std::nothrow_t&)
operator new	src/libc_override_redefine.h	/^void* operator new(size_t size)                  { return tc_new(size);       }$/;"	f	signature:(size_t size)
operator new	src/libc_override_redefine.h	/^void* operator new(size_t size, std::align_val_t al) {$/;"	f	signature:(size_t size, std::align_val_t al)
operator new	src/tests/heap-checker_unittest.cc	/^void* operator new(size_t size, const Initialized&) {$/;"	f	signature:(size_t size, const Initialized&)
operator new	src/windows/get_mangled_names.cc	/^void* operator new(size_t size) { return &m; }$/;"	f	signature:(size_t size)
operator new	src/windows/get_mangled_names.cc	/^void* operator new(size_t size, const std::nothrow_t&) throw() { return &m; }$/;"	f	signature:(size_t size, const std::nothrow_t&)
operator new[]	src/libc_override_redefine.h	/^void* operator new[](size_t size)                { return tc_newarray(size);  }$/;"	f	signature:(size_t size)
operator new[]	src/libc_override_redefine.h	/^void* operator new[](size_t size, std::align_val_t al) {$/;"	f	signature:(size_t size, std::align_val_t al)
operator new[]	src/tests/heap-checker_unittest.cc	/^void* operator new[](size_t size, const Initialized&) {$/;"	f	signature:(size_t size, const Initialized&)
operator new[]	src/windows/get_mangled_names.cc	/^void* operator new[](size_t size) { return &m; }$/;"	f	signature:(size_t size)
operator new[]	src/windows/get_mangled_names.cc	/^void* operator new[](size_t size, const std::nothrow_t&) throw() { return &m; }$/;"	f	signature:(size_t size, const std::nothrow_t&)
or	docs/heapprofile.html	/^<code>malloc<\/code>, <code>calloc<\/code>, <code>realloc<\/code>, or,$/;"	v
orig_rax	src/base/elfcore.h	/^    uint64_t  r9,r8,rax,rcx,rdx,rsi,rdi,orig_rax;$/;"	m	struct:i386_regs	access:public
original_function	src/windows/auto_testing_hook.h	/^  T original_function() {$/;"	f	class:sidestep::AutoTestingHookImpl	access:public	signature:()
original_function	src/windows/preamble_patcher_test.cc	/^IncrementingFunc original_function = NULL;$/;"	m	namespace:__anon12	file:
original_function_	src/windows/auto_testing_hook.h	/^  T original_function_;  \/\/ always valid$/;"	m	class:sidestep::AutoTestingHookImpl	access:private
origstub_fn	src/windows/patch_functions.cc	/^    GenericFnPtr origstub_fn;        \/\/ original fn contents after we patch$/;"	m	struct:__anon13::WindowsInfo::FunctionInfo	file:	access:public
origstub_fn_	src/windows/patch_functions.cc	/^  static GenericFnPtr origstub_fn_[kNumFunctions];$/;"	m	class:__anon13::LibcInfoWithPatchFunctions	file:	access:private
origstub_fn_	src/windows/patch_functions.cc	/^template<int T> GenericFnPtr LibcInfoWithPatchFunctions<T>::origstub_fn_[] = {$/;"	m	class:__anon13::LibcInfoWithPatchFunctions	file:
other	src/base/stl_allocator.h	/^    typedef STL_Allocator<T1, Alloc> other;$/;"	t	struct:STL_Allocator::rebind	access:public
out_	src/profiledata.h	/^  int           out_;           \/\/ fd for output file.$/;"	m	class:ProfileData	access:private
output_verbose_link_cmd	m4/libtool.m4	/^    output_verbose_link_cmd=echo$/;"	v
overaligned_type	src/tests/tcmalloc_unittest.cc	/^struct overaligned_type$/;"	s	file:
overaligned_type::data	src/tests/tcmalloc_unittest.cc	/^  unsigned char data[OVERALIGNMENT * 2]; \/\/ make the object size different from$/;"	m	struct:overaligned_type	file:	access:public
overall_thread_cache_size	src/thread_cache.h	/^  static size_t overall_thread_cache_size() {$/;"	f	class:tcmalloc::ThreadCache	access:public	signature:()
overall_thread_cache_size_	src/thread_cache.cc	/^size_t ThreadCache::overall_thread_cache_size_ = kDefaultOverallThreadCacheSize;$/;"	m	class:tcmalloc::ThreadCache	file:
overall_thread_cache_size_	src/thread_cache.h	/^  static size_t overall_thread_cache_size_;$/;"	m	class:tcmalloc::ThreadCache	access:private
owner_lock_	src/memory_region_map.cc	/^SpinLock MemoryRegionMap::owner_lock_(  \/\/ ACQUIRED_AFTER(lock_)$/;"	p	class:MemoryRegionMap	file:	signature:( SpinLock::LINKER_INITIALIZED)
owner_lock_	src/memory_region_map.h	/^  static SpinLock owner_lock_;$/;"	m	class:MemoryRegionMap	access:private
p	src/.libs/libtcmalloc_internal_la-internal_logging.o	/^/;"	v
p	src/base/basictypes.h	/^  void*  p;$/;"	m	union:MemoryAligner	access:public
p	src/libtcmalloc_internal_la-symbolize.o	/^/;"	v
p	src/libtcmalloc_minimal_internal_la-symbolize.o	/^/;"	v
p$	src/libtcmalloc_internal_la-fake_stacktrace_scope.o	/^/;"	v
p1	Makefile	/^	while read p p1; do if test -f $$p || test -f $$p1; \\$/;"	v
p1	Makefile.in	/^	while read p p1; do if test -f $$p || test -f $$p1; \\$/;"	v
p1_	src/tests/heap-checker_unittest.cc	/^  P1 p1_;$/;"	m	class:Callback1	file:	access:private
p1_	src/tests/heap-checker_unittest.cc	/^  P1 p1_;$/;"	m	class:Callback2	file:	access:private
p2_	src/tests/heap-checker_unittest.cc	/^  P2 p2_;$/;"	m	class:Callback2	file:	access:private
pT	src/.libs/libtcmalloc_internal_la-internal_logging.o	/^/;"	v
p_	src/internal_logging.cc	/^  char* p_;$/;"	m	class:tcmalloc::Logger	file:	access:public
p_	src/tests/sampler_test.cc	/^  T* p_;$/;"	m	class:__anon54::scoped_array	file:	access:private
p_process_term_tcmalloc	src/windows/port.cc	/^int (*p_process_term_tcmalloc)(void) = on_process_term;$/;"	v
p_thread_callback_tcmalloc	src/windows/port.cc	/^void (NTAPI *p_thread_callback_tcmalloc)($/;"	v
pad	src/base/elfcore.h	/^    unsigned long pad[6];       \/* Unused padding to match kernel structures *\/$/;"	m	struct:mips_regs	access:public
pad1	src/base/linux_syscall_support.h	/^  short              pad1;$/;"	m	struct:kernel_stat	access:public
pad2	src/base/linux_syscall_support.h	/^  short              pad2;$/;"	m	struct:kernel_stat	access:public
pad_	src/central_freelist.h	/^  char pad_[64 - kFreeListSizeMod64];$/;"	m	class:tcmalloc::CentralFreeListPaddedTo	access:private
page	docs/tcmalloc.html	/^pages, span <em>b<\/em> occupies 1 page, span <em>c<\/em> occupies 5$/;"	m	class:object	typeref:class:object::occupies	file:	access:private
pageheap	src/static_vars.h	/^  static PageHeap* pageheap() { return reinterpret_cast<PageHeap *>(&pageheap_.memory); }$/;"	f	class:tcmalloc::Static	access:public	signature:()
pageheap	src/tcmalloc.cc	/^  PageHeap::Stats pageheap;   \/\/ Stats from page heap$/;"	m	struct:TCMallocStats	file:	access:public
pageheap_	src/static_vars.cc	/^Static::PageHeapStorage Static::pageheap_;$/;"	m	class:tcmalloc::Static	file:
pageheap_	src/static_vars.h	/^  ATTRIBUTE_HIDDEN static PageHeapStorage pageheap_;$/;"	m	class:tcmalloc::Static	access:private
pageheap_lock	src/static_vars.h	/^  static SpinLock* pageheap_lock() { return &pageheap_lock_; }$/;"	f	class:tcmalloc::Static	access:public	signature:()
pageheap_lock_	src/static_vars.cc	/^SpinLock Static::pageheap_lock_(SpinLock::LINKER_INITIALIZED);$/;"	p	class:tcmalloc::Static	file:	signature:(SpinLock::LINKER_INITIALIZED)
pageheap_lock_	src/static_vars.h	/^  \/* ATTRIBUTE_HIDDEN *\/ static SpinLock pageheap_lock_;$/;"	m	class:tcmalloc::Static	access:private
pagemap_	src/page_heap.h	/^  PageMap pagemap_;$/;"	m	class:tcmalloc::PageHeap	access:private
pagemap_cache_	src/page_heap.h	/^  mutable PageMapCache pagemap_cache_;$/;"	m	class:tcmalloc::PageHeap	access:private
pages	docs/tcmalloc.html	/^pages, span <em>b<\/em> occupies 1 page, span <em>c<\/em> occupies 5$/;"	m	class:object	typeref:class:object::occupies	file:	access:private
pages	src/common.h	/^inline Length pages(size_t bytes) {$/;"	f	namespace:tcmalloc	signature:(size_t bytes)
pages_allocator_place	src/emergency_malloc.cc	/^  } pages_allocator_place;$/;"	m	namespace:tcmalloc	typeref:union:tcmalloc::__anon29	file:
pagesize	src/base/low_level_alloc.cc	/^  size_t pagesize;        \/\/ ==getpagesize()  (init under mu, then ro)$/;"	m	struct:LowLevelAlloc::Arena	file:	access:public
pagesize	src/system-alloc.cc	/^static size_t pagesize = 0;$/;"	v	file:
pagesize	src/tcmalloc.cc	/^static size_t pagesize = 0;$/;"	v	file:
pagesize_	src/windows/preamble_patcher.cc	/^long PreamblePatcher::pagesize_ = 0;$/;"	m	class:sidestep::PreamblePatcher	file:
pagesize_	src/windows/preamble_patcher.h	/^  static long pagesize_;$/;"	m	class:sidestep::PreamblePatcher	access:private
param	benchmark/run_benchmark.c	/^  uintptr_t param;$/;"	m	struct:internal_bench	file:	access:public
parameter	src/base/linuxthreads.cc	/^  void        *parameter;$/;"	m	struct:ListerParams	file:	access:public
parent	src/tests/heap-checker_unittest.cc	/^    Nesting* parent;$/;"	m	struct:Nesting::Inner	file:	access:public
passed_	src/tests/tcmalloc_unittest.cc	/^  vector<Object>        passed_;        \/\/ Pending objects passed from others$/;"	m	class:testing::TesterThread	file:	access:private
patch_all_modules_lock	src/windows/patch_functions.cc	/^static SpinLock patch_all_modules_lock(SpinLock::LINKER_INITIALIZED);$/;"	p	namespace:__anon13	file:	signature:(SpinLock::LINKER_INITIALIZED)
patched	src/windows/patch_functions.cc	/^  bool patched() const { return is_valid(); }$/;"	f	class:__anon13::LibcInfo	access:public	signature:() const
pc_offset	src/getpc.h	/^  int pc_offset;$/;"	m	struct:CallUnrollInfo	access:public
pclose	src/windows/port.h	/^inline int pclose(FILE *stream) {$/;"	f	signature:(FILE *stream)
per_thread_cache_size_	src/thread_cache.cc	/^volatile size_t ThreadCache::per_thread_cache_size_ = kMaxThreadCacheSize;$/;"	m	class:tcmalloc::ThreadCache	file:
per_thread_cache_size_	src/thread_cache.h	/^  static volatile size_t per_thread_cache_size_;$/;"	m	class:tcmalloc::ThreadCache	access:private
per_thread_timer_enabled_	src/profile-handler.cc	/^  bool per_thread_timer_enabled_;$/;"	m	class:ProfileHandler	file:	access:private
perftools	docs/pprof_remote_servers.html	/^ProfilerStart\/ProfilerStart) are not available as part of perftools,$/;"	v
perftools_fn	src/windows/patch_functions.cc	/^    const GenericFnPtr perftools_fn; \/\/ fn we want to patch in$/;"	m	struct:__anon13::WindowsInfo::FunctionInfo	file:	access:public
perftools_fn_	src/windows/patch_functions.cc	/^  static const GenericFnPtr perftools_fn_[kNumFunctions];$/;"	m	class:__anon13::LibcInfoWithPatchFunctions	file:	access:private
perftools_fn_	src/windows/patch_functions.cc	/^const GenericFnPtr LibcInfoWithPatchFunctions<T>::perftools_fn_[] = {$/;"	m	class:__anon13::LibcInfoWithPatchFunctions	file:
perftools_pthread_atfork	src/maybe_threads.cc	/^void perftools_pthread_atfork(void (*before)(),$/;"	f	signature:(void (*before)(), void (*parent_after)(), void (*child_after)())
perftools_pthread_atfork	src/maybe_threads.h	/^void perftools_pthread_atfork(void (*before)(),$/;"	p	signature:(void (*before)(), void (*parent_after)(), void (*child_after)())
perftools_pthread_getspecific	src/maybe_threads.cc	/^void *perftools_pthread_getspecific(pthread_key_t key) {$/;"	f	signature:(pthread_key_t key)
perftools_pthread_getspecific	src/maybe_threads.h	/^void *perftools_pthread_getspecific(pthread_key_t key);$/;"	p	signature:(pthread_key_t key)
perftools_pthread_getspecific	src/windows/port.h	/^inline void* perftools_pthread_getspecific(DWORD key) {$/;"	f	signature:(DWORD key)
perftools_pthread_key_create	src/maybe_threads.cc	/^int perftools_pthread_key_create(pthread_key_t *key,$/;"	f	signature:(pthread_key_t *key, void (*destr_function) (void *))
perftools_pthread_key_create	src/maybe_threads.h	/^int perftools_pthread_key_create(pthread_key_t *key,$/;"	p	signature:(pthread_key_t *key, void (*destr_function) (void *))
perftools_pthread_key_create	src/windows/port.h	/^inline int perftools_pthread_key_create(pthread_key_t *pkey,$/;"	f	signature:(pthread_key_t *pkey, void (*destructor)(void*))
perftools_pthread_key_delete	src/maybe_threads.cc	/^int perftools_pthread_key_delete(pthread_key_t key) {$/;"	f	signature:(pthread_key_t key)
perftools_pthread_key_delete	src/maybe_threads.h	/^int perftools_pthread_key_delete(pthread_key_t key);$/;"	p	signature:(pthread_key_t key)
perftools_pthread_once	src/maybe_threads.cc	/^int perftools_pthread_once(pthread_once_t *ctl,$/;"	f	signature:(pthread_once_t *ctl, void (*init_routine) (void))
perftools_pthread_once	src/maybe_threads.h	/^int perftools_pthread_once(pthread_once_t *ctl,$/;"	p	signature:(pthread_once_t *ctl, void (*init_routine) (void))
perftools_pthread_once	src/windows/port.cc	/^extern "C" int perftools_pthread_once(pthread_once_t *once_control,$/;"	f	signature:(pthread_once_t *once_control, void (*init_routine)(void))
perftools_pthread_once	src/windows/port.h	/^EXTERN_C int perftools_pthread_once(pthread_once_t *once_control,$/;"	p	signature:(pthread_once_t *once_control, void (*init_routine)(void))
perftools_pthread_setspecific	src/maybe_threads.cc	/^int perftools_pthread_setspecific(pthread_key_t key, void *val) {$/;"	f	signature:(pthread_key_t key, void *val)
perftools_pthread_setspecific	src/maybe_threads.h	/^int perftools_pthread_setspecific(pthread_key_t key, void *val);$/;"	p	signature:(pthread_key_t key, void *val)
perftools_pthread_setspecific	src/windows/port.h	/^inline int perftools_pthread_setspecific(pthread_key_t key, const void *value) {$/;"	f	signature:(pthread_key_t key, const void *value)
perftools_pthread_specific_vals	src/maybe_threads.cc	/^static void *perftools_pthread_specific_vals[MAX_PERTHREAD_VALS];$/;"	v	file:
perftools_vsnprintf	src/base/logging.h	70;"	d
perftools_vsnprintf	src/windows/port.h	/^inline int perftools_vsnprintf(char *str, size_t size, const char *format,$/;"	f	signature:(char *str, size_t size, const char *format, va_list ap)
period	docs/cpuprofile-fileformat.html	/^    <td>sampling period, in microseconds<\/td>$/;"	v
phinited	src/thread_cache.cc	/^static bool phinited = false;$/;"	m	namespace:tcmalloc	file:
pid_	src/base/sysinfo.h	/^  pid_t pid_;$/;"	m	class:ProcMapsIterator	access:private
pid_t	src/windows/port.h	/^typedef int pid_t;$/;"	t
pipe	src/base/linux_syscall_support.h	/^    LSS_INLINE int LSS_NAME(pipe)( int * p) {$/;"	f	signature:( int * p)
pipe	src/base/linux_syscall_support.h	/^    LSS_INLINE int LSS_NAME(pipe)(int *p) {$/;"	f	signature:(int *p)
pipe_works	m4/libtool.m4	/^	    pipe_works=yes$/;"	v
place	src/heap-checker.cc	/^  ObjectPlacement place;  \/\/ where ptr points to$/;"	m	struct:AllocObject	file:	access:public
platform	INSTALL	/^platform different from the build platform, you should specify the$/;"	v
pointer	src/base/stl_allocator.h	/^  typedef T*         pointer;$/;"	t	class:STL_Allocator	access:public
pointer_source_alignment	src/heap-checker.cc	/^static size_t pointer_source_alignment = kPointerSourceAlignment;$/;"	v	file:
poll	src/windows/port.h	/^inline int poll(struct pollfd* fds, int nfds, int timeout) {$/;"	f	signature:(struct pollfd* fds, int nfds, int timeout)
popen	src/windows/port.h	/^inline FILE *popen(const char *command, const char *type) {$/;"	f	signature:(const char *command, const char *type)
pos	src/stacktrace_libgcc-inl.h	/^  int pos;$/;"	m	struct:libgcc_backtrace_data	access:public
posix_memalign	src/libc_override_redefine.h	/^  int posix_memalign(void** r, size_t a, size_t s)         {$/;"	f	signature:(void** r, size_t a, size_t s)
postinstall_cmds	m4/libtool.m4	/^  postinstall_cmds='chmod 555 $lib'$/;"	v
postuninstall_cmds	m4/libtool.m4	/^    postuninstall_cmds='dldll=`$SHELL 2>&1 -c '\\''. $file; echo \\$dlname'\\''`~$/;"	v
ppc_regs	src/base/elfcore.h	/^  typedef struct ppc_regs {$/;"	s
ppc_regs	src/base/elfcore.h	/^  } ppc_regs;$/;"	t	typeref:struct:ppc_regs
ppc_regs::ccr	src/base/elfcore.h	/^    unsigned long ccr;$/;"	m	struct:ppc_regs	access:public
ppc_regs::ctr	src/base/elfcore.h	/^    unsigned long ctr;$/;"	m	struct:ppc_regs	access:public
ppc_regs::fpr	src/base/elfcore.h	/^    double        fpr[32];	\/* Floating-Point Registers - f0-f31.        *\/$/;"	m	struct:ppc_regs	access:public
ppc_regs::lr	src/base/elfcore.h	/^    unsigned long lr;$/;"	m	struct:ppc_regs	access:public
ppc_regs::mq	src/base/elfcore.h	/^    unsigned long mq;$/;"	m	struct:ppc_regs	access:public
ppc_regs::msr	src/base/elfcore.h	/^    unsigned long msr;$/;"	m	struct:ppc_regs	access:public
ppc_regs::rip	src/base/elfcore.h	/^    unsigned long rip;		\/* Program counter.                          *\/$/;"	m	struct:ppc_regs	access:public
ppc_regs::uregs	src/base/elfcore.h	/^    unsigned long uregs[32];	\/* General Purpose Registers - r0-r31.       *\/$/;"	m	struct:ppc_regs	access:public
ppc_regs::xeq	src/base/elfcore.h	/^    unsigned long xeq;$/;"	m	struct:ppc_regs	access:public
pprof	NEWS	/^Note, while we still ship perl implementation of pprof, everyone is$/;"	v
pprof	docs/pprof_remote_servers.html	/^HREF="cpu_profiler.html">pprof<\/A>, the tool that analyzes CPU and$/;"	v
preamble_pages_	src/windows/preamble_patcher.cc	/^PreamblePatcher::PreamblePage* PreamblePatcher::preamble_pages_ = NULL;$/;"	m	class:sidestep::PreamblePatcher	file:
preamble_pages_	src/windows/preamble_patcher.h	/^  static PreamblePage* preamble_pages_;$/;"	m	class:sidestep::PreamblePatcher	access:private
prefix_list	src/pprof	/^my @prefix_list = ();$/;"	v
premmap_hooks_	src/malloc_hook.cc	/^HookList<MallocHook::PreMmapHook> premmap_hooks_ =$/;"	m	namespace:base::internal	file:
presbrk_hooks_	src/malloc_hook.cc	/^HookList<MallocHook::PreSbrkHook> presbrk_hooks_ =$/;"	m	namespace:base::internal	file:
prev	src/span.h	/^  Span*         prev;           \/\/ Used when in link list$/;"	m	struct:tcmalloc::Span	access:public
prev_	src/thread_cache.h	/^  ThreadCache* prev_;$/;"	m	class:tcmalloc::ThreadCache	access:public
printf	src/internal_logging.cc	/^void TCMalloc_Printer::printf(const char* format, ...) {$/;"	f	class:TCMalloc_Printer	signature:(const char* format, ...)
printf	src/internal_logging.h	/^  void printf(const char* format, ...)$/;"	p	class:TCMalloc_Printer	access:public	signature:(const char* format, ...)
priv_data	src/malloc_hook-inl.h	/^  AtomicWord priv_data[kHookListCapacity];$/;"	m	struct:base::internal::HookList	access:public
priv_end	src/malloc_hook-inl.h	/^  AtomicWord priv_end;$/;"	m	struct:base::internal::HookList	access:public
prof_handler	src/profiler.cc	/^  static void prof_handler(int sig, siginfo_t*, void* signal_ucontext,$/;"	p	class:CpuProfiler	file:	access:private	signature:(int sig, siginfo_t*, void* signal_ucontext, void* cpu_profiler)
prof_handler	src/profiler.cc	/^void CpuProfiler::prof_handler(int sig, siginfo_t*, void* signal_ucontext,$/;"	f	class:CpuProfiler	signature:(int sig, siginfo_t*, void* signal_ucontext, void* cpu_profiler)
prof_handler	src/tests/getpc_test.cc	/^static void prof_handler(int sig, siginfo_t*, void* signal_ucontext) {$/;"	f	file:	signature:(int sig, siginfo_t*, void* signal_ucontext)
prof_handler_called	src/tests/getpc_test.cc	/^static volatile bool prof_handler_called = false;$/;"	v	file:
prof_handler_token_	src/profiler.cc	/^  ProfileHandlerToken* prof_handler_token_;$/;"	m	class:CpuProfiler	file:	access:private
profile	docs/heap_checker.html	/^program-exit), it dumps another profile, named$/;"	v
profile_mmap_	src/heap-profile-table.h	/^  bool profile_mmap_;$/;"	m	class:HeapProfileTable	access:private
profile_name	src/gperftools/profiler.h	/^  char   profile_name[1024];  \/* Name of profile file being written, or '\\0' *\/$/;"	m	struct:ProfilerState	access:public
profile_name	src/profiledata.h	/^    char     profile_name[1024];  \/\/ Name of file being written, or '\\0'$/;"	m	struct:ProfileData::State	access:public
profile_name_prefix	src/heap-checker.cc	/^static const string* profile_name_prefix = NULL;$/;"	v	file:
profile_stats	src/heap-profile-table.h	/^    Stats* profile_stats;  \/\/ stats to update (may be NULL)$/;"	m	struct:HeapProfileTable::DumpArgs	access:public
profiler	README	/^If you want the CPU profiler, heap profiler, and heap leak-checker to$/;"	v
profiler	docs/heapprofile.html	/^system.)  Note that if you wish to use the heap profiler, you must$/;"	v
profiler_h	src/tests/simple_compat_test.cc	/^ProfilerOptions* profiler_h;$/;"	v
profiles	docs/pprof_remote_servers.html	/^<p><code>pprof<\/code> itself does just this for local profiles (not$/;"	p	file:	signature:(not ones that talk to remote servers)
profiling	docs/cpuprofile.html	/^<p>This does <i>not<\/i> turn on CPU profiling; it just inserts the$/;"	v
profiling	docs/heapprofile.html	/^<p>This does <i>not<\/i> turn on heap profiling; it just inserts the$/;"	v
program	missing	/^program=`echo "$1" | sed '$/;"	v
properties	docs/tcmalloc.html	/^<p>It is possible for an application to set and get these properties,$/;"	m	class:object::structure	file:	access:private
pthread_equal	src/windows/port.h	/^inline bool pthread_equal(pthread_t left, pthread_t right) {$/;"	f	signature:(pthread_t left, pthread_t right)
pthread_key_t	src/windows/port.h	/^typedef DWORD pthread_key_t;$/;"	t
pthread_once_init	src/maybe_threads.cc	/^static pthread_once_t pthread_once_init = PTHREAD_ONCE_INIT;$/;"	v	file:
pthread_once_t	src/windows/port.h	/^typedef LONG pthread_once_t;$/;"	t
pthread_self	src/windows/port.h	/^inline pthread_t pthread_self(void) {$/;"	f	signature:(void)
pthread_t	src/windows/port.h	/^typedef DWORD pthread_t;$/;"	t
pthreads	docs/heap_checker.html	/^<p>Also, <code>thread_lister<\/code> only works for Linux pthreads;$/;"	v
ptr	src/base/low_level_alloc.cc	/^  void *ptr;$/;"	m	union:__anon40	file:	access:public
ptr	src/debugallocation.cc	/^  void *ptr;$/;"	m	union:__anon8	file:	access:public
ptr	src/emergency_malloc.cc	/^    void *ptr;$/;"	m	union:tcmalloc::__anon29	file:	access:public
ptr	src/heap-checker.cc	/^  const void* ptr;        \/\/ the object$/;"	m	struct:AllocObject	file:	access:public
ptr	src/internal_logging.h	/^    const void* ptr;$/;"	m	union:tcmalloc::LogItem::__anon9	access:public
ptr	src/memfs_malloc.cc	/^  void *ptr;$/;"	m	union:__anon5	file:	access:public
ptr	src/system-alloc.cc	/^  void *ptr;$/;"	m	union:__anon33	file:	access:public
ptr	src/system-alloc.cc	/^  void *ptr;$/;"	m	union:__anon34	file:	access:public
ptr	src/system-alloc.cc	/^  void *ptr;$/;"	m	union:__anon35	file:	access:public
ptr	src/tests/addressmap_unittest.cc	/^  char* ptr;$/;"	m	struct:PtrAndSize	file:	access:public
ptr	src/tests/heap-checker_unittest.cc	/^  T* ptr;$/;"	m	struct:Array	file:	access:private
ptr	src/tests/heap-checker_unittest.cc	/^  mutable C* ptr;$/;"	m	class:TClass	file:	access:public
ptr	src/tests/heap-checker_unittest.cc	/^  mutable char* ptr;$/;"	m	class:ClassA	file:	access:public
ptr	src/tests/low_level_alloc_unittest.cc	/^  char *ptr;      \/\/ pointer to memory$/;"	m	struct:BlockDesc	file:	access:public
ptr	src/tests/tcmalloc_unittest.cc	/^    char*       ptr;                    \/\/ Allocated pointer$/;"	m	struct:testing::TesterThread::Object	file:	access:public
ptr	src/tests/tcmalloc_unittest.cc	/^  uintptr_t ptr;$/;"	m	struct:testing::__anon59::RangeCallbackState	file:	access:public
ptr	src/tests/tcmalloc_unittest.cc	/^  void *ptr;$/;"	m	union:__anon58	file:	access:public
ptr_	src/raw_printer.h	/^  char* ptr_;           \/\/ Where should we write next$/;"	m	class:base::RawPrinter	access:private
ptr_	src/tests/system-alloc_unittest.cc	/^  int ptr_;$/;"	m	class:ArraySysAllocator	file:	access:private
ptr_to_function	src/tests/testutil.cc	/^  void (*ptr_to_function)(int);$/;"	m	struct:FunctionAndId	file:	access:public
ptrace_detach	src/base/linux_syscall_support.h	/^  LSS_INLINE int LSS_NAME(ptrace_detach)(pid_t pid) {$/;"	f	signature:(pid_t pid)
ptrs	src/pagemap.h	/^    Node* ptrs[INTERIOR_LENGTH];$/;"	m	struct:TCMalloc_PageMap3::Node	access:public
purify	m4/libtool.m4	/^    distcc | *[[\\\\\/]]distcc | purify | *[[\\\\\/]]purify ) ;;$/;"	v
pvalloc	src/libc_override_osx.h	/^  void* pvalloc(size_t s)                { return tc_pvalloc(s);      }$/;"	f	signature:(size_t s)
pvalloc	src/libc_override_redefine.h	/^  void* pvalloc(size_t s)                        { return tc_pvalloc(s);      }$/;"	f	signature:(size_t s)
pvalloc	src/tests/tcmalloc_unittest.cc	105;"	d	file:
q	src/.libs/libtcmalloc_internal_la-internal_logging.o	/^/;"	v
q	src/tcm_min_asserts_unittest-symbolize.o	/^/;"	v
q_	src/debugallocation.cc	/^  QueueEntry q_[kFreeQueueSize];$/;"	m	class:FreeQueue	file:	access:private
q_back_	src/debugallocation.cc	/^  int q_back_;$/;"	m	class:FreeQueue	file:	access:private
q_front_	src/debugallocation.cc	/^  int q_front_;$/;"	m	class:FreeQueue	file:	access:private
query	docs/pprof_remote_servers.html	/^give the script a host and port it should query, replacing the normal$/;"	v
r	benchmark/binary_trees.cc	/^  Node *l, *r;$/;"	m	struct:Node	file:	access:public
r	src/libtcmalloc_minimal_internal_la-thread_cache.o	/^/;"	v
r	src/tests/profiler1_unittest-profiler_unittest.o	/^/;"	v
r	src/tests/profiler2_unittest-profiler_unittest.o	/^/;"	v
r10	src/base/elfcore.h	/^    uint64_t  r15,r14,r13,r12,rbp,rbx,r11,r10;$/;"	m	struct:i386_regs	access:public
r11	src/base/elfcore.h	/^    uint64_t  r15,r14,r13,r12,rbp,rbx,r11,r10;$/;"	m	struct:i386_regs	access:public
r12	src/base/elfcore.h	/^    uint64_t  r15,r14,r13,r12,rbp,rbx,r11,r10;$/;"	m	struct:i386_regs	access:public
r13	src/base/elfcore.h	/^    uint64_t  r15,r14,r13,r12,rbp,rbx,r11,r10;$/;"	m	struct:i386_regs	access:public
r14	src/base/elfcore.h	/^    uint64_t  r15,r14,r13,r12,rbp,rbx,r11,r10;$/;"	m	struct:i386_regs	access:public
r15	src/base/elfcore.h	/^    uint64_t  r15,r14,r13,r12,rbp,rbx,r11,r10;$/;"	m	struct:i386_regs	access:public
r2	src/third_party/valgrind.h	/^      unsigned int r2;  \/* what tocptr do we need? *\/$/;"	m	struct:__anon26	access:public
r2	src/third_party/valgrind.h	/^      unsigned long long int r2;  \/* what tocptr do we need? *\/$/;"	m	struct:__anon25	access:public
r2	src/third_party/valgrind.h	/^      unsigned long long int r2;  \/* what tocptr do we need? *\/$/;"	m	struct:__anon27	access:public
r8	src/base/elfcore.h	/^    uint64_t  r9,r8,rax,rcx,rdx,rsi,rdi,orig_rax;$/;"	m	struct:i386_regs	access:public
r9	src/base/elfcore.h	/^    uint64_t  r9,r8,rax,rcx,rdx,rsi,rdi,orig_rax;$/;"	m	struct:i386_regs	access:public
random	src/windows/port.h	/^inline long random(void) { return rand(); }$/;"	f	signature:(void)
randomize_buffer	benchmark/malloc_bench.cc	/^static void *randomize_buffer[13<<20];$/;"	v	file:
randomize_one_size_class	benchmark/malloc_bench.cc	/^void randomize_one_size_class(size_t size) {$/;"	f	signature:(size_t size)
randomize_size_classes	benchmark/malloc_bench.cc	/^void randomize_size_classes() {$/;"	f	signature:()
rax	src/base/elfcore.h	/^    uint64_t  r9,r8,rax,rcx,rdx,rsi,rdi,orig_rax;$/;"	m	struct:i386_regs	access:public
rax	src/windows/shortproc.asm	/^	mov rax, 1$/;"	v
rbp	src/base/elfcore.h	/^    uint64_t  r15,r14,r13,r12,rbp,rbx,r11,r10;$/;"	m	struct:i386_regs	access:public
rbx	src/base/elfcore.h	/^    uint64_t  r15,r14,r13,r12,rbp,rbx,r11,r10;$/;"	m	struct:i386_regs	access:public
rcx	src/base/elfcore.h	/^    uint64_t  r9,r8,rax,rcx,rdx,rsi,rdi,orig_rax;$/;"	m	struct:i386_regs	access:public
rdi	src/base/elfcore.h	/^    uint64_t  r9,r8,rax,rcx,rdx,rsi,rdi,orig_rax;$/;"	m	struct:i386_regs	access:public
rdx	src/base/elfcore.h	/^    uint64_t  r9,r8,rax,rcx,rdx,rsi,rdi,orig_rax;$/;"	m	struct:i386_regs	access:public
rdx	src/windows/shortproc.asm	/^	mov rdx, 0ffff1111H$/;"	v
read	src/windows/port.h	/^inline ssize_t read(int fd, void *buf, size_t count) {$/;"	f	signature:(int fd, void *buf, size_t count)
real_malloced_size	src/debugallocation.cc	/^  static size_t real_malloced_size(size_t size) {$/;"	f	class:MallocBlock	file:	access:private	signature:(size_t size)
real_mmapped_size	src/debugallocation.cc	/^  static size_t real_mmapped_size(size_t size) {$/;"	f	class:MallocBlock	file:	access:private	signature:(size_t size)
real_size	src/debugallocation.cc	/^  size_t real_size() {$/;"	f	class:MallocBlock	file:	access:private	signature:()
realloc	docs/heapprofile.html	/^    <code>malloc<\/code>, <code>calloc<\/code>, <code>realloc<\/code>,$/;"	v
realloc	docs/heapprofile.html	/^    to <code>malloc<\/code>, <code>calloc<\/code>, <code>realloc<\/code>,$/;"	v
realloc	docs/heapprofile.html	/^<code>malloc<\/code>, <code>calloc<\/code>, <code>realloc<\/code>, or,$/;"	v
realloc	src/libc_override_redefine.h	/^  void* realloc(void* p, size_t s)               { return tc_realloc(p, s);   }$/;"	f	signature:(void* p, size_t s)
rebind	src/base/stl_allocator.h	/^  template <class T1> struct rebind {$/;"	s	class:STL_Allocator	access:public
recognize$	tags	/^script	config.guess	\/^This script, last modified $timestamp, has failed to recognize$\/;"	v$/;"	v
recommend	ChangeLog.old	/^	* Use, and recommend, -fno-builtin-malloc when compiling (csilvers)$/;"	v
recursion_count_	src/memory_region_map.cc	/^int MemoryRegionMap::recursion_count_ = 0;  \/\/ GUARDED_BY(owner_lock_)$/;"	m	class:MemoryRegionMap	file:
recursion_count_	src/memory_region_map.h	/^  static int recursion_count_;$/;"	m	class:MemoryRegionMap	access:private
recursive_insert	src/memory_region_map.cc	/^static bool recursive_insert = false;$/;"	v	file:
refcount	src/span.h	/^  unsigned int  refcount : 16;  \/\/ Number of non-free objects$/;"	m	struct:tcmalloc::Span	access:public
reference	src/base/stl_allocator.h	/^  typedef T&         reference;$/;"	t	class:STL_Allocator	access:public
region_set	src/memory_region_map.cc	/^  RegionSet* region_set() { return reinterpret_cast<RegionSet*>(rep); }$/;"	f	union:MemoryRegionMap::RegionSetRep	access:public	signature:()
regions_	src/memory_region_map.cc	/^MemoryRegionMap::RegionSet* MemoryRegionMap::regions_ = NULL;$/;"	m	class:MemoryRegionMap	file:
regions_	src/memory_region_map.h	/^  static RegionSet* regions_;$/;"	m	class:MemoryRegionMap	access:private
regions_rep	src/memory_region_map.cc	/^static MemoryRegionMap::RegionSetRep regions_rep;$/;"	v	file:
release	config.guess	/^		release='-gnu'$/;"	v
release_index_	src/page_heap.h	/^  int release_index_;$/;"	m	class:tcmalloc::PageHeap	access:private
relink_command	binary_trees_shared	/^relink_command="(cd \/root\/.ghq\/github.com\/dodong471520\/gperftools; { test -z \\"\\${LIBRARY_PATH+set}\\" || unset LIBRARY_PATH || { LIBRARY_PATH=; export LIBRARY_PATH; }; }; { test -z \\"\\${COMPILER_PATH+set}\\" || unset COMPILER_PATH || { COMPILER_PATH=; export COMPILER_PATH; }; }; { test -z \\"\\${GCC_EXEC_PREFIX+set}\\" || unset GCC_EXEC_PREFIX || { GCC_EXEC_PREFIX=; export GCC_EXEC_PREFIX; }; }; { test -z \\"\\${LD_RUN_PATH+set}\\" || unset LD_RUN_PATH || { LD_RUN_PATH=; export LD_RUN_PATH; }; }; { test -z \\"\\${LD_LIBRARY_PATH+set}\\" || unset LD_LIBRARY_PATH || { LD_LIBRARY_PATH=; export LD_LIBRARY_PATH; }; }; PATH=\/usr\/lib64\/qt-3.3\/bin:\/usr\/local\/sbin:\/usr\/sbin:\/sbin:\/usr\/local\/bin:\/usr\/bin:\/bin:\/root\/bin:\/usr\/local\/go\/bin:\/root\/go\/bin:\/root\/.fzf\/bin:\/usr\/local\/go\/bin:\/root\/go\/bin:\/root\/.fzf\/bin; export PATH; g++ -pthread -Wall -Wwrite-strings -Woverloaded-virtual -Wno-sign-compare -fno-builtin-malloc -fno-builtin-free -fno-builtin-realloc -fno-builtin-calloc -fno-builtin-cfree -fno-builtin-memalign -fno-builtin-posix_memalign -fno-builtin-valloc -fno-builtin-pvalloc -Wno-unused-result -DNO_FRAME_POINTER -fno-builtin -g3 -O0 -pthread -o \\$progdir\/\\$file benchmark\/binary_trees_shared-binary_trees.o  .\/.libs\/libtcmalloc_minimal.so \/usr\/local\/lib\/..\/lib64\/libstdc++.so -lm -lpthread -pthread -Wl,-rpath -Wl,\/root\/.ghq\/github.com\/dodong471520\/gperftools\/.libs -Wl,-rpath -Wl,\/usr\/local\/lib\/..\/lib64 -Wl,-rpath -Wl,\/usr\/local\/lib\/..\/lib64)"$/;"	v
relink_command	current_allocated_bytes_test	/^relink_command="(cd \/root\/.ghq\/github.com\/dodong471520\/gperftools; { test -z \\"\\${LIBRARY_PATH+set}\\" || unset LIBRARY_PATH || { LIBRARY_PATH=; export LIBRARY_PATH; }; }; { test -z \\"\\${COMPILER_PATH+set}\\" || unset COMPILER_PATH || { COMPILER_PATH=; export COMPILER_PATH; }; }; { test -z \\"\\${GCC_EXEC_PREFIX+set}\\" || unset GCC_EXEC_PREFIX || { GCC_EXEC_PREFIX=; export GCC_EXEC_PREFIX; }; }; { test -z \\"\\${LD_RUN_PATH+set}\\" || unset LD_RUN_PATH || { LD_RUN_PATH=; export LD_RUN_PATH; }; }; { test -z \\"\\${LD_LIBRARY_PATH+set}\\" || unset LD_LIBRARY_PATH || { LD_LIBRARY_PATH=; export LD_LIBRARY_PATH; }; }; PATH=\/usr\/lib64\/qt-3.3\/bin:\/usr\/local\/sbin:\/usr\/sbin:\/sbin:\/usr\/local\/bin:\/usr\/bin:\/bin:\/root\/bin:\/usr\/local\/go\/bin:\/root\/go\/bin:\/root\/.fzf\/bin:\/usr\/local\/go\/bin:\/root\/go\/bin:\/root\/.fzf\/bin; export PATH; g++ -pthread -Wall -Wwrite-strings -Woverloaded-virtual -Wno-sign-compare -fno-builtin-malloc -fno-builtin-free -fno-builtin-realloc -fno-builtin-calloc -fno-builtin-cfree -fno-builtin-memalign -fno-builtin-posix_memalign -fno-builtin-valloc -fno-builtin-pvalloc -Wno-unused-result -DNO_FRAME_POINTER -g3 -O0 -pthread -o \\$progdir\/\\$file src\/tests\/current_allocated_bytes_test-current_allocated_bytes_test.o  .\/.libs\/libtcmalloc_minimal.so \/usr\/local\/lib\/..\/lib64\/libstdc++.so -lm -lpthread -pthread -Wl,-rpath -Wl,\/root\/.ghq\/github.com\/dodong471520\/gperftools\/.libs -Wl,-rpath -Wl,\/usr\/local\/lib\/..\/lib64 -Wl,-rpath -Wl,\/usr\/local\/lib\/..\/lib64)"$/;"	v
relink_command	debugallocation_test	/^relink_command="(cd \/root\/.ghq\/github.com\/dodong471520\/gperftools; { test -z \\"\\${LIBRARY_PATH+set}\\" || unset LIBRARY_PATH || { LIBRARY_PATH=; export LIBRARY_PATH; }; }; { test -z \\"\\${COMPILER_PATH+set}\\" || unset COMPILER_PATH || { COMPILER_PATH=; export COMPILER_PATH; }; }; { test -z \\"\\${GCC_EXEC_PREFIX+set}\\" || unset GCC_EXEC_PREFIX || { GCC_EXEC_PREFIX=; export GCC_EXEC_PREFIX; }; }; { test -z \\"\\${LD_RUN_PATH+set}\\" || unset LD_RUN_PATH || { LD_RUN_PATH=; export LD_RUN_PATH; }; }; { test -z \\"\\${LD_LIBRARY_PATH+set}\\" || unset LD_LIBRARY_PATH || { LD_LIBRARY_PATH=; export LD_LIBRARY_PATH; }; }; PATH=\/usr\/lib64\/qt-3.3\/bin:\/usr\/local\/sbin:\/usr\/sbin:\/sbin:\/usr\/local\/bin:\/usr\/bin:\/bin:\/root\/bin:\/usr\/local\/go\/bin:\/root\/go\/bin:\/root\/.fzf\/bin:\/usr\/local\/go\/bin:\/root\/go\/bin:\/root\/.fzf\/bin; export PATH; g++ -pthread -Wall -Wwrite-strings -Woverloaded-virtual -Wno-sign-compare -fno-builtin-malloc -fno-builtin-free -fno-builtin-realloc -fno-builtin-calloc -fno-builtin-cfree -fno-builtin-memalign -fno-builtin-posix_memalign -fno-builtin-valloc -fno-builtin-pvalloc -Wno-unused-result -DNO_FRAME_POINTER -fno-builtin -g3 -O0 -pthread -o \\$progdir\/\\$file src\/tests\/debugallocation_test-debugallocation_test.o  .\/.libs\/libtcmalloc_debug.so \/usr\/local\/lib\/libunwind.so -lc -lgcc_s \/usr\/local\/lib\/..\/lib64\/libstdc++.so -lm -lpthread -pthread -Wl,-rpath -Wl,\/root\/.ghq\/github.com\/dodong471520\/gperftools\/.libs -Wl,-rpath -Wl,\/usr\/local\/lib\/..\/lib64 -Wl,-rpath -Wl,\/usr\/local\/lib\/..\/lib64)"$/;"	v
relink_command	frag_unittest	/^relink_command="(cd \/root\/.ghq\/github.com\/dodong471520\/gperftools; { test -z \\"\\${LIBRARY_PATH+set}\\" || unset LIBRARY_PATH || { LIBRARY_PATH=; export LIBRARY_PATH; }; }; { test -z \\"\\${COMPILER_PATH+set}\\" || unset COMPILER_PATH || { COMPILER_PATH=; export COMPILER_PATH; }; }; { test -z \\"\\${GCC_EXEC_PREFIX+set}\\" || unset GCC_EXEC_PREFIX || { GCC_EXEC_PREFIX=; export GCC_EXEC_PREFIX; }; }; { test -z \\"\\${LD_RUN_PATH+set}\\" || unset LD_RUN_PATH || { LD_RUN_PATH=; export LD_RUN_PATH; }; }; { test -z \\"\\${LD_LIBRARY_PATH+set}\\" || unset LD_LIBRARY_PATH || { LD_LIBRARY_PATH=; export LD_LIBRARY_PATH; }; }; PATH=\/usr\/lib64\/qt-3.3\/bin:\/usr\/local\/sbin:\/usr\/sbin:\/sbin:\/usr\/local\/bin:\/usr\/bin:\/bin:\/root\/bin:\/usr\/local\/go\/bin:\/root\/go\/bin:\/root\/.fzf\/bin:\/usr\/local\/go\/bin:\/root\/go\/bin:\/root\/.fzf\/bin; export PATH; g++ -pthread -Wall -Wwrite-strings -Woverloaded-virtual -Wno-sign-compare -fno-builtin-malloc -fno-builtin-free -fno-builtin-realloc -fno-builtin-calloc -fno-builtin-cfree -fno-builtin-memalign -fno-builtin-posix_memalign -fno-builtin-valloc -fno-builtin-pvalloc -Wno-unused-result -DNO_FRAME_POINTER -fno-builtin -g3 -O0 -pthread -o \\$progdir\/\\$file src\/tests\/frag_unittest-frag_unittest.o  .\/.libs\/libtcmalloc_minimal.so \/usr\/local\/lib\/..\/lib64\/libstdc++.so -lm -lpthread -pthread -Wl,-rpath -Wl,\/root\/.ghq\/github.com\/dodong471520\/gperftools\/.libs -Wl,-rpath -Wl,\/usr\/local\/lib\/..\/lib64 -Wl,-rpath -Wl,\/usr\/local\/lib\/..\/lib64)"$/;"	v
relink_command	heap-checker_debug_unittest	/^relink_command="(cd \/root\/.ghq\/github.com\/dodong471520\/gperftools; { test -z \\"\\${LIBRARY_PATH+set}\\" || unset LIBRARY_PATH || { LIBRARY_PATH=; export LIBRARY_PATH; }; }; { test -z \\"\\${COMPILER_PATH+set}\\" || unset COMPILER_PATH || { COMPILER_PATH=; export COMPILER_PATH; }; }; { test -z \\"\\${GCC_EXEC_PREFIX+set}\\" || unset GCC_EXEC_PREFIX || { GCC_EXEC_PREFIX=; export GCC_EXEC_PREFIX; }; }; { test -z \\"\\${LD_RUN_PATH+set}\\" || unset LD_RUN_PATH || { LD_RUN_PATH=; export LD_RUN_PATH; }; }; { test -z \\"\\${LD_LIBRARY_PATH+set}\\" || unset LD_LIBRARY_PATH || { LD_LIBRARY_PATH=; export LD_LIBRARY_PATH; }; }; PATH=\/usr\/lib64\/qt-3.3\/bin:\/usr\/local\/sbin:\/usr\/sbin:\/sbin:\/usr\/local\/bin:\/usr\/bin:\/bin:\/root\/bin:\/usr\/local\/go\/bin:\/root\/go\/bin:\/root\/.fzf\/bin:\/usr\/local\/go\/bin:\/root\/go\/bin:\/root\/.fzf\/bin; export PATH; g++ -g -pthread -Wall -Wwrite-strings -Woverloaded-virtual -Wno-sign-compare -fno-builtin-malloc -fno-builtin-free -fno-builtin-realloc -fno-builtin-calloc -fno-builtin-cfree -fno-builtin-memalign -fno-builtin-posix_memalign -fno-builtin-valloc -fno-builtin-pvalloc -Wno-unused-result -DNO_FRAME_POINTER -fno-builtin -g3 -O0 -g -pthread -o \\$progdir\/\\$file src\/tests\/heap_checker_debug_unittest-heap-checker_unittest.o  .\/.libs\/libtcmalloc_debug.so \/usr\/local\/lib\/libunwind.so -lc -lgcc_s .\/.libs\/liblogging.a \/usr\/local\/lib\/..\/lib64\/libstdc++.so -lm -lpthread -pthread -Wl,-rpath -Wl,\/root\/.ghq\/github.com\/dodong471520\/gperftools\/.libs -Wl,-rpath -Wl,\/usr\/local\/lib\/..\/lib64 -Wl,-rpath -Wl,\/usr\/local\/lib\/..\/lib64)"$/;"	v
relink_command	heap-checker_unittest	/^relink_command="(cd \/root\/.ghq\/github.com\/dodong471520\/gperftools; { test -z \\"\\${LIBRARY_PATH+set}\\" || unset LIBRARY_PATH || { LIBRARY_PATH=; export LIBRARY_PATH; }; }; { test -z \\"\\${COMPILER_PATH+set}\\" || unset COMPILER_PATH || { COMPILER_PATH=; export COMPILER_PATH; }; }; { test -z \\"\\${GCC_EXEC_PREFIX+set}\\" || unset GCC_EXEC_PREFIX || { GCC_EXEC_PREFIX=; export GCC_EXEC_PREFIX; }; }; { test -z \\"\\${LD_RUN_PATH+set}\\" || unset LD_RUN_PATH || { LD_RUN_PATH=; export LD_RUN_PATH; }; }; { test -z \\"\\${LD_LIBRARY_PATH+set}\\" || unset LD_LIBRARY_PATH || { LD_LIBRARY_PATH=; export LD_LIBRARY_PATH; }; }; PATH=\/usr\/lib64\/qt-3.3\/bin:\/usr\/local\/sbin:\/usr\/sbin:\/sbin:\/usr\/local\/bin:\/usr\/bin:\/bin:\/root\/bin:\/usr\/local\/go\/bin:\/root\/go\/bin:\/root\/.fzf\/bin:\/usr\/local\/go\/bin:\/root\/go\/bin:\/root\/.fzf\/bin; export PATH; g++ -g -pthread -Wall -Wwrite-strings -Woverloaded-virtual -Wno-sign-compare -fno-builtin-malloc -fno-builtin-free -fno-builtin-realloc -fno-builtin-calloc -fno-builtin-cfree -fno-builtin-memalign -fno-builtin-posix_memalign -fno-builtin-valloc -fno-builtin-pvalloc -Wno-unused-result -DNO_FRAME_POINTER -fno-builtin -g3 -O0 -g -pthread -o \\$progdir\/\\$file src\/tests\/heap_checker_unittest-heap-checker_unittest.o  .\/.libs\/libtcmalloc.so \/usr\/local\/lib\/libunwind.so -lc -lgcc_s .\/.libs\/liblogging.a \/usr\/local\/lib\/..\/lib64\/libstdc++.so -lm -lpthread -pthread -Wl,-rpath -Wl,\/root\/.ghq\/github.com\/dodong471520\/gperftools\/.libs -Wl,-rpath -Wl,\/usr\/local\/lib\/..\/lib64 -Wl,-rpath -Wl,\/usr\/local\/lib\/..\/lib64)"$/;"	v
relink_command	heap-profiler_debug_unittest	/^relink_command="(cd \/root\/.ghq\/github.com\/dodong471520\/gperftools; { test -z \\"\\${LIBRARY_PATH+set}\\" || unset LIBRARY_PATH || { LIBRARY_PATH=; export LIBRARY_PATH; }; }; { test -z \\"\\${COMPILER_PATH+set}\\" || unset COMPILER_PATH || { COMPILER_PATH=; export COMPILER_PATH; }; }; { test -z \\"\\${GCC_EXEC_PREFIX+set}\\" || unset GCC_EXEC_PREFIX || { GCC_EXEC_PREFIX=; export GCC_EXEC_PREFIX; }; }; { test -z \\"\\${LD_RUN_PATH+set}\\" || unset LD_RUN_PATH || { LD_RUN_PATH=; export LD_RUN_PATH; }; }; { test -z \\"\\${LD_LIBRARY_PATH+set}\\" || unset LD_LIBRARY_PATH || { LD_LIBRARY_PATH=; export LD_LIBRARY_PATH; }; }; PATH=\/usr\/lib64\/qt-3.3\/bin:\/usr\/local\/sbin:\/usr\/sbin:\/sbin:\/usr\/local\/bin:\/usr\/bin:\/bin:\/root\/bin:\/usr\/local\/go\/bin:\/root\/go\/bin:\/root\/.fzf\/bin:\/usr\/local\/go\/bin:\/root\/go\/bin:\/root\/.fzf\/bin; export PATH; g++ -g -pthread -Wall -Wwrite-strings -Woverloaded-virtual -Wno-sign-compare -fno-builtin-malloc -fno-builtin-free -fno-builtin-realloc -fno-builtin-calloc -fno-builtin-cfree -fno-builtin-memalign -fno-builtin-posix_memalign -fno-builtin-valloc -fno-builtin-pvalloc -Wno-unused-result -DNO_FRAME_POINTER -fno-builtin -g3 -O0 -g -pthread -o \\$progdir\/\\$file src\/tests\/heap_profiler_debug_unittest-heap-profiler_unittest.o  .\/.libs\/libtcmalloc_debug.so \/usr\/local\/lib\/libunwind.so -lc -lgcc_s \/usr\/local\/lib\/..\/lib64\/libstdc++.so -lm -lpthread -pthread -Wl,-rpath -Wl,\/root\/.ghq\/github.com\/dodong471520\/gperftools\/.libs -Wl,-rpath -Wl,\/usr\/local\/lib\/..\/lib64 -Wl,-rpath -Wl,\/usr\/local\/lib\/..\/lib64)"$/;"	v
relink_command	heap-profiler_unittest	/^relink_command="(cd \/root\/.ghq\/github.com\/dodong471520\/gperftools; { test -z \\"\\${LIBRARY_PATH+set}\\" || unset LIBRARY_PATH || { LIBRARY_PATH=; export LIBRARY_PATH; }; }; { test -z \\"\\${COMPILER_PATH+set}\\" || unset COMPILER_PATH || { COMPILER_PATH=; export COMPILER_PATH; }; }; { test -z \\"\\${GCC_EXEC_PREFIX+set}\\" || unset GCC_EXEC_PREFIX || { GCC_EXEC_PREFIX=; export GCC_EXEC_PREFIX; }; }; { test -z \\"\\${LD_RUN_PATH+set}\\" || unset LD_RUN_PATH || { LD_RUN_PATH=; export LD_RUN_PATH; }; }; { test -z \\"\\${LD_LIBRARY_PATH+set}\\" || unset LD_LIBRARY_PATH || { LD_LIBRARY_PATH=; export LD_LIBRARY_PATH; }; }; PATH=\/usr\/lib64\/qt-3.3\/bin:\/usr\/local\/sbin:\/usr\/sbin:\/sbin:\/usr\/local\/bin:\/usr\/bin:\/bin:\/root\/bin:\/usr\/local\/go\/bin:\/root\/go\/bin:\/root\/.fzf\/bin:\/usr\/local\/go\/bin:\/root\/go\/bin:\/root\/.fzf\/bin; export PATH; g++ -g -pthread -Wall -Wwrite-strings -Woverloaded-virtual -Wno-sign-compare -fno-builtin-malloc -fno-builtin-free -fno-builtin-realloc -fno-builtin-calloc -fno-builtin-cfree -fno-builtin-memalign -fno-builtin-posix_memalign -fno-builtin-valloc -fno-builtin-pvalloc -Wno-unused-result -DNO_FRAME_POINTER -fno-builtin -g3 -O0 -g -pthread -o \\$progdir\/\\$file src\/tests\/heap_profiler_unittest-heap-profiler_unittest.o  .\/.libs\/libtcmalloc.so \/usr\/local\/lib\/libunwind.so -lc -lgcc_s \/usr\/local\/lib\/..\/lib64\/libstdc++.so -lm -lpthread -pthread -Wl,-rpath -Wl,\/root\/.ghq\/github.com\/dodong471520\/gperftools\/.libs -Wl,-rpath -Wl,\/usr\/local\/lib\/..\/lib64 -Wl,-rpath -Wl,\/usr\/local\/lib\/..\/lib64)"$/;"	v
relink_command	malloc_bench_shared	/^relink_command="(cd \/root\/.ghq\/github.com\/dodong471520\/gperftools; { test -z \\"\\${LIBRARY_PATH+set}\\" || unset LIBRARY_PATH || { LIBRARY_PATH=; export LIBRARY_PATH; }; }; { test -z \\"\\${COMPILER_PATH+set}\\" || unset COMPILER_PATH || { COMPILER_PATH=; export COMPILER_PATH; }; }; { test -z \\"\\${GCC_EXEC_PREFIX+set}\\" || unset GCC_EXEC_PREFIX || { GCC_EXEC_PREFIX=; export GCC_EXEC_PREFIX; }; }; { test -z \\"\\${LD_RUN_PATH+set}\\" || unset LD_RUN_PATH || { LD_RUN_PATH=; export LD_RUN_PATH; }; }; { test -z \\"\\${LD_LIBRARY_PATH+set}\\" || unset LD_LIBRARY_PATH || { LD_LIBRARY_PATH=; export LD_LIBRARY_PATH; }; }; PATH=\/usr\/lib64\/qt-3.3\/bin:\/usr\/local\/sbin:\/usr\/sbin:\/sbin:\/usr\/local\/bin:\/usr\/bin:\/bin:\/root\/bin:\/usr\/local\/go\/bin:\/root\/go\/bin:\/root\/.fzf\/bin:\/usr\/local\/go\/bin:\/root\/go\/bin:\/root\/.fzf\/bin; export PATH; g++ -pthread -Wall -Wwrite-strings -Woverloaded-virtual -Wno-sign-compare -fno-builtin-malloc -fno-builtin-free -fno-builtin-realloc -fno-builtin-calloc -fno-builtin-cfree -fno-builtin-memalign -fno-builtin-posix_memalign -fno-builtin-valloc -fno-builtin-pvalloc -Wno-unused-result -DNO_FRAME_POINTER -fno-builtin -g3 -O0 -pthread -o \\$progdir\/\\$file benchmark\/malloc_bench_shared-malloc_bench.o  .\/.libs\/librun_benchmark.a .\/.libs\/libtcmalloc_minimal.so \/usr\/local\/lib\/..\/lib64\/libstdc++.so -lm -lpthread -pthread -Wl,-rpath -Wl,\/root\/.ghq\/github.com\/dodong471520\/gperftools\/.libs -Wl,-rpath -Wl,\/usr\/local\/lib\/..\/lib64 -Wl,-rpath -Wl,\/usr\/local\/lib\/..\/lib64)"$/;"	v
relink_command	malloc_bench_shared_full	/^relink_command="(cd \/root\/.ghq\/github.com\/dodong471520\/gperftools; { test -z \\"\\${LIBRARY_PATH+set}\\" || unset LIBRARY_PATH || { LIBRARY_PATH=; export LIBRARY_PATH; }; }; { test -z \\"\\${COMPILER_PATH+set}\\" || unset COMPILER_PATH || { COMPILER_PATH=; export COMPILER_PATH; }; }; { test -z \\"\\${GCC_EXEC_PREFIX+set}\\" || unset GCC_EXEC_PREFIX || { GCC_EXEC_PREFIX=; export GCC_EXEC_PREFIX; }; }; { test -z \\"\\${LD_RUN_PATH+set}\\" || unset LD_RUN_PATH || { LD_RUN_PATH=; export LD_RUN_PATH; }; }; { test -z \\"\\${LD_LIBRARY_PATH+set}\\" || unset LD_LIBRARY_PATH || { LD_LIBRARY_PATH=; export LD_LIBRARY_PATH; }; }; PATH=\/usr\/lib64\/qt-3.3\/bin:\/usr\/local\/sbin:\/usr\/sbin:\/sbin:\/usr\/local\/bin:\/usr\/bin:\/bin:\/root\/bin:\/usr\/local\/go\/bin:\/root\/go\/bin:\/root\/.fzf\/bin:\/usr\/local\/go\/bin:\/root\/go\/bin:\/root\/.fzf\/bin; export PATH; g++ -pthread -Wall -Wwrite-strings -Woverloaded-virtual -Wno-sign-compare -fno-builtin-malloc -fno-builtin-free -fno-builtin-realloc -fno-builtin-calloc -fno-builtin-cfree -fno-builtin-memalign -fno-builtin-posix_memalign -fno-builtin-valloc -fno-builtin-pvalloc -Wno-unused-result -DNO_FRAME_POINTER -fno-builtin -g3 -O0 -pthread -o \\$progdir\/\\$file benchmark\/malloc_bench_shared_full-malloc_bench.o  .\/.libs\/librun_benchmark.a .\/.libs\/libtcmalloc.so \/usr\/local\/lib\/libunwind.so -lc -lgcc_s \/usr\/local\/lib\/..\/lib64\/libstdc++.so -lm -lpthread -pthread -Wl,-rpath -Wl,\/root\/.ghq\/github.com\/dodong471520\/gperftools\/.libs -Wl,-rpath -Wl,\/usr\/local\/lib\/..\/lib64 -Wl,-rpath -Wl,\/usr\/local\/lib\/..\/lib64)"$/;"	v
relink_command	malloc_extension_c_test	/^relink_command="(cd \/root\/.ghq\/github.com\/dodong471520\/gperftools; { test -z \\"\\${LIBRARY_PATH+set}\\" || unset LIBRARY_PATH || { LIBRARY_PATH=; export LIBRARY_PATH; }; }; { test -z \\"\\${COMPILER_PATH+set}\\" || unset COMPILER_PATH || { COMPILER_PATH=; export COMPILER_PATH; }; }; { test -z \\"\\${GCC_EXEC_PREFIX+set}\\" || unset GCC_EXEC_PREFIX || { GCC_EXEC_PREFIX=; export GCC_EXEC_PREFIX; }; }; { test -z \\"\\${LD_RUN_PATH+set}\\" || unset LD_RUN_PATH || { LD_RUN_PATH=; export LD_RUN_PATH; }; }; { test -z \\"\\${LD_LIBRARY_PATH+set}\\" || unset LD_LIBRARY_PATH || { LD_LIBRARY_PATH=; export LD_LIBRARY_PATH; }; }; PATH=\/usr\/lib64\/qt-3.3\/bin:\/usr\/local\/sbin:\/usr\/sbin:\/sbin:\/usr\/local\/bin:\/usr\/bin:\/bin:\/root\/bin:\/usr\/local\/go\/bin:\/root\/go\/bin:\/root\/.fzf\/bin:\/usr\/local\/go\/bin:\/root\/go\/bin:\/root\/.fzf\/bin; export PATH; gcc -pthread -ansi -g3 -O0 -pthread -o \\$progdir\/\\$file src\/tests\/malloc_extension_c_test-malloc_extension_c_test.o  .\/.libs\/libtcmalloc_minimal.so -lpthread \/usr\/local\/lib\/..\/lib64\/libstdc++.so -lm -pthread -Wl,-rpath -Wl,\/root\/.ghq\/github.com\/dodong471520\/gperftools\/.libs -Wl,-rpath -Wl,\/usr\/local\/lib\/..\/lib64 -Wl,-rpath -Wl,\/usr\/local\/lib\/..\/lib64)"$/;"	v
relink_command	malloc_extension_debug_test	/^relink_command="(cd \/root\/.ghq\/github.com\/dodong471520\/gperftools; { test -z \\"\\${LIBRARY_PATH+set}\\" || unset LIBRARY_PATH || { LIBRARY_PATH=; export LIBRARY_PATH; }; }; { test -z \\"\\${COMPILER_PATH+set}\\" || unset COMPILER_PATH || { COMPILER_PATH=; export COMPILER_PATH; }; }; { test -z \\"\\${GCC_EXEC_PREFIX+set}\\" || unset GCC_EXEC_PREFIX || { GCC_EXEC_PREFIX=; export GCC_EXEC_PREFIX; }; }; { test -z \\"\\${LD_RUN_PATH+set}\\" || unset LD_RUN_PATH || { LD_RUN_PATH=; export LD_RUN_PATH; }; }; { test -z \\"\\${LD_LIBRARY_PATH+set}\\" || unset LD_LIBRARY_PATH || { LD_LIBRARY_PATH=; export LD_LIBRARY_PATH; }; }; PATH=\/usr\/lib64\/qt-3.3\/bin:\/usr\/local\/sbin:\/usr\/sbin:\/sbin:\/usr\/local\/bin:\/usr\/bin:\/bin:\/root\/bin:\/usr\/local\/go\/bin:\/root\/go\/bin:\/root\/.fzf\/bin:\/usr\/local\/go\/bin:\/root\/go\/bin:\/root\/.fzf\/bin; export PATH; g++ -pthread -Wall -Wwrite-strings -Woverloaded-virtual -Wno-sign-compare -fno-builtin-malloc -fno-builtin-free -fno-builtin-realloc -fno-builtin-calloc -fno-builtin-cfree -fno-builtin-memalign -fno-builtin-posix_memalign -fno-builtin-valloc -fno-builtin-pvalloc -Wno-unused-result -DNO_FRAME_POINTER -g3 -O0 -pthread -o \\$progdir\/\\$file src\/tests\/malloc_extension_debug_test-malloc_extension_test.o  .\/.libs\/libtcmalloc_minimal_debug.so \/usr\/local\/lib\/..\/lib64\/libstdc++.so -lm -lpthread -pthread -Wl,-rpath -Wl,\/root\/.ghq\/github.com\/dodong471520\/gperftools\/.libs -Wl,-rpath -Wl,\/usr\/local\/lib\/..\/lib64 -Wl,-rpath -Wl,\/usr\/local\/lib\/..\/lib64)"$/;"	v
relink_command	malloc_extension_test	/^relink_command="(cd \/root\/.ghq\/github.com\/dodong471520\/gperftools; { test -z \\"\\${LIBRARY_PATH+set}\\" || unset LIBRARY_PATH || { LIBRARY_PATH=; export LIBRARY_PATH; }; }; { test -z \\"\\${COMPILER_PATH+set}\\" || unset COMPILER_PATH || { COMPILER_PATH=; export COMPILER_PATH; }; }; { test -z \\"\\${GCC_EXEC_PREFIX+set}\\" || unset GCC_EXEC_PREFIX || { GCC_EXEC_PREFIX=; export GCC_EXEC_PREFIX; }; }; { test -z \\"\\${LD_RUN_PATH+set}\\" || unset LD_RUN_PATH || { LD_RUN_PATH=; export LD_RUN_PATH; }; }; { test -z \\"\\${LD_LIBRARY_PATH+set}\\" || unset LD_LIBRARY_PATH || { LD_LIBRARY_PATH=; export LD_LIBRARY_PATH; }; }; PATH=\/usr\/lib64\/qt-3.3\/bin:\/usr\/local\/sbin:\/usr\/sbin:\/sbin:\/usr\/local\/bin:\/usr\/bin:\/bin:\/root\/bin:\/usr\/local\/go\/bin:\/root\/go\/bin:\/root\/.fzf\/bin:\/usr\/local\/go\/bin:\/root\/go\/bin:\/root\/.fzf\/bin; export PATH; g++ -pthread -Wall -Wwrite-strings -Woverloaded-virtual -Wno-sign-compare -fno-builtin-malloc -fno-builtin-free -fno-builtin-realloc -fno-builtin-calloc -fno-builtin-cfree -fno-builtin-memalign -fno-builtin-posix_memalign -fno-builtin-valloc -fno-builtin-pvalloc -Wno-unused-result -DNO_FRAME_POINTER -g3 -O0 -pthread -o \\$progdir\/\\$file src\/tests\/malloc_extension_test-malloc_extension_test.o  .\/.libs\/libtcmalloc_minimal.so \/usr\/local\/lib\/..\/lib64\/libstdc++.so -lm -lpthread -pthread -Wl,-rpath -Wl,\/root\/.ghq\/github.com\/dodong471520\/gperftools\/.libs -Wl,-rpath -Wl,\/usr\/local\/lib\/..\/lib64 -Wl,-rpath -Wl,\/usr\/local\/lib\/..\/lib64)"$/;"	v
relink_command	malloc_hook_test	/^relink_command="(cd \/root\/.ghq\/github.com\/dodong471520\/gperftools; { test -z \\"\\${LIBRARY_PATH+set}\\" || unset LIBRARY_PATH || { LIBRARY_PATH=; export LIBRARY_PATH; }; }; { test -z \\"\\${COMPILER_PATH+set}\\" || unset COMPILER_PATH || { COMPILER_PATH=; export COMPILER_PATH; }; }; { test -z \\"\\${GCC_EXEC_PREFIX+set}\\" || unset GCC_EXEC_PREFIX || { GCC_EXEC_PREFIX=; export GCC_EXEC_PREFIX; }; }; { test -z \\"\\${LD_RUN_PATH+set}\\" || unset LD_RUN_PATH || { LD_RUN_PATH=; export LD_RUN_PATH; }; }; { test -z \\"\\${LD_LIBRARY_PATH+set}\\" || unset LD_LIBRARY_PATH || { LD_LIBRARY_PATH=; export LD_LIBRARY_PATH; }; }; PATH=\/usr\/lib64\/qt-3.3\/bin:\/usr\/local\/sbin:\/usr\/sbin:\/sbin:\/usr\/local\/bin:\/usr\/bin:\/bin:\/root\/bin:\/usr\/local\/go\/bin:\/root\/go\/bin:\/root\/.fzf\/bin:\/usr\/local\/go\/bin:\/root\/go\/bin:\/root\/.fzf\/bin; export PATH; g++ -pthread -Wall -Wwrite-strings -Woverloaded-virtual -Wno-sign-compare -fno-builtin-malloc -fno-builtin-free -fno-builtin-realloc -fno-builtin-calloc -fno-builtin-cfree -fno-builtin-memalign -fno-builtin-posix_memalign -fno-builtin-valloc -fno-builtin-pvalloc -Wno-unused-result -DNO_FRAME_POINTER -g3 -O0 -pthread -o \\$progdir\/\\$file src\/tests\/malloc_hook_test-malloc_hook_test.o src\/tests\/malloc_hook_test-testutil.o  .\/.libs\/libtcmalloc_minimal.so \/usr\/local\/lib\/..\/lib64\/libstdc++.so -lm -lpthread -pthread -Wl,-rpath -Wl,\/root\/.ghq\/github.com\/dodong471520\/gperftools\/.libs -Wl,-rpath -Wl,\/usr\/local\/lib\/..\/lib64 -Wl,-rpath -Wl,\/usr\/local\/lib\/..\/lib64)"$/;"	v
relink_command	markidle_unittest	/^relink_command="(cd \/root\/.ghq\/github.com\/dodong471520\/gperftools; { test -z \\"\\${LIBRARY_PATH+set}\\" || unset LIBRARY_PATH || { LIBRARY_PATH=; export LIBRARY_PATH; }; }; { test -z \\"\\${COMPILER_PATH+set}\\" || unset COMPILER_PATH || { COMPILER_PATH=; export COMPILER_PATH; }; }; { test -z \\"\\${GCC_EXEC_PREFIX+set}\\" || unset GCC_EXEC_PREFIX || { GCC_EXEC_PREFIX=; export GCC_EXEC_PREFIX; }; }; { test -z \\"\\${LD_RUN_PATH+set}\\" || unset LD_RUN_PATH || { LD_RUN_PATH=; export LD_RUN_PATH; }; }; { test -z \\"\\${LD_LIBRARY_PATH+set}\\" || unset LD_LIBRARY_PATH || { LD_LIBRARY_PATH=; export LD_LIBRARY_PATH; }; }; PATH=\/usr\/lib64\/qt-3.3\/bin:\/usr\/local\/sbin:\/usr\/sbin:\/sbin:\/usr\/local\/bin:\/usr\/bin:\/bin:\/root\/bin:\/usr\/local\/go\/bin:\/root\/go\/bin:\/root\/.fzf\/bin:\/usr\/local\/go\/bin:\/root\/go\/bin:\/root\/.fzf\/bin; export PATH; g++ -pthread -Wall -Wwrite-strings -Woverloaded-virtual -Wno-sign-compare -fno-builtin-malloc -fno-builtin-free -fno-builtin-realloc -fno-builtin-calloc -fno-builtin-cfree -fno-builtin-memalign -fno-builtin-posix_memalign -fno-builtin-valloc -fno-builtin-pvalloc -Wno-unused-result -DNO_FRAME_POINTER -fno-builtin -g3 -O0 -pthread -o \\$progdir\/\\$file src\/tests\/markidle_unittest-markidle_unittest.o src\/tests\/markidle_unittest-testutil.o  .\/.libs\/libtcmalloc_minimal.so \/usr\/local\/lib\/..\/lib64\/libstdc++.so -lm -lpthread -pthread -Wl,-rpath -Wl,\/root\/.ghq\/github.com\/dodong471520\/gperftools\/.libs -Wl,-rpath -Wl,\/usr\/local\/lib\/..\/lib64 -Wl,-rpath -Wl,\/usr\/local\/lib\/..\/lib64)"$/;"	v
relink_command	memalign_debug_unittest	/^relink_command="(cd \/root\/.ghq\/github.com\/dodong471520\/gperftools; { test -z \\"\\${LIBRARY_PATH+set}\\" || unset LIBRARY_PATH || { LIBRARY_PATH=; export LIBRARY_PATH; }; }; { test -z \\"\\${COMPILER_PATH+set}\\" || unset COMPILER_PATH || { COMPILER_PATH=; export COMPILER_PATH; }; }; { test -z \\"\\${GCC_EXEC_PREFIX+set}\\" || unset GCC_EXEC_PREFIX || { GCC_EXEC_PREFIX=; export GCC_EXEC_PREFIX; }; }; { test -z \\"\\${LD_RUN_PATH+set}\\" || unset LD_RUN_PATH || { LD_RUN_PATH=; export LD_RUN_PATH; }; }; { test -z \\"\\${LD_LIBRARY_PATH+set}\\" || unset LD_LIBRARY_PATH || { LD_LIBRARY_PATH=; export LD_LIBRARY_PATH; }; }; PATH=\/usr\/lib64\/qt-3.3\/bin:\/usr\/local\/sbin:\/usr\/sbin:\/sbin:\/usr\/local\/bin:\/usr\/bin:\/bin:\/root\/bin:\/usr\/local\/go\/bin:\/root\/go\/bin:\/root\/.fzf\/bin:\/usr\/local\/go\/bin:\/root\/go\/bin:\/root\/.fzf\/bin; export PATH; g++ -pthread -Wall -Wwrite-strings -Woverloaded-virtual -Wno-sign-compare -fno-builtin-malloc -fno-builtin-free -fno-builtin-realloc -fno-builtin-calloc -fno-builtin-cfree -fno-builtin-memalign -fno-builtin-posix_memalign -fno-builtin-valloc -fno-builtin-pvalloc -Wno-unused-result -DNO_FRAME_POINTER -fno-builtin -g3 -O0 -pthread -o \\$progdir\/\\$file src\/tests\/memalign_debug_unittest-memalign_unittest.o src\/tests\/memalign_debug_unittest-testutil.o  .\/.libs\/libtcmalloc_minimal_debug.so \/usr\/local\/lib\/..\/lib64\/libstdc++.so -lm -lpthread -pthread -Wl,-rpath -Wl,\/root\/.ghq\/github.com\/dodong471520\/gperftools\/.libs -Wl,-rpath -Wl,\/usr\/local\/lib\/..\/lib64 -Wl,-rpath -Wl,\/usr\/local\/lib\/..\/lib64)"$/;"	v
relink_command	memalign_unittest	/^relink_command="(cd \/root\/.ghq\/github.com\/dodong471520\/gperftools; { test -z \\"\\${LIBRARY_PATH+set}\\" || unset LIBRARY_PATH || { LIBRARY_PATH=; export LIBRARY_PATH; }; }; { test -z \\"\\${COMPILER_PATH+set}\\" || unset COMPILER_PATH || { COMPILER_PATH=; export COMPILER_PATH; }; }; { test -z \\"\\${GCC_EXEC_PREFIX+set}\\" || unset GCC_EXEC_PREFIX || { GCC_EXEC_PREFIX=; export GCC_EXEC_PREFIX; }; }; { test -z \\"\\${LD_RUN_PATH+set}\\" || unset LD_RUN_PATH || { LD_RUN_PATH=; export LD_RUN_PATH; }; }; { test -z \\"\\${LD_LIBRARY_PATH+set}\\" || unset LD_LIBRARY_PATH || { LD_LIBRARY_PATH=; export LD_LIBRARY_PATH; }; }; PATH=\/usr\/lib64\/qt-3.3\/bin:\/usr\/local\/sbin:\/usr\/sbin:\/sbin:\/usr\/local\/bin:\/usr\/bin:\/bin:\/root\/bin:\/usr\/local\/go\/bin:\/root\/go\/bin:\/root\/.fzf\/bin:\/usr\/local\/go\/bin:\/root\/go\/bin:\/root\/.fzf\/bin; export PATH; g++ -pthread -Wall -Wwrite-strings -Woverloaded-virtual -Wno-sign-compare -fno-builtin-malloc -fno-builtin-free -fno-builtin-realloc -fno-builtin-calloc -fno-builtin-cfree -fno-builtin-memalign -fno-builtin-posix_memalign -fno-builtin-valloc -fno-builtin-pvalloc -Wno-unused-result -DNO_FRAME_POINTER -fno-builtin -g3 -O0 -pthread -o \\$progdir\/\\$file src\/tests\/memalign_unittest-memalign_unittest.o src\/tests\/memalign_unittest-testutil.o  .\/.libs\/libtcmalloc_minimal.so \/usr\/local\/lib\/..\/lib64\/libstdc++.so -lm -lpthread -pthread -Wl,-rpath -Wl,\/root\/.ghq\/github.com\/dodong471520\/gperftools\/.libs -Wl,-rpath -Wl,\/usr\/local\/lib\/..\/lib64 -Wl,-rpath -Wl,\/usr\/local\/lib\/..\/lib64)"$/;"	v
relink_command	packed_cache_test	/^relink_command="(cd \/root\/.ghq\/github.com\/dodong471520\/gperftools; { test -z \\"\\${LIBRARY_PATH+set}\\" || unset LIBRARY_PATH || { LIBRARY_PATH=; export LIBRARY_PATH; }; }; { test -z \\"\\${COMPILER_PATH+set}\\" || unset COMPILER_PATH || { COMPILER_PATH=; export COMPILER_PATH; }; }; { test -z \\"\\${GCC_EXEC_PREFIX+set}\\" || unset GCC_EXEC_PREFIX || { GCC_EXEC_PREFIX=; export GCC_EXEC_PREFIX; }; }; { test -z \\"\\${LD_RUN_PATH+set}\\" || unset LD_RUN_PATH || { LD_RUN_PATH=; export LD_RUN_PATH; }; }; { test -z \\"\\${LD_LIBRARY_PATH+set}\\" || unset LD_LIBRARY_PATH || { LD_LIBRARY_PATH=; export LD_LIBRARY_PATH; }; }; PATH=\/usr\/lib64\/qt-3.3\/bin:\/usr\/local\/sbin:\/usr\/sbin:\/sbin:\/usr\/local\/bin:\/usr\/bin:\/bin:\/root\/bin:\/usr\/local\/go\/bin:\/root\/go\/bin:\/root\/.fzf\/bin:\/usr\/local\/go\/bin:\/root\/go\/bin:\/root\/.fzf\/bin; export PATH; g++ -pthread -Wall -Wwrite-strings -Woverloaded-virtual -Wno-sign-compare -fno-builtin-malloc -fno-builtin-free -fno-builtin-realloc -fno-builtin-calloc -fno-builtin-cfree -fno-builtin-memalign -fno-builtin-posix_memalign -fno-builtin-valloc -fno-builtin-pvalloc -Wno-unused-result -DNO_FRAME_POINTER -g3 -O0 -pthread -o \\$progdir\/\\$file src\/tests\/packed_cache_test-packed-cache_test.o  .\/.libs\/libtcmalloc_minimal.so \/usr\/local\/lib\/..\/lib64\/libstdc++.so -lm -lpthread -pthread -Wl,-rpath -Wl,\/root\/.ghq\/github.com\/dodong471520\/gperftools\/.libs -Wl,-rpath -Wl,\/usr\/local\/lib\/..\/lib64 -Wl,-rpath -Wl,\/usr\/local\/lib\/..\/lib64)"$/;"	v
relink_command	page_heap_test	/^relink_command="(cd \/root\/.ghq\/github.com\/dodong471520\/gperftools; { test -z \\"\\${LIBRARY_PATH+set}\\" || unset LIBRARY_PATH || { LIBRARY_PATH=; export LIBRARY_PATH; }; }; { test -z \\"\\${COMPILER_PATH+set}\\" || unset COMPILER_PATH || { COMPILER_PATH=; export COMPILER_PATH; }; }; { test -z \\"\\${GCC_EXEC_PREFIX+set}\\" || unset GCC_EXEC_PREFIX || { GCC_EXEC_PREFIX=; export GCC_EXEC_PREFIX; }; }; { test -z \\"\\${LD_RUN_PATH+set}\\" || unset LD_RUN_PATH || { LD_RUN_PATH=; export LD_RUN_PATH; }; }; { test -z \\"\\${LD_LIBRARY_PATH+set}\\" || unset LD_LIBRARY_PATH || { LD_LIBRARY_PATH=; export LD_LIBRARY_PATH; }; }; PATH=\/usr\/lib64\/qt-3.3\/bin:\/usr\/local\/sbin:\/usr\/sbin:\/sbin:\/usr\/local\/bin:\/usr\/bin:\/bin:\/root\/bin:\/usr\/local\/go\/bin:\/root\/go\/bin:\/root\/.fzf\/bin:\/usr\/local\/go\/bin:\/root\/go\/bin:\/root\/.fzf\/bin; export PATH; g++ -pthread -Wall -Wwrite-strings -Woverloaded-virtual -Wno-sign-compare -fno-builtin-malloc -fno-builtin-free -fno-builtin-realloc -fno-builtin-calloc -fno-builtin-cfree -fno-builtin-memalign -fno-builtin-posix_memalign -fno-builtin-valloc -fno-builtin-pvalloc -Wno-unused-result -DNO_FRAME_POINTER -g3 -O0 -pthread -o \\$progdir\/\\$file src\/tests\/page_heap_test-page_heap_test.o  .\/.libs\/libtcmalloc_minimal.so \/usr\/local\/lib\/..\/lib64\/libstdc++.so -lm -lpthread -pthread -Wl,-rpath -Wl,\/root\/.ghq\/github.com\/dodong471520\/gperftools\/.libs -Wl,-rpath -Wl,\/usr\/local\/lib\/..\/lib64 -Wl,-rpath -Wl,\/usr\/local\/lib\/..\/lib64)"$/;"	v
relink_command	pagemap_unittest	/^relink_command="(cd \/root\/.ghq\/github.com\/dodong471520\/gperftools; { test -z \\"\\${LIBRARY_PATH+set}\\" || unset LIBRARY_PATH || { LIBRARY_PATH=; export LIBRARY_PATH; }; }; { test -z \\"\\${COMPILER_PATH+set}\\" || unset COMPILER_PATH || { COMPILER_PATH=; export COMPILER_PATH; }; }; { test -z \\"\\${GCC_EXEC_PREFIX+set}\\" || unset GCC_EXEC_PREFIX || { GCC_EXEC_PREFIX=; export GCC_EXEC_PREFIX; }; }; { test -z \\"\\${LD_RUN_PATH+set}\\" || unset LD_RUN_PATH || { LD_RUN_PATH=; export LD_RUN_PATH; }; }; { test -z \\"\\${LD_LIBRARY_PATH+set}\\" || unset LD_LIBRARY_PATH || { LD_LIBRARY_PATH=; export LD_LIBRARY_PATH; }; }; PATH=\/usr\/lib64\/qt-3.3\/bin:\/usr\/local\/sbin:\/usr\/sbin:\/sbin:\/usr\/local\/bin:\/usr\/bin:\/bin:\/root\/bin:\/usr\/local\/go\/bin:\/root\/go\/bin:\/root\/.fzf\/bin:\/usr\/local\/go\/bin:\/root\/go\/bin:\/root\/.fzf\/bin; export PATH; g++ -pthread -Wall -Wwrite-strings -Woverloaded-virtual -Wno-sign-compare -fno-builtin-malloc -fno-builtin-free -fno-builtin-realloc -fno-builtin-calloc -fno-builtin-cfree -fno-builtin-memalign -fno-builtin-posix_memalign -fno-builtin-valloc -fno-builtin-pvalloc -Wno-unused-result -DNO_FRAME_POINTER -fno-builtin -g3 -O0 -pthread -o \\$progdir\/\\$file src\/tests\/pagemap_unittest-pagemap_unittest.o  .\/.libs\/libtcmalloc_minimal.so \/usr\/local\/lib\/..\/lib64\/libstdc++.so -lm -lpthread -pthread -Wl,-rpath -Wl,\/root\/.ghq\/github.com\/dodong471520\/gperftools\/.libs -Wl,-rpath -Wl,\/usr\/local\/lib\/..\/lib64 -Wl,-rpath -Wl,\/usr\/local\/lib\/..\/lib64)"$/;"	v
relink_command	profile_handler_unittest	/^relink_command="(cd \/root\/.ghq\/github.com\/dodong471520\/gperftools; { test -z \\"\\${LIBRARY_PATH+set}\\" || unset LIBRARY_PATH || { LIBRARY_PATH=; export LIBRARY_PATH; }; }; { test -z \\"\\${COMPILER_PATH+set}\\" || unset COMPILER_PATH || { COMPILER_PATH=; export COMPILER_PATH; }; }; { test -z \\"\\${GCC_EXEC_PREFIX+set}\\" || unset GCC_EXEC_PREFIX || { GCC_EXEC_PREFIX=; export GCC_EXEC_PREFIX; }; }; { test -z \\"\\${LD_RUN_PATH+set}\\" || unset LD_RUN_PATH || { LD_RUN_PATH=; export LD_RUN_PATH; }; }; { test -z \\"\\${LD_LIBRARY_PATH+set}\\" || unset LD_LIBRARY_PATH || { LD_LIBRARY_PATH=; export LD_LIBRARY_PATH; }; }; PATH=\/usr\/lib64\/qt-3.3\/bin:\/usr\/local\/sbin:\/usr\/sbin:\/sbin:\/usr\/local\/bin:\/usr\/bin:\/bin:\/root\/bin:\/usr\/local\/go\/bin:\/root\/go\/bin:\/root\/.fzf\/bin:\/usr\/local\/go\/bin:\/root\/go\/bin:\/root\/.fzf\/bin; export PATH; g++ -pthread -g3 -O0 -pthread -o \\$progdir\/\\$file src\/tests\/profile_handler_unittest-profile-handler_unittest.o  .\/.libs\/libstacktrace.a .\/.libs\/libprofiler.so \/usr\/local\/lib\/libunwind.so -lc -lgcc_s \/usr\/local\/lib\/..\/lib64\/libstdc++.so -lm -lpthread -pthread -Wl,-rpath -Wl,\/root\/.ghq\/github.com\/dodong471520\/gperftools\/.libs -Wl,-rpath -Wl,\/usr\/local\/lib\/..\/lib64 -Wl,-rpath -Wl,\/usr\/local\/lib\/..\/lib64)"$/;"	v
relink_command	profiledata_unittest	/^relink_command="(cd \/root\/.ghq\/github.com\/dodong471520\/gperftools; { test -z \\"\\${LIBRARY_PATH+set}\\" || unset LIBRARY_PATH || { LIBRARY_PATH=; export LIBRARY_PATH; }; }; { test -z \\"\\${COMPILER_PATH+set}\\" || unset COMPILER_PATH || { COMPILER_PATH=; export COMPILER_PATH; }; }; { test -z \\"\\${GCC_EXEC_PREFIX+set}\\" || unset GCC_EXEC_PREFIX || { GCC_EXEC_PREFIX=; export GCC_EXEC_PREFIX; }; }; { test -z \\"\\${LD_RUN_PATH+set}\\" || unset LD_RUN_PATH || { LD_RUN_PATH=; export LD_RUN_PATH; }; }; { test -z \\"\\${LD_LIBRARY_PATH+set}\\" || unset LD_LIBRARY_PATH || { LD_LIBRARY_PATH=; export LD_LIBRARY_PATH; }; }; PATH=\/usr\/lib64\/qt-3.3\/bin:\/usr\/local\/sbin:\/usr\/sbin:\/sbin:\/usr\/local\/bin:\/usr\/bin:\/bin:\/root\/bin:\/usr\/local\/go\/bin:\/root\/go\/bin:\/root\/.fzf\/bin:\/usr\/local\/go\/bin:\/root\/go\/bin:\/root\/.fzf\/bin; export PATH; g++ -Wall -Wwrite-strings -Woverloaded-virtual -Wno-sign-compare -fno-builtin-malloc -fno-builtin-free -fno-builtin-realloc -fno-builtin-calloc -fno-builtin-cfree -fno-builtin-memalign -fno-builtin-posix_memalign -fno-builtin-valloc -fno-builtin-pvalloc -Wno-unused-result -DNO_FRAME_POINTER -g3 -O0 -o \\$progdir\/\\$file src\/tests\/profiledata_unittest.o  .\/.libs\/libstacktrace.a .\/.libs\/libprofiler.so \/usr\/local\/lib\/libunwind.so -lc -lgcc_s \/usr\/local\/lib\/..\/lib64\/libstdc++.so -lm -Wl,-rpath -Wl,\/root\/.ghq\/github.com\/dodong471520\/gperftools\/.libs -Wl,-rpath -Wl,\/usr\/local\/lib\/..\/lib64 -Wl,-rpath -Wl,\/usr\/local\/lib\/..\/lib64)"$/;"	v
relink_command	profiler1_unittest	/^relink_command="(cd \/root\/.ghq\/github.com\/dodong471520\/gperftools; { test -z \\"\\${LIBRARY_PATH+set}\\" || unset LIBRARY_PATH || { LIBRARY_PATH=; export LIBRARY_PATH; }; }; { test -z \\"\\${COMPILER_PATH+set}\\" || unset COMPILER_PATH || { COMPILER_PATH=; export COMPILER_PATH; }; }; { test -z \\"\\${GCC_EXEC_PREFIX+set}\\" || unset GCC_EXEC_PREFIX || { GCC_EXEC_PREFIX=; export GCC_EXEC_PREFIX; }; }; { test -z \\"\\${LD_RUN_PATH+set}\\" || unset LD_RUN_PATH || { LD_RUN_PATH=; export LD_RUN_PATH; }; }; { test -z \\"\\${LD_LIBRARY_PATH+set}\\" || unset LD_LIBRARY_PATH || { LD_LIBRARY_PATH=; export LD_LIBRARY_PATH; }; }; PATH=\/usr\/lib64\/qt-3.3\/bin:\/usr\/local\/sbin:\/usr\/sbin:\/sbin:\/usr\/local\/bin:\/usr\/bin:\/bin:\/root\/bin:\/usr\/local\/go\/bin:\/root\/go\/bin:\/root\/.fzf\/bin:\/usr\/local\/go\/bin:\/root\/go\/bin:\/root\/.fzf\/bin; export PATH; g++ -g -DNO_THREADS -Wall -Wwrite-strings -Woverloaded-virtual -Wno-sign-compare -fno-builtin-malloc -fno-builtin-free -fno-builtin-realloc -fno-builtin-calloc -fno-builtin-cfree -fno-builtin-memalign -fno-builtin-posix_memalign -fno-builtin-valloc -fno-builtin-pvalloc -Wno-unused-result -DNO_FRAME_POINTER -g3 -O0 -o \\$progdir\/\\$file src\/tests\/profiler1_unittest-profiler_unittest.o src\/tests\/profiler1_unittest-testutil.o  .\/.libs\/libstacktrace.a .\/.libs\/libprofiler.so \/usr\/local\/lib\/libunwind.so -lc -lgcc_s \/usr\/local\/lib\/..\/lib64\/libstdc++.so -lm -Wl,-rpath -Wl,\/root\/.ghq\/github.com\/dodong471520\/gperftools\/.libs -Wl,-rpath -Wl,\/usr\/local\/lib\/..\/lib64 -Wl,-rpath -Wl,\/usr\/local\/lib\/..\/lib64)"$/;"	v
relink_command	profiler2_unittest	/^relink_command="(cd \/root\/.ghq\/github.com\/dodong471520\/gperftools; { test -z \\"\\${LIBRARY_PATH+set}\\" || unset LIBRARY_PATH || { LIBRARY_PATH=; export LIBRARY_PATH; }; }; { test -z \\"\\${COMPILER_PATH+set}\\" || unset COMPILER_PATH || { COMPILER_PATH=; export COMPILER_PATH; }; }; { test -z \\"\\${GCC_EXEC_PREFIX+set}\\" || unset GCC_EXEC_PREFIX || { GCC_EXEC_PREFIX=; export GCC_EXEC_PREFIX; }; }; { test -z \\"\\${LD_RUN_PATH+set}\\" || unset LD_RUN_PATH || { LD_RUN_PATH=; export LD_RUN_PATH; }; }; { test -z \\"\\${LD_LIBRARY_PATH+set}\\" || unset LD_LIBRARY_PATH || { LD_LIBRARY_PATH=; export LD_LIBRARY_PATH; }; }; PATH=\/usr\/lib64\/qt-3.3\/bin:\/usr\/local\/sbin:\/usr\/sbin:\/sbin:\/usr\/local\/bin:\/usr\/bin:\/bin:\/root\/bin:\/usr\/local\/go\/bin:\/root\/go\/bin:\/root\/.fzf\/bin:\/usr\/local\/go\/bin:\/root\/go\/bin:\/root\/.fzf\/bin; export PATH; g++ -g -DNO_THREADS -Wall -Wwrite-strings -Woverloaded-virtual -Wno-sign-compare -fno-builtin-malloc -fno-builtin-free -fno-builtin-realloc -fno-builtin-calloc -fno-builtin-cfree -fno-builtin-memalign -fno-builtin-posix_memalign -fno-builtin-valloc -fno-builtin-pvalloc -Wno-unused-result -DNO_FRAME_POINTER -g3 -O0 -o \\$progdir\/\\$file src\/tests\/profiler2_unittest-profiler_unittest.o src\/tests\/profiler2_unittest-testutil.o  \/root\/.ghq\/github.com\/dodong471520\/gperftools\/.libs\/libstacktrace.a \/root\/.ghq\/github.com\/dodong471520\/gperftools\/.libs\/libprofiler.so \/usr\/local\/lib\/libunwind.so -lc -lgcc_s \/usr\/local\/lib\/..\/lib64\/libstdc++.so -lm -Wl,-rpath -Wl,\/root\/.ghq\/github.com\/dodong471520\/gperftools\/.libs -Wl,-rpath -Wl,\/usr\/local\/lib\/..\/lib64 -Wl,-rpath -Wl,\/usr\/local\/lib\/..\/lib64)"$/;"	v
relink_command	profiler3_unittest	/^relink_command="(cd \/root\/.ghq\/github.com\/dodong471520\/gperftools; { test -z \\"\\${LIBRARY_PATH+set}\\" || unset LIBRARY_PATH || { LIBRARY_PATH=; export LIBRARY_PATH; }; }; { test -z \\"\\${COMPILER_PATH+set}\\" || unset COMPILER_PATH || { COMPILER_PATH=; export COMPILER_PATH; }; }; { test -z \\"\\${GCC_EXEC_PREFIX+set}\\" || unset GCC_EXEC_PREFIX || { GCC_EXEC_PREFIX=; export GCC_EXEC_PREFIX; }; }; { test -z \\"\\${LD_RUN_PATH+set}\\" || unset LD_RUN_PATH || { LD_RUN_PATH=; export LD_RUN_PATH; }; }; { test -z \\"\\${LD_LIBRARY_PATH+set}\\" || unset LD_LIBRARY_PATH || { LD_LIBRARY_PATH=; export LD_LIBRARY_PATH; }; }; PATH=\/usr\/lib64\/qt-3.3\/bin:\/usr\/local\/sbin:\/usr\/sbin:\/sbin:\/usr\/local\/bin:\/usr\/bin:\/bin:\/root\/bin:\/usr\/local\/go\/bin:\/root\/go\/bin:\/root\/.fzf\/bin:\/usr\/local\/go\/bin:\/root\/go\/bin:\/root\/.fzf\/bin; export PATH; g++ -g -pthread -Wall -Wwrite-strings -Woverloaded-virtual -Wno-sign-compare -fno-builtin-malloc -fno-builtin-free -fno-builtin-realloc -fno-builtin-calloc -fno-builtin-cfree -fno-builtin-memalign -fno-builtin-posix_memalign -fno-builtin-valloc -fno-builtin-pvalloc -Wno-unused-result -DNO_FRAME_POINTER -g3 -O0 -pthread -o \\$progdir\/\\$file src\/tests\/profiler3_unittest-profiler_unittest.o src\/tests\/profiler3_unittest-testutil.o  .\/.libs\/libstacktrace.a .\/.libs\/libprofiler.so \/usr\/local\/lib\/libunwind.so -lc -lgcc_s \/usr\/local\/lib\/..\/lib64\/libstdc++.so -lm -lpthread -pthread -Wl,-rpath -Wl,\/root\/.ghq\/github.com\/dodong471520\/gperftools\/.libs -Wl,-rpath -Wl,\/usr\/local\/lib\/..\/lib64 -Wl,-rpath -Wl,\/usr\/local\/lib\/..\/lib64)"$/;"	v
relink_command	profiler4_unittest	/^relink_command="(cd \/root\/.ghq\/github.com\/dodong471520\/gperftools; { test -z \\"\\${LIBRARY_PATH+set}\\" || unset LIBRARY_PATH || { LIBRARY_PATH=; export LIBRARY_PATH; }; }; { test -z \\"\\${COMPILER_PATH+set}\\" || unset COMPILER_PATH || { COMPILER_PATH=; export COMPILER_PATH; }; }; { test -z \\"\\${GCC_EXEC_PREFIX+set}\\" || unset GCC_EXEC_PREFIX || { GCC_EXEC_PREFIX=; export GCC_EXEC_PREFIX; }; }; { test -z \\"\\${LD_RUN_PATH+set}\\" || unset LD_RUN_PATH || { LD_RUN_PATH=; export LD_RUN_PATH; }; }; { test -z \\"\\${LD_LIBRARY_PATH+set}\\" || unset LD_LIBRARY_PATH || { LD_LIBRARY_PATH=; export LD_LIBRARY_PATH; }; }; PATH=\/usr\/lib64\/qt-3.3\/bin:\/usr\/local\/sbin:\/usr\/sbin:\/sbin:\/usr\/local\/bin:\/usr\/bin:\/bin:\/root\/bin:\/usr\/local\/go\/bin:\/root\/go\/bin:\/root\/.fzf\/bin:\/usr\/local\/go\/bin:\/root\/go\/bin:\/root\/.fzf\/bin; export PATH; g++ -g -pthread -Wall -Wwrite-strings -Woverloaded-virtual -Wno-sign-compare -fno-builtin-malloc -fno-builtin-free -fno-builtin-realloc -fno-builtin-calloc -fno-builtin-cfree -fno-builtin-memalign -fno-builtin-posix_memalign -fno-builtin-valloc -fno-builtin-pvalloc -Wno-unused-result -DNO_FRAME_POINTER -g3 -O0 -pthread -o \\$progdir\/\\$file src\/tests\/profiler4_unittest-profiler_unittest.o src\/tests\/profiler4_unittest-testutil.o  \/root\/.ghq\/github.com\/dodong471520\/gperftools\/.libs\/libstacktrace.a \/root\/.ghq\/github.com\/dodong471520\/gperftools\/.libs\/libprofiler.so \/usr\/local\/lib\/libunwind.so -lc -lgcc_s \/usr\/local\/lib\/..\/lib64\/libstdc++.so -lm -lpthread -pthread -Wl,-rpath -Wl,\/root\/.ghq\/github.com\/dodong471520\/gperftools\/.libs -Wl,-rpath -Wl,\/usr\/local\/lib\/..\/lib64 -Wl,-rpath -Wl,\/usr\/local\/lib\/..\/lib64)"$/;"	v
relink_command	raw_printer_test	/^relink_command="(cd \/root\/.ghq\/github.com\/dodong471520\/gperftools; { test -z \\"\\${LIBRARY_PATH+set}\\" || unset LIBRARY_PATH || { LIBRARY_PATH=; export LIBRARY_PATH; }; }; { test -z \\"\\${COMPILER_PATH+set}\\" || unset COMPILER_PATH || { COMPILER_PATH=; export COMPILER_PATH; }; }; { test -z \\"\\${GCC_EXEC_PREFIX+set}\\" || unset GCC_EXEC_PREFIX || { GCC_EXEC_PREFIX=; export GCC_EXEC_PREFIX; }; }; { test -z \\"\\${LD_RUN_PATH+set}\\" || unset LD_RUN_PATH || { LD_RUN_PATH=; export LD_RUN_PATH; }; }; { test -z \\"\\${LD_LIBRARY_PATH+set}\\" || unset LD_LIBRARY_PATH || { LD_LIBRARY_PATH=; export LD_LIBRARY_PATH; }; }; PATH=\/usr\/lib64\/qt-3.3\/bin:\/usr\/local\/sbin:\/usr\/sbin:\/sbin:\/usr\/local\/bin:\/usr\/bin:\/bin:\/root\/bin:\/usr\/local\/go\/bin:\/root\/go\/bin:\/root\/.fzf\/bin:\/usr\/local\/go\/bin:\/root\/go\/bin:\/root\/.fzf\/bin; export PATH; g++ -pthread -Wall -Wwrite-strings -Woverloaded-virtual -Wno-sign-compare -fno-builtin-malloc -fno-builtin-free -fno-builtin-realloc -fno-builtin-calloc -fno-builtin-cfree -fno-builtin-memalign -fno-builtin-posix_memalign -fno-builtin-valloc -fno-builtin-pvalloc -Wno-unused-result -DNO_FRAME_POINTER -g3 -O0 -pthread -o \\$progdir\/\\$file src\/tests\/raw_printer_test-raw_printer_test.o  .\/.libs\/libtcmalloc.so \/usr\/local\/lib\/libunwind.so -lc -lgcc_s \/usr\/local\/lib\/..\/lib64\/libstdc++.so -lm -lpthread -pthread -Wl,-rpath -Wl,\/root\/.ghq\/github.com\/dodong471520\/gperftools\/.libs -Wl,-rpath -Wl,\/usr\/local\/lib\/..\/lib64 -Wl,-rpath -Wl,\/usr\/local\/lib\/..\/lib64)"$/;"	v
relink_command	realloc_debug_unittest	/^relink_command="(cd \/root\/.ghq\/github.com\/dodong471520\/gperftools; { test -z \\"\\${LIBRARY_PATH+set}\\" || unset LIBRARY_PATH || { LIBRARY_PATH=; export LIBRARY_PATH; }; }; { test -z \\"\\${COMPILER_PATH+set}\\" || unset COMPILER_PATH || { COMPILER_PATH=; export COMPILER_PATH; }; }; { test -z \\"\\${GCC_EXEC_PREFIX+set}\\" || unset GCC_EXEC_PREFIX || { GCC_EXEC_PREFIX=; export GCC_EXEC_PREFIX; }; }; { test -z \\"\\${LD_RUN_PATH+set}\\" || unset LD_RUN_PATH || { LD_RUN_PATH=; export LD_RUN_PATH; }; }; { test -z \\"\\${LD_LIBRARY_PATH+set}\\" || unset LD_LIBRARY_PATH || { LD_LIBRARY_PATH=; export LD_LIBRARY_PATH; }; }; PATH=\/usr\/lib64\/qt-3.3\/bin:\/usr\/local\/sbin:\/usr\/sbin:\/sbin:\/usr\/local\/bin:\/usr\/bin:\/bin:\/root\/bin:\/usr\/local\/go\/bin:\/root\/go\/bin:\/root\/.fzf\/bin:\/usr\/local\/go\/bin:\/root\/go\/bin:\/root\/.fzf\/bin; export PATH; g++ -pthread -Wall -Wwrite-strings -Woverloaded-virtual -Wno-sign-compare -fno-builtin-malloc -fno-builtin-free -fno-builtin-realloc -fno-builtin-calloc -fno-builtin-cfree -fno-builtin-memalign -fno-builtin-posix_memalign -fno-builtin-valloc -fno-builtin-pvalloc -Wno-unused-result -DNO_FRAME_POINTER -fno-builtin -g3 -O0 -pthread -o \\$progdir\/\\$file src\/tests\/realloc_debug_unittest-realloc_unittest.o  .\/.libs\/libtcmalloc_minimal_debug.so \/usr\/local\/lib\/..\/lib64\/libstdc++.so -lm -lpthread -pthread -Wl,-rpath -Wl,\/root\/.ghq\/github.com\/dodong471520\/gperftools\/.libs -Wl,-rpath -Wl,\/usr\/local\/lib\/..\/lib64 -Wl,-rpath -Wl,\/usr\/local\/lib\/..\/lib64)"$/;"	v
relink_command	realloc_unittest	/^relink_command="(cd \/root\/.ghq\/github.com\/dodong471520\/gperftools; { test -z \\"\\${LIBRARY_PATH+set}\\" || unset LIBRARY_PATH || { LIBRARY_PATH=; export LIBRARY_PATH; }; }; { test -z \\"\\${COMPILER_PATH+set}\\" || unset COMPILER_PATH || { COMPILER_PATH=; export COMPILER_PATH; }; }; { test -z \\"\\${GCC_EXEC_PREFIX+set}\\" || unset GCC_EXEC_PREFIX || { GCC_EXEC_PREFIX=; export GCC_EXEC_PREFIX; }; }; { test -z \\"\\${LD_RUN_PATH+set}\\" || unset LD_RUN_PATH || { LD_RUN_PATH=; export LD_RUN_PATH; }; }; { test -z \\"\\${LD_LIBRARY_PATH+set}\\" || unset LD_LIBRARY_PATH || { LD_LIBRARY_PATH=; export LD_LIBRARY_PATH; }; }; PATH=\/usr\/lib64\/qt-3.3\/bin:\/usr\/local\/sbin:\/usr\/sbin:\/sbin:\/usr\/local\/bin:\/usr\/bin:\/bin:\/root\/bin:\/usr\/local\/go\/bin:\/root\/go\/bin:\/root\/.fzf\/bin:\/usr\/local\/go\/bin:\/root\/go\/bin:\/root\/.fzf\/bin; export PATH; g++ -pthread -Wall -Wwrite-strings -Woverloaded-virtual -Wno-sign-compare -fno-builtin-malloc -fno-builtin-free -fno-builtin-realloc -fno-builtin-calloc -fno-builtin-cfree -fno-builtin-memalign -fno-builtin-posix_memalign -fno-builtin-valloc -fno-builtin-pvalloc -Wno-unused-result -DNO_FRAME_POINTER -fno-builtin -g3 -O0 -pthread -o \\$progdir\/\\$file src\/tests\/realloc_unittest-realloc_unittest.o  .\/.libs\/libtcmalloc_minimal.so \/usr\/local\/lib\/..\/lib64\/libstdc++.so -lm -lpthread -pthread -Wl,-rpath -Wl,\/root\/.ghq\/github.com\/dodong471520\/gperftools\/.libs -Wl,-rpath -Wl,\/usr\/local\/lib\/..\/lib64 -Wl,-rpath -Wl,\/usr\/local\/lib\/..\/lib64)"$/;"	v
relink_command	sampler_debug_test	/^relink_command="(cd \/root\/.ghq\/github.com\/dodong471520\/gperftools; { test -z \\"\\${LIBRARY_PATH+set}\\" || unset LIBRARY_PATH || { LIBRARY_PATH=; export LIBRARY_PATH; }; }; { test -z \\"\\${COMPILER_PATH+set}\\" || unset COMPILER_PATH || { COMPILER_PATH=; export COMPILER_PATH; }; }; { test -z \\"\\${GCC_EXEC_PREFIX+set}\\" || unset GCC_EXEC_PREFIX || { GCC_EXEC_PREFIX=; export GCC_EXEC_PREFIX; }; }; { test -z \\"\\${LD_RUN_PATH+set}\\" || unset LD_RUN_PATH || { LD_RUN_PATH=; export LD_RUN_PATH; }; }; { test -z \\"\\${LD_LIBRARY_PATH+set}\\" || unset LD_LIBRARY_PATH || { LD_LIBRARY_PATH=; export LD_LIBRARY_PATH; }; }; PATH=\/usr\/lib64\/qt-3.3\/bin:\/usr\/local\/sbin:\/usr\/sbin:\/sbin:\/usr\/local\/bin:\/usr\/bin:\/bin:\/root\/bin:\/usr\/local\/go\/bin:\/root\/go\/bin:\/root\/.fzf\/bin:\/usr\/local\/go\/bin:\/root\/go\/bin:\/root\/.fzf\/bin; export PATH; g++ -g3 -O0 -pthread -o \\$progdir\/\\$file src\/tests\/sampler_debug_test-sampler_test.o  .\/.libs\/libtcmalloc_debug.so \/usr\/local\/lib\/libunwind.so -lc -lgcc_s \/usr\/local\/lib\/..\/lib64\/libstdc++.so -lpthread -lm -pthread -Wl,-rpath -Wl,\/root\/.ghq\/github.com\/dodong471520\/gperftools\/.libs -Wl,-rpath -Wl,\/usr\/local\/lib\/..\/lib64 -Wl,-rpath -Wl,\/usr\/local\/lib\/..\/lib64)"$/;"	v
relink_command	sampler_test	/^relink_command="(cd \/root\/.ghq\/github.com\/dodong471520\/gperftools; { test -z \\"\\${LIBRARY_PATH+set}\\" || unset LIBRARY_PATH || { LIBRARY_PATH=; export LIBRARY_PATH; }; }; { test -z \\"\\${COMPILER_PATH+set}\\" || unset COMPILER_PATH || { COMPILER_PATH=; export COMPILER_PATH; }; }; { test -z \\"\\${GCC_EXEC_PREFIX+set}\\" || unset GCC_EXEC_PREFIX || { GCC_EXEC_PREFIX=; export GCC_EXEC_PREFIX; }; }; { test -z \\"\\${LD_RUN_PATH+set}\\" || unset LD_RUN_PATH || { LD_RUN_PATH=; export LD_RUN_PATH; }; }; { test -z \\"\\${LD_LIBRARY_PATH+set}\\" || unset LD_LIBRARY_PATH || { LD_LIBRARY_PATH=; export LD_LIBRARY_PATH; }; }; PATH=\/usr\/lib64\/qt-3.3\/bin:\/usr\/local\/sbin:\/usr\/sbin:\/sbin:\/usr\/local\/bin:\/usr\/bin:\/bin:\/root\/bin:\/usr\/local\/go\/bin:\/root\/go\/bin:\/root\/.fzf\/bin:\/usr\/local\/go\/bin:\/root\/go\/bin:\/root\/.fzf\/bin; export PATH; g++ -pthread -Wall -Wwrite-strings -Woverloaded-virtual -Wno-sign-compare -fno-builtin-malloc -fno-builtin-free -fno-builtin-realloc -fno-builtin-calloc -fno-builtin-cfree -fno-builtin-memalign -fno-builtin-posix_memalign -fno-builtin-valloc -fno-builtin-pvalloc -Wno-unused-result -DNO_FRAME_POINTER -g3 -O0 -pthread -o \\$progdir\/\\$file src\/tests\/sampler_test-sampler_test.o  .\/.libs\/libtcmalloc.so \/usr\/local\/lib\/libunwind.so -lc -lgcc_s \/usr\/local\/lib\/..\/lib64\/libstdc++.so -lpthread -lm -pthread -Wl,-rpath -Wl,\/root\/.ghq\/github.com\/dodong471520\/gperftools\/.libs -Wl,-rpath -Wl,\/usr\/local\/lib\/..\/lib64 -Wl,-rpath -Wl,\/usr\/local\/lib\/..\/lib64)"$/;"	v
relink_command	sampling_debug_test	/^relink_command="(cd \/root\/.ghq\/github.com\/dodong471520\/gperftools; { test -z \\"\\${LIBRARY_PATH+set}\\" || unset LIBRARY_PATH || { LIBRARY_PATH=; export LIBRARY_PATH; }; }; { test -z \\"\\${COMPILER_PATH+set}\\" || unset COMPILER_PATH || { COMPILER_PATH=; export COMPILER_PATH; }; }; { test -z \\"\\${GCC_EXEC_PREFIX+set}\\" || unset GCC_EXEC_PREFIX || { GCC_EXEC_PREFIX=; export GCC_EXEC_PREFIX; }; }; { test -z \\"\\${LD_RUN_PATH+set}\\" || unset LD_RUN_PATH || { LD_RUN_PATH=; export LD_RUN_PATH; }; }; { test -z \\"\\${LD_LIBRARY_PATH+set}\\" || unset LD_LIBRARY_PATH || { LD_LIBRARY_PATH=; export LD_LIBRARY_PATH; }; }; PATH=\/usr\/lib64\/qt-3.3\/bin:\/usr\/local\/sbin:\/usr\/sbin:\/sbin:\/usr\/local\/bin:\/usr\/bin:\/bin:\/root\/bin:\/usr\/local\/go\/bin:\/root\/go\/bin:\/root\/.fzf\/bin:\/usr\/local\/go\/bin:\/root\/go\/bin:\/root\/.fzf\/bin; export PATH; g++ -g -pthread -Wall -Wwrite-strings -Woverloaded-virtual -Wno-sign-compare -fno-builtin-malloc -fno-builtin-free -fno-builtin-realloc -fno-builtin-calloc -fno-builtin-cfree -fno-builtin-memalign -fno-builtin-posix_memalign -fno-builtin-valloc -fno-builtin-pvalloc -Wno-unused-result -DNO_FRAME_POINTER -g3 -O0 -g -pthread -o \\$progdir\/\\$file src\/tests\/sampling_debug_test-sampling_test.o  .\/.libs\/libtcmalloc_debug.so \/usr\/local\/lib\/libunwind.so -lc -lgcc_s \/usr\/local\/lib\/..\/lib64\/libstdc++.so -lm -lpthread -pthread -Wl,-rpath -Wl,\/root\/.ghq\/github.com\/dodong471520\/gperftools\/.libs -Wl,-rpath -Wl,\/usr\/local\/lib\/..\/lib64 -Wl,-rpath -Wl,\/usr\/local\/lib\/..\/lib64)"$/;"	v
relink_command	sampling_test	/^relink_command="(cd \/root\/.ghq\/github.com\/dodong471520\/gperftools; { test -z \\"\\${LIBRARY_PATH+set}\\" || unset LIBRARY_PATH || { LIBRARY_PATH=; export LIBRARY_PATH; }; }; { test -z \\"\\${COMPILER_PATH+set}\\" || unset COMPILER_PATH || { COMPILER_PATH=; export COMPILER_PATH; }; }; { test -z \\"\\${GCC_EXEC_PREFIX+set}\\" || unset GCC_EXEC_PREFIX || { GCC_EXEC_PREFIX=; export GCC_EXEC_PREFIX; }; }; { test -z \\"\\${LD_RUN_PATH+set}\\" || unset LD_RUN_PATH || { LD_RUN_PATH=; export LD_RUN_PATH; }; }; { test -z \\"\\${LD_LIBRARY_PATH+set}\\" || unset LD_LIBRARY_PATH || { LD_LIBRARY_PATH=; export LD_LIBRARY_PATH; }; }; PATH=\/usr\/lib64\/qt-3.3\/bin:\/usr\/local\/sbin:\/usr\/sbin:\/sbin:\/usr\/local\/bin:\/usr\/bin:\/bin:\/root\/bin:\/usr\/local\/go\/bin:\/root\/go\/bin:\/root\/.fzf\/bin:\/usr\/local\/go\/bin:\/root\/go\/bin:\/root\/.fzf\/bin; export PATH; g++ -g -pthread -Wall -Wwrite-strings -Woverloaded-virtual -Wno-sign-compare -fno-builtin-malloc -fno-builtin-free -fno-builtin-realloc -fno-builtin-calloc -fno-builtin-cfree -fno-builtin-memalign -fno-builtin-posix_memalign -fno-builtin-valloc -fno-builtin-pvalloc -Wno-unused-result -DNO_FRAME_POINTER -g3 -O0 -g -pthread -o \\$progdir\/\\$file src\/tests\/sampling_test-sampling_test.o  .\/.libs\/libtcmalloc.so \/usr\/local\/lib\/libunwind.so -lc -lgcc_s \/usr\/local\/lib\/..\/lib64\/libstdc++.so -lm -lpthread -pthread -Wl,-rpath -Wl,\/root\/.ghq\/github.com\/dodong471520\/gperftools\/.libs -Wl,-rpath -Wl,\/usr\/local\/lib\/..\/lib64 -Wl,-rpath -Wl,\/usr\/local\/lib\/..\/lib64)"$/;"	v
relink_command	simple_compat_test	/^relink_command="(cd \/root\/.ghq\/github.com\/dodong471520\/gperftools; { test -z \\"\\${LIBRARY_PATH+set}\\" || unset LIBRARY_PATH || { LIBRARY_PATH=; export LIBRARY_PATH; }; }; { test -z \\"\\${COMPILER_PATH+set}\\" || unset COMPILER_PATH || { COMPILER_PATH=; export COMPILER_PATH; }; }; { test -z \\"\\${GCC_EXEC_PREFIX+set}\\" || unset GCC_EXEC_PREFIX || { GCC_EXEC_PREFIX=; export GCC_EXEC_PREFIX; }; }; { test -z \\"\\${LD_RUN_PATH+set}\\" || unset LD_RUN_PATH || { LD_RUN_PATH=; export LD_RUN_PATH; }; }; { test -z \\"\\${LD_LIBRARY_PATH+set}\\" || unset LD_LIBRARY_PATH || { LD_LIBRARY_PATH=; export LD_LIBRARY_PATH; }; }; PATH=\/usr\/lib64\/qt-3.3\/bin:\/usr\/local\/sbin:\/usr\/sbin:\/sbin:\/usr\/local\/bin:\/usr\/bin:\/bin:\/root\/bin:\/usr\/local\/go\/bin:\/root\/go\/bin:\/root\/.fzf\/bin:\/usr\/local\/go\/bin:\/root\/go\/bin:\/root\/.fzf\/bin; export PATH; g++ -Wall -Wwrite-strings -Woverloaded-virtual -Wno-sign-compare -fno-builtin-malloc -fno-builtin-free -fno-builtin-realloc -fno-builtin-calloc -fno-builtin-cfree -fno-builtin-memalign -fno-builtin-posix_memalign -fno-builtin-valloc -fno-builtin-pvalloc -Wno-unused-result -DNO_FRAME_POINTER -g3 -O0 -o \\$progdir\/\\$file src\/tests\/simple_compat_test.o  .\/.libs\/libtcmalloc.so \/usr\/local\/lib\/libunwind.so -lc -lgcc_s -lpthread \/usr\/local\/lib\/..\/lib64\/libstdc++.so -lm -pthread -Wl,-rpath -Wl,\/root\/.ghq\/github.com\/dodong471520\/gperftools\/.libs -Wl,-rpath -Wl,\/usr\/local\/lib\/..\/lib64 -Wl,-rpath -Wl,\/usr\/local\/lib\/..\/lib64)"$/;"	v
relink_command	stack_trace_table_test	/^relink_command="(cd \/root\/.ghq\/github.com\/dodong471520\/gperftools; { test -z \\"\\${LIBRARY_PATH+set}\\" || unset LIBRARY_PATH || { LIBRARY_PATH=; export LIBRARY_PATH; }; }; { test -z \\"\\${COMPILER_PATH+set}\\" || unset COMPILER_PATH || { COMPILER_PATH=; export COMPILER_PATH; }; }; { test -z \\"\\${GCC_EXEC_PREFIX+set}\\" || unset GCC_EXEC_PREFIX || { GCC_EXEC_PREFIX=; export GCC_EXEC_PREFIX; }; }; { test -z \\"\\${LD_RUN_PATH+set}\\" || unset LD_RUN_PATH || { LD_RUN_PATH=; export LD_RUN_PATH; }; }; { test -z \\"\\${LD_LIBRARY_PATH+set}\\" || unset LD_LIBRARY_PATH || { LD_LIBRARY_PATH=; export LD_LIBRARY_PATH; }; }; PATH=\/usr\/lib64\/qt-3.3\/bin:\/usr\/local\/sbin:\/usr\/sbin:\/sbin:\/usr\/local\/bin:\/usr\/bin:\/bin:\/root\/bin:\/usr\/local\/go\/bin:\/root\/go\/bin:\/root\/.fzf\/bin:\/usr\/local\/go\/bin:\/root\/go\/bin:\/root\/.fzf\/bin; export PATH; g++ -pthread -Wall -Wwrite-strings -Woverloaded-virtual -Wno-sign-compare -fno-builtin-malloc -fno-builtin-free -fno-builtin-realloc -fno-builtin-calloc -fno-builtin-cfree -fno-builtin-memalign -fno-builtin-posix_memalign -fno-builtin-valloc -fno-builtin-pvalloc -Wno-unused-result -DNO_FRAME_POINTER -g3 -O0 -pthread -o \\$progdir\/\\$file src\/tests\/stack_trace_table_test-stack_trace_table_test.o  .\/.libs\/libtcmalloc_minimal.so \/usr\/local\/lib\/..\/lib64\/libstdc++.so -lm -lpthread -pthread -Wl,-rpath -Wl,\/root\/.ghq\/github.com\/dodong471520\/gperftools\/.libs -Wl,-rpath -Wl,\/usr\/local\/lib\/..\/lib64 -Wl,-rpath -Wl,\/usr\/local\/lib\/..\/lib64)"$/;"	v
relink_command	system_alloc_unittest	/^relink_command="(cd \/root\/.ghq\/github.com\/dodong471520\/gperftools; { test -z \\"\\${LIBRARY_PATH+set}\\" || unset LIBRARY_PATH || { LIBRARY_PATH=; export LIBRARY_PATH; }; }; { test -z \\"\\${COMPILER_PATH+set}\\" || unset COMPILER_PATH || { COMPILER_PATH=; export COMPILER_PATH; }; }; { test -z \\"\\${GCC_EXEC_PREFIX+set}\\" || unset GCC_EXEC_PREFIX || { GCC_EXEC_PREFIX=; export GCC_EXEC_PREFIX; }; }; { test -z \\"\\${LD_RUN_PATH+set}\\" || unset LD_RUN_PATH || { LD_RUN_PATH=; export LD_RUN_PATH; }; }; { test -z \\"\\${LD_LIBRARY_PATH+set}\\" || unset LD_LIBRARY_PATH || { LD_LIBRARY_PATH=; export LD_LIBRARY_PATH; }; }; PATH=\/usr\/lib64\/qt-3.3\/bin:\/usr\/local\/sbin:\/usr\/sbin:\/sbin:\/usr\/local\/bin:\/usr\/bin:\/bin:\/root\/bin:\/usr\/local\/go\/bin:\/root\/go\/bin:\/root\/.fzf\/bin:\/usr\/local\/go\/bin:\/root\/go\/bin:\/root\/.fzf\/bin; export PATH; g++ -pthread -Wall -Wwrite-strings -Woverloaded-virtual -Wno-sign-compare -fno-builtin-malloc -fno-builtin-free -fno-builtin-realloc -fno-builtin-calloc -fno-builtin-cfree -fno-builtin-memalign -fno-builtin-posix_memalign -fno-builtin-valloc -fno-builtin-pvalloc -Wno-unused-result -DNO_FRAME_POINTER -fno-builtin -g3 -O0 -pthread -o \\$progdir\/\\$file src\/tests\/system_alloc_unittest-system-alloc_unittest.o  .\/.libs\/libtcmalloc_minimal.so \/usr\/local\/lib\/..\/lib64\/libstdc++.so -lm -lpthread -pthread -Wl,-rpath -Wl,\/root\/.ghq\/github.com\/dodong471520\/gperftools\/.libs -Wl,-rpath -Wl,\/usr\/local\/lib\/..\/lib64 -Wl,-rpath -Wl,\/usr\/local\/lib\/..\/lib64)"$/;"	v
relink_command	tcmalloc_and_profiler_unittest	/^relink_command="(cd \/root\/.ghq\/github.com\/dodong471520\/gperftools; { test -z \\"\\${LIBRARY_PATH+set}\\" || unset LIBRARY_PATH || { LIBRARY_PATH=; export LIBRARY_PATH; }; }; { test -z \\"\\${COMPILER_PATH+set}\\" || unset COMPILER_PATH || { COMPILER_PATH=; export COMPILER_PATH; }; }; { test -z \\"\\${GCC_EXEC_PREFIX+set}\\" || unset GCC_EXEC_PREFIX || { GCC_EXEC_PREFIX=; export GCC_EXEC_PREFIX; }; }; { test -z \\"\\${LD_RUN_PATH+set}\\" || unset LD_RUN_PATH || { LD_RUN_PATH=; export LD_RUN_PATH; }; }; { test -z \\"\\${LD_LIBRARY_PATH+set}\\" || unset LD_LIBRARY_PATH || { LD_LIBRARY_PATH=; export LD_LIBRARY_PATH; }; }; PATH=\/usr\/lib64\/qt-3.3\/bin:\/usr\/local\/sbin:\/usr\/sbin:\/sbin:\/usr\/local\/bin:\/usr\/bin:\/bin:\/root\/bin:\/usr\/local\/go\/bin:\/root\/go\/bin:\/root\/.fzf\/bin:\/usr\/local\/go\/bin:\/root\/go\/bin:\/root\/.fzf\/bin; export PATH; g++ -pthread -Wall -Wwrite-strings -Woverloaded-virtual -Wno-sign-compare -fno-builtin-malloc -fno-builtin-free -fno-builtin-realloc -fno-builtin-calloc -fno-builtin-cfree -fno-builtin-memalign -fno-builtin-posix_memalign -fno-builtin-valloc -fno-builtin-pvalloc -Wno-unused-result -DNO_FRAME_POINTER -fno-builtin -g3 -O0 -pthread -o \\$progdir\/\\$file src\/tests\/tcmalloc_and_profiler_unittest-tcmalloc_unittest.o src\/tests\/tcmalloc_and_profiler_unittest-testutil.o  .\/.libs\/libtcmalloc_and_profiler.so \/usr\/local\/lib\/libunwind.so -lc -lgcc_s -lpthread \/usr\/local\/lib\/..\/lib64\/libstdc++.so -lm -pthread -Wl,-rpath -Wl,\/root\/.ghq\/github.com\/dodong471520\/gperftools\/.libs -Wl,-rpath -Wl,\/usr\/local\/lib\/..\/lib64 -Wl,-rpath -Wl,\/usr\/local\/lib\/..\/lib64)"$/;"	v
relink_command	tcmalloc_both_unittest	/^relink_command="(cd \/root\/.ghq\/github.com\/dodong471520\/gperftools; { test -z \\"\\${LIBRARY_PATH+set}\\" || unset LIBRARY_PATH || { LIBRARY_PATH=; export LIBRARY_PATH; }; }; { test -z \\"\\${COMPILER_PATH+set}\\" || unset COMPILER_PATH || { COMPILER_PATH=; export COMPILER_PATH; }; }; { test -z \\"\\${GCC_EXEC_PREFIX+set}\\" || unset GCC_EXEC_PREFIX || { GCC_EXEC_PREFIX=; export GCC_EXEC_PREFIX; }; }; { test -z \\"\\${LD_RUN_PATH+set}\\" || unset LD_RUN_PATH || { LD_RUN_PATH=; export LD_RUN_PATH; }; }; { test -z \\"\\${LD_LIBRARY_PATH+set}\\" || unset LD_LIBRARY_PATH || { LD_LIBRARY_PATH=; export LD_LIBRARY_PATH; }; }; PATH=\/usr\/lib64\/qt-3.3\/bin:\/usr\/local\/sbin:\/usr\/sbin:\/sbin:\/usr\/local\/bin:\/usr\/bin:\/bin:\/root\/bin:\/usr\/local\/go\/bin:\/root\/go\/bin:\/root\/.fzf\/bin:\/usr\/local\/go\/bin:\/root\/go\/bin:\/root\/.fzf\/bin; export PATH; g++ -pthread -Wall -Wwrite-strings -Woverloaded-virtual -Wno-sign-compare -fno-builtin-malloc -fno-builtin-free -fno-builtin-realloc -fno-builtin-calloc -fno-builtin-cfree -fno-builtin-memalign -fno-builtin-posix_memalign -fno-builtin-valloc -fno-builtin-pvalloc -Wno-unused-result -DNO_FRAME_POINTER -fno-builtin -g3 -O0 -pthread -o \\$progdir\/\\$file src\/tests\/tcmalloc_both_unittest-tcmalloc_unittest.o src\/tests\/tcmalloc_both_unittest-testutil.o  .\/.libs\/libtcmalloc.so .\/.libs\/libtcmalloc_minimal.so .\/.libs\/libprofiler.so \/usr\/local\/lib\/libunwind.so -lc -lgcc_s .\/.libs\/liblogging.a \/usr\/local\/lib\/..\/lib64\/libstdc++.so -lm -lpthread -pthread -Wl,-rpath -Wl,\/root\/.ghq\/github.com\/dodong471520\/gperftools\/.libs -Wl,-rpath -Wl,\/usr\/local\/lib\/..\/lib64 -Wl,-rpath -Wl,\/usr\/local\/lib\/..\/lib64)"$/;"	v
relink_command	tcmalloc_debug_unittest	/^relink_command="(cd \/root\/.ghq\/github.com\/dodong471520\/gperftools; { test -z \\"\\${LIBRARY_PATH+set}\\" || unset LIBRARY_PATH || { LIBRARY_PATH=; export LIBRARY_PATH; }; }; { test -z \\"\\${COMPILER_PATH+set}\\" || unset COMPILER_PATH || { COMPILER_PATH=; export COMPILER_PATH; }; }; { test -z \\"\\${GCC_EXEC_PREFIX+set}\\" || unset GCC_EXEC_PREFIX || { GCC_EXEC_PREFIX=; export GCC_EXEC_PREFIX; }; }; { test -z \\"\\${LD_RUN_PATH+set}\\" || unset LD_RUN_PATH || { LD_RUN_PATH=; export LD_RUN_PATH; }; }; { test -z \\"\\${LD_LIBRARY_PATH+set}\\" || unset LD_LIBRARY_PATH || { LD_LIBRARY_PATH=; export LD_LIBRARY_PATH; }; }; PATH=\/usr\/lib64\/qt-3.3\/bin:\/usr\/local\/sbin:\/usr\/sbin:\/sbin:\/usr\/local\/bin:\/usr\/bin:\/bin:\/root\/bin:\/usr\/local\/go\/bin:\/root\/go\/bin:\/root\/.fzf\/bin:\/usr\/local\/go\/bin:\/root\/go\/bin:\/root\/.fzf\/bin; export PATH; g++ -pthread -Wall -Wwrite-strings -Woverloaded-virtual -Wno-sign-compare -fno-builtin-malloc -fno-builtin-free -fno-builtin-realloc -fno-builtin-calloc -fno-builtin-cfree -fno-builtin-memalign -fno-builtin-posix_memalign -fno-builtin-valloc -fno-builtin-pvalloc -Wno-unused-result -DNO_FRAME_POINTER -fno-builtin -DDEBUGALLOCATION -g3 -O0 -pthread -o \\$progdir\/\\$file src\/tests\/tcmalloc_debug_unittest-tcmalloc_unittest.o src\/tests\/tcmalloc_debug_unittest-testutil.o  .\/.libs\/libtcmalloc_debug.so \/usr\/local\/lib\/libunwind.so -lc -lgcc_s \/usr\/local\/lib\/..\/lib64\/libstdc++.so -lm -lpthread -pthread -Wl,-rpath -Wl,\/root\/.ghq\/github.com\/dodong471520\/gperftools\/.libs -Wl,-rpath -Wl,\/usr\/local\/lib\/..\/lib64 -Wl,-rpath -Wl,\/usr\/local\/lib\/..\/lib64)"$/;"	v
relink_command	tcmalloc_large_heap_fragmentation_unittest	/^relink_command="(cd \/root\/.ghq\/github.com\/dodong471520\/gperftools; { test -z \\"\\${LIBRARY_PATH+set}\\" || unset LIBRARY_PATH || { LIBRARY_PATH=; export LIBRARY_PATH; }; }; { test -z \\"\\${COMPILER_PATH+set}\\" || unset COMPILER_PATH || { COMPILER_PATH=; export COMPILER_PATH; }; }; { test -z \\"\\${GCC_EXEC_PREFIX+set}\\" || unset GCC_EXEC_PREFIX || { GCC_EXEC_PREFIX=; export GCC_EXEC_PREFIX; }; }; { test -z \\"\\${LD_RUN_PATH+set}\\" || unset LD_RUN_PATH || { LD_RUN_PATH=; export LD_RUN_PATH; }; }; { test -z \\"\\${LD_LIBRARY_PATH+set}\\" || unset LD_LIBRARY_PATH || { LD_LIBRARY_PATH=; export LD_LIBRARY_PATH; }; }; PATH=\/usr\/lib64\/qt-3.3\/bin:\/usr\/local\/sbin:\/usr\/sbin:\/sbin:\/usr\/local\/bin:\/usr\/bin:\/bin:\/root\/bin:\/usr\/local\/go\/bin:\/root\/go\/bin:\/root\/.fzf\/bin:\/usr\/local\/go\/bin:\/root\/go\/bin:\/root\/.fzf\/bin; export PATH; g++ -pthread -Wall -Wwrite-strings -Woverloaded-virtual -Wno-sign-compare -fno-builtin-malloc -fno-builtin-free -fno-builtin-realloc -fno-builtin-calloc -fno-builtin-cfree -fno-builtin-memalign -fno-builtin-posix_memalign -fno-builtin-valloc -fno-builtin-pvalloc -Wno-unused-result -DNO_FRAME_POINTER -fno-builtin -g3 -O0 -pthread -o \\$progdir\/\\$file src\/tests\/tcmalloc_large_heap_fragmentation_unittest-large_heap_fragmentation_unittest.o  .\/.libs\/libtcmalloc.so \/usr\/local\/lib\/libunwind.so -lc -lgcc_s \/usr\/local\/lib\/..\/lib64\/libstdc++.so -lm -lpthread -pthread -Wl,-rpath -Wl,\/root\/.ghq\/github.com\/dodong471520\/gperftools\/.libs -Wl,-rpath -Wl,\/usr\/local\/lib\/..\/lib64 -Wl,-rpath -Wl,\/usr\/local\/lib\/..\/lib64)"$/;"	v
relink_command	tcmalloc_large_unittest	/^relink_command="(cd \/root\/.ghq\/github.com\/dodong471520\/gperftools; { test -z \\"\\${LIBRARY_PATH+set}\\" || unset LIBRARY_PATH || { LIBRARY_PATH=; export LIBRARY_PATH; }; }; { test -z \\"\\${COMPILER_PATH+set}\\" || unset COMPILER_PATH || { COMPILER_PATH=; export COMPILER_PATH; }; }; { test -z \\"\\${GCC_EXEC_PREFIX+set}\\" || unset GCC_EXEC_PREFIX || { GCC_EXEC_PREFIX=; export GCC_EXEC_PREFIX; }; }; { test -z \\"\\${LD_RUN_PATH+set}\\" || unset LD_RUN_PATH || { LD_RUN_PATH=; export LD_RUN_PATH; }; }; { test -z \\"\\${LD_LIBRARY_PATH+set}\\" || unset LD_LIBRARY_PATH || { LD_LIBRARY_PATH=; export LD_LIBRARY_PATH; }; }; PATH=\/usr\/lib64\/qt-3.3\/bin:\/usr\/local\/sbin:\/usr\/sbin:\/sbin:\/usr\/local\/bin:\/usr\/bin:\/bin:\/root\/bin:\/usr\/local\/go\/bin:\/root\/go\/bin:\/root\/.fzf\/bin:\/usr\/local\/go\/bin:\/root\/go\/bin:\/root\/.fzf\/bin; export PATH; g++ -pthread -Wall -Wwrite-strings -Woverloaded-virtual -Wno-sign-compare -fno-builtin-malloc -fno-builtin-free -fno-builtin-realloc -fno-builtin-calloc -fno-builtin-cfree -fno-builtin-memalign -fno-builtin-posix_memalign -fno-builtin-valloc -fno-builtin-pvalloc -Wno-unused-result -DNO_FRAME_POINTER -fno-builtin -g3 -O0 -pthread -o \\$progdir\/\\$file src\/tests\/tcmalloc_large_unittest-tcmalloc_large_unittest.o  .\/.libs\/libtcmalloc.so \/usr\/local\/lib\/libunwind.so -lc -lgcc_s \/usr\/local\/lib\/..\/lib64\/libstdc++.so -lm -lpthread -pthread -Wl,-rpath -Wl,\/root\/.ghq\/github.com\/dodong471520\/gperftools\/.libs -Wl,-rpath -Wl,\/usr\/local\/lib\/..\/lib64 -Wl,-rpath -Wl,\/usr\/local\/lib\/..\/lib64)"$/;"	v
relink_command	tcmalloc_minimal_debug_unittest	/^relink_command="(cd \/root\/.ghq\/github.com\/dodong471520\/gperftools; { test -z \\"\\${LIBRARY_PATH+set}\\" || unset LIBRARY_PATH || { LIBRARY_PATH=; export LIBRARY_PATH; }; }; { test -z \\"\\${COMPILER_PATH+set}\\" || unset COMPILER_PATH || { COMPILER_PATH=; export COMPILER_PATH; }; }; { test -z \\"\\${GCC_EXEC_PREFIX+set}\\" || unset GCC_EXEC_PREFIX || { GCC_EXEC_PREFIX=; export GCC_EXEC_PREFIX; }; }; { test -z \\"\\${LD_RUN_PATH+set}\\" || unset LD_RUN_PATH || { LD_RUN_PATH=; export LD_RUN_PATH; }; }; { test -z \\"\\${LD_LIBRARY_PATH+set}\\" || unset LD_LIBRARY_PATH || { LD_LIBRARY_PATH=; export LD_LIBRARY_PATH; }; }; PATH=\/usr\/lib64\/qt-3.3\/bin:\/usr\/local\/sbin:\/usr\/sbin:\/sbin:\/usr\/local\/bin:\/usr\/bin:\/bin:\/root\/bin:\/usr\/local\/go\/bin:\/root\/go\/bin:\/root\/.fzf\/bin:\/usr\/local\/go\/bin:\/root\/go\/bin:\/root\/.fzf\/bin; export PATH; g++ -pthread -Wall -Wwrite-strings -Woverloaded-virtual -Wno-sign-compare -fno-builtin-malloc -fno-builtin-free -fno-builtin-realloc -fno-builtin-calloc -fno-builtin-cfree -fno-builtin-memalign -fno-builtin-posix_memalign -fno-builtin-valloc -fno-builtin-pvalloc -Wno-unused-result -DNO_FRAME_POINTER -fno-builtin -DDEBUGALLOCATION -g3 -O0 -pthread -o \\$progdir\/\\$file src\/tests\/tcmalloc_minimal_debug_unittest-tcmalloc_unittest.o src\/tests\/tcmalloc_minimal_debug_unittest-testutil.o  .\/.libs\/libtcmalloc_minimal_debug.so \/usr\/local\/lib\/..\/lib64\/libstdc++.so -lm -lpthread -pthread -Wl,-rpath -Wl,\/root\/.ghq\/github.com\/dodong471520\/gperftools\/.libs -Wl,-rpath -Wl,\/usr\/local\/lib\/..\/lib64 -Wl,-rpath -Wl,\/usr\/local\/lib\/..\/lib64)"$/;"	v
relink_command	tcmalloc_minimal_large_heap_fragmentation_unittest	/^relink_command="(cd \/root\/.ghq\/github.com\/dodong471520\/gperftools; { test -z \\"\\${LIBRARY_PATH+set}\\" || unset LIBRARY_PATH || { LIBRARY_PATH=; export LIBRARY_PATH; }; }; { test -z \\"\\${COMPILER_PATH+set}\\" || unset COMPILER_PATH || { COMPILER_PATH=; export COMPILER_PATH; }; }; { test -z \\"\\${GCC_EXEC_PREFIX+set}\\" || unset GCC_EXEC_PREFIX || { GCC_EXEC_PREFIX=; export GCC_EXEC_PREFIX; }; }; { test -z \\"\\${LD_RUN_PATH+set}\\" || unset LD_RUN_PATH || { LD_RUN_PATH=; export LD_RUN_PATH; }; }; { test -z \\"\\${LD_LIBRARY_PATH+set}\\" || unset LD_LIBRARY_PATH || { LD_LIBRARY_PATH=; export LD_LIBRARY_PATH; }; }; PATH=\/usr\/lib64\/qt-3.3\/bin:\/usr\/local\/sbin:\/usr\/sbin:\/sbin:\/usr\/local\/bin:\/usr\/bin:\/bin:\/root\/bin:\/usr\/local\/go\/bin:\/root\/go\/bin:\/root\/.fzf\/bin:\/usr\/local\/go\/bin:\/root\/go\/bin:\/root\/.fzf\/bin; export PATH; g++ -pthread -Wall -Wwrite-strings -Woverloaded-virtual -Wno-sign-compare -fno-builtin-malloc -fno-builtin-free -fno-builtin-realloc -fno-builtin-calloc -fno-builtin-cfree -fno-builtin-memalign -fno-builtin-posix_memalign -fno-builtin-valloc -fno-builtin-pvalloc -Wno-unused-result -DNO_FRAME_POINTER -fno-builtin -g3 -O0 -pthread -o \\$progdir\/\\$file src\/tests\/tcmalloc_minimal_large_heap_fragmentation_unittest-large_heap_fragmentation_unittest.o  .\/.libs\/libtcmalloc_minimal.so \/usr\/local\/lib\/..\/lib64\/libstdc++.so -lm -lpthread -pthread -Wl,-rpath -Wl,\/root\/.ghq\/github.com\/dodong471520\/gperftools\/.libs -Wl,-rpath -Wl,\/usr\/local\/lib\/..\/lib64 -Wl,-rpath -Wl,\/usr\/local\/lib\/..\/lib64)"$/;"	v
relink_command	tcmalloc_minimal_large_unittest	/^relink_command="(cd \/root\/.ghq\/github.com\/dodong471520\/gperftools; { test -z \\"\\${LIBRARY_PATH+set}\\" || unset LIBRARY_PATH || { LIBRARY_PATH=; export LIBRARY_PATH; }; }; { test -z \\"\\${COMPILER_PATH+set}\\" || unset COMPILER_PATH || { COMPILER_PATH=; export COMPILER_PATH; }; }; { test -z \\"\\${GCC_EXEC_PREFIX+set}\\" || unset GCC_EXEC_PREFIX || { GCC_EXEC_PREFIX=; export GCC_EXEC_PREFIX; }; }; { test -z \\"\\${LD_RUN_PATH+set}\\" || unset LD_RUN_PATH || { LD_RUN_PATH=; export LD_RUN_PATH; }; }; { test -z \\"\\${LD_LIBRARY_PATH+set}\\" || unset LD_LIBRARY_PATH || { LD_LIBRARY_PATH=; export LD_LIBRARY_PATH; }; }; PATH=\/usr\/lib64\/qt-3.3\/bin:\/usr\/local\/sbin:\/usr\/sbin:\/sbin:\/usr\/local\/bin:\/usr\/bin:\/bin:\/root\/bin:\/usr\/local\/go\/bin:\/root\/go\/bin:\/root\/.fzf\/bin:\/usr\/local\/go\/bin:\/root\/go\/bin:\/root\/.fzf\/bin; export PATH; g++ -pthread -Wall -Wwrite-strings -Woverloaded-virtual -Wno-sign-compare -fno-builtin-malloc -fno-builtin-free -fno-builtin-realloc -fno-builtin-calloc -fno-builtin-cfree -fno-builtin-memalign -fno-builtin-posix_memalign -fno-builtin-valloc -fno-builtin-pvalloc -Wno-unused-result -DNO_FRAME_POINTER -fno-builtin -g3 -O0 -pthread -o \\$progdir\/\\$file src\/tests\/tcmalloc_minimal_large_unittest-tcmalloc_large_unittest.o  .\/.libs\/libtcmalloc_minimal.so \/usr\/local\/lib\/..\/lib64\/libstdc++.so -lm -lpthread -pthread -Wl,-rpath -Wl,\/root\/.ghq\/github.com\/dodong471520\/gperftools\/.libs -Wl,-rpath -Wl,\/usr\/local\/lib\/..\/lib64 -Wl,-rpath -Wl,\/usr\/local\/lib\/..\/lib64)"$/;"	v
relink_command	tcmalloc_minimal_unittest	/^relink_command="(cd \/root\/.ghq\/github.com\/dodong471520\/gperftools; { test -z \\"\\${LIBRARY_PATH+set}\\" || unset LIBRARY_PATH || { LIBRARY_PATH=; export LIBRARY_PATH; }; }; { test -z \\"\\${COMPILER_PATH+set}\\" || unset COMPILER_PATH || { COMPILER_PATH=; export COMPILER_PATH; }; }; { test -z \\"\\${GCC_EXEC_PREFIX+set}\\" || unset GCC_EXEC_PREFIX || { GCC_EXEC_PREFIX=; export GCC_EXEC_PREFIX; }; }; { test -z \\"\\${LD_RUN_PATH+set}\\" || unset LD_RUN_PATH || { LD_RUN_PATH=; export LD_RUN_PATH; }; }; { test -z \\"\\${LD_LIBRARY_PATH+set}\\" || unset LD_LIBRARY_PATH || { LD_LIBRARY_PATH=; export LD_LIBRARY_PATH; }; }; PATH=\/usr\/lib64\/qt-3.3\/bin:\/usr\/local\/sbin:\/usr\/sbin:\/sbin:\/usr\/local\/bin:\/usr\/bin:\/bin:\/root\/bin:\/usr\/local\/go\/bin:\/root\/go\/bin:\/root\/.fzf\/bin:\/root\/bin:\/usr\/local\/go\/bin:\/root\/go\/bin:\/root\/.fzf\/bin:\/usr\/local\/go\/bin:\/root\/go\/bin:\/root\/.fzf\/bin; export PATH; g++ -pthread -Wall -Wwrite-strings -Woverloaded-virtual -Wno-sign-compare -fno-builtin-malloc -fno-builtin-free -fno-builtin-realloc -fno-builtin-calloc -fno-builtin-cfree -fno-builtin-memalign -fno-builtin-posix_memalign -fno-builtin-valloc -fno-builtin-pvalloc -Wno-unused-result -DNO_FRAME_POINTER -fno-builtin -g3 -O0 -pthread -o \\$progdir\/\\$file src\/tests\/tcmalloc_minimal_unittest-tcmalloc_unittest.o src\/tests\/tcmalloc_minimal_unittest-testutil.o  .\/.libs\/libtcmalloc_minimal.so .\/.libs\/liblogging.a \/usr\/local\/lib\/..\/lib64\/libstdc++.so -lm -lpthread -pthread -Wl,-rpath -Wl,\/root\/.ghq\/github.com\/dodong471520\/gperftools\/.libs -Wl,-rpath -Wl,\/usr\/local\/lib\/..\/lib64 -Wl,-rpath -Wl,\/usr\/local\/lib\/..\/lib64)"$/;"	v
relink_command	tcmalloc_unittest	/^relink_command="(cd \/root\/.ghq\/github.com\/dodong471520\/gperftools; { test -z \\"\\${LIBRARY_PATH+set}\\" || unset LIBRARY_PATH || { LIBRARY_PATH=; export LIBRARY_PATH; }; }; { test -z \\"\\${COMPILER_PATH+set}\\" || unset COMPILER_PATH || { COMPILER_PATH=; export COMPILER_PATH; }; }; { test -z \\"\\${GCC_EXEC_PREFIX+set}\\" || unset GCC_EXEC_PREFIX || { GCC_EXEC_PREFIX=; export GCC_EXEC_PREFIX; }; }; { test -z \\"\\${LD_RUN_PATH+set}\\" || unset LD_RUN_PATH || { LD_RUN_PATH=; export LD_RUN_PATH; }; }; { test -z \\"\\${LD_LIBRARY_PATH+set}\\" || unset LD_LIBRARY_PATH || { LD_LIBRARY_PATH=; export LD_LIBRARY_PATH; }; }; PATH=\/usr\/lib64\/qt-3.3\/bin:\/usr\/local\/sbin:\/usr\/sbin:\/sbin:\/usr\/local\/bin:\/usr\/bin:\/bin:\/root\/bin:\/usr\/local\/go\/bin:\/root\/go\/bin:\/root\/.fzf\/bin:\/usr\/local\/go\/bin:\/root\/go\/bin:\/root\/.fzf\/bin; export PATH; g++ -pthread -Wall -Wwrite-strings -Woverloaded-virtual -Wno-sign-compare -fno-builtin-malloc -fno-builtin-free -fno-builtin-realloc -fno-builtin-calloc -fno-builtin-cfree -fno-builtin-memalign -fno-builtin-posix_memalign -fno-builtin-valloc -fno-builtin-pvalloc -Wno-unused-result -DNO_FRAME_POINTER -fno-builtin -g3 -O0 -pthread -o \\$progdir\/\\$file src\/tests\/tcmalloc_unittest-tcmalloc_unittest.o src\/tests\/tcmalloc_unittest-testutil.o  .\/.libs\/libtcmalloc.so \/usr\/local\/lib\/libunwind.so -lc -lgcc_s .\/.libs\/liblogging.a \/usr\/local\/lib\/..\/lib64\/libstdc++.so -lm -lpthread -pthread -Wl,-rpath -Wl,\/root\/.ghq\/github.com\/dodong471520\/gperftools\/.libs -Wl,-rpath -Wl,\/usr\/local\/lib\/..\/lib64 -Wl,-rpath -Wl,\/usr\/local\/lib\/..\/lib64)"$/;"	v
relink_command	thread_dealloc_unittest	/^relink_command="(cd \/root\/.ghq\/github.com\/dodong471520\/gperftools; { test -z \\"\\${LIBRARY_PATH+set}\\" || unset LIBRARY_PATH || { LIBRARY_PATH=; export LIBRARY_PATH; }; }; { test -z \\"\\${COMPILER_PATH+set}\\" || unset COMPILER_PATH || { COMPILER_PATH=; export COMPILER_PATH; }; }; { test -z \\"\\${GCC_EXEC_PREFIX+set}\\" || unset GCC_EXEC_PREFIX || { GCC_EXEC_PREFIX=; export GCC_EXEC_PREFIX; }; }; { test -z \\"\\${LD_RUN_PATH+set}\\" || unset LD_RUN_PATH || { LD_RUN_PATH=; export LD_RUN_PATH; }; }; { test -z \\"\\${LD_LIBRARY_PATH+set}\\" || unset LD_LIBRARY_PATH || { LD_LIBRARY_PATH=; export LD_LIBRARY_PATH; }; }; PATH=\/usr\/lib64\/qt-3.3\/bin:\/usr\/local\/sbin:\/usr\/sbin:\/sbin:\/usr\/local\/bin:\/usr\/bin:\/bin:\/root\/bin:\/usr\/local\/go\/bin:\/root\/go\/bin:\/root\/.fzf\/bin:\/usr\/local\/go\/bin:\/root\/go\/bin:\/root\/.fzf\/bin; export PATH; g++ -pthread -Wall -Wwrite-strings -Woverloaded-virtual -Wno-sign-compare -fno-builtin-malloc -fno-builtin-free -fno-builtin-realloc -fno-builtin-calloc -fno-builtin-cfree -fno-builtin-memalign -fno-builtin-posix_memalign -fno-builtin-valloc -fno-builtin-pvalloc -Wno-unused-result -DNO_FRAME_POINTER -fno-builtin -g3 -O0 -pthread -o \\$progdir\/\\$file src\/tests\/thread_dealloc_unittest-thread_dealloc_unittest.o src\/tests\/thread_dealloc_unittest-testutil.o  .\/.libs\/libtcmalloc_minimal.so \/usr\/local\/lib\/..\/lib64\/libstdc++.so -lm -lpthread -pthread -Wl,-rpath -Wl,\/root\/.ghq\/github.com\/dodong471520\/gperftools\/.libs -Wl,-rpath -Wl,\/usr\/local\/lib\/..\/lib64 -Wl,-rpath -Wl,\/usr\/local\/lib\/..\/lib64)"$/;"	v
relink_command	unwind_bench	/^relink_command="(cd \/root\/.ghq\/github.com\/dodong471520\/gperftools; { test -z \\"\\${LIBRARY_PATH+set}\\" || unset LIBRARY_PATH || { LIBRARY_PATH=; export LIBRARY_PATH; }; }; { test -z \\"\\${COMPILER_PATH+set}\\" || unset COMPILER_PATH || { COMPILER_PATH=; export COMPILER_PATH; }; }; { test -z \\"\\${GCC_EXEC_PREFIX+set}\\" || unset GCC_EXEC_PREFIX || { GCC_EXEC_PREFIX=; export GCC_EXEC_PREFIX; }; }; { test -z \\"\\${LD_RUN_PATH+set}\\" || unset LD_RUN_PATH || { LD_RUN_PATH=; export LD_RUN_PATH; }; }; { test -z \\"\\${LD_LIBRARY_PATH+set}\\" || unset LD_LIBRARY_PATH || { LD_LIBRARY_PATH=; export LD_LIBRARY_PATH; }; }; PATH=\/usr\/lib64\/qt-3.3\/bin:\/usr\/local\/sbin:\/usr\/sbin:\/sbin:\/usr\/local\/bin:\/usr\/bin:\/bin:\/root\/bin:\/usr\/local\/go\/bin:\/root\/go\/bin:\/root\/.fzf\/bin:\/usr\/local\/go\/bin:\/root\/go\/bin:\/root\/.fzf\/bin; export PATH; g++ -pthread -Wall -Wwrite-strings -Woverloaded-virtual -Wno-sign-compare -fno-builtin-malloc -fno-builtin-free -fno-builtin-realloc -fno-builtin-calloc -fno-builtin-cfree -fno-builtin-memalign -fno-builtin-posix_memalign -fno-builtin-valloc -fno-builtin-pvalloc -Wno-unused-result -DNO_FRAME_POINTER -fno-builtin -g3 -O0 -pthread -o \\$progdir\/\\$file benchmark\/unwind_bench-unwind_bench.o benchmark\/unwind_bench-getcontext_light.o  .\/.libs\/librun_benchmark.a .\/.libs\/libtcmalloc.so \/usr\/local\/lib\/libunwind.so -lc -lgcc_s \/usr\/local\/lib\/..\/lib64\/libstdc++.so -lm -lpthread -pthread -Wl,-rpath -Wl,\/root\/.ghq\/github.com\/dodong471520\/gperftools\/.libs -Wl,-rpath -Wl,\/usr\/local\/lib\/..\/lib64 -Wl,-rpath -Wl,\/usr\/local\/lib\/..\/lib64)"$/;"	v
reload_cmds	m4/libtool.m4	/^      reload_cmds='$LTCC $LTCFLAGS -nostdlib ${wl}-r -o $output$reload_objs'$/;"	v
reload_cmds	m4/libtool.m4	/^reload_cmds='$LD$reload_flag -o $output$reload_objs'$/;"	v
rep	src/memory_region_map.cc	/^  char rep[sizeof(RegionSet)];$/;"	m	union:MemoryRegionMap::RegionSetRep	file:	access:public
replacement_function_	src/windows/auto_testing_hook.h	/^  T replacement_function_;  \/\/ always valid$/;"	m	class:sidestep::AutoTestingHookImpl	access:private
report_benchmark	benchmark/run_benchmark.c	/^void report_benchmark(const char *name, bench_body body, uintptr_t param)$/;"	f	signature:(const char *name, bench_body body, uintptr_t param)
report_benchmark	benchmark/run_benchmark.h	/^void report_benchmark(const char *name, bench_body body, uintptr_t param);$/;"	p	signature:(const char *name, bench_body body, uintptr_t param)
reserve_count	src/page_heap.h	/^    uint64_t reserve_count;         \/\/ Number of virtual memory reserves$/;"	m	struct:tcmalloc::PageHeap::Stats	access:public
resolve_delete_sized	src/libc_override_gcc_and_weak.h	/^static void *resolve_delete_sized(void) {$/;"	f	signature:(void)
resolve_delete_sized_aligned	src/libc_override_gcc_and_weak.h	/^static void *resolve_delete_sized_aligned(void) {$/;"	f	signature:(void)
resolve_deletearray_sized	src/libc_override_gcc_and_weak.h	/^static void *resolve_deletearray_sized(void) {$/;"	f	signature:(void)
resolve_deletearray_sized_aligned	src/libc_override_gcc_and_weak.h	/^static void *resolve_deletearray_sized_aligned(void) {$/;"	f	signature:(void)
result	src/base/linuxthreads.cc	/^  int         result, err;$/;"	m	struct:ListerParams	file:	access:public
result	src/tests/profiler_unittest.cc	/^static volatile int result = 0;$/;"	v	file:
ret	compile	/^ret=$?$/;"	v
retry_debug_allocate	src/debugallocation.cc	/^static void *retry_debug_allocate(void *arg) {$/;"	f	file:	signature:(void *arg)
retry_debug_memalign	src/debugallocation.cc	/^static void *retry_debug_memalign(void *arg) {$/;"	f	file:	signature:(void *arg)
retry_do_memalign	src/tcmalloc.cc	/^static void *retry_do_memalign(void *arg) {$/;"	f	namespace:tcmalloc	signature:(void *arg)
retry_malloc	src/tcmalloc.cc	/^static void *retry_malloc(void* size) {$/;"	f	namespace:__anon3	signature:(void* size)
retry_memalign_data	src/tcmalloc.cc	/^struct retry_memalign_data {$/;"	s	namespace:tcmalloc	file:
return_addr	src/stacktrace_powerpc-inl.h	/^  void *return_addr;$/;"	m	struct:layout_ppc	access:public
return_addr	src/stacktrace_powerpc-linux-inl.h	/^  void *return_addr;$/;"	m	struct:layout_ppc	access:public
return_sp_offset	src/getpc.h	/^  int return_sp_offset;$/;"	m	struct:CallUnrollInfo	access:public
returned	src/page_heap.h	/^    Span        returned;$/;"	m	struct:tcmalloc::PageHeap::SpanList	access:public
returned_length	src/page_heap.h	/^    int64 returned_length[kMaxPages];$/;"	m	struct:tcmalloc::PageHeap::SmallSpanStats	access:public
returned_pages	src/page_heap.h	/^    int64 returned_pages;  \/\/ Combined page length of unmapped spans$/;"	m	struct:tcmalloc::PageHeap::LargeSpanStats	access:public
rgProcAddresses	src/windows/patch_functions.cc	/^  GenericFnPtr rgProcAddresses[LibcInfo::ctrgProcAddress];$/;"	m	struct:__anon13::ModuleEntryCopy	file:	access:public
rip	src/base/elfcore.h	/^    uint64_t  rip,cs,eflags;$/;"	m	struct:i386_regs	access:public
rip	src/base/elfcore.h	/^    unsigned long rip;		\/* Program counter.                          *\/$/;"	m	struct:ppc_regs	access:public
rnd	src/tests/addressmap_unittest.cc	/^static UniformRandomNumberGenerator rnd;$/;"	v	file:
rnd_	src/sampler.h	/^  uint64_t rnd_;  \/\/ Cheap random number generator$/;"	m	class:tcmalloc::Sampler	access:public
rnd_	src/tests/sampler_test.cc	/^  uint32_t rnd_;                   \/\/ Cheap random number generator$/;"	m	class:OldSampler	file:	access:private
rnd_	src/tests/tcmalloc_unittest.cc	/^  AllocatorState        rnd_;           \/\/ For generating random numbers$/;"	m	class:testing::TesterThread	file:	access:private
root_	src/pagemap.h	/^  Leaf* root_[ROOT_LENGTH];             \/\/ Pointers to child nodes$/;"	m	class:TCMalloc_PageMap2	access:private
root_	src/pagemap.h	/^  Node  root_;                          \/\/ Root of radix tree$/;"	m	class:TCMalloc_PageMap3	access:private
roundup	src/base/low_level_alloc.cc	/^  size_t roundup;         \/\/ lowest power of 2 >= max(16,sizeof (AllocList))$/;"	m	struct:LowLevelAlloc::Arena	file:	access:public
rsi	src/base/elfcore.h	/^    uint64_t  r9,r8,rax,rcx,rdx,rsi,rdi,orig_rax;$/;"	m	struct:i386_regs	access:public
rsp	src/base/elfcore.h	/^    uint64_t  rsp,ss;$/;"	m	struct:i386_regs	access:public
ru_idrss	src/base/linux_syscall_support.h	/^  long               ru_idrss;$/;"	m	struct:kernel_rusage	access:public
ru_inblock	src/base/linux_syscall_support.h	/^  long               ru_inblock;$/;"	m	struct:kernel_rusage	access:public
ru_isrss	src/base/linux_syscall_support.h	/^  long               ru_isrss;$/;"	m	struct:kernel_rusage	access:public
ru_ixrss	src/base/linux_syscall_support.h	/^  long               ru_ixrss;$/;"	m	struct:kernel_rusage	access:public
ru_majflt	src/base/linux_syscall_support.h	/^  long               ru_majflt;$/;"	m	struct:kernel_rusage	access:public
ru_maxrss	src/base/linux_syscall_support.h	/^  long               ru_maxrss;$/;"	m	struct:kernel_rusage	access:public
ru_minflt	src/base/linux_syscall_support.h	/^  long               ru_minflt;$/;"	m	struct:kernel_rusage	access:public
ru_msgrcv	src/base/linux_syscall_support.h	/^  long               ru_msgrcv;$/;"	m	struct:kernel_rusage	access:public
ru_msgsnd	src/base/linux_syscall_support.h	/^  long               ru_msgsnd;$/;"	m	struct:kernel_rusage	access:public
ru_nivcsw	src/base/linux_syscall_support.h	/^  long               ru_nivcsw;$/;"	m	struct:kernel_rusage	access:public
ru_nsignals	src/base/linux_syscall_support.h	/^  long               ru_nsignals;$/;"	m	struct:kernel_rusage	access:public
ru_nswap	src/base/linux_syscall_support.h	/^  long               ru_nswap;$/;"	m	struct:kernel_rusage	access:public
ru_nvcsw	src/base/linux_syscall_support.h	/^  long               ru_nvcsw;$/;"	m	struct:kernel_rusage	access:public
ru_oublock	src/base/linux_syscall_support.h	/^  long               ru_oublock;$/;"	m	struct:kernel_rusage	access:public
ru_stime	src/base/linux_syscall_support.h	/^  struct kernel_timeval ru_stime;$/;"	m	struct:kernel_rusage	typeref:struct:kernel_rusage::kernel_timeval	access:public
ru_utime	src/base/linux_syscall_support.h	/^  struct kernel_timeval ru_utime;$/;"	m	struct:kernel_rusage	typeref:struct:kernel_rusage::kernel_timeval	access:public
run	benchmark/binary_trees.cc	/^void run(int given_depth) {$/;"	f	signature:(int given_depth)
run	missing	/^    run=:$/;"	v
run	missing	/^run=:$/;"	v
run_benchmark	benchmark/run_benchmark.c	/^static double run_benchmark(struct internal_bench *b)$/;"	f	file:	signature:(struct internal_bench *b)
run_body	benchmark/run_benchmark.c	/^static void run_body(struct internal_bench *b, long iterations)$/;"	f	file:	signature:(struct internal_bench *b, long iterations)
run_hidden_ptr	src/tests/heap-checker_unittest.cc	/^void (*volatile run_hidden_ptr)(Closure* c, int n);$/;"	v
run_tramp	benchmark/binary_trees.cc	/^static void *run_tramp(void *_a) {$/;"	f	file:	signature:(void *_a)
runpath_var	m4/libtool.m4	/^      runpath_var='LD_RUN_PATH'$/;"	v
runtime	docs/tcmalloc.html	/^<code>tcmalloc_release_rate<\/code> value at runtime, or$/;"	m	class:object::structure	file:	access:private
s	src/.libs/libtcmalloc_internal_la-internal_logging.o	/^/;"	v
s	src/.libs/libtcmalloc_minimal_internal_la-internal_logging.o	/^/;"	v
s	src/base/basictypes.h	/^  size_t s;$/;"	m	union:MemoryAligner	access:public
s	src/base/dynamic_annotations.o	/^/;"	v
s	src/tcm_min_asserts_unittest-thread_cache.o	/^/;"	v
s_first_opcode_byte	src/windows/ia32_opcode_map.cc	/^const Opcode s_first_opcode_byte[] = {$/;"	m	namespace:sidestep	file:
s_ia16_modrm_map_	src/windows/ia32_modrm_map.cc	/^const ModrmEntry MiniDisassembler::s_ia16_modrm_map_[] = {$/;"	m	class:sidestep::MiniDisassembler	file:
s_ia16_modrm_map_	src/windows/mini_disassembler.h	/^  static const ModrmEntry s_ia16_modrm_map_[];$/;"	m	class:sidestep::MiniDisassembler	access:private
s_ia32_modrm_map_	src/windows/ia32_modrm_map.cc	/^const ModrmEntry MiniDisassembler::s_ia32_modrm_map_[] = {$/;"	m	class:sidestep::MiniDisassembler	file:
s_ia32_modrm_map_	src/windows/mini_disassembler.h	/^  static const ModrmEntry s_ia32_modrm_map_[];$/;"	m	class:sidestep::MiniDisassembler	access:private
s_ia32_opcode_map_	src/windows/ia32_opcode_map.cc	/^const OpcodeTable MiniDisassembler::s_ia32_opcode_map_[]={$/;"	m	class:sidestep::MiniDisassembler	file:
s_ia32_opcode_map_	src/windows/mini_disassembler.h	/^  static const OpcodeTable s_ia32_opcode_map_[];$/;"	m	class:sidestep::MiniDisassembler	access:private
s_opcode_byte_after_0f	src/windows/ia32_opcode_map.cc	/^const Opcode s_opcode_byte_after_0f[] = {$/;"	m	namespace:sidestep	file:
s_opcode_byte_after_0f00	src/windows/ia32_opcode_map.cc	/^const Opcode s_opcode_byte_after_0f00[] = {$/;"	m	namespace:sidestep	file:
s_opcode_byte_after_0f01	src/windows/ia32_opcode_map.cc	/^const Opcode s_opcode_byte_after_0f01[] = {$/;"	m	namespace:sidestep	file:
s_opcode_byte_after_0f18	src/windows/ia32_opcode_map.cc	/^const Opcode s_opcode_byte_after_0f18[] = {$/;"	m	namespace:sidestep	file:
s_opcode_byte_after_0f71	src/windows/ia32_opcode_map.cc	/^const Opcode s_opcode_byte_after_0f71[] = {$/;"	m	namespace:sidestep	file:
s_opcode_byte_after_0f72	src/windows/ia32_opcode_map.cc	/^const Opcode s_opcode_byte_after_0f72[] = {$/;"	m	namespace:sidestep	file:
s_opcode_byte_after_0f73	src/windows/ia32_opcode_map.cc	/^const Opcode s_opcode_byte_after_0f73[] = {$/;"	m	namespace:sidestep	file:
s_opcode_byte_after_0fae	src/windows/ia32_opcode_map.cc	/^const Opcode s_opcode_byte_after_0fae[] = {$/;"	m	namespace:sidestep	file:
s_opcode_byte_after_0fba	src/windows/ia32_opcode_map.cc	/^const Opcode s_opcode_byte_after_0fba[] = {$/;"	m	namespace:sidestep	file:
s_opcode_byte_after_0fc7	src/windows/ia32_opcode_map.cc	/^const Opcode s_opcode_byte_after_0fc7[] = {$/;"	m	namespace:sidestep	file:
s_opcode_byte_after_80	src/windows/ia32_opcode_map.cc	/^const Opcode s_opcode_byte_after_80[] = {$/;"	m	namespace:sidestep	file:
s_opcode_byte_after_81	src/windows/ia32_opcode_map.cc	/^const Opcode s_opcode_byte_after_81[] = {$/;"	m	namespace:sidestep	file:
s_opcode_byte_after_82	src/windows/ia32_opcode_map.cc	/^const Opcode s_opcode_byte_after_82[] = {$/;"	m	namespace:sidestep	file:
s_opcode_byte_after_83	src/windows/ia32_opcode_map.cc	/^const Opcode s_opcode_byte_after_83[] = {$/;"	m	namespace:sidestep	file:
s_opcode_byte_after_c0	src/windows/ia32_opcode_map.cc	/^const Opcode s_opcode_byte_after_c0[] = {$/;"	m	namespace:sidestep	file:
s_opcode_byte_after_c1	src/windows/ia32_opcode_map.cc	/^const Opcode s_opcode_byte_after_c1[] = {$/;"	m	namespace:sidestep	file:
s_opcode_byte_after_d0	src/windows/ia32_opcode_map.cc	/^const Opcode s_opcode_byte_after_d0[] = {$/;"	m	namespace:sidestep	file:
s_opcode_byte_after_d1	src/windows/ia32_opcode_map.cc	/^const Opcode s_opcode_byte_after_d1[] = {$/;"	m	namespace:sidestep	file:
s_opcode_byte_after_d2	src/windows/ia32_opcode_map.cc	/^const Opcode s_opcode_byte_after_d2[] = {$/;"	m	namespace:sidestep	file:
s_opcode_byte_after_d3	src/windows/ia32_opcode_map.cc	/^const Opcode s_opcode_byte_after_d3[] = {$/;"	m	namespace:sidestep	file:
s_opcode_byte_after_f6	src/windows/ia32_opcode_map.cc	/^const Opcode s_opcode_byte_after_f6[] = {$/;"	m	namespace:sidestep	file:
s_opcode_byte_after_f7	src/windows/ia32_opcode_map.cc	/^const Opcode s_opcode_byte_after_f7[] = {$/;"	m	namespace:sidestep	file:
s_opcode_byte_after_fe	src/windows/ia32_opcode_map.cc	/^const Opcode s_opcode_byte_after_fe[] = {$/;"	m	namespace:sidestep	file:
s_opcode_byte_after_ff	src/windows/ia32_opcode_map.cc	/^const Opcode s_opcode_byte_after_ff[] = {$/;"	m	namespace:sidestep	file:
sa_flags	src/base/linux_syscall_support.h	/^  unsigned long      sa_flags;$/;"	m	struct:kernel_old_sigaction	access:public
sa_flags	src/base/linux_syscall_support.h	/^  unsigned long      sa_flags;$/;"	m	struct:kernel_sigaction	access:public
sa_handler_	src/base/linux_syscall_support.h	/^    void             (*sa_handler_)(int);$/;"	m	union:kernel_old_sigaction::__anon48	access:public
sa_handler_	src/base/linux_syscall_support.h	/^    void             (*sa_handler_)(int);$/;"	m	union:kernel_sigaction::__anon49	access:public
sa_mask	src/base/linux_syscall_support.h	/^  struct kernel_sigset_t sa_mask;$/;"	m	struct:kernel_sigaction	typeref:struct:kernel_sigaction::kernel_sigset_t	access:public
sa_mask	src/base/linux_syscall_support.h	/^  unsigned long      sa_mask;$/;"	m	struct:kernel_old_sigaction	access:public
sa_restorer	src/base/linux_syscall_support.h	/^  void               (*sa_restorer)(void);$/;"	m	struct:kernel_old_sigaction	access:public
sa_sigaction_	src/base/linux_syscall_support.h	/^    void             (*sa_sigaction_)(int, siginfo_t *, void *);$/;"	m	union:kernel_old_sigaction::__anon48	access:public
sa_sigaction_	src/base/linux_syscall_support.h	/^    void             (*sa_sigaction_)(int, siginfo_t *, void *);$/;"	m	union:kernel_sigaction::__anon49	access:public
safe_vsnprintf	src/windows/preamble_patcher_test.cc	/^int safe_vsnprintf(char *str, size_t size, const char *format, va_list ap) {$/;"	f	signature:(char *str, size_t size, const char *format, va_list ap)
safeclose	src/base/sysinfo.cc	102;"	d	file:
safeclose	src/base/sysinfo.cc	104;"	d	file:
safeopen	src/base/sysinfo.cc	92;"	d	file:
safeopen	src/base/sysinfo.cc	94;"	d	file:
saferead	src/base/sysinfo.cc	97;"	d	file:
saferead	src/base/sysinfo.cc	99;"	d	file:
sample	src/span.h	/^  unsigned int  sample : 1;     \/\/ Sampled object?$/;"	m	struct:tcmalloc::Span	access:public
sample_period	src/tests/sampler_test.cc	/^  static uint64_t sample_period;$/;"	m	class:OldSampler	file:	access:private
sample_period	src/tests/sampler_test.cc	/^uint64_t OldSampler::sample_period;$/;"	m	class:OldSampler	file:
sampled_objects	src/static_vars.h	/^  static Span* sampled_objects() { return &sampled_objects_; }$/;"	f	class:tcmalloc::Static	access:public	signature:()
sampled_objects_	src/static_vars.cc	/^Span Static::sampled_objects_;$/;"	m	class:tcmalloc::Static	file:
sampled_objects_	src/static_vars.h	/^  ATTRIBUTE_HIDDEN static Span sampled_objects_;$/;"	m	class:tcmalloc::Static	access:private
sampler_	src/thread_cache.h	/^  Sampler       sampler_;               \/\/ A sampler$/;"	m	class:tcmalloc::ThreadCache	access:private
samples_gathered	src/gperftools/profiler.h	/^  int    samples_gathered;    \/* Number of samples gathered so far (or 0) *\/$/;"	m	struct:ProfilerState	access:public
samples_gathered	src/profiledata.h	/^    int      samples_gathered;    \/\/ Number of samples gathered to far (or 0)$/;"	m	struct:ProfileData::State	access:public
save_LIBS	m4/acx_pthread.m4	/^        save_LIBS="$LIBS"$/;"	v
saved_buckets_	src/memory_region_map.cc	/^HeapProfileBucket MemoryRegionMap::saved_buckets_[20];  \/\/ GUARDED_BY(lock_)$/;"	m	class:MemoryRegionMap	file:
saved_buckets_count_	src/memory_region_map.cc	/^int MemoryRegionMap::saved_buckets_count_ = 0;  \/\/ GUARDED_BY(lock_)$/;"	m	class:MemoryRegionMap	file:
saved_buckets_keys_	src/memory_region_map.cc	/^const void* MemoryRegionMap::saved_buckets_keys_[20][kMaxStackDepth];$/;"	m	class:MemoryRegionMap	file:
saved_regions	src/memory_region_map.cc	/^static MemoryRegionMap::Region saved_regions[20];$/;"	v	file:
saved_regions_count	src/memory_region_map.cc	/^static int saved_regions_count = 0;$/;"	v	file:
saw_new_handler_runs	src/tests/tcmalloc_unittest.cc	/^static int saw_new_handler_runs;$/;"	m	namespace:testing	file:
sbrk	src/windows/port.h	/^inline void *sbrk(intptr_t increment) {$/;"	f	signature:(intptr_t increment)
sbrk_hooks_	src/malloc_hook.cc	/^HookList<MallocHook::SbrkHook> sbrk_hooks_ = INIT_HOOK_LIST;$/;"	m	namespace:base::internal	file:
sbrk_name	src/system-alloc.cc	/^static const char sbrk_name[] = "SbrkSysAllocator";$/;"	v	file:
sbrk_space	src/system-alloc.cc	/^} sbrk_space;$/;"	v	typeref:union:__anon33	file:
sc_cpu_version	config.guess	/^		    sc_cpu_version=`\/usr\/bin\/getconf SC_CPU_VERSION 2>\/dev\/null`$/;"	v
scavenge_count	src/page_heap.h	/^    uint64_t scavenge_count;   \/\/ Number of times scavagened flush pages$/;"	m	struct:tcmalloc::PageHeap::Stats	access:public
scavenge_counter_	src/page_heap.h	/^  int64_t scavenge_counter_;$/;"	m	class:tcmalloc::PageHeap	access:private
schar	src/base/basictypes.h	/^typedef signed char         schar;$/;"	t
sched_yield	src/windows/port.h	/^inline void sched_yield(void) {$/;"	f	signature:(void)
scoped_array	src/tests/profiledata_unittest.cc	/^  scoped_array(T* data) : data_(data) { }$/;"	f	class:__anon53::scoped_array	access:public	signature:(T* data)
scoped_array	src/tests/profiledata_unittest.cc	/^template<typename T> class scoped_array {$/;"	c	namespace:__anon53	file:
scoped_array	src/tests/sampler_test.cc	/^  scoped_array(T* p) : p_(p) { }$/;"	f	class:__anon54::scoped_array	access:public	signature:(T* p)
scoped_array	src/tests/sampler_test.cc	/^template<typename T> class scoped_array {$/;"	c	namespace:__anon54	file:
script	config.guess	/^This script, last modified $timestamp, has failed to recognize$/;"	v
sed	Makefile	/^	list=`for p in $$list; do echo "$$p"; done | sed 's\/$(EXEEXT)$$\/\/'`; \\$/;"	v
sed	Makefile.in	/^	list=`for p in $$list; do echo "$$p"; done | sed 's\/$(EXEEXT)$$\/\/'`; \\$/;"	v
sed_quote_subst	m4/libtool.m4	/^sed_quote_subst='s\/\\([["`$\\\\]]\\)\/\\\\\\1\/g'$/;"	v
seed_	src/tests/tcmalloc_unittest.cc	/^    int32 seed_;$/;"	m	class:testing::TesterThread::ACMRandom	file:	access:private
seen	README	/^The fastest malloc weâve seen; works particularly well with threads$/;"	v
segment	docs/heap_checker.html	/^beginning of the code segment, and call$/;"	v
self_thread_pid	src/heap-checker.cc	/^static pid_t self_thread_pid = 0;$/;"	v	file:
self_thread_stack_top	src/heap-checker.cc	/^static const void* self_thread_stack_top;$/;"	v	file:
set	src/pagemap.h	/^  void set(Number k, void* v) {$/;"	f	class:TCMalloc_PageMap1	access:public	signature:(Number k, void* v)
set	src/pagemap.h	/^  void set(Number k, void* v) {$/;"	f	class:TCMalloc_PageMap2	access:public	signature:(Number k, void* v)
set	src/pagemap.h	/^  void set(Number k, void* v) {$/;"	f	class:TCMalloc_PageMap3	access:public	signature:(Number k, void* v)
set_bucket	src/heap-profile-table.h	/^    void set_bucket(Bucket* b) { bucket_rep = reinterpret_cast<uintptr_t>(b); }$/;"	f	struct:HeapProfileTable::AllocValue	access:public	signature:(Bucket* b)
set_call_stack_depth	src/memory_region_map.h	/^    void set_call_stack_depth(int depth) {$/;"	f	struct:MemoryRegionMap::Region	access:private	signature:(int depth)
set_cc_for_build	config.guess	/^set_cc_for_build='$/;"	v
set_data	src/tests/heap-checker_unittest.cc	/^static int set_data[] = { 1, 2, 3, 4, 5, 6, 7, 21, 22, 23, 24, 25, 26, 27 };$/;"	v	file:
set_end_addr	src/memory_region_map.h	/^    void set_end_addr(uintptr_t addr) {$/;"	f	struct:MemoryRegionMap::Region	access:private	signature:(uintptr_t addr)
set_frequency	src/profiledata.h	/^    void set_frequency(int frequency) {$/;"	f	class:ProfileData::Options	access:public	signature:(int frequency)
set_growth_stacks	src/static_vars.h	/^  static void set_growth_stacks(StackTrace* s) { growth_stacks_ = s; }$/;"	f	class:tcmalloc::Static	access:public	signature:(StackTrace* s)
set_ignore	src/heap-profile-table.h	/^    void set_ignore(bool r) {$/;"	f	struct:HeapProfileTable::AllocValue	access:public	signature:(bool r)
set_is_stack	src/memory_region_map.h	/^    void set_is_stack() { is_stack = true; }$/;"	f	struct:MemoryRegionMap::Region	access:private	signature:()
set_is_valid	src/windows/patch_functions.cc	/^  void set_is_valid(bool b) { is_valid_ = b; }$/;"	f	class:__anon13::LibcInfo	access:public	signature:(bool b)
set_length_overages	src/thread_cache.h	/^    void set_length_overages(size_t new_count) {$/;"	f	class:tcmalloc::ThreadCache::FreeList	access:public	signature:(size_t new_count)
set_live	src/heap-profile-table.h	/^    void set_live(bool l) {$/;"	f	struct:HeapProfileTable::AllocValue	access:public	signature:(bool l)
set_max_length	src/thread_cache.h	/^    void set_max_length(size_t new_max) {$/;"	f	class:tcmalloc::ThreadCache::FreeList	access:public	signature:(size_t new_max)
set_new_handler_lock	src/tcmalloc.cc	/^SpinLock set_new_handler_lock(SpinLock::LINKER_INITIALIZED);$/;"	p	namespace:__anon3	file:	signature:(SpinLock::LINKER_INITIALIZED)
set_offset	src/debugallocation.cc	/^  void set_offset(int offset) { this->offset_ = offset; }$/;"	f	class:MallocBlock	access:public	signature:(int offset)
set_overall_thread_cache_size	src/thread_cache.cc	/^void ThreadCache::set_overall_thread_cache_size(size_t new_size) {$/;"	f	class:tcmalloc::ThreadCache	signature:(size_t new_size)
set_overall_thread_cache_size	src/thread_cache.h	/^  static void set_overall_thread_cache_size(size_t new_size);$/;"	p	class:tcmalloc::ThreadCache	access:public	signature:(size_t new_size)
set_start_addr	src/memory_region_map.h	/^    void set_start_addr(uintptr_t addr) {$/;"	f	struct:MemoryRegionMap::Region	access:private	signature:(uintptr_t addr)
set_stop_work	src/tests/profile-handler_unittest.cc	/^  void set_stop_work(bool stop_work) {$/;"	f	class:__anon56::BusyThread	access:public	signature:(bool stop_work)
set_thread_disable_counter	src/heap-checker.cc	/^inline void set_thread_disable_counter(int value) {$/;"	f	signature:(int value)
setup_oomable_sys_alloc	src/tests/tcmalloc_unittest.cc	/^void setup_oomable_sys_alloc() {$/;"	f	signature:()
shift	compile	/^	shift$/;"	v
shift_	src/windows/mini_disassembler_types.h	/^  unsigned char shift_;$/;"	m	struct:sidestep::OpcodeTable	access:public
shlibpath_overrides_runpath	m4/libtool.m4	/^    shlibpath_overrides_runpath=yes$/;"	v
shlibpath_var	m4/libtool.m4	/^  shlibpath_var=LD_LIBRARY${shlibsuff}_PATH$/;"	v
shlibpath_var	m4/libtool.m4	/^  shlibpath_var=LD_LIBRARY_PATH$/;"	v
should_decode_modrm_	src/windows/mini_disassembler.h	/^  bool should_decode_modrm_;$/;"	m	class:sidestep::MiniDisassembler	access:private
should_report_large	src/tcmalloc.cc	/^inline bool should_report_large(Length num_pages) {$/;"	f	namespace:__anon3	signature:(Length num_pages)
shrext_cmds	m4/libtool.m4	/^    shrext_cmds='.sl'$/;"	v
sidestep	src/windows/auto_testing_hook.h	/^namespace sidestep {$/;"	n
sidestep	src/windows/ia32_modrm_map.cc	/^namespace sidestep {$/;"	n	file:
sidestep	src/windows/ia32_opcode_map.cc	/^namespace sidestep {$/;"	n	file:
sidestep	src/windows/mini_disassembler.cc	/^namespace sidestep {$/;"	n	file:
sidestep	src/windows/mini_disassembler.h	/^namespace sidestep {$/;"	n
sidestep	src/windows/mini_disassembler_types.h	/^namespace sidestep {$/;"	n
sidestep	src/windows/preamble_patcher.cc	/^namespace sidestep {$/;"	n	file:
sidestep	src/windows/preamble_patcher.h	/^namespace sidestep {$/;"	n
sidestep	src/windows/preamble_patcher_test.cc	/^namespace sidestep {$/;"	n	file:
sidestep	src/windows/preamble_patcher_with_stub.cc	/^namespace sidestep {$/;"	n	file:
sidestep::AM_A	src/windows/mini_disassembler_types.h	/^  AM_A = 0x00010000,    \/\/ A addressing type$/;"	e	enum:sidestep::AddressingMethod
sidestep::AM_C	src/windows/mini_disassembler_types.h	/^  AM_C = 0x00020000,    \/\/ C addressing type$/;"	e	enum:sidestep::AddressingMethod
sidestep::AM_D	src/windows/mini_disassembler_types.h	/^  AM_D = 0x00030000,    \/\/ D addressing type$/;"	e	enum:sidestep::AddressingMethod
sidestep::AM_E	src/windows/mini_disassembler_types.h	/^  AM_E = 0x00040000,    \/\/ E addressing type$/;"	e	enum:sidestep::AddressingMethod
sidestep::AM_F	src/windows/mini_disassembler_types.h	/^  AM_F = 0x00050000,    \/\/ F addressing type$/;"	e	enum:sidestep::AddressingMethod
sidestep::AM_G	src/windows/mini_disassembler_types.h	/^  AM_G = 0x00060000,    \/\/ G addressing type$/;"	e	enum:sidestep::AddressingMethod
sidestep::AM_I	src/windows/mini_disassembler_types.h	/^  AM_I = 0x00070000,    \/\/ I addressing type$/;"	e	enum:sidestep::AddressingMethod
sidestep::AM_IMPLICIT	src/windows/mini_disassembler_types.h	/^  AM_IMPLICIT = 0x00150000,  \/\/ An implicit, fixed value is used$/;"	e	enum:sidestep::AddressingMethod
sidestep::AM_J	src/windows/mini_disassembler_types.h	/^  AM_J = 0x00080000,    \/\/ J addressing type$/;"	e	enum:sidestep::AddressingMethod
sidestep::AM_M	src/windows/mini_disassembler_types.h	/^  AM_M = 0x00090000,    \/\/ M addressing type$/;"	e	enum:sidestep::AddressingMethod
sidestep::AM_MASK	src/windows/mini_disassembler_types.h	/^  AM_MASK = 0x00FF0000,  \/\/ Mask for the rest of the values in this enumeration$/;"	e	enum:sidestep::AddressingMethod
sidestep::AM_NOT_USED	src/windows/mini_disassembler_types.h	/^  AM_NOT_USED = 0,        \/\/ This operand is not used for this instruction$/;"	e	enum:sidestep::AddressingMethod
sidestep::AM_O	src/windows/mini_disassembler_types.h	/^  AM_O = 0x000A0000,    \/\/ O addressing type$/;"	e	enum:sidestep::AddressingMethod
sidestep::AM_P	src/windows/mini_disassembler_types.h	/^  AM_P = 0x000B0000,    \/\/ P addressing type$/;"	e	enum:sidestep::AddressingMethod
sidestep::AM_Q	src/windows/mini_disassembler_types.h	/^  AM_Q = 0x000C0000,    \/\/ Q addressing type$/;"	e	enum:sidestep::AddressingMethod
sidestep::AM_R	src/windows/mini_disassembler_types.h	/^  AM_R = 0x000D0000,    \/\/ R addressing type$/;"	e	enum:sidestep::AddressingMethod
sidestep::AM_REGISTER	src/windows/mini_disassembler_types.h	/^  AM_REGISTER = 0x00140000,  \/\/ Specific register is always used as this op$/;"	e	enum:sidestep::AddressingMethod
sidestep::AM_S	src/windows/mini_disassembler_types.h	/^  AM_S = 0x000E0000,    \/\/ S addressing type$/;"	e	enum:sidestep::AddressingMethod
sidestep::AM_T	src/windows/mini_disassembler_types.h	/^  AM_T = 0x000F0000,    \/\/ T addressing type$/;"	e	enum:sidestep::AddressingMethod
sidestep::AM_V	src/windows/mini_disassembler_types.h	/^  AM_V = 0x00100000,    \/\/ V addressing type$/;"	e	enum:sidestep::AddressingMethod
sidestep::AM_W	src/windows/mini_disassembler_types.h	/^  AM_W = 0x00110000,    \/\/ W addressing type$/;"	e	enum:sidestep::AddressingMethod
sidestep::AM_X	src/windows/mini_disassembler_types.h	/^  AM_X = 0x00120000,    \/\/ X addressing type$/;"	e	enum:sidestep::AddressingMethod
sidestep::AM_Y	src/windows/mini_disassembler_types.h	/^  AM_Y = 0x00130000,    \/\/ Y addressing type$/;"	e	enum:sidestep::AddressingMethod
sidestep::AddressingMethod	src/windows/mini_disassembler_types.h	/^enum AddressingMethod {$/;"	g	namespace:sidestep
sidestep::AutoTestingHook	src/windows/auto_testing_hook.h	/^typedef const AutoTestingHookBase& AutoTestingHook;$/;"	t	namespace:sidestep
sidestep::AutoTestingHookBase	src/windows/auto_testing_hook.h	/^class AutoTestingHookBase {$/;"	c	namespace:sidestep
sidestep::AutoTestingHookBase::~AutoTestingHookBase	src/windows/auto_testing_hook.h	/^  virtual ~AutoTestingHookBase() {}$/;"	f	class:sidestep::AutoTestingHookBase	access:public	signature:()
sidestep::AutoTestingHookHolder	src/windows/auto_testing_hook.h	/^class AutoTestingHookHolder {$/;"	c	namespace:sidestep
sidestep::AutoTestingHookHolder::AutoTestingHookHolder	src/windows/auto_testing_hook.h	/^  AutoTestingHookHolder() {}  \/\/ disallow$/;"	f	class:sidestep::AutoTestingHookHolder	access:private	signature:()
sidestep::AutoTestingHookHolder::AutoTestingHookHolder	src/windows/auto_testing_hook.h	/^  explicit AutoTestingHookHolder(AutoTestingHookBase* hook) : hook_(hook) {}$/;"	f	class:sidestep::AutoTestingHookHolder	access:public	signature:(AutoTestingHookBase* hook)
sidestep::AutoTestingHookHolder::hook_	src/windows/auto_testing_hook.h	/^  AutoTestingHookBase* hook_;$/;"	m	class:sidestep::AutoTestingHookHolder	access:private
sidestep::AutoTestingHookHolder::~AutoTestingHookHolder	src/windows/auto_testing_hook.h	/^  ~AutoTestingHookHolder() { delete hook_; }$/;"	f	class:sidestep::AutoTestingHookHolder	access:public	signature:()
sidestep::AutoTestingHookImpl	src/windows/auto_testing_hook.h	/^class AutoTestingHookImpl : public AutoTestingHookBase {$/;"	c	namespace:sidestep	inherits:AutoTestingHookBase
sidestep::AutoTestingHookImpl::AutoTestingHookImpl	src/windows/auto_testing_hook.h	/^  AutoTestingHookImpl(T target_function, T replacement_function, bool do_it)$/;"	f	class:sidestep::AutoTestingHookImpl	access:private	signature:(T target_function, T replacement_function, bool do_it)
sidestep::AutoTestingHookImpl::MakeTestingHook	src/windows/auto_testing_hook.h	/^  static AutoTestingHookImpl<T> MakeTestingHook(T target_function,$/;"	f	class:sidestep::AutoTestingHookImpl	access:public	signature:(T target_function, T replacement_function, bool do_it)
sidestep::AutoTestingHookImpl::MakeTestingHookHolder	src/windows/auto_testing_hook.h	/^  static AutoTestingHookImpl<T>* MakeTestingHookHolder(T target_function,$/;"	f	class:sidestep::AutoTestingHookImpl	access:public	signature:(T target_function, T replacement_function, bool do_it)
sidestep::AutoTestingHookImpl::did_it_	src/windows/auto_testing_hook.h	/^  bool did_it_;  \/\/ Remember if we did it or not...$/;"	m	class:sidestep::AutoTestingHookImpl	access:private
sidestep::AutoTestingHookImpl::original_function	src/windows/auto_testing_hook.h	/^  T original_function() {$/;"	f	class:sidestep::AutoTestingHookImpl	access:public	signature:()
sidestep::AutoTestingHookImpl::original_function_	src/windows/auto_testing_hook.h	/^  T original_function_;  \/\/ always valid$/;"	m	class:sidestep::AutoTestingHookImpl	access:private
sidestep::AutoTestingHookImpl::replacement_function_	src/windows/auto_testing_hook.h	/^  T replacement_function_;  \/\/ always valid$/;"	m	class:sidestep::AutoTestingHookImpl	access:private
sidestep::AutoTestingHookImpl::target_function_	src/windows/auto_testing_hook.h	/^  T target_function_;  \/\/ always valid$/;"	m	class:sidestep::AutoTestingHookImpl	access:private
sidestep::AutoTestingHookImpl::~AutoTestingHookImpl	src/windows/auto_testing_hook.h	/^  ~AutoTestingHookImpl() {$/;"	f	class:sidestep::AutoTestingHookImpl	access:public	signature:()
sidestep::AutoTestingHookInContainerTest	src/windows/preamble_patcher_test.cc	/^bool AutoTestingHookInContainerTest() {$/;"	f	namespace:sidestep	signature:()
sidestep::AutoTestingHookTest	src/windows/preamble_patcher_test.cc	/^bool AutoTestingHookTest() {$/;"	f	namespace:sidestep	signature:()
sidestep::DeleteUnsignedCharArray	src/windows/preamble_patcher.cc	/^class DeleteUnsignedCharArray {$/;"	c	namespace:sidestep	file:
sidestep::DeleteUnsignedCharArray::DeleteUnsignedCharArray	src/windows/preamble_patcher.cc	/^  DeleteUnsignedCharArray(unsigned char* array) : array_(array) {$/;"	f	class:sidestep::DeleteUnsignedCharArray	access:public	signature:(unsigned char* array)
sidestep::DeleteUnsignedCharArray::Release	src/windows/preamble_patcher.cc	/^  unsigned char* Release() {$/;"	f	class:sidestep::DeleteUnsignedCharArray	access:public	signature:()
sidestep::DeleteUnsignedCharArray::array_	src/windows/preamble_patcher.cc	/^  unsigned char* array_;$/;"	m	class:sidestep::DeleteUnsignedCharArray	file:	access:private
sidestep::DeleteUnsignedCharArray::~DeleteUnsignedCharArray	src/windows/preamble_patcher.cc	/^  ~DeleteUnsignedCharArray() {$/;"	f	class:sidestep::DeleteUnsignedCharArray	access:public	signature:()
sidestep::IOS_64	src/windows/mini_disassembler_types.h	/^  IOS_64 = 0x00001000$/;"	e	enum:sidestep::ImmediateOperandSize
sidestep::IOS_DEFAULT	src/windows/mini_disassembler_types.h	/^  IOS_DEFAULT = 0x0,$/;"	e	enum:sidestep::ImmediateOperandSize
sidestep::IOS_MASK	src/windows/mini_disassembler_types.h	/^  IOS_MASK = 0x0000F000,$/;"	e	enum:sidestep::ImmediateOperandSize
sidestep::IT_GENERIC	src/windows/mini_disassembler_types.h	/^  IT_GENERIC,$/;"	e	enum:sidestep::InstructionType
sidestep::IT_JUMP	src/windows/mini_disassembler_types.h	/^  IT_JUMP,$/;"	e	enum:sidestep::InstructionType
sidestep::IT_PREFIX	src/windows/mini_disassembler_types.h	/^  IT_PREFIX,$/;"	e	enum:sidestep::InstructionType
sidestep::IT_PREFIX_ADDRESS	src/windows/mini_disassembler_types.h	/^  IT_PREFIX_ADDRESS,$/;"	e	enum:sidestep::InstructionType
sidestep::IT_PREFIX_OPERAND	src/windows/mini_disassembler_types.h	/^  IT_PREFIX_OPERAND,$/;"	e	enum:sidestep::InstructionType
sidestep::IT_REFERENCE	src/windows/mini_disassembler_types.h	/^  IT_REFERENCE,$/;"	e	enum:sidestep::InstructionType
sidestep::IT_RETURN	src/windows/mini_disassembler_types.h	/^  IT_RETURN,$/;"	e	enum:sidestep::InstructionType
sidestep::IT_UNKNOWN	src/windows/mini_disassembler_types.h	/^  IT_UNKNOWN,$/;"	e	enum:sidestep::InstructionType
sidestep::IT_UNUSED	src/windows/mini_disassembler_types.h	/^  IT_UNUSED,$/;"	e	enum:sidestep::InstructionType
sidestep::ImmediateOperandSize	src/windows/mini_disassembler_types.h	/^enum ImmediateOperandSize {$/;"	g	namespace:sidestep
sidestep::InstructionType	src/windows/mini_disassembler_types.h	/^enum InstructionType {$/;"	g	namespace:sidestep
sidestep::MakeTestingHook	src/windows/auto_testing_hook.h	/^inline AutoTestingHookImpl<T> MakeTestingHook(T target, T replacement) {$/;"	f	namespace:sidestep	signature:(T target, T replacement)
sidestep::MakeTestingHook	src/windows/auto_testing_hook.h	/^inline AutoTestingHookImpl<T> MakeTestingHook(T target,$/;"	f	namespace:sidestep	signature:(T target, T replacement, bool do_it)
sidestep::MakeTestingHookHolder	src/windows/auto_testing_hook.h	/^inline AutoTestingHookImpl<T>* MakeTestingHookHolder(T target, T replacement) {$/;"	f	namespace:sidestep	signature:(T target, T replacement)
sidestep::MiniDisassembler	src/windows/mini_disassembler.h	/^class PERFTOOLS_DLL_DECL MiniDisassembler {$/;"	c	namespace:sidestep
sidestep::MiniDisassembler::Disassemble	src/windows/mini_disassembler.cc	/^InstructionType MiniDisassembler::Disassemble($/;"	f	class:sidestep::MiniDisassembler	signature:( unsigned char* start_byte, unsigned int& instruction_bytes)
sidestep::MiniDisassembler::Disassemble	src/windows/mini_disassembler.h	/^  InstructionType Disassemble(unsigned char* start, unsigned int& instruction_bytes);$/;"	p	class:sidestep::MiniDisassembler	access:public	signature:(unsigned char* start, unsigned int& instruction_bytes)
sidestep::MiniDisassembler::Initialize	src/windows/mini_disassembler.cc	/^void MiniDisassembler::Initialize() {$/;"	f	class:sidestep::MiniDisassembler	signature:()
sidestep::MiniDisassembler::Initialize	src/windows/mini_disassembler.h	/^  void Initialize();$/;"	p	class:sidestep::MiniDisassembler	access:private	signature:()
sidestep::MiniDisassembler::MiniDisassembler	src/windows/mini_disassembler.cc	/^MiniDisassembler::MiniDisassembler()$/;"	f	class:sidestep::MiniDisassembler	signature:()
sidestep::MiniDisassembler::MiniDisassembler	src/windows/mini_disassembler.cc	/^MiniDisassembler::MiniDisassembler(bool operand_default_is_32_bits,$/;"	f	class:sidestep::MiniDisassembler	signature:(bool operand_default_is_32_bits, bool address_default_is_32_bits)
sidestep::MiniDisassembler::MiniDisassembler	src/windows/mini_disassembler.h	/^  MiniDisassembler();$/;"	p	class:sidestep::MiniDisassembler	access:public	signature:()
sidestep::MiniDisassembler::MiniDisassembler	src/windows/mini_disassembler.h	/^  MiniDisassembler(bool operand_default_32_bits,$/;"	p	class:sidestep::MiniDisassembler	access:public	signature:(bool operand_default_32_bits, bool address_default_32_bits)
sidestep::MiniDisassembler::ProcessModrm	src/windows/mini_disassembler.cc	/^bool MiniDisassembler::ProcessModrm(unsigned char* start_byte,$/;"	f	class:sidestep::MiniDisassembler	signature:(unsigned char* start_byte, unsigned int& size)
sidestep::MiniDisassembler::ProcessModrm	src/windows/mini_disassembler.h	/^  bool ProcessModrm(unsigned char* start, unsigned int& size);$/;"	p	class:sidestep::MiniDisassembler	access:private	signature:(unsigned char* start, unsigned int& size)
sidestep::MiniDisassembler::ProcessOpcode	src/windows/mini_disassembler.cc	/^InstructionType MiniDisassembler::ProcessOpcode(unsigned char* start_byte,$/;"	f	class:sidestep::MiniDisassembler	signature:(unsigned char* start_byte, unsigned int table_index, unsigned int& size)
sidestep::MiniDisassembler::ProcessOpcode	src/windows/mini_disassembler.h	/^  InstructionType ProcessOpcode(unsigned char* start,$/;"	p	class:sidestep::MiniDisassembler	access:private	signature:(unsigned char* start, unsigned int table, unsigned int& size)
sidestep::MiniDisassembler::ProcessOperand	src/windows/mini_disassembler.cc	/^bool MiniDisassembler::ProcessOperand(int flag_operand) {$/;"	f	class:sidestep::MiniDisassembler	signature:(int flag_operand)
sidestep::MiniDisassembler::ProcessOperand	src/windows/mini_disassembler.h	/^  bool ProcessOperand(int flag_operand);$/;"	p	class:sidestep::MiniDisassembler	access:private	signature:(int flag_operand)
sidestep::MiniDisassembler::ProcessPrefixes	src/windows/mini_disassembler.cc	/^InstructionType MiniDisassembler::ProcessPrefixes(unsigned char* start_byte,$/;"	f	class:sidestep::MiniDisassembler	signature:(unsigned char* start_byte, unsigned int& size)
sidestep::MiniDisassembler::ProcessPrefixes	src/windows/mini_disassembler.h	/^  InstructionType ProcessPrefixes(unsigned char* start, unsigned int& size);$/;"	p	class:sidestep::MiniDisassembler	access:private	signature:(unsigned char* start, unsigned int& size)
sidestep::MiniDisassembler::ProcessSib	src/windows/mini_disassembler.cc	/^bool MiniDisassembler::ProcessSib(unsigned char* start_byte,$/;"	f	class:sidestep::MiniDisassembler	signature:(unsigned char* start_byte, unsigned char mod, unsigned int& size)
sidestep::MiniDisassembler::ProcessSib	src/windows/mini_disassembler.h	/^  bool ProcessSib(unsigned char* start, unsigned char mod, unsigned int& size);$/;"	p	class:sidestep::MiniDisassembler	access:private	signature:(unsigned char* start, unsigned char mod, unsigned int& size)
sidestep::MiniDisassembler::address_default_is_32_bits_	src/windows/mini_disassembler.h	/^  bool address_default_is_32_bits_;$/;"	m	class:sidestep::MiniDisassembler	access:private
sidestep::MiniDisassembler::address_is_32_bits_	src/windows/mini_disassembler.h	/^  bool address_is_32_bits_;$/;"	m	class:sidestep::MiniDisassembler	access:private
sidestep::MiniDisassembler::got_66_prefix_	src/windows/mini_disassembler.h	/^  bool got_f2_prefix_, got_f3_prefix_, got_66_prefix_;$/;"	m	class:sidestep::MiniDisassembler	access:private
sidestep::MiniDisassembler::got_f2_prefix_	src/windows/mini_disassembler.h	/^  bool got_f2_prefix_, got_f3_prefix_, got_66_prefix_;$/;"	m	class:sidestep::MiniDisassembler	access:private
sidestep::MiniDisassembler::got_f3_prefix_	src/windows/mini_disassembler.h	/^  bool got_f2_prefix_, got_f3_prefix_, got_66_prefix_;$/;"	m	class:sidestep::MiniDisassembler	access:private
sidestep::MiniDisassembler::have_modrm_	src/windows/mini_disassembler.h	/^  bool have_modrm_;$/;"	m	class:sidestep::MiniDisassembler	access:private
sidestep::MiniDisassembler::instruction_type_	src/windows/mini_disassembler.h	/^  InstructionType instruction_type_;$/;"	m	class:sidestep::MiniDisassembler	access:private
sidestep::MiniDisassembler::operand_bytes_	src/windows/mini_disassembler.h	/^  unsigned int operand_bytes_;$/;"	m	class:sidestep::MiniDisassembler	access:private
sidestep::MiniDisassembler::operand_default_is_32_bits_	src/windows/mini_disassembler.h	/^  bool operand_default_is_32_bits_;$/;"	m	class:sidestep::MiniDisassembler	access:private
sidestep::MiniDisassembler::operand_default_support_64_bits_	src/windows/mini_disassembler.h	/^  bool operand_default_support_64_bits_;$/;"	m	class:sidestep::MiniDisassembler	access:private
sidestep::MiniDisassembler::operand_is_32_bits_	src/windows/mini_disassembler.h	/^  bool operand_is_32_bits_;$/;"	m	class:sidestep::MiniDisassembler	access:private
sidestep::MiniDisassembler::operand_is_64_bits_	src/windows/mini_disassembler.h	/^  bool operand_is_64_bits_;$/;"	m	class:sidestep::MiniDisassembler	access:private
sidestep::MiniDisassembler::s_ia16_modrm_map_	src/windows/ia32_modrm_map.cc	/^const ModrmEntry MiniDisassembler::s_ia16_modrm_map_[] = {$/;"	m	class:sidestep::MiniDisassembler	file:
sidestep::MiniDisassembler::s_ia16_modrm_map_	src/windows/mini_disassembler.h	/^  static const ModrmEntry s_ia16_modrm_map_[];$/;"	m	class:sidestep::MiniDisassembler	access:private
sidestep::MiniDisassembler::s_ia32_modrm_map_	src/windows/ia32_modrm_map.cc	/^const ModrmEntry MiniDisassembler::s_ia32_modrm_map_[] = {$/;"	m	class:sidestep::MiniDisassembler	file:
sidestep::MiniDisassembler::s_ia32_modrm_map_	src/windows/mini_disassembler.h	/^  static const ModrmEntry s_ia32_modrm_map_[];$/;"	m	class:sidestep::MiniDisassembler	access:private
sidestep::MiniDisassembler::s_ia32_opcode_map_	src/windows/ia32_opcode_map.cc	/^const OpcodeTable MiniDisassembler::s_ia32_opcode_map_[]={$/;"	m	class:sidestep::MiniDisassembler	file:
sidestep::MiniDisassembler::s_ia32_opcode_map_	src/windows/mini_disassembler.h	/^  static const OpcodeTable s_ia32_opcode_map_[];$/;"	m	class:sidestep::MiniDisassembler	access:private
sidestep::MiniDisassembler::should_decode_modrm_	src/windows/mini_disassembler.h	/^  bool should_decode_modrm_;$/;"	m	class:sidestep::MiniDisassembler	access:private
sidestep::ModrmEntry	src/windows/mini_disassembler_types.h	/^struct ModrmEntry {$/;"	s	namespace:sidestep
sidestep::ModrmEntry::is_encoded_in_instruction_	src/windows/mini_disassembler_types.h	/^  bool is_encoded_in_instruction_;$/;"	m	struct:sidestep::ModrmEntry	access:public
sidestep::ModrmEntry::operand_size_	src/windows/mini_disassembler_types.h	/^  OperandSize operand_size_;$/;"	m	struct:sidestep::ModrmEntry	access:public
sidestep::ModrmEntry::use_sib_byte_	src/windows/mini_disassembler_types.h	/^  bool use_sib_byte_;$/;"	m	struct:sidestep::ModrmEntry	access:public
sidestep::OS_128_BIT_PACKED_SINGLE_PRECISION_FLOATING	src/windows/mini_disassembler_types.h	/^  OS_128_BIT_PACKED_SINGLE_PRECISION_FLOATING = 128\/8,$/;"	e	enum:sidestep::OperandSize
sidestep::OS_32_BIT_POINTER	src/windows/mini_disassembler_types.h	/^  OS_32_BIT_POINTER = 32\/8,$/;"	e	enum:sidestep::OperandSize
sidestep::OS_48_BIT_POINTER	src/windows/mini_disassembler_types.h	/^  OS_48_BIT_POINTER = 48\/8,$/;"	e	enum:sidestep::OperandSize
sidestep::OS_BYTE	src/windows/mini_disassembler_types.h	/^  OS_BYTE = 1,$/;"	e	enum:sidestep::OperandSize
sidestep::OS_DOUBLE_EXTENDED_PRECISION_FLOATING	src/windows/mini_disassembler_types.h	/^  OS_DOUBLE_EXTENDED_PRECISION_FLOATING = 80\/8,$/;"	e	enum:sidestep::OperandSize
sidestep::OS_DOUBLE_PRECISION_FLOATING	src/windows/mini_disassembler_types.h	/^  OS_DOUBLE_PRECISION_FLOATING = 64\/8,$/;"	e	enum:sidestep::OperandSize
sidestep::OS_DOUBLE_QUAD_WORD	src/windows/mini_disassembler_types.h	/^  OS_DOUBLE_QUAD_WORD = 16,$/;"	e	enum:sidestep::OperandSize
sidestep::OS_DOUBLE_WORD	src/windows/mini_disassembler_types.h	/^  OS_DOUBLE_WORD = 4,$/;"	e	enum:sidestep::OperandSize
sidestep::OS_PSEUDO_DESCRIPTOR	src/windows/mini_disassembler_types.h	/^  OS_PSEUDO_DESCRIPTOR = 6$/;"	e	enum:sidestep::OperandSize
sidestep::OS_QUAD_WORD	src/windows/mini_disassembler_types.h	/^  OS_QUAD_WORD = 8,$/;"	e	enum:sidestep::OperandSize
sidestep::OS_SINGLE_PRECISION_FLOATING	src/windows/mini_disassembler_types.h	/^  OS_SINGLE_PRECISION_FLOATING = 32\/8,$/;"	e	enum:sidestep::OperandSize
sidestep::OS_WORD	src/windows/mini_disassembler_types.h	/^  OS_WORD = 2,$/;"	e	enum:sidestep::OperandSize
sidestep::OS_ZERO	src/windows/mini_disassembler_types.h	/^  OS_ZERO = 0,$/;"	e	enum:sidestep::OperandSize
sidestep::OT_A	src/windows/mini_disassembler_types.h	/^  OT_A = 0x01000000,$/;"	e	enum:sidestep::OperandType
sidestep::OT_ADDRESS_MODE_M	src/windows/mini_disassembler_types.h	/^  OT_ADDRESS_MODE_M = 0x80000000$/;"	e	enum:sidestep::OperandType
sidestep::OT_B	src/windows/mini_disassembler_types.h	/^  OT_B = 0x02000000,$/;"	e	enum:sidestep::OperandType
sidestep::OT_C	src/windows/mini_disassembler_types.h	/^  OT_C = 0x03000000,$/;"	e	enum:sidestep::OperandType
sidestep::OT_D	src/windows/mini_disassembler_types.h	/^  OT_D = 0x04000000,$/;"	e	enum:sidestep::OperandType
sidestep::OT_DQ	src/windows/mini_disassembler_types.h	/^  OT_DQ = 0x05000000,$/;"	e	enum:sidestep::OperandType
sidestep::OT_MASK	src/windows/mini_disassembler_types.h	/^  OT_MASK = 0xFF000000,$/;"	e	enum:sidestep::OperandType
sidestep::OT_P	src/windows/mini_disassembler_types.h	/^  OT_P = 0x06000000,$/;"	e	enum:sidestep::OperandType
sidestep::OT_PD	src/windows/mini_disassembler_types.h	/^  OT_PD = 0x10000000,  \/\/ double-precision floating point$/;"	e	enum:sidestep::OperandType
sidestep::OT_PI	src/windows/mini_disassembler_types.h	/^  OT_PI = 0x07000000,$/;"	e	enum:sidestep::OperandType
sidestep::OT_PS	src/windows/mini_disassembler_types.h	/^  OT_PS = 0x08000000,  \/\/ actually unsupported for (we don't know its size)$/;"	e	enum:sidestep::OperandType
sidestep::OT_Q	src/windows/mini_disassembler_types.h	/^  OT_Q = 0x09000000,$/;"	e	enum:sidestep::OperandType
sidestep::OT_S	src/windows/mini_disassembler_types.h	/^  OT_S = 0x0A000000,$/;"	e	enum:sidestep::OperandType
sidestep::OT_SD	src/windows/mini_disassembler_types.h	/^  OT_SD = 0x0F000000,  \/\/ scalar double-precision floating-point value$/;"	e	enum:sidestep::OperandType
sidestep::OT_SI	src/windows/mini_disassembler_types.h	/^  OT_SI = 0x0C000000,$/;"	e	enum:sidestep::OperandType
sidestep::OT_SS	src/windows/mini_disassembler_types.h	/^  OT_SS = 0x0B000000,$/;"	e	enum:sidestep::OperandType
sidestep::OT_V	src/windows/mini_disassembler_types.h	/^  OT_V = 0x0D000000,$/;"	e	enum:sidestep::OperandType
sidestep::OT_W	src/windows/mini_disassembler_types.h	/^  OT_W = 0x0E000000,$/;"	e	enum:sidestep::OperandType
sidestep::Opcode	src/windows/mini_disassembler_types.h	/^struct Opcode {$/;"	s	namespace:sidestep
sidestep::Opcode::flag_aux_	src/windows/mini_disassembler_types.h	/^  unsigned flag_aux_;$/;"	m	struct:sidestep::Opcode	access:public
sidestep::Opcode::flag_dest_	src/windows/mini_disassembler_types.h	/^  unsigned flag_dest_;$/;"	m	struct:sidestep::Opcode	access:public
sidestep::Opcode::flag_source_	src/windows/mini_disassembler_types.h	/^  unsigned flag_source_;$/;"	m	struct:sidestep::Opcode	access:public
sidestep::Opcode::is_prefix_dependent_	src/windows/mini_disassembler_types.h	/^  bool is_prefix_dependent_;$/;"	m	struct:sidestep::Opcode	access:public
sidestep::Opcode::mnemonic_	src/windows/mini_disassembler_types.h	/^  const char* mnemonic_;$/;"	m	struct:sidestep::Opcode	access:public
sidestep::Opcode::opcode_if_66_prefix_	src/windows/mini_disassembler_types.h	/^  SpecificOpcode opcode_if_66_prefix_;$/;"	m	struct:sidestep::Opcode	access:public
sidestep::Opcode::opcode_if_f2_prefix_	src/windows/mini_disassembler_types.h	/^  SpecificOpcode opcode_if_f2_prefix_;$/;"	m	struct:sidestep::Opcode	access:public
sidestep::Opcode::opcode_if_f3_prefix_	src/windows/mini_disassembler_types.h	/^  SpecificOpcode opcode_if_f3_prefix_;$/;"	m	struct:sidestep::Opcode	access:public
sidestep::Opcode::table_index_	src/windows/mini_disassembler_types.h	/^  int table_index_;$/;"	m	struct:sidestep::Opcode	access:public
sidestep::Opcode::type_	src/windows/mini_disassembler_types.h	/^  InstructionType type_;$/;"	m	struct:sidestep::Opcode	access:public
sidestep::OpcodeTable	src/windows/mini_disassembler_types.h	/^struct OpcodeTable {$/;"	s	namespace:sidestep
sidestep::OpcodeTable::mask_	src/windows/mini_disassembler_types.h	/^  unsigned char mask_;$/;"	m	struct:sidestep::OpcodeTable	access:public
sidestep::OpcodeTable::max_lim_	src/windows/mini_disassembler_types.h	/^  unsigned char max_lim_;$/;"	m	struct:sidestep::OpcodeTable	access:public
sidestep::OpcodeTable::min_lim_	src/windows/mini_disassembler_types.h	/^  unsigned char min_lim_;$/;"	m	struct:sidestep::OpcodeTable	access:public
sidestep::OpcodeTable::shift_	src/windows/mini_disassembler_types.h	/^  unsigned char shift_;$/;"	m	struct:sidestep::OpcodeTable	access:public
sidestep::OpcodeTable::table_	src/windows/mini_disassembler_types.h	/^  const Opcode* table_;$/;"	m	struct:sidestep::OpcodeTable	access:public
sidestep::OperandSize	src/windows/mini_disassembler_types.h	/^enum OperandSize {$/;"	g	namespace:sidestep
sidestep::OperandType	src/windows/mini_disassembler_types.h	/^enum OperandType {$/;"	g	namespace:sidestep
sidestep::PatchThenUnpatch	src/windows/preamble_patcher_test.cc	/^bool PatchThenUnpatch() {$/;"	f	namespace:sidestep	signature:()
sidestep::PreamblePatcher	src/windows/preamble_patcher.h	/^class PERFTOOLS_DLL_DECL PreamblePatcher {$/;"	c	namespace:sidestep
sidestep::PreamblePatcher::AllocPageNear	src/windows/preamble_patcher.cc	/^void* PreamblePatcher::AllocPageNear(void* target) {$/;"	f	class:sidestep::PreamblePatcher	signature:(void* target)
sidestep::PreamblePatcher::AllocPageNear	src/windows/preamble_patcher.h	/^  static void* AllocPageNear(void* target);$/;"	p	class:sidestep::PreamblePatcher	access:private	signature:(void* target)
sidestep::PreamblePatcher::AllocPreambleBlockNear	src/windows/preamble_patcher.cc	/^unsigned char* PreamblePatcher::AllocPreambleBlockNear(void* target) {$/;"	f	class:sidestep::PreamblePatcher	signature:(void* target)
sidestep::PreamblePatcher::AllocPreambleBlockNear	src/windows/preamble_patcher.h	/^  static unsigned char* AllocPreambleBlockNear(void* target);$/;"	p	class:sidestep::PreamblePatcher	access:public	signature:(void* target)
sidestep::PreamblePatcher::FreePreambleBlock	src/windows/preamble_patcher.cc	/^void PreamblePatcher::FreePreambleBlock(unsigned char* block) {$/;"	f	class:sidestep::PreamblePatcher	signature:(unsigned char* block)
sidestep::PreamblePatcher::FreePreambleBlock	src/windows/preamble_patcher.h	/^  static void FreePreambleBlock(unsigned char* block);$/;"	p	class:sidestep::PreamblePatcher	access:public	signature:(unsigned char* block)
sidestep::PreamblePatcher::Initialize	src/windows/preamble_patcher.cc	/^void PreamblePatcher::Initialize() {$/;"	f	class:sidestep::PreamblePatcher	signature:()
sidestep::PreamblePatcher::Initialize	src/windows/preamble_patcher.h	/^  static void Initialize();$/;"	p	class:sidestep::PreamblePatcher	access:private	signature:()
sidestep::PreamblePatcher::IsMovWithDisplacement	src/windows/preamble_patcher.cc	/^bool PreamblePatcher::IsMovWithDisplacement($/;"	f	class:sidestep::PreamblePatcher	signature:( unsigned char* target, unsigned int instruction_size)
sidestep::PreamblePatcher::IsMovWithDisplacement	src/windows/preamble_patcher.h	/^  static bool IsMovWithDisplacement(unsigned char* target,$/;"	p	class:sidestep::PreamblePatcher	access:private	signature:(unsigned char* target, unsigned int instruction_size)
sidestep::PreamblePatcher::IsNearAbsoluteCall	src/windows/preamble_patcher.cc	/^bool PreamblePatcher::IsNearAbsoluteCall($/;"	f	class:sidestep::PreamblePatcher	signature:( unsigned char* target, unsigned int instruction_size)
sidestep::PreamblePatcher::IsNearAbsoluteCall	src/windows/preamble_patcher.h	/^  static bool IsNearAbsoluteCall(unsigned char* target,$/;"	p	class:sidestep::PreamblePatcher	access:private	signature:(unsigned char* target, unsigned int instruction_size)
sidestep::PreamblePatcher::IsNearConditionalJump	src/windows/preamble_patcher.cc	/^bool PreamblePatcher::IsNearConditionalJump($/;"	f	class:sidestep::PreamblePatcher	signature:( unsigned char* target, unsigned int instruction_size)
sidestep::PreamblePatcher::IsNearConditionalJump	src/windows/preamble_patcher.h	/^  static bool IsNearConditionalJump(unsigned char* target,$/;"	p	class:sidestep::PreamblePatcher	access:private	signature:(unsigned char* target, unsigned int instruction_size)
sidestep::PreamblePatcher::IsNearRelativeCall	src/windows/preamble_patcher.cc	/^bool PreamblePatcher::IsNearRelativeCall($/;"	f	class:sidestep::PreamblePatcher	signature:( unsigned char* target, unsigned int instruction_size)
sidestep::PreamblePatcher::IsNearRelativeCall	src/windows/preamble_patcher.h	/^  static bool IsNearRelativeCall(unsigned char* target,$/;"	p	class:sidestep::PreamblePatcher	access:private	signature:(unsigned char* target, unsigned int instruction_size)
sidestep::PreamblePatcher::IsNearRelativeJump	src/windows/preamble_patcher.cc	/^bool PreamblePatcher::IsNearRelativeJump($/;"	f	class:sidestep::PreamblePatcher	signature:( unsigned char* target, unsigned int instruction_size)
sidestep::PreamblePatcher::IsNearRelativeJump	src/windows/preamble_patcher.h	/^  static bool IsNearRelativeJump(unsigned char* target,$/;"	p	class:sidestep::PreamblePatcher	access:private	signature:(unsigned char* target, unsigned int instruction_size)
sidestep::PreamblePatcher::IsShortConditionalJump	src/windows/preamble_patcher.cc	/^bool PreamblePatcher::IsShortConditionalJump($/;"	f	class:sidestep::PreamblePatcher	signature:( unsigned char* target, unsigned int instruction_size)
sidestep::PreamblePatcher::IsShortConditionalJump	src/windows/preamble_patcher.h	/^  static bool IsShortConditionalJump(unsigned char* target,$/;"	p	class:sidestep::PreamblePatcher	access:private	signature:(unsigned char* target, unsigned int instruction_size)
sidestep::PreamblePatcher::IsShortJump	src/windows/preamble_patcher.cc	/^bool PreamblePatcher::IsShortJump($/;"	f	class:sidestep::PreamblePatcher	signature:( unsigned char* target, unsigned int instruction_size)
sidestep::PreamblePatcher::IsShortJump	src/windows/preamble_patcher.h	/^  static bool IsShortJump(unsigned char *target, unsigned int instruction_size);$/;"	p	class:sidestep::PreamblePatcher	access:private	signature:(unsigned char *target, unsigned int instruction_size)
sidestep::PreamblePatcher::Patch	src/windows/preamble_patcher.h	/^  static SideStepError Patch(LPCTSTR module_name,$/;"	f	class:sidestep::PreamblePatcher	access:public	signature:(LPCTSTR module_name, LPCSTR function_name, T replacement_function, T* original_function_stub)
sidestep::PreamblePatcher::Patch	src/windows/preamble_patcher.h	/^  static SideStepError Patch(T target_function,$/;"	f	class:sidestep::PreamblePatcher	access:public	signature:(T target_function, T replacement_function, T* original_function_stub)
sidestep::PreamblePatcher::PatchMovWithDisplacement	src/windows/preamble_patcher.cc	/^SideStepError PreamblePatcher::PatchMovWithDisplacement($/;"	f	class:sidestep::PreamblePatcher	signature:( unsigned char* source, unsigned int instruction_size, unsigned char* target, unsigned int* target_bytes, unsigned int target_size)
sidestep::PreamblePatcher::PatchMovWithDisplacement	src/windows/preamble_patcher.h	/^  static SideStepError PatchMovWithDisplacement(unsigned char* source,$/;"	p	class:sidestep::PreamblePatcher	access:private	signature:(unsigned char* source, unsigned int instruction_size, unsigned char* target, unsigned int* target_bytes, unsigned int target_size)
sidestep::PreamblePatcher::PatchNearJumpOrCall	src/windows/preamble_patcher.cc	/^SideStepError PreamblePatcher::PatchNearJumpOrCall($/;"	f	class:sidestep::PreamblePatcher	signature:( unsigned char* source, unsigned int instruction_size, unsigned char* target, unsigned int* target_bytes, unsigned int target_size)
sidestep::PreamblePatcher::PatchNearJumpOrCall	src/windows/preamble_patcher.h	/^  static SideStepError PatchNearJumpOrCall(unsigned char* source,$/;"	p	class:sidestep::PreamblePatcher	access:private	signature:(unsigned char* source, unsigned int instruction_size, unsigned char* target, unsigned int* target_bytes, unsigned int target_size)
sidestep::PreamblePatcher::PatchShortConditionalJump	src/windows/preamble_patcher.cc	/^SideStepError PreamblePatcher::PatchShortConditionalJump($/;"	f	class:sidestep::PreamblePatcher	signature:( unsigned char* source, unsigned int instruction_size, unsigned char* target, unsigned int* target_bytes, unsigned int target_size)
sidestep::PreamblePatcher::PatchShortConditionalJump	src/windows/preamble_patcher.h	/^  static SideStepError PatchShortConditionalJump(unsigned char* source,$/;"	p	class:sidestep::PreamblePatcher	access:private	signature:(unsigned char* source, unsigned int instruction_size, unsigned char* target, unsigned int* target_bytes, unsigned int target_size)
sidestep::PreamblePatcher::PatchShortJump	src/windows/preamble_patcher.cc	/^SideStepError PreamblePatcher::PatchShortJump($/;"	f	class:sidestep::PreamblePatcher	signature:( unsigned char* source, unsigned int instruction_size, unsigned char* target, unsigned int* target_bytes, unsigned int target_size)
sidestep::PreamblePatcher::PatchShortJump	src/windows/preamble_patcher.h	/^  static SideStepError PatchShortJump(unsigned char* source,$/;"	p	class:sidestep::PreamblePatcher	access:private	signature:(unsigned char* source, unsigned int instruction_size, unsigned char* target, unsigned int* target_bytes, unsigned int target_size)
sidestep::PreamblePatcher::PreamblePage	src/windows/preamble_patcher.h	/^  struct PreamblePage {$/;"	s	class:sidestep::PreamblePatcher	access:private
sidestep::PreamblePatcher::PreamblePage::free_	src/windows/preamble_patcher.h	/^    void* free_;$/;"	m	struct:sidestep::PreamblePatcher::PreamblePage	access:public
sidestep::PreamblePatcher::PreamblePage::magic_	src/windows/preamble_patcher.h	/^    unsigned int magic_;$/;"	m	struct:sidestep::PreamblePatcher::PreamblePage	access:public
sidestep::PreamblePatcher::PreamblePage::next_	src/windows/preamble_patcher.h	/^    PreamblePage* next_;$/;"	m	struct:sidestep::PreamblePatcher::PreamblePage	access:public
sidestep::PreamblePatcher::RawPatch	src/windows/preamble_patcher.cc	/^SideStepError PreamblePatcher::RawPatch(void* target_function,$/;"	f	class:sidestep::PreamblePatcher	signature:(void* target_function, void* replacement_function, void** original_function_stub)
sidestep::PreamblePatcher::RawPatch	src/windows/preamble_patcher.h	/^  static SideStepError RawPatch(void* target_function,$/;"	p	class:sidestep::PreamblePatcher	access:public	signature:(void* target_function, void* replacement_function, void** original_function_stub)
sidestep::PreamblePatcher::RawPatchWithStub	src/windows/preamble_patcher.h	/^  static SideStepError RawPatchWithStub(void* target_function,$/;"	p	class:sidestep::PreamblePatcher	access:private	signature:(void* target_function, void* replacement_function, unsigned char* preamble_stub, unsigned long stub_size, unsigned long* bytes_needed)
sidestep::PreamblePatcher::RawPatchWithStub	src/windows/preamble_patcher_with_stub.cc	/^SideStepError PreamblePatcher::RawPatchWithStub($/;"	f	class:sidestep::PreamblePatcher	signature:( void* target_function, void* replacement_function, unsigned char* preamble_stub, unsigned long stub_size, unsigned long* bytes_needed)
sidestep::PreamblePatcher::RawPatchWithStubAndProtections	src/windows/preamble_patcher.cc	/^SideStepError PreamblePatcher::RawPatchWithStubAndProtections($/;"	f	class:sidestep::PreamblePatcher	signature:( void* target_function, void *replacement_function, unsigned char* preamble_stub, unsigned long stub_size, unsigned long* bytes_needed)
sidestep::PreamblePatcher::RawPatchWithStubAndProtections	src/windows/preamble_patcher.h	/^  static SideStepError RawPatchWithStubAndProtections($/;"	p	class:sidestep::PreamblePatcher	access:private	signature:( void* target_function, void* replacement_function, unsigned char* preamble_stub, unsigned long stub_size, unsigned long* bytes_needed)
sidestep::PreamblePatcher::ResolveTarget	src/windows/preamble_patcher.h	/^  static T ResolveTarget(T target_function) {$/;"	f	class:sidestep::PreamblePatcher	access:public	signature:(T target_function)
sidestep::PreamblePatcher::ResolveTargetImpl	src/windows/preamble_patcher.cc	/^void* PreamblePatcher::ResolveTargetImpl(unsigned char* target,$/;"	f	class:sidestep::PreamblePatcher	signature:(unsigned char* target, unsigned char* stop_before, bool stop_before_trampoline)
sidestep::PreamblePatcher::ResolveTargetImpl	src/windows/preamble_patcher.h	/^  static void* ResolveTargetImpl(unsigned char* target_function,$/;"	p	class:sidestep::PreamblePatcher	access:private	signature:(unsigned char* target_function, unsigned char* stop_before, bool stop_before_trampoline = false)
sidestep::PreamblePatcher::Unpatch	src/windows/preamble_patcher.cc	/^SideStepError PreamblePatcher::Unpatch(void* target_function,$/;"	f	class:sidestep::PreamblePatcher	signature:(void* target_function, void* replacement_function, void* original_function_stub)
sidestep::PreamblePatcher::Unpatch	src/windows/preamble_patcher.h	/^  static SideStepError Unpatch(void* target_function,$/;"	p	class:sidestep::PreamblePatcher	access:public	signature:(void* target_function, void* replacement_function, void* original_function_stub)
sidestep::PreamblePatcher::granularity_	src/windows/preamble_patcher.cc	/^long PreamblePatcher::granularity_ = 0;$/;"	m	class:sidestep::PreamblePatcher	file:
sidestep::PreamblePatcher::granularity_	src/windows/preamble_patcher.h	/^  static long granularity_;$/;"	m	class:sidestep::PreamblePatcher	access:private
sidestep::PreamblePatcher::initialized_	src/windows/preamble_patcher.cc	/^bool PreamblePatcher::initialized_ = false;$/;"	m	class:sidestep::PreamblePatcher	file:
sidestep::PreamblePatcher::initialized_	src/windows/preamble_patcher.h	/^  static bool initialized_;$/;"	m	class:sidestep::PreamblePatcher	access:private
sidestep::PreamblePatcher::pagesize_	src/windows/preamble_patcher.cc	/^long PreamblePatcher::pagesize_ = 0;$/;"	m	class:sidestep::PreamblePatcher	file:
sidestep::PreamblePatcher::pagesize_	src/windows/preamble_patcher.h	/^  static long pagesize_;$/;"	m	class:sidestep::PreamblePatcher	access:private
sidestep::PreamblePatcher::preamble_pages_	src/windows/preamble_patcher.cc	/^PreamblePatcher::PreamblePage* PreamblePatcher::preamble_pages_ = NULL;$/;"	m	class:sidestep::PreamblePatcher	file:
sidestep::PreamblePatcher::preamble_pages_	src/windows/preamble_patcher.h	/^  static PreamblePage* preamble_pages_;$/;"	m	class:sidestep::PreamblePatcher	access:private
sidestep::SIDESTEP_ACCESS_DENIED	src/windows/preamble_patcher.h	/^  SIDESTEP_ACCESS_DENIED,$/;"	e	enum:sidestep::SideStepError
sidestep::SIDESTEP_FUNCTION_TOO_SMALL	src/windows/preamble_patcher.h	/^  SIDESTEP_FUNCTION_TOO_SMALL,$/;"	e	enum:sidestep::SideStepError
sidestep::SIDESTEP_INSUFFICIENT_BUFFER	src/windows/preamble_patcher.h	/^  SIDESTEP_INSUFFICIENT_BUFFER,$/;"	e	enum:sidestep::SideStepError
sidestep::SIDESTEP_INVALID_PARAMETER	src/windows/preamble_patcher.h	/^  SIDESTEP_INVALID_PARAMETER,$/;"	e	enum:sidestep::SideStepError
sidestep::SIDESTEP_JUMP_INSTRUCTION	src/windows/preamble_patcher.h	/^  SIDESTEP_JUMP_INSTRUCTION,$/;"	e	enum:sidestep::SideStepError
sidestep::SIDESTEP_NO_SUCH_FUNCTION	src/windows/preamble_patcher.h	/^  SIDESTEP_NO_SUCH_FUNCTION,$/;"	e	enum:sidestep::SideStepError
sidestep::SIDESTEP_NO_SUCH_MODULE	src/windows/preamble_patcher.h	/^  SIDESTEP_NO_SUCH_MODULE,$/;"	e	enum:sidestep::SideStepError
sidestep::SIDESTEP_SUCCESS	src/windows/preamble_patcher.h	/^  SIDESTEP_SUCCESS = 0,$/;"	e	enum:sidestep::SideStepError
sidestep::SIDESTEP_UNEXPECTED	src/windows/preamble_patcher.h	/^  SIDESTEP_UNEXPECTED,$/;"	e	enum:sidestep::SideStepError
sidestep::SIDESTEP_UNSUPPORTED_INSTRUCTION	src/windows/preamble_patcher.h	/^  SIDESTEP_UNSUPPORTED_INSTRUCTION,$/;"	e	enum:sidestep::SideStepError
sidestep::SideStepError	src/windows/preamble_patcher.h	/^enum SideStepError {$/;"	g	namespace:sidestep
sidestep::SpecificOpcode	src/windows/mini_disassembler_types.h	/^struct SpecificOpcode {$/;"	s	namespace:sidestep
sidestep::SpecificOpcode::flag_aux_	src/windows/mini_disassembler_types.h	/^  int flag_aux_;$/;"	m	struct:sidestep::SpecificOpcode	access:public
sidestep::SpecificOpcode::flag_dest_	src/windows/mini_disassembler_types.h	/^  int flag_dest_;$/;"	m	struct:sidestep::SpecificOpcode	access:public
sidestep::SpecificOpcode::flag_source_	src/windows/mini_disassembler_types.h	/^  int flag_source_;$/;"	m	struct:sidestep::SpecificOpcode	access:public
sidestep::SpecificOpcode::mnemonic_	src/windows/mini_disassembler_types.h	/^  const char* mnemonic_;$/;"	m	struct:sidestep::SpecificOpcode	access:public
sidestep::SpecificOpcode::table_index_	src/windows/mini_disassembler_types.h	/^  int table_index_;$/;"	m	struct:sidestep::SpecificOpcode	access:public
sidestep::SpecificOpcode::type_	src/windows/mini_disassembler_types.h	/^  InstructionType type_;$/;"	m	struct:sidestep::SpecificOpcode	access:public
sidestep::TestDisassembler	src/windows/preamble_patcher_test.cc	/^bool TestDisassembler() {$/;"	f	namespace:sidestep	signature:()
sidestep::TestPatchUsingDynamicStub	src/windows/preamble_patcher_test.cc	/^bool TestPatchUsingDynamicStub() {$/;"	f	namespace:sidestep	signature:()
sidestep::TestPatchWithLongJump	src/windows/preamble_patcher_test.cc	/^bool TestPatchWithLongJump() {$/;"	f	namespace:sidestep	signature:()
sidestep::TestPatchWithPreambleAbsoluteJump	src/windows/preamble_patcher_test.cc	/^bool TestPatchWithPreambleAbsoluteJump() {$/;"	f	namespace:sidestep	signature:()
sidestep::TestPatchWithPreambleNearRelativeCall	src/windows/preamble_patcher_test.cc	/^bool TestPatchWithPreambleNearRelativeCall() {$/;"	f	namespace:sidestep	signature:()
sidestep::TestPatchWithPreambleNearRelativeCondJump	src/windows/preamble_patcher_test.cc	/^bool TestPatchWithPreambleNearRelativeCondJump() {$/;"	f	namespace:sidestep	signature:()
sidestep::TestPatchWithPreambleShortCondJump	src/windows/preamble_patcher_test.cc	/^bool TestPatchWithPreambleShortCondJump() {$/;"	f	namespace:sidestep	signature:()
sidestep::TestPreambleAllocation	src/windows/preamble_patcher_test.cc	/^bool TestPreambleAllocation() {$/;"	f	namespace:sidestep	signature:()
sidestep::UnitTests	src/windows/preamble_patcher_test.cc	/^bool UnitTests() {$/;"	f	namespace:sidestep	signature:()
sidestep::kPreamblePageMagic	src/windows/preamble_patcher.cc	/^static const unsigned int kPreamblePageMagic = 0x4347414D; \/\/ "MAGC"$/;"	m	namespace:sidestep	file:
sidestep::s_first_opcode_byte	src/windows/ia32_opcode_map.cc	/^const Opcode s_first_opcode_byte[] = {$/;"	m	namespace:sidestep	file:
sidestep::s_opcode_byte_after_0f	src/windows/ia32_opcode_map.cc	/^const Opcode s_opcode_byte_after_0f[] = {$/;"	m	namespace:sidestep	file:
sidestep::s_opcode_byte_after_0f00	src/windows/ia32_opcode_map.cc	/^const Opcode s_opcode_byte_after_0f00[] = {$/;"	m	namespace:sidestep	file:
sidestep::s_opcode_byte_after_0f01	src/windows/ia32_opcode_map.cc	/^const Opcode s_opcode_byte_after_0f01[] = {$/;"	m	namespace:sidestep	file:
sidestep::s_opcode_byte_after_0f18	src/windows/ia32_opcode_map.cc	/^const Opcode s_opcode_byte_after_0f18[] = {$/;"	m	namespace:sidestep	file:
sidestep::s_opcode_byte_after_0f71	src/windows/ia32_opcode_map.cc	/^const Opcode s_opcode_byte_after_0f71[] = {$/;"	m	namespace:sidestep	file:
sidestep::s_opcode_byte_after_0f72	src/windows/ia32_opcode_map.cc	/^const Opcode s_opcode_byte_after_0f72[] = {$/;"	m	namespace:sidestep	file:
sidestep::s_opcode_byte_after_0f73	src/windows/ia32_opcode_map.cc	/^const Opcode s_opcode_byte_after_0f73[] = {$/;"	m	namespace:sidestep	file:
sidestep::s_opcode_byte_after_0fae	src/windows/ia32_opcode_map.cc	/^const Opcode s_opcode_byte_after_0fae[] = {$/;"	m	namespace:sidestep	file:
sidestep::s_opcode_byte_after_0fba	src/windows/ia32_opcode_map.cc	/^const Opcode s_opcode_byte_after_0fba[] = {$/;"	m	namespace:sidestep	file:
sidestep::s_opcode_byte_after_0fc7	src/windows/ia32_opcode_map.cc	/^const Opcode s_opcode_byte_after_0fc7[] = {$/;"	m	namespace:sidestep	file:
sidestep::s_opcode_byte_after_80	src/windows/ia32_opcode_map.cc	/^const Opcode s_opcode_byte_after_80[] = {$/;"	m	namespace:sidestep	file:
sidestep::s_opcode_byte_after_81	src/windows/ia32_opcode_map.cc	/^const Opcode s_opcode_byte_after_81[] = {$/;"	m	namespace:sidestep	file:
sidestep::s_opcode_byte_after_82	src/windows/ia32_opcode_map.cc	/^const Opcode s_opcode_byte_after_82[] = {$/;"	m	namespace:sidestep	file:
sidestep::s_opcode_byte_after_83	src/windows/ia32_opcode_map.cc	/^const Opcode s_opcode_byte_after_83[] = {$/;"	m	namespace:sidestep	file:
sidestep::s_opcode_byte_after_c0	src/windows/ia32_opcode_map.cc	/^const Opcode s_opcode_byte_after_c0[] = {$/;"	m	namespace:sidestep	file:
sidestep::s_opcode_byte_after_c1	src/windows/ia32_opcode_map.cc	/^const Opcode s_opcode_byte_after_c1[] = {$/;"	m	namespace:sidestep	file:
sidestep::s_opcode_byte_after_d0	src/windows/ia32_opcode_map.cc	/^const Opcode s_opcode_byte_after_d0[] = {$/;"	m	namespace:sidestep	file:
sidestep::s_opcode_byte_after_d1	src/windows/ia32_opcode_map.cc	/^const Opcode s_opcode_byte_after_d1[] = {$/;"	m	namespace:sidestep	file:
sidestep::s_opcode_byte_after_d2	src/windows/ia32_opcode_map.cc	/^const Opcode s_opcode_byte_after_d2[] = {$/;"	m	namespace:sidestep	file:
sidestep::s_opcode_byte_after_d3	src/windows/ia32_opcode_map.cc	/^const Opcode s_opcode_byte_after_d3[] = {$/;"	m	namespace:sidestep	file:
sidestep::s_opcode_byte_after_f6	src/windows/ia32_opcode_map.cc	/^const Opcode s_opcode_byte_after_f6[] = {$/;"	m	namespace:sidestep	file:
sidestep::s_opcode_byte_after_f7	src/windows/ia32_opcode_map.cc	/^const Opcode s_opcode_byte_after_f7[] = {$/;"	m	namespace:sidestep	file:
sidestep::s_opcode_byte_after_fe	src/windows/ia32_opcode_map.cc	/^const Opcode s_opcode_byte_after_fe[] = {$/;"	m	namespace:sidestep	file:
sidestep::s_opcode_byte_after_ff	src/windows/ia32_opcode_map.cc	/^const Opcode s_opcode_byte_after_ff[] = {$/;"	m	namespace:sidestep	file:
sig	src/base/linux_syscall_support.h	/^  unsigned long sig[(KERNEL_NSIG + 8*sizeof(unsigned long) - 1)\/$/;"	m	struct:kernel_sigset_t	access:public
sig_marker	src/base/linuxthreads.cc	/^static volatile int *sig_pids, sig_num_threads, sig_proc, sig_marker;$/;"	v	file:
sig_num_threads	src/base/linuxthreads.cc	/^static volatile int *sig_pids, sig_num_threads, sig_proc, sig_marker;$/;"	v	file:
sig_pids	src/base/linuxthreads.cc	/^static volatile int *sig_pids, sig_num_threads, sig_proc, sig_marker;$/;"	v	file:
sig_proc	src/base/linuxthreads.cc	/^static volatile int *sig_pids, sig_num_threads, sig_proc, sig_marker;$/;"	v	file:
sig_set_	src/profile-handler.cc	/^  sigset_t sig_set_;$/;"	m	class:ScopedSignalBlocker	file:	access:private
sigaction	src/base/linux_syscall_support.h	/^    LSS_INLINE int LSS_NAME(sigaction)(int signum,$/;"	f	signature:(int signum, const struct kernel_sigaction *act, struct kernel_sigaction *oldact)
sigaddset	src/base/linux_syscall_support.h	/^  LSS_INLINE int LSS_NAME(sigaddset)(struct kernel_sigset_t *set,$/;"	f	signature:(struct kernel_sigset_t *set, int signum)
sigdelset	src/base/linux_syscall_support.h	/^  LSS_INLINE int LSS_NAME(sigdelset)(struct kernel_sigset_t *set,$/;"	f	signature:(struct kernel_sigset_t *set, int signum)
sigemptyset	src/base/linux_syscall_support.h	/^  LSS_INLINE int LSS_NAME(sigemptyset)(struct kernel_sigset_t *set) {$/;"	f	signature:(struct kernel_sigset_t *set)
sigfillset	src/base/linux_syscall_support.h	/^  LSS_INLINE int LSS_NAME(sigfillset)(struct kernel_sigset_t *set) {$/;"	f	signature:(struct kernel_sigset_t *set)
signal	docs/cpuprofile.html	/^       acts as a switch, triggered by the signal, which is off by default.$/;"	v
signal_lock_	src/profile-handler.cc	/^  SpinLock signal_lock_;$/;"	m	class:ProfileHandler	file:	access:private
signal_number_	src/profile-handler.cc	/^  int signal_number_;$/;"	m	class:ProfileHandler	file:	access:private
sigprocmask	src/base/linux_syscall_support.h	/^    LSS_INLINE int LSS_NAME(sigprocmask)(int how,$/;"	f	signature:(int how, const struct kernel_sigset_t *set, struct kernel_sigset_t *oldset)
simulate_oom	src/tests/tcmalloc_unittest.cc	/^  int simulate_oom;$/;"	m	struct:OOMAbleSysAlloc	file:	access:public
size	src/base/low_level_alloc.cc	/^      intptr_t size;  \/\/ size of entire region, including this field. Must be$/;"	m	struct:low_level_alloc_internal::AllocList::Header	file:	access:public
size	src/common.h	/^  uintptr_t size;          \/\/ Size of object$/;"	m	struct:tcmalloc::StackTrace	access:public
size	src/debugallocation.cc	/^  size_t size() const {$/;"	f	class:FreeQueue	access:public	signature:() const
size	src/debugallocation.cc	/^  size_t size;$/;"	m	struct:MallocBlockQueueEntry	file:	access:public
size	src/debugallocation.cc	/^  size_t size;$/;"	m	struct:debug_alloc_retry_data	file:	access:public
size	src/debugallocation.cc	/^  size_t size;$/;"	m	struct:memalign_retry_data	file:	access:public
size	src/heap-checker.cc	/^  uintptr_t size;         \/\/ its size$/;"	m	struct:AllocObject	file:	access:public
size	src/tcmalloc.cc	/^  size_t size;$/;"	m	struct:tcmalloc::retry_memalign_data	file:	access:public
size	src/tests/addressmap_unittest.cc	/^  size_t size;$/;"	m	struct:PtrAndSize	file:	access:public
size	src/tests/heap-checker_unittest.cc	/^  size_t size;$/;"	m	struct:Array	file:	access:private
size	src/tests/tcmalloc_unittest.cc	/^    int         size;                   \/\/ Allocated size$/;"	m	struct:testing::TesterThread::Object	file:	access:public
size1_	src/debugallocation.cc	/^  size_t size1_;$/;"	m	class:MallocBlock	file:	access:private
size2_	src/debugallocation.cc	/^  size_t size2_;$/;"	m	class:MallocBlock	file:	access:private
size2_addr	src/debugallocation.cc	/^  const size_t* size2_addr() const {$/;"	f	class:MallocBlock	file:	access:private	signature:() const
size2_addr	src/debugallocation.cc	/^  size_t* size2_addr() { return (size_t*)((char*)&size2_ + size1_); }$/;"	f	class:MallocBlock	file:	access:private	signature:()
size_	src/thread_cache.h	/^    int32_t size_;$/;"	m	class:tcmalloc::ThreadCache::FreeList	access:private
size_	src/thread_cache.h	/^  int32         size_;                     \/\/ Combined size of data$/;"	m	class:tcmalloc::ThreadCache	access:private
size_class_	src/central_freelist.h	/^  size_t   size_class_;     \/\/ My size class$/;"	m	class:tcmalloc::CentralFreeList	access:private
size_class_with_alignment	src/tcmalloc.cc	/^static bool size_class_with_alignment(size_t size, size_t align, uint32_t* cl) {$/;"	f	file:	signature:(size_t size, size_t align, uint32_t* cl)
size_type	src/base/stl_allocator.h	/^  typedef size_t     size_type;$/;"	t	class:STL_Allocator	access:public
sizeclass	src/span.h	/^  unsigned int  sizeclass : 8;  \/\/ Size-class for small objects (or 0)$/;"	m	struct:tcmalloc::Span	access:public
sized_delete_enabled	src/libc_override_gcc_and_weak.h	/^static bool sized_delete_enabled(void) {$/;"	f	signature:(void)
sizemap	src/static_vars.h	/^  static SizeMap* sizemap() { return &sizemap_; }$/;"	f	class:tcmalloc::Static	access:public	signature:()
sizemap_	src/static_vars.cc	/^SizeMap Static::sizemap_;$/;"	m	class:tcmalloc::Static	file:
sizemap_	src/static_vars.h	/^  ATTRIBUTE_HIDDEN static SizeMap sizemap_;$/;"	m	class:tcmalloc::Static	access:private
sizeof	src/base/atomicops-internals-windows.h	/^COMPILE_ASSERT(sizeof(Atomic64) == sizeof(PVOID), atomic_word_is_atomic);$/;"	m	namespace:base::subtle
sizeof	src/malloc_hook-inl.h	/^  COMPILE_ASSERT(sizeof(T) <= sizeof(AtomicWord), T_should_fit_in_AtomicWord);$/;"	p	struct:base::internal::HookList	access:public	signature:(T)
skip	src/stacktrace_libgcc-inl.h	/^  int skip;$/;"	m	struct:libgcc_backtrace_data	access:public
sleep	src/windows/port.h	/^inline unsigned int sleep(unsigned int seconds) {$/;"	f	signature:(unsigned int seconds)
slots	docs/cpuprofile-fileformat.html	/^<p>The contents are shown in terms of slots, and in terms of 4-byte$/;"	v
slow_memchr	src/base/sysinfo.cc	/^static const char *slow_memchr(const char *s, int c, size_t n) {$/;"	f	file:	signature:(const char *s, int c, size_t n)
slow_memcmp	src/base/sysinfo.cc	/^static int slow_memcmp(const void *_a, const void *_b, size_t n) {$/;"	f	file:	signature:(const void *_a, const void *_b, size_t n)
slow_strlen	src/base/sysinfo.cc	/^static size_t slow_strlen(const char *s) {$/;"	f	file:	signature:(const char *s)
small	src/tcmalloc.cc	143;"	d	file:
snapshot_	src/base/sysinfo.h	/^  HANDLE snapshot_;   \/\/ filehandle on dll info$/;"	m	class:ProcMapsIterator	access:private
snprintf	src/windows/port.h	/^inline int snprintf(char *str, size_t size, const char *format, ...) {$/;"	f	signature:(char *str, size_t size, const char *format, ...)
snum	src/internal_logging.h	/^    int64_t snum;$/;"	m	union:tcmalloc::LogItem::__anon9	access:public
socket	src/base/linux_syscall_support.h	/^    LSS_INLINE int LSS_NAME(socket)(int domain, int type, int protocol) {$/;"	f	signature:(int domain, int type, int protocol)
some_ints	src/tests/heap-checker_unittest.cc	/^static int some_ints[] = { 1, 2, 3, 21, 22, 23, 24, 25 };$/;"	v	file:
someplace	README_windows.txt	/^build the dll and install it someplace, so you can link it into$/;"	v
soname	m4/libtool.m4	/^        soname=conftest$/;"	v
soname_spec	m4/libtool.m4	/^      soname_spec='${libname}`echo ${release} | $SED -e 's\/[[.]]\/-\/g'`${versuffix}${shared_ext}'$/;"	v
space_left	src/raw_printer.h	/^  int space_left() const { return (limit_ - ptr_); }$/;"	f	class:base::RawPrinter	access:public	signature:() const
span_allocator	src/static_vars.h	/^  static PageHeapAllocator<Span>* span_allocator() { return &span_allocator_; }$/;"	f	class:tcmalloc::Static	access:public	signature:()
span_allocator_	src/static_vars.cc	/^PageHeapAllocator<Span> Static::span_allocator_;$/;"	m	class:tcmalloc::Static	file:
span_allocator_	src/static_vars.h	/^  ATTRIBUTE_HIDDEN static PageHeapAllocator<Span> span_allocator_;$/;"	m	class:tcmalloc::Static	access:private
spans	src/page_heap.h	/^    int64 spans;           \/\/ Number of such spans$/;"	m	struct:tcmalloc::PageHeap::LargeSpanStats	access:public
spinlock	src/system-alloc.cc	/^static SpinLock spinlock(SpinLock::LINKER_INITIALIZED);$/;"	p	file:	signature:(SpinLock::LINKER_INITIALIZED)
spinlock	src/windows/system-alloc.cc	/^static SpinLock spinlock(SpinLock::LINKER_INITIALIZED);$/;"	p	file:	signature:(SpinLock::LINKER_INITIALIZED)
srandom	src/windows/port.h	/^inline void srandom(unsigned int seed) { srand(seed); }$/;"	f	signature:(unsigned int seed)
ss	src/base/elfcore.h	/^    uint64_t  rsp,ss;$/;"	m	struct:i386_regs	access:public
ssize_t	src/windows/port.h	/^typedef intptr_t ssize_t;$/;"	t
st_atim	src/base/linux_syscall_support.h	/^  kernel_timespec    st_atim;$/;"	m	struct:kernel_stat	access:public
st_atim	src/base/linux_syscall_support.h	/^  kernel_timespec    st_atim;$/;"	m	struct:kernel_stat64	access:public
st_atime_	src/base/linux_syscall_support.h	/^  long               st_atime_;$/;"	m	struct:kernel_stat	access:public
st_atime_	src/base/linux_syscall_support.h	/^  uint64_t           st_atime_;$/;"	m	struct:kernel_stat	access:public
st_atime_	src/base/linux_syscall_support.h	/^  unsigned           st_atime_;$/;"	m	struct:kernel_stat	access:public
st_atime_	src/base/linux_syscall_support.h	/^  unsigned           st_atime_;$/;"	m	struct:kernel_stat64	access:public
st_atime_	src/base/linux_syscall_support.h	/^  unsigned long      st_atime_;$/;"	m	struct:kernel_stat	access:public
st_atime_nsec_	src/base/linux_syscall_support.h	/^  long               st_atime_nsec_;$/;"	m	struct:kernel_stat	access:public
st_atime_nsec_	src/base/linux_syscall_support.h	/^  uint64_t           st_atime_nsec_;$/;"	m	struct:kernel_stat	access:public
st_atime_nsec_	src/base/linux_syscall_support.h	/^  unsigned           st_atime_nsec_;$/;"	m	struct:kernel_stat	access:public
st_atime_nsec_	src/base/linux_syscall_support.h	/^  unsigned           st_atime_nsec_;$/;"	m	struct:kernel_stat64	access:public
st_atime_nsec_	src/base/linux_syscall_support.h	/^  unsigned long      st_atime_nsec_;$/;"	m	struct:kernel_stat	access:public
st_blksize	src/base/linux_syscall_support.h	/^  int                st_blksize;$/;"	m	struct:kernel_stat	access:public
st_blksize	src/base/linux_syscall_support.h	/^  int64_t            st_blksize;$/;"	m	struct:kernel_stat	access:public
st_blksize	src/base/linux_syscall_support.h	/^  long long          st_blksize;$/;"	m	struct:kernel_stat64	access:public
st_blksize	src/base/linux_syscall_support.h	/^  unsigned           st_blksize;$/;"	m	struct:kernel_stat	access:public
st_blksize	src/base/linux_syscall_support.h	/^  unsigned           st_blksize;$/;"	m	struct:kernel_stat64	access:public
st_blksize	src/base/linux_syscall_support.h	/^  unsigned long      st_blksize;$/;"	m	struct:kernel_stat	access:public
st_blocks	src/base/linux_syscall_support.h	/^  int                st_blocks;$/;"	m	struct:kernel_stat	access:public
st_blocks	src/base/linux_syscall_support.h	/^  int64_t            st_blocks;$/;"	m	struct:kernel_stat	access:public
st_blocks	src/base/linux_syscall_support.h	/^  long               st_blocks;$/;"	m	struct:kernel_stat	access:public
st_blocks	src/base/linux_syscall_support.h	/^  long long          st_blocks;$/;"	m	struct:kernel_stat64	access:public
st_blocks	src/base/linux_syscall_support.h	/^  unsigned           st_blocks;$/;"	m	struct:kernel_stat	access:public
st_blocks	src/base/linux_syscall_support.h	/^  unsigned long      st_blocks;$/;"	m	struct:kernel_stat	access:public
st_blocks	src/base/linux_syscall_support.h	/^  unsigned long long st_blocks;$/;"	m	struct:kernel_stat	access:public
st_blocks	src/base/linux_syscall_support.h	/^  unsigned long long st_blocks;$/;"	m	struct:kernel_stat64	access:public
st_ctim	src/base/linux_syscall_support.h	/^  kernel_timespec    st_ctim;$/;"	m	struct:kernel_stat	access:public
st_ctim	src/base/linux_syscall_support.h	/^  kernel_timespec    st_ctim;$/;"	m	struct:kernel_stat64	access:public
st_ctime_	src/base/linux_syscall_support.h	/^  long               st_ctime_;$/;"	m	struct:kernel_stat	access:public
st_ctime_	src/base/linux_syscall_support.h	/^  uint64_t           st_ctime_;$/;"	m	struct:kernel_stat	access:public
st_ctime_	src/base/linux_syscall_support.h	/^  unsigned           st_ctime_;$/;"	m	struct:kernel_stat	access:public
st_ctime_	src/base/linux_syscall_support.h	/^  unsigned           st_ctime_;$/;"	m	struct:kernel_stat64	access:public
st_ctime_	src/base/linux_syscall_support.h	/^  unsigned long      st_ctime_;$/;"	m	struct:kernel_stat	access:public
st_ctime_nsec_	src/base/linux_syscall_support.h	/^  long               st_ctime_nsec_;$/;"	m	struct:kernel_stat	access:public
st_ctime_nsec_	src/base/linux_syscall_support.h	/^  uint64_t           st_ctime_nsec_;$/;"	m	struct:kernel_stat	access:public
st_ctime_nsec_	src/base/linux_syscall_support.h	/^  unsigned           st_ctime_nsec_;$/;"	m	struct:kernel_stat	access:public
st_ctime_nsec_	src/base/linux_syscall_support.h	/^  unsigned           st_ctime_nsec_;$/;"	m	struct:kernel_stat64	access:public
st_ctime_nsec_	src/base/linux_syscall_support.h	/^  unsigned long      st_ctime_nsec_;$/;"	m	struct:kernel_stat	access:public
st_dev	src/base/linux_syscall_support.h	/^  uint64_t           st_dev;$/;"	m	struct:kernel_stat	access:public
st_dev	src/base/linux_syscall_support.h	/^  unsigned           st_dev;$/;"	m	struct:kernel_stat	access:public
st_dev	src/base/linux_syscall_support.h	/^  unsigned long      st_dev;$/;"	m	struct:kernel_stat	access:public
st_dev	src/base/linux_syscall_support.h	/^  unsigned long long st_dev;$/;"	m	struct:kernel_stat	access:public
st_dev	src/base/linux_syscall_support.h	/^  unsigned long long st_dev;$/;"	m	struct:kernel_stat64	access:public
st_dev	src/base/linux_syscall_support.h	/^  unsigned short     st_dev;$/;"	m	struct:kernel_stat	access:public
st_gid	src/base/linux_syscall_support.h	/^  unsigned           st_gid;$/;"	m	struct:kernel_stat	access:public
st_gid	src/base/linux_syscall_support.h	/^  unsigned           st_gid;$/;"	m	struct:kernel_stat64	access:public
st_gid	src/base/linux_syscall_support.h	/^  unsigned int       st_gid;$/;"	m	struct:kernel_stat	access:public
st_gid	src/base/linux_syscall_support.h	/^  unsigned short     st_gid;$/;"	m	struct:kernel_stat	access:public
st_ino	src/base/linux_syscall_support.h	/^  uint64_t           st_ino;$/;"	m	struct:kernel_stat	access:public
st_ino	src/base/linux_syscall_support.h	/^  unsigned           st_ino;$/;"	m	struct:kernel_stat	access:public
st_ino	src/base/linux_syscall_support.h	/^  unsigned long      st_ino;$/;"	m	struct:kernel_stat	access:public
st_ino	src/base/linux_syscall_support.h	/^  unsigned long long st_ino;$/;"	m	struct:kernel_stat	access:public
st_ino	src/base/linux_syscall_support.h	/^  unsigned long long st_ino;$/;"	m	struct:kernel_stat64	access:public
st_mode	src/base/linux_syscall_support.h	/^  unsigned           st_mode;$/;"	m	struct:kernel_stat	access:public
st_mode	src/base/linux_syscall_support.h	/^  unsigned           st_mode;$/;"	m	struct:kernel_stat64	access:public
st_mode	src/base/linux_syscall_support.h	/^  unsigned int       st_mode;$/;"	m	struct:kernel_stat	access:public
st_mode	src/base/linux_syscall_support.h	/^  unsigned long      st_mode;$/;"	m	struct:kernel_stat	access:public
st_mode	src/base/linux_syscall_support.h	/^  unsigned short     st_mode;$/;"	m	struct:kernel_stat	access:public
st_mtim	src/base/linux_syscall_support.h	/^  kernel_timespec    st_mtim;$/;"	m	struct:kernel_stat	access:public
st_mtim	src/base/linux_syscall_support.h	/^  kernel_timespec    st_mtim;$/;"	m	struct:kernel_stat64	access:public
st_mtime_	src/base/linux_syscall_support.h	/^  long               st_mtime_;$/;"	m	struct:kernel_stat	access:public
st_mtime_	src/base/linux_syscall_support.h	/^  uint64_t           st_mtime_;$/;"	m	struct:kernel_stat	access:public
st_mtime_	src/base/linux_syscall_support.h	/^  unsigned           st_mtime_;$/;"	m	struct:kernel_stat	access:public
st_mtime_	src/base/linux_syscall_support.h	/^  unsigned           st_mtime_;$/;"	m	struct:kernel_stat64	access:public
st_mtime_	src/base/linux_syscall_support.h	/^  unsigned long      st_mtime_;$/;"	m	struct:kernel_stat	access:public
st_mtime_nsec_	src/base/linux_syscall_support.h	/^  long               st_mtime_nsec_;$/;"	m	struct:kernel_stat	access:public
st_mtime_nsec_	src/base/linux_syscall_support.h	/^  uint64_t           st_mtime_nsec_;$/;"	m	struct:kernel_stat	access:public
st_mtime_nsec_	src/base/linux_syscall_support.h	/^  unsigned           st_mtime_nsec_;$/;"	m	struct:kernel_stat	access:public
st_mtime_nsec_	src/base/linux_syscall_support.h	/^  unsigned           st_mtime_nsec_;$/;"	m	struct:kernel_stat64	access:public
st_mtime_nsec_	src/base/linux_syscall_support.h	/^  unsigned long      st_mtime_nsec_;$/;"	m	struct:kernel_stat	access:public
st_nlink	src/base/linux_syscall_support.h	/^  uint64_t           st_nlink;$/;"	m	struct:kernel_stat	access:public
st_nlink	src/base/linux_syscall_support.h	/^  unsigned           st_nlink;$/;"	m	struct:kernel_stat	access:public
st_nlink	src/base/linux_syscall_support.h	/^  unsigned           st_nlink;$/;"	m	struct:kernel_stat64	access:public
st_nlink	src/base/linux_syscall_support.h	/^  unsigned int       st_nlink;$/;"	m	struct:kernel_stat	access:public
st_nlink	src/base/linux_syscall_support.h	/^  unsigned long      st_nlink;$/;"	m	struct:kernel_stat	access:public
st_nlink	src/base/linux_syscall_support.h	/^  unsigned short     st_nlink;$/;"	m	struct:kernel_stat	access:public
st_pad1	src/base/linux_syscall_support.h	/^  int                st_pad1[3];$/;"	m	struct:kernel_stat	access:public
st_pad2	src/base/linux_syscall_support.h	/^  int                st_pad2[2];$/;"	m	struct:kernel_stat	access:public
st_pad3	src/base/linux_syscall_support.h	/^  int                st_pad3;$/;"	m	struct:kernel_stat	access:public
st_pad4	src/base/linux_syscall_support.h	/^  int                st_pad4[14];$/;"	m	struct:kernel_stat	access:public
st_rdev	src/base/linux_syscall_support.h	/^  uint64_t           st_rdev;$/;"	m	struct:kernel_stat	access:public
st_rdev	src/base/linux_syscall_support.h	/^  unsigned           st_rdev;$/;"	m	struct:kernel_stat	access:public
st_rdev	src/base/linux_syscall_support.h	/^  unsigned long      st_rdev;$/;"	m	struct:kernel_stat	access:public
st_rdev	src/base/linux_syscall_support.h	/^  unsigned long long st_rdev;$/;"	m	struct:kernel_stat	access:public
st_rdev	src/base/linux_syscall_support.h	/^  unsigned long long st_rdev;$/;"	m	struct:kernel_stat64	access:public
st_rdev	src/base/linux_syscall_support.h	/^  unsigned short     st_rdev;$/;"	m	struct:kernel_stat	access:public
st_size	src/base/linux_syscall_support.h	/^  int64_t            st_size;$/;"	m	struct:kernel_stat	access:public
st_size	src/base/linux_syscall_support.h	/^  long               st_size;$/;"	m	struct:kernel_stat	access:public
st_size	src/base/linux_syscall_support.h	/^  long long          st_size;$/;"	m	struct:kernel_stat	access:public
st_size	src/base/linux_syscall_support.h	/^  long long          st_size;$/;"	m	struct:kernel_stat64	access:public
st_size	src/base/linux_syscall_support.h	/^  unsigned           st_size;$/;"	m	struct:kernel_stat	access:public
st_size	src/base/linux_syscall_support.h	/^  unsigned long      st_size;$/;"	m	struct:kernel_stat	access:public
st_uid	src/base/linux_syscall_support.h	/^  unsigned           st_uid;$/;"	m	struct:kernel_stat	access:public
st_uid	src/base/linux_syscall_support.h	/^  unsigned           st_uid;$/;"	m	struct:kernel_stat64	access:public
st_uid	src/base/linux_syscall_support.h	/^  unsigned int       st_uid;$/;"	m	struct:kernel_stat	access:public
st_uid	src/base/linux_syscall_support.h	/^  unsigned short     st_uid;$/;"	m	struct:kernel_stat	access:public
stack	src/common.h	/^  void*     stack[kMaxStackDepth];$/;"	m	struct:tcmalloc::StackTrace	access:public
stack	src/heap-profile-stats.h	/^  const void** stack;       \/\/ Stack trace.$/;"	m	struct:HeapProfileBucket	access:public
stack	src/profiledata.h	/^    Slot stack[kMaxStackDepth];  \/\/ Stack contents$/;"	m	struct:ProfileData::Entry	access:public
stackTraces	src/pprof	/^my @stackTraces;$/;"	v
stack_depth	src/heap-profile-table.h	/^    int stack_depth;                \/\/ Depth of stack trace$/;"	m	struct:HeapProfileTable::AllocContextInfo	access:public
stack_depth	src/heap-profile-table.h	/^    int stack_depth;  \/\/ depth of call_stack$/;"	m	struct:HeapProfileTable::AllocInfo	access:public
stack_depth	src/stacktrace_instrument-inl.h	/^  int   stack_depth;$/;"	m	struct:__anon30	access:public
stack_direction	src/heap-checker.cc	/^static StackDirection stack_direction = UNKNOWN_DIRECTION;$/;"	v	file:
stack_tops	src/heap-checker.cc	/^static StackTopSet* stack_tops = NULL;$/;"	v	file:
stacktrace_allocator	src/static_vars.h	/^  static PageHeapAllocator<StackTrace>* stacktrace_allocator() {$/;"	f	class:tcmalloc::Static	access:public	signature:()
stacktrace_allocator_	src/static_vars.cc	/^PageHeapAllocator<StackTrace> Static::stacktrace_allocator_;$/;"	m	class:tcmalloc::Static	file:
stacktrace_allocator_	src/static_vars.h	/^  ATTRIBUTE_HIDDEN static PageHeapAllocator<StackTrace> stacktrace_allocator_;$/;"	m	class:tcmalloc::Static	access:private
stacktrace_allowed	src/stacktrace.cc	/^    bool stacktrace_allowed;$/;"	m	class:__anon20::StacktraceScope	file:	access:private
stacktrace_h	src/tests/simple_compat_test.cc	/^int (*stacktrace_h)(void**, int, int) = &GetStackTrace;$/;"	v
start	src/span.h	/^  PageID        start;          \/\/ Starting page number$/;"	m	struct:tcmalloc::Span	access:public
start	src/tests/stacktrace_unittest.cc	/^  const void *start, *end;$/;"	m	struct:__anon52::AddressRange	file:	access:public
start_addr	src/memory_region_map.h	/^    uintptr_t start_addr;  \/\/ region start address$/;"	m	struct:MemoryRegionMap::Region	access:public
start_address	src/heap-checker.cc	/^  uintptr_t start_address;  \/\/ the start of the range$/;"	m	struct:HeapLeakChecker::RangeValue	file:	access:public
start_snapshot_	src/gperftools/heap-checker.h	/^  void* start_snapshot_;$/;"	m	class:HeapLeakChecker	access:private
start_time	src/gperftools/profiler.h	/^  time_t start_time;          \/* If enabled, when was profiling started? *\/$/;"	m	struct:ProfilerState	access:public
start_time	src/profiledata.h	/^    time_t   start_time;          \/\/ If enabled, when was profiling started?$/;"	m	struct:ProfileData::State	access:public
start_time_	src/profiledata.h	/^  time_t        start_time_;    \/\/ Start time, or 0$/;"	m	class:ProfileData	access:private
stat	depcomp	/^  stat=$?$/;"	v
stat	src/base/linux_syscall_support.h	/^    LSS_INLINE int LSS_NAME(stat)(const char* p, struct kernel_stat* b) {$/;"	f	signature:(const char* p, struct kernel_stat* b)
static_fn	src/windows/patch_functions.cc	/^  static GenericFnPtr static_fn(int ifunction) {$/;"	f	class:__anon13::LibcInfo	access:public	signature:(int ifunction)
static_fn_	src/windows/patch_functions.cc	/^  static const GenericFnPtr static_fn_[kNumFunctions];$/;"	m	class:__anon13::LibcInfo	file:	access:protected
static_fn_	src/windows/patch_functions.cc	/^const GenericFnPtr LibcInfo::static_fn_[] = {$/;"	m	class:__anon13::LibcInfo	file:
stats	src/page_heap.h	/^  inline Stats stats() const { return stats_; }$/;"	f	class:tcmalloc::PageHeap	access:public	signature:() const
stats_	src/page_heap.h	/^  Stats stats_;$/;"	m	class:tcmalloc::PageHeap	access:private
stats_blocks_	src/debugallocation.cc	/^  static int stats_blocks_;$/;"	m	class:MallocBlock	file:	access:private
stats_blocks_	src/debugallocation.cc	/^int MallocBlock::stats_blocks_;$/;"	m	class:MallocBlock	file:
stats_buffer	src/internal_logging.cc	/^static char stats_buffer[kStatsBufferSize] = { 0 };$/;"	v	file:
stats_histogram_	src/debugallocation.cc	/^  static int* stats_histogram_;$/;"	m	class:MallocBlock	file:	access:private
stats_histogram_	src/debugallocation.cc	/^int* MallocBlock::stats_histogram_;$/;"	m	class:MallocBlock	file:
stats_total_	src/debugallocation.cc	/^  static size_t stats_total_;$/;"	m	class:MallocBlock	file:	access:private
stats_total_	src/debugallocation.cc	/^size_t MallocBlock::stats_total_;$/;"	m	class:MallocBlock	file:
stext_	src/base/sysinfo.h	/^  char *stext_;       \/\/ start of text$/;"	m	class:ProcMapsIterator	access:private
stop_work	src/tests/profile-handler_unittest.cc	/^  bool stop_work() {$/;"	f	class:__anon56::BusyThread	access:public	signature:()
stop_work_	src/tests/profile-handler_unittest.cc	/^  bool stop_work_;$/;"	m	class:__anon56::BusyThread	file:	access:private
str	src/internal_logging.h	/^    const char* str;$/;"	m	union:tcmalloc::LogItem::__anon9	access:public
strict	README	/^Other values for HEAPCHECK: normal (equivalent to "1"), strict, draconian$/;"	v
strict	src/pprof	/^use strict;$/;"	v
string	docs/tcmalloc.html	/^   MallocExtension::instance()->GetHeapGrowthStacks(&string);$/;"	m	class:object::structure	file:	access:private
string	docs/tcmalloc.html	/^   MallocExtension::instance()->GetHeapSample(&string);$/;"	m	class:object::structure	file:	access:private
strsize_	src/base/elf_mem_image.h	/^  size_t strsize_;$/;"	m	class:base::ElfMemImage	access:private
strtoll	src/windows/port.h	/^inline long long int strtoll(const char *nptr, char **endptr, int base) {$/;"	f	signature:(const char *nptr, char **endptr, int base)
strtoq	src/windows/port.h	/^inline long long int strtoq(const char *nptr, char **endptr, int base) {$/;"	f	signature:(const char *nptr, char **endptr, int base)
strtoull	src/windows/port.h	/^inline unsigned long long int strtoull(const char *nptr, char **endptr,$/;"	f	signature:(const char *nptr, char **endptr, int base)
strtouq	src/windows/port.h	/^inline unsigned long long int strtouq(const char *nptr, char **endptr,$/;"	f	signature:(const char *nptr, char **endptr, int base)
structure	docs/tcmalloc.html	/^structure: a set of spans, and a linked list of free objects per$/;"	c	class:object	file:	inherits:asetofspans,andalinkedlistoffreeobjectsperspan,Anobjectisallocatedfromacentralfreelistbyremovingthefirstentryfromthelinkedlistofsomespan,Ifallspanshaveemptylinkedlists,asuitablysizedspanisfirstallocatedfromthecentralpageheap,Anobjectisreturnedtoacentralfreelistbyaddingittothelinkedlistofitscontainingspan,Ifthelinkedlistlengthnowequalsthetotalnumberofsmallobjectsinthespan,spanisnowcompletelyfreeandisreturnedtothepageheap,GarbageCollectionofThreadCachesGarbagecollectingobjectsfromathreadcachekeepsthesizeofthecacheundercontrolandreturnsunusedobjectstothecentralfreelists,Somethreadsneedlargecachestoperformwell,otherscangetbywithlittleornocacheatall,Whenathreadcachegoesoveritsmax_size,garbagecollectionkicksinandthenthethreadcompeteswiththeotherthreads,alargercache,Garbagecollectionisrunonlyduringadeallocation,Wewalkoverallfreelistsinthecacheandmovesomenumberofobjectsfromthefreelisttothecorrespondingcentrallist,Thenumberofobjectstobemovedfromafreelistisdetermined,aper,listlow,water,markL,Lrecordstheminimumlengthofthelistsincethelastgarbagecollection,NotethatwecouldhaveshortenedthelistbyLobjectsatthelastgarbagecollectionwithoutrequiringanyextraaccessestothecentrallist,Weuse,pasthistoryasapredictoroffutureaccessesandmoveL,objectsfromthethreadcachefreelisttothecorrespondingcentralfreelist,Thisalgorithmhasthenicepropertythat,athreadstops,aparticularsize,allobjectsofthatsizewillquicklymovefromthethreadcachetothecentralfreelistwheretheycanbeusedbyotherthreads,Ifathreadconsistentlydeallocatesmoreobjectsofacertainsizethanitallocates,L,behaviorwillcauseatleastL,objectstoalwayssitinthefreelist,Toavoidwastingmemory,way,weshrinkthemaximumlengthofthefreelisttoconvergeonnum_objects_to_move,seealsoSizingThreadCacheFreeLists,GarbageCollection,L,max_length,num_objects_to_move	access:private
subtle	src/base/atomicops-internals-arm-generic.h	/^namespace subtle {$/;"	n	namespace:base
subtle	src/base/atomicops-internals-arm-v6plus.h	/^namespace subtle {$/;"	n	namespace:base
subtle	src/base/atomicops-internals-gcc.h	/^namespace subtle {$/;"	n	namespace:base
subtle	src/base/atomicops-internals-linuxppc.h	/^namespace subtle {$/;"	n	namespace:base
subtle	src/base/atomicops-internals-macosx.h	/^namespace subtle {$/;"	n	namespace:base
subtle	src/base/atomicops-internals-mips.h	/^namespace subtle {$/;"	n	namespace:base
subtle	src/base/atomicops-internals-windows.h	/^namespace subtle {$/;"	n	namespace:base
subtle	src/base/atomicops-internals-x86.h	/^namespace subtle {$/;"	n	namespace:base
subtle	src/base/atomicops.h	/^namespace subtle {$/;"	n	namespace:base
sym_cmp	src/windows/nm-pdb.c	/^static int sym_cmp(const void *_s1, const void *_s2) {$/;"	f	file:	signature:(const void *_s1, const void *_s2)
symbol	src/base/elf_mem_image.h	/^    const ElfW(Sym) *symbol;    \/\/ Symbol in the dynamic symbol table.$/;"	m	struct:base::ElfMemImage::SymbolInfo	access:public
symbol_buffer_	src/symbolize.h	/^  char *symbol_buffer_;$/;"	m	class:SymbolTable	access:private
symbolization_table_	src/symbolize.h	/^  SymbolMap symbolization_table_;$/;"	m	class:SymbolTable	access:private
symcode	m4/libtool.m4	/^    symcode='[[ABCDEGRST]]'$/;"	v
symcode	m4/libtool.m4	/^  symcode='[[ABDT]]'$/;"	v
symcode	m4/libtool.m4	/^  symcode='[[BCDEGQRST]]'$/;"	v
symcode	m4/libtool.m4	/^  symcode='[[BCDEGRST]]'$/;"	v
symcode	m4/libtool.m4	/^  symcode='[[BDRT]]'$/;"	v
symcode	m4/libtool.m4	/^  symcode='[[DFNSTU]]'$/;"	v
syms	src/windows/nm-pdb.c	/^  SYM *syms;$/;"	m	struct:__anon11	file:	access:public
syms_cap	src/windows/nm-pdb.c	/^  DWORD syms_cap;$/;"	m	struct:__anon11	file:	access:public
syms_len	src/windows/nm-pdb.c	/^  DWORD syms_len;$/;"	m	struct:__anon11	file:	access:public
sync_signals	src/base/linuxthreads.cc	/^static const int sync_signals[]  = { SIGABRT, SIGILL, SIGFPE, SIGSEGV, SIGBUS,$/;"	v	file:
sys0_sigprocmask	src/base/linuxthreads.cc	609;"	d	file:
sys0_waitpid	src/base/linuxthreads.cc	610;"	d	file:
sys_lib_dlsearch_path_spec	m4/libtool.m4	/^  sys_lib_dlsearch_path_spec="$lt_cv_sys_lib_dlsearch_path_spec"$/;"	v
sys_lib_dlsearch_path_spec	m4/libtool.m4	/^  sys_lib_dlsearch_path_spec='\/usr\/lib'$/;"	v
sys_lib_search_path_spec	m4/libtool.m4	/^        sys_lib_search_path_spec=`$ECHO "$sys_lib_search_path_spec" | $SED -e 's\/;\/ \/g'`$/;"	v
sys_lib_search_path_spec	m4/libtool.m4	/^      sys_lib_search_path_spec="\/usr\/lib\/hpux32 \/usr\/local\/lib\/hpux32 \/usr\/local\/lib"$/;"	v
sys_lib_search_path_spec	m4/libtool.m4	/^    sys_lib_search_path_spec='\/usr\/local\/lib \/usr\/gnu\/lib \/usr\/ccs\/lib \/usr\/lib \/lib'$/;"	v
sys_lib_search_path_spec	m4/libtool.m4	/^  sys_lib_search_path_spec="$lt_cv_sys_lib_search_path_spec"$/;"	v
sys_ptrace	src/heap-checker.cc	1045;"	d	file:
system_alloc_inited	src/system-alloc.cc	/^static bool system_alloc_inited = false;$/;"	v	file:
system_alloc_inited	src/windows/system-alloc.cc	/^static bool system_alloc_inited = false;$/;"	v	file:
system_bytes	src/page_heap.h	/^    uint64_t system_bytes;    \/\/ Total bytes allocated from system$/;"	m	struct:tcmalloc::PageHeap::Stats	access:public
t	src/.libs/libtcmalloc_internal_la-internal_logging.o	/^/;"	v
t	src/.libs/libtcmalloc_internal_la-raw_printer.o	/^ü/;"	v
t	src/.libs/libtcmalloc_minimal_internal_la-internal_logging.o	/^/;"	v
t	src/libtcmalloc_internal_la-raw_printer.o	/^ü/;"	v
t	src/tcm_min_asserts_unittest-symbolize.o	/^/;"	v
t	src/tests/tcmalloc_debug_unittest-tcmalloc_unittest.o	/^/;"	v
t	src/tests/tcmalloc_minimal_debug_unittest-tcmalloc_unittest.o	/^/;"	v
table_	src/stack_trace_table.h	/^  Bucket** table_;$/;"	m	class:tcmalloc::StackTraceTable	access:private
table_	src/windows/mini_disassembler_types.h	/^  const Opcode* table_;$/;"	m	struct:sidestep::OpcodeTable	access:public
table_index_	src/windows/mini_disassembler_types.h	/^  int table_index_;$/;"	m	struct:sidestep::Opcode	access:public
table_index_	src/windows/mini_disassembler_types.h	/^  int table_index_;$/;"	m	struct:sidestep::SpecificOpcode	access:public
table_offset	src/base/elf_mem_image.cc	/^                         ElfW(Off) table_offset,$/;"	m	namespace:base::__anon50	file:
tag_	src/internal_logging.h	/^  Tag tag_;$/;"	m	class:tcmalloc::LogItem	access:private
tail	src/central_freelist.h	/^    void *tail;  \/\/ Tail of chain of objects.$/;"	m	struct:tcmalloc::CentralFreeList::TCEntry	access:public
target_function_	src/windows/auto_testing_hook.h	/^  T target_function_;  \/\/ always valid$/;"	m	class:sidestep::AutoTestingHookImpl	access:private
task	docs/heapprofile.html	/^allocations.  However, for that task, it's easier to use the <A$/;"	v
tc_calloc	src/libc_override_glibc.h	/^  void* __libc_calloc(size_t n, size_t size)      ALIAS(tc_calloc);$/;"	v
tc_cfree	src/libc_override_glibc.h	/^  void __libc_cfree(void* ptr)                    ALIAS(tc_cfree);$/;"	v
tc_free	src/libc_override_glibc.h	/^  void __libc_free(void* ptr)                     ALIAS(tc_free);$/;"	v
tc_free_sized	benchmark/malloc_bench.cc	/^extern "C" void tc_free_sized(void *ptr, size_t size) __attribute__((weak));$/;"	p	file:	signature:(void *ptr, size_t size)
tc_get_sysalloc_default	src/windows/system-alloc.cc	/^extern "C" SysAllocator* tc_get_sysalloc_default(SysAllocator *def)$/;"	f	signature:(SysAllocator *def)
tc_get_sysalloc_override	src/system-alloc.cc	/^SysAllocator *tc_get_sysalloc_override(SysAllocator *def)$/;"	f	signature:(SysAllocator *def)
tc_get_sysalloc_override	src/windows/system-alloc.cc	/^SysAllocator* tc_get_sysalloc_override(SysAllocator *def)$/;"	f	signature:(SysAllocator *def)
tc_length	src/central_freelist.cc	/^int CentralFreeList::tc_length() {$/;"	f	class:tcmalloc::CentralFreeList	signature:()
tc_length	src/central_freelist.h	/^  int tc_length();$/;"	p	class:tcmalloc::CentralFreeList	access:public	signature:()
tc_malloc	src/libc_override_glibc.h	/^  void* __libc_malloc(size_t size)                ALIAS(tc_malloc);$/;"	v
tc_memalign	benchmark/malloc_bench.cc	/^extern "C" void *tc_memalign(size_t align, size_t size) __attribute__((weak));$/;"	p	file:	signature:(size_t align, size_t size)
tc_memalign	src/libc_override_glibc.h	/^  void* __libc_memalign(size_t align, size_t s)   ALIAS(tc_memalign);$/;"	v
tc_nallocx	src/gperftools/nallocx.h	/^PERFTOOLS_DLL_DECL size_t tc_nallocx(size_t size, int flags);$/;"	p	signature:(size_t size, int flags)
tc_nallocx	src/tcmalloc.cc	/^  TC_ALIAS(tc_nallocx);$/;"	v
tc_nallocx	src/tcmalloc.cc	/^size_t tc_nallocx(size_t size, int flags) {$/;"	f	signature:(size_t size, int flags)
tc_new	src/debugallocation.cc	/^extern "C" PERFTOOLS_DLL_DECL void* tc_new(size_t size) {$/;"	f	signature:(size_t size)
tc_new	src/gperftools/tcmalloc.h	/^  PERFTOOLS_DLL_DECL void* tc_new(size_t size);$/;"	p	signature:(size_t size)
tc_new	src/gperftools/tcmalloc.h.in	/^  PERFTOOLS_DLL_DECL void* tc_new(size_t size);$/;"	p	file:	signature:(size_t size)
tc_new	src/tcmalloc.cc	/^TC_ALIAS(tc_new);$/;"	v
tc_new	src/tcmalloc.cc	/^void* tc_new(size_t size) {$/;"	f	signature:(size_t size)
tc_new	src/windows/gperftools/tcmalloc.h	/^  PERFTOOLS_DLL_DECL void* tc_new(size_t size);$/;"	p	signature:(size_t size)
tc_new	src/windows/gperftools/tcmalloc.h.in	/^  PERFTOOLS_DLL_DECL void* tc_new(size_t size);$/;"	p	file:	signature:(size_t size)
tc_new_aligned	src/debugallocation.cc	/^extern "C" PERFTOOLS_DLL_DECL void* tc_new_aligned(size_t size, std::align_val_t align) {$/;"	f	signature:(size_t size, std::align_val_t align)
tc_new_aligned	src/gperftools/tcmalloc.h.in	/^  PERFTOOLS_DLL_DECL void* tc_new_aligned(size_t size, std::align_val_t al);$/;"	p	file:	signature:(size_t size, std::align_val_t al)
tc_new_aligned	src/libc_override_gcc_and_weak.h	/^    ALIAS(tc_new_aligned);$/;"	v
tc_new_aligned	src/tcmalloc.cc	/^TC_ALIAS(tc_new_aligned);$/;"	v
tc_new_aligned	src/tcmalloc.cc	/^extern "C" PERFTOOLS_DLL_DECL void* tc_new_aligned(size_t size, std::align_val_t align) {$/;"	f	signature:(size_t size, std::align_val_t align)
tc_new_mode	src/tcmalloc.cc	/^static int tc_new_mode = 0;  \/\/ See tc_set_new_mode().$/;"	v	file:
tc_newarray	src/debugallocation.cc	/^extern "C" PERFTOOLS_DLL_DECL void* tc_newarray(size_t size) {$/;"	f	signature:(size_t size)
tc_newarray	src/gperftools/tcmalloc.h	/^  PERFTOOLS_DLL_DECL void* tc_newarray(size_t size);$/;"	p	signature:(size_t size)
tc_newarray	src/gperftools/tcmalloc.h.in	/^  PERFTOOLS_DLL_DECL void* tc_newarray(size_t size);$/;"	p	file:	signature:(size_t size)
tc_newarray	src/windows/gperftools/tcmalloc.h	/^  PERFTOOLS_DLL_DECL void* tc_newarray(size_t size);$/;"	p	signature:(size_t size)
tc_newarray	src/windows/gperftools/tcmalloc.h.in	/^  PERFTOOLS_DLL_DECL void* tc_newarray(size_t size);$/;"	p	file:	signature:(size_t size)
tc_newarray_aligned	src/debugallocation.cc	/^extern "C" PERFTOOLS_DLL_DECL void* tc_newarray_aligned(size_t size, std::align_val_t align) {$/;"	f	signature:(size_t size, std::align_val_t align)
tc_newarray_aligned	src/gperftools/tcmalloc.h.in	/^  PERFTOOLS_DLL_DECL void* tc_newarray_aligned(size_t size, std::align_val_t al);$/;"	p	file:	signature:(size_t size, std::align_val_t al)
tc_newarray_aligned	src/libc_override_gcc_and_weak.h	/^    ALIAS(tc_newarray_aligned);$/;"	v
tc_posix_memalign	src/libc_override_glibc.h	/^  int __posix_memalign(void** r, size_t a, size_t s)  ALIAS(tc_posix_memalign);$/;"	v
tc_pvalloc	src/libc_override_glibc.h	/^  void* __libc_pvalloc(size_t size)               ALIAS(tc_pvalloc);$/;"	v
tc_realloc	src/libc_override_glibc.h	/^  void* __libc_realloc(void* ptr, size_t size)    ALIAS(tc_realloc);$/;"	v
tc_slots_	src/central_freelist.h	/^  TCEntry tc_slots_[kMaxNumTransferEntries];$/;"	m	class:tcmalloc::CentralFreeList	access:private
tc_valloc	src/libc_override_glibc.h	/^  void* __libc_valloc(size_t size)                ALIAS(tc_valloc);$/;"	v
tcmalloc	src/base/commandlineflags.h	/^namespace tcmalloc {$/;"	n
tcmalloc	src/base/sysinfo.cc	/^namespace tcmalloc {$/;"	n	file:
tcmalloc	src/base/sysinfo.h	/^namespace tcmalloc {$/;"	n
tcmalloc	src/central_freelist.cc	/^namespace tcmalloc {$/;"	n	file:
tcmalloc	src/central_freelist.h	/^namespace tcmalloc {$/;"	n
tcmalloc	src/common.cc	/^namespace tcmalloc {$/;"	n	file:
tcmalloc	src/common.h	/^namespace tcmalloc {$/;"	n
tcmalloc	src/emergency_malloc.cc	/^namespace tcmalloc {$/;"	n	file:
tcmalloc	src/emergency_malloc.h	/^namespace tcmalloc {$/;"	n
tcmalloc	src/emergency_malloc_for_stacktrace.cc	/^namespace tcmalloc {$/;"	n	file:
tcmalloc	src/fake_stacktrace_scope.cc	/^namespace tcmalloc {$/;"	n	file:
tcmalloc	src/internal_logging.cc	/^namespace tcmalloc {$/;"	n	file:
tcmalloc	src/internal_logging.h	/^namespace tcmalloc {$/;"	n
tcmalloc	src/libc_override_osx.h	/^namespace tcmalloc {$/;"	n
tcmalloc	src/linked_list.h	/^namespace tcmalloc {$/;"	n
tcmalloc	src/maybe_emergency_malloc.h	/^namespace tcmalloc {$/;"	n
tcmalloc	src/page_heap.cc	/^namespace tcmalloc {$/;"	n	file:
tcmalloc	src/page_heap.h	/^namespace tcmalloc {$/;"	n
tcmalloc	src/page_heap_allocator.h	/^namespace tcmalloc {$/;"	n
tcmalloc	src/sampler.cc	/^namespace tcmalloc {$/;"	n	file:
tcmalloc	src/sampler.h	/^namespace tcmalloc {$/;"	n
tcmalloc	src/span.cc	/^namespace tcmalloc {$/;"	n	file:
tcmalloc	src/span.h	/^namespace tcmalloc {$/;"	n
tcmalloc	src/stack_trace_table.cc	/^namespace tcmalloc {$/;"	n	file:
tcmalloc	src/stack_trace_table.h	/^namespace tcmalloc {$/;"	n
tcmalloc	src/stacktrace.cc	/^namespace tcmalloc {$/;"	n	file:
tcmalloc	src/static_vars.cc	/^namespace tcmalloc {$/;"	n	file:
tcmalloc	src/static_vars.h	/^namespace tcmalloc {$/;"	n
tcmalloc	src/tcmalloc.cc	/^namespace tcmalloc {$/;"	n	file:
tcmalloc	src/thread_cache.cc	/^namespace tcmalloc {$/;"	n	file:
tcmalloc	src/thread_cache.h	/^namespace tcmalloc {$/;"	n
tcmalloc::AlignmentForSize	src/common.cc	/^int AlignmentForSize(size_t size) {$/;"	f	namespace:tcmalloc	signature:(size_t size)
tcmalloc::AlignmentForSize	src/common.h	/^int AlignmentForSize(size_t size);$/;"	p	namespace:tcmalloc	signature:(size_t size)
tcmalloc::CACHELINE_ALIGNED	src/thread_cache.cc	/^    ATTR_INITIAL_EXEC CACHELINE_ALIGNED;$/;"	m	namespace:tcmalloc	file:
tcmalloc::CACHELINE_ALIGNED	src/thread_cache.h	/^} CACHELINE_ALIGNED;$/;"	m	namespace:tcmalloc	typeref:class:tcmalloc::ThreadCache
tcmalloc::CentralCacheLockAll	src/libc_override_osx.h	/^  void CentralCacheLockAll();$/;"	p	namespace:tcmalloc	signature:()
tcmalloc::CentralCacheLockAll	src/static_vars.cc	/^void CentralCacheLockAll()$/;"	f	namespace:tcmalloc	signature:()
tcmalloc::CentralCacheUnlockAll	src/libc_override_osx.h	/^  void CentralCacheUnlockAll();$/;"	p	namespace:tcmalloc	signature:()
tcmalloc::CentralCacheUnlockAll	src/static_vars.cc	/^void CentralCacheUnlockAll()$/;"	f	namespace:tcmalloc	signature:()
tcmalloc::CentralFreeList	src/central_freelist.h	/^class CentralFreeList {$/;"	c	namespace:tcmalloc
tcmalloc::CentralFreeList::CentralFreeList	src/central_freelist.h	/^  CentralFreeList() : lock_(base::LINKER_INITIALIZED) { }$/;"	f	class:tcmalloc::CentralFreeList	access:public	signature:()
tcmalloc::CentralFreeList::EXCLUSIVE_LOCKS_REQUIRED	src/central_freelist.h	/^  bool MakeCacheSpace() EXCLUSIVE_LOCKS_REQUIRED(lock_);$/;"	p	class:tcmalloc::CentralFreeList	access:private	signature:(lock_)
tcmalloc::CentralFreeList::EXCLUSIVE_LOCKS_REQUIRED	src/central_freelist.h	/^  int FetchFromOneSpans(int N, void **start, void **end) EXCLUSIVE_LOCKS_REQUIRED(lock_);$/;"	p	class:tcmalloc::CentralFreeList	access:private	signature:(lock_)
tcmalloc::CentralFreeList::EXCLUSIVE_LOCKS_REQUIRED	src/central_freelist.h	/^  int FetchFromOneSpansSafe(int N, void **start, void **end) EXCLUSIVE_LOCKS_REQUIRED(lock_);$/;"	p	class:tcmalloc::CentralFreeList	access:private	signature:(lock_)
tcmalloc::CentralFreeList::EXCLUSIVE_LOCKS_REQUIRED	src/central_freelist.h	/^  void Populate() EXCLUSIVE_LOCKS_REQUIRED(lock_);$/;"	p	class:tcmalloc::CentralFreeList	access:private	signature:(lock_)
tcmalloc::CentralFreeList::EXCLUSIVE_LOCKS_REQUIRED	src/central_freelist.h	/^  void ReleaseListToSpans(void *start) EXCLUSIVE_LOCKS_REQUIRED(lock_);$/;"	p	class:tcmalloc::CentralFreeList	access:private	signature:(lock_)
tcmalloc::CentralFreeList::EXCLUSIVE_LOCKS_REQUIRED	src/central_freelist.h	/^  void ReleaseToSpans(void* object) EXCLUSIVE_LOCKS_REQUIRED(lock_);$/;"	p	class:tcmalloc::CentralFreeList	access:private	signature:(lock_)
tcmalloc::CentralFreeList::EvictRandomSizeClass	src/central_freelist.cc	/^bool CentralFreeList::EvictRandomSizeClass($/;"	f	class:tcmalloc::CentralFreeList	signature:( int locked_size_class, bool force)
tcmalloc::CentralFreeList::EvictRandomSizeClass	src/central_freelist.h	/^  static bool EvictRandomSizeClass(int locked_size_class, bool force);$/;"	p	class:tcmalloc::CentralFreeList	access:private	signature:(int locked_size_class, bool force)
tcmalloc::CentralFreeList::FetchFromOneSpans	src/central_freelist.cc	/^int CentralFreeList::FetchFromOneSpans(int N, void **start, void **end) {$/;"	f	class:tcmalloc::CentralFreeList	signature:(int N, void **start, void **end)
tcmalloc::CentralFreeList::FetchFromOneSpansSafe	src/central_freelist.cc	/^int CentralFreeList::FetchFromOneSpansSafe(int N, void **start, void **end) {$/;"	f	class:tcmalloc::CentralFreeList	signature:(int N, void **start, void **end)
tcmalloc::CentralFreeList::Init	src/central_freelist.cc	/^void CentralFreeList::Init(size_t cl) {$/;"	f	class:tcmalloc::CentralFreeList	signature:(size_t cl)
tcmalloc::CentralFreeList::Init	src/central_freelist.h	/^  void Init(size_t cl);$/;"	p	class:tcmalloc::CentralFreeList	access:public	signature:(size_t cl)
tcmalloc::CentralFreeList::InsertRange	src/central_freelist.cc	/^void CentralFreeList::InsertRange(void *start, void *end, int N) {$/;"	f	class:tcmalloc::CentralFreeList	signature:(void *start, void *end, int N)
tcmalloc::CentralFreeList::InsertRange	src/central_freelist.h	/^  void InsertRange(void *start, void *end, int N);$/;"	p	class:tcmalloc::CentralFreeList	access:public	signature:(void *start, void *end, int N)
tcmalloc::CentralFreeList::LOCKS_EXCLUDED	src/central_freelist.h	/^  bool ShrinkCache(int locked_size_class, bool force) LOCKS_EXCLUDED(lock_);$/;"	p	class:tcmalloc::CentralFreeList	access:private	signature:(lock_)
tcmalloc::CentralFreeList::Lock	src/central_freelist.h	/^  void Lock() {$/;"	f	class:tcmalloc::CentralFreeList	access:public	signature:()
tcmalloc::CentralFreeList::MakeCacheSpace	src/central_freelist.cc	/^bool CentralFreeList::MakeCacheSpace() {$/;"	f	class:tcmalloc::CentralFreeList	signature:()
tcmalloc::CentralFreeList::OverheadBytes	src/central_freelist.cc	/^size_t CentralFreeList::OverheadBytes() {$/;"	f	class:tcmalloc::CentralFreeList	signature:()
tcmalloc::CentralFreeList::OverheadBytes	src/central_freelist.h	/^  size_t OverheadBytes();$/;"	p	class:tcmalloc::CentralFreeList	access:public	signature:()
tcmalloc::CentralFreeList::Populate	src/central_freelist.cc	/^void CentralFreeList::Populate() {$/;"	f	class:tcmalloc::CentralFreeList	signature:()
tcmalloc::CentralFreeList::ReleaseListToSpans	src/central_freelist.cc	/^void CentralFreeList::ReleaseListToSpans(void* start) {$/;"	f	class:tcmalloc::CentralFreeList	signature:(void* start)
tcmalloc::CentralFreeList::ReleaseToSpans	src/central_freelist.cc	/^void CentralFreeList::ReleaseToSpans(void* object) {$/;"	f	class:tcmalloc::CentralFreeList	signature:(void* object)
tcmalloc::CentralFreeList::RemoveRange	src/central_freelist.cc	/^int CentralFreeList::RemoveRange(void **start, void **end, int N) {$/;"	f	class:tcmalloc::CentralFreeList	signature:(void **start, void **end, int N)
tcmalloc::CentralFreeList::RemoveRange	src/central_freelist.h	/^  int RemoveRange(void **start, void **end, int N);$/;"	p	class:tcmalloc::CentralFreeList	access:public	signature:(void **start, void **end, int N)
tcmalloc::CentralFreeList::TCEntry	src/central_freelist.h	/^  struct TCEntry {$/;"	s	class:tcmalloc::CentralFreeList	access:private
tcmalloc::CentralFreeList::TCEntry::head	src/central_freelist.h	/^    void *head;  \/\/ Head of chain of objects.$/;"	m	struct:tcmalloc::CentralFreeList::TCEntry	access:public
tcmalloc::CentralFreeList::TCEntry::tail	src/central_freelist.h	/^    void *tail;  \/\/ Tail of chain of objects.$/;"	m	struct:tcmalloc::CentralFreeList::TCEntry	access:public
tcmalloc::CentralFreeList::Unlock	src/central_freelist.h	/^  void Unlock() {$/;"	f	class:tcmalloc::CentralFreeList	access:public	signature:()
tcmalloc::CentralFreeList::cache_size_	src/central_freelist.h	/^  int32_t cache_size_;$/;"	m	class:tcmalloc::CentralFreeList	access:private
tcmalloc::CentralFreeList::counter_	src/central_freelist.h	/^  size_t   counter_;        \/\/ Number of free objects in cache entry$/;"	m	class:tcmalloc::CentralFreeList	access:private
tcmalloc::CentralFreeList::empty_	src/central_freelist.h	/^  Span     empty_;          \/\/ Dummy header for list of empty spans$/;"	m	class:tcmalloc::CentralFreeList	access:private
tcmalloc::CentralFreeList::kMaxNumTransferEntries	src/central_freelist.h	/^  static const int kMaxNumTransferEntries = 0;$/;"	m	class:tcmalloc::CentralFreeList	access:private
tcmalloc::CentralFreeList::kMaxNumTransferEntries	src/central_freelist.h	/^  static const int kMaxNumTransferEntries = 64;$/;"	m	class:tcmalloc::CentralFreeList	access:private
tcmalloc::CentralFreeList::length	src/central_freelist.h	/^  int length() {$/;"	f	class:tcmalloc::CentralFreeList	access:public	signature:()
tcmalloc::CentralFreeList::lock_	src/central_freelist.h	/^  SpinLock lock_;$/;"	m	class:tcmalloc::CentralFreeList	access:private
tcmalloc::CentralFreeList::max_cache_size_	src/central_freelist.h	/^  int32_t max_cache_size_;$/;"	m	class:tcmalloc::CentralFreeList	access:private
tcmalloc::CentralFreeList::nonempty_	src/central_freelist.h	/^  Span     nonempty_;       \/\/ Dummy header for list of non-empty spans$/;"	m	class:tcmalloc::CentralFreeList	access:private
tcmalloc::CentralFreeList::num_spans_	src/central_freelist.h	/^  size_t   num_spans_;      \/\/ Number of spans in empty_ plus nonempty_$/;"	m	class:tcmalloc::CentralFreeList	access:private
tcmalloc::CentralFreeList::size_class_	src/central_freelist.h	/^  size_t   size_class_;     \/\/ My size class$/;"	m	class:tcmalloc::CentralFreeList	access:private
tcmalloc::CentralFreeList::tc_length	src/central_freelist.cc	/^int CentralFreeList::tc_length() {$/;"	f	class:tcmalloc::CentralFreeList	signature:()
tcmalloc::CentralFreeList::tc_length	src/central_freelist.h	/^  int tc_length();$/;"	p	class:tcmalloc::CentralFreeList	access:public	signature:()
tcmalloc::CentralFreeList::tc_slots_	src/central_freelist.h	/^  TCEntry tc_slots_[kMaxNumTransferEntries];$/;"	m	class:tcmalloc::CentralFreeList	access:private
tcmalloc::CentralFreeList::used_slots_	src/central_freelist.h	/^  int32_t used_slots_;$/;"	m	class:tcmalloc::CentralFreeList	access:private
tcmalloc::CentralFreeListPadded	src/central_freelist.h	/^class CentralFreeListPadded : public CentralFreeListPaddedTo<$/;"	c	namespace:tcmalloc	inherits:CentralFreeListPaddedTo
tcmalloc::CentralFreeListPaddedTo	src/central_freelist.h	/^class CentralFreeListPaddedTo : public CentralFreeList {$/;"	c	namespace:tcmalloc	inherits:CentralFreeList
tcmalloc::CentralFreeListPaddedTo	src/central_freelist.h	/^class CentralFreeListPaddedTo<0> : public CentralFreeList {$/;"	c	namespace:tcmalloc	inherits:CentralFreeList
tcmalloc::CentralFreeListPaddedTo::pad_	src/central_freelist.h	/^  char pad_[64 - kFreeListSizeMod64];$/;"	m	class:tcmalloc::CentralFreeListPaddedTo	access:private
tcmalloc::DLL_Init	src/span.cc	/^void DLL_Init(Span* list) {$/;"	f	namespace:tcmalloc	signature:(Span* list)
tcmalloc::DLL_Init	src/span.h	/^void DLL_Init(Span* list);$/;"	p	namespace:tcmalloc	signature:(Span* list)
tcmalloc::DLL_IsEmpty	src/span.h	/^inline bool DLL_IsEmpty(const Span* list) {$/;"	f	namespace:tcmalloc	signature:(const Span* list)
tcmalloc::DLL_Length	src/span.cc	/^int DLL_Length(const Span* list) {$/;"	f	namespace:tcmalloc	signature:(const Span* list)
tcmalloc::DLL_Length	src/span.h	/^int DLL_Length(const Span* list);$/;"	p	namespace:tcmalloc	signature:(const Span* list)
tcmalloc::DLL_Prepend	src/span.cc	/^void DLL_Prepend(Span* list, Span* span) {$/;"	f	namespace:tcmalloc	signature:(Span* list, Span* span)
tcmalloc::DLL_Prepend	src/span.h	/^void DLL_Prepend(Span* list, Span* span);$/;"	p	namespace:tcmalloc	signature:(Span* list, Span* span)
tcmalloc::DLL_Remove	src/span.cc	/^void DLL_Remove(Span* span) {$/;"	f	namespace:tcmalloc	signature:(Span* span)
tcmalloc::DLL_Remove	src/span.h	/^void DLL_Remove(Span* span);$/;"	p	namespace:tcmalloc	signature:(Span* span)
tcmalloc::DeleteSpan	src/span.cc	/^void DeleteSpan(Span* span) {$/;"	f	namespace:tcmalloc	signature:(Span* span)
tcmalloc::DeleteSpan	src/span.h	/^void DeleteSpan(Span* span);$/;"	p	namespace:tcmalloc	signature:(Span* span)
tcmalloc::DumpProcSelfMaps	src/base/sysinfo.cc	/^void DumpProcSelfMaps(RawFD fd) {$/;"	f	namespace:tcmalloc	signature:(RawFD fd)
tcmalloc::DumpProcSelfMaps	src/base/sysinfo.h	/^void DumpProcSelfMaps(RawFD fd);$/;"	p	namespace:tcmalloc	signature:(RawFD fd)
tcmalloc::EmergencyArenaPagesAllocator	src/emergency_malloc.cc	/^  class EmergencyArenaPagesAllocator : public LowLevelAlloc::PagesAllocator {$/;"	c	namespace:tcmalloc	file:	inherits:LowLevelAlloc::PagesAllocator
tcmalloc::EmergencyArenaPagesAllocator::MapPages	src/emergency_malloc.cc	/^    void *MapPages(int32 flags, size_t size) {$/;"	f	class:tcmalloc::EmergencyArenaPagesAllocator	file:	access:private	signature:(int32 flags, size_t size)
tcmalloc::EmergencyArenaPagesAllocator::UnMapPages	src/emergency_malloc.cc	/^    void UnMapPages(int32 flags, void *addr, size_t size) {$/;"	f	class:tcmalloc::EmergencyArenaPagesAllocator	file:	access:private	signature:(int32 flags, void *addr, size_t size)
tcmalloc::EmergencyArenaPagesAllocator::~EmergencyArenaPagesAllocator	src/emergency_malloc.cc	/^    ~EmergencyArenaPagesAllocator() {}$/;"	f	class:tcmalloc::EmergencyArenaPagesAllocator	file:	access:private	signature:()
tcmalloc::EmergencyCalloc	src/emergency_malloc.cc	/^  PERFTOOLS_DLL_DECL void *EmergencyCalloc(size_t n, size_t elem_size) {$/;"	f	namespace:tcmalloc	signature:(size_t n, size_t elem_size)
tcmalloc::EmergencyCalloc	src/emergency_malloc.h	/^  PERFTOOLS_DLL_DECL void *EmergencyCalloc(size_t n, size_t elem_size);$/;"	p	namespace:tcmalloc	signature:(size_t n, size_t elem_size)
tcmalloc::EmergencyCalloc	src/maybe_emergency_malloc.h	/^  static inline void *EmergencyCalloc(size_t n, size_t elem_size) {return NULL;}$/;"	f	namespace:tcmalloc	signature:(size_t n, size_t elem_size)
tcmalloc::EmergencyFree	src/emergency_malloc.cc	/^  PERFTOOLS_DLL_DECL void EmergencyFree(void *p) {$/;"	f	namespace:tcmalloc	signature:(void *p)
tcmalloc::EmergencyFree	src/emergency_malloc.h	/^  PERFTOOLS_DLL_DECL void EmergencyFree(void *p);$/;"	p	namespace:tcmalloc	signature:(void *p)
tcmalloc::EmergencyFree	src/maybe_emergency_malloc.h	/^  static inline void EmergencyFree(void *p) {}$/;"	f	namespace:tcmalloc	signature:(void *p)
tcmalloc::EmergencyMalloc	src/emergency_malloc.cc	/^  PERFTOOLS_DLL_DECL void *EmergencyMalloc(size_t size) {$/;"	f	namespace:tcmalloc	signature:(size_t size)
tcmalloc::EmergencyMalloc	src/emergency_malloc.h	/^  PERFTOOLS_DLL_DECL void *EmergencyMalloc(size_t size);$/;"	p	namespace:tcmalloc	signature:(size_t size)
tcmalloc::EmergencyMalloc	src/maybe_emergency_malloc.h	/^  static inline void *EmergencyMalloc(size_t size) {return NULL;}$/;"	f	namespace:tcmalloc	signature:(size_t size)
tcmalloc::EmergencyRealloc	src/emergency_malloc.cc	/^  PERFTOOLS_DLL_DECL void *EmergencyRealloc(void *_old_ptr, size_t new_size) {$/;"	f	namespace:tcmalloc	signature:(void *_old_ptr, size_t new_size)
tcmalloc::EmergencyRealloc	src/emergency_malloc.h	/^  PERFTOOLS_DLL_DECL void *EmergencyRealloc(void *old_ptr, size_t new_size);$/;"	p	namespace:tcmalloc	signature:(void *old_ptr, size_t new_size)
tcmalloc::EmergencyRealloc	src/maybe_emergency_malloc.h	/^  static inline void *EmergencyRealloc(void *old_ptr, size_t new_size) {return NULL;}$/;"	f	namespace:tcmalloc	signature:(void *old_ptr, size_t new_size)
tcmalloc::EnterStacktraceScope	src/emergency_malloc_for_stacktrace.cc	/^  bool EnterStacktraceScope(void);$/;"	p	namespace:tcmalloc	file:	signature:(void)
tcmalloc::EnterStacktraceScope	src/emergency_malloc_for_stacktrace.cc	/^bool tcmalloc::EnterStacktraceScope(void) {$/;"	f	class:tcmalloc	signature:(void)
tcmalloc::EnterStacktraceScope	src/fake_stacktrace_scope.cc	/^  ATTRIBUTE_WEAK bool EnterStacktraceScope(void) {$/;"	f	namespace:tcmalloc	signature:(void)
tcmalloc::EnterStacktraceScope	src/stacktrace.cc	/^  bool EnterStacktraceScope(void);$/;"	p	namespace:tcmalloc	file:	signature:(void)
tcmalloc::Event	src/span.cc	/^void Event(Span* span, char op, int v = 0) {$/;"	f	namespace:tcmalloc	signature:(Span* span, char op, int v = 0)
tcmalloc::Event	src/span.h	/^void Event(Span* span, char op, int v = 0);$/;"	p	namespace:tcmalloc	signature:(Span* span, char op, int v = 0)
tcmalloc::FLAGS_tcmalloc_transfer_num_objects	src/common.cc	/^static int32 FLAGS_tcmalloc_transfer_num_objects;$/;"	m	namespace:tcmalloc	file:
tcmalloc::FillProcSelfMaps	src/base/sysinfo.cc	/^int FillProcSelfMaps(char buf[], int size, bool* wrote_all) {$/;"	f	namespace:tcmalloc	signature:(char buf[], int size, bool* wrote_all)
tcmalloc::FillProcSelfMaps	src/base/sysinfo.h	/^int FillProcSelfMaps(char buf[], int size, bool* wrote_all);$/;"	p	namespace:tcmalloc	signature:(char buf[], int size, bool* wrote_all)
tcmalloc::InitEmergencyMalloc	src/emergency_malloc.cc	/^  static void InitEmergencyMalloc(void) {$/;"	f	namespace:tcmalloc	signature:(void)
tcmalloc::InitTCMallocTransferNumObjects	src/common.cc	/^static inline void InitTCMallocTransferNumObjects()$/;"	f	namespace:tcmalloc	signature:()
tcmalloc::IsEmergencyPtr	src/emergency_malloc.h	/^  static inline bool IsEmergencyPtr(const void *_ptr) {$/;"	f	namespace:tcmalloc	signature:(const void *_ptr)
tcmalloc::IsEmergencyPtr	src/maybe_emergency_malloc.h	/^  static inline bool IsEmergencyPtr(const void *_ptr) {$/;"	f	namespace:tcmalloc	signature:(const void *_ptr)
tcmalloc::LeaveStacktraceScope	src/emergency_malloc_for_stacktrace.cc	/^  void LeaveStacktraceScope(void);$/;"	p	namespace:tcmalloc	file:	signature:(void)
tcmalloc::LeaveStacktraceScope	src/emergency_malloc_for_stacktrace.cc	/^void tcmalloc::LeaveStacktraceScope(void) {$/;"	f	class:tcmalloc	signature:(void)
tcmalloc::LeaveStacktraceScope	src/fake_stacktrace_scope.cc	/^  ATTRIBUTE_WEAK void LeaveStacktraceScope(void) {$/;"	f	namespace:tcmalloc	signature:(void)
tcmalloc::LeaveStacktraceScope	src/stacktrace.cc	/^  void LeaveStacktraceScope(void);$/;"	p	namespace:tcmalloc	file:	signature:(void)
tcmalloc::LgFloor	src/common.cc	/^static inline int LgFloor(size_t n) {$/;"	f	namespace:tcmalloc	signature:(size_t n)
tcmalloc::Log	src/internal_logging.cc	/^void Log(LogMode mode, const char* filename, int line,$/;"	f	namespace:tcmalloc	signature:(LogMode mode, const char* filename, int line, LogItem a, LogItem b, LogItem c, LogItem d)
tcmalloc::Log	src/internal_logging.h	/^extern PERFTOOLS_DLL_DECL void Log(LogMode mode, const char* filename, int line,$/;"	p	namespace:tcmalloc	signature:(LogMode mode, const char* filename, int line, LogItem a, LogItem b = LogItem(), LogItem c = LogItem(), LogItem d = LogItem())
tcmalloc::LogItem	src/internal_logging.h	/^class LogItem {$/;"	c	namespace:tcmalloc
tcmalloc::LogItem::LogItem	src/internal_logging.h	/^  LogItem()                     : tag_(kEnd)      { }$/;"	f	class:tcmalloc::LogItem	access:public	signature:()
tcmalloc::LogItem::LogItem	src/internal_logging.h	/^  LogItem(const char* v)        : tag_(kStr)      { u_.str = v; }$/;"	f	class:tcmalloc::LogItem	access:public	signature:(const char* v)
tcmalloc::LogItem::LogItem	src/internal_logging.h	/^  LogItem(const void* v)        : tag_(kPtr)      { u_.ptr = v; }$/;"	f	class:tcmalloc::LogItem	access:public	signature:(const void* v)
tcmalloc::LogItem::LogItem	src/internal_logging.h	/^  LogItem(int v)                : tag_(kSigned)   { u_.snum = v; }$/;"	f	class:tcmalloc::LogItem	access:public	signature:(int v)
tcmalloc::LogItem::LogItem	src/internal_logging.h	/^  LogItem(long long v)          : tag_(kSigned)   { u_.snum = v; }$/;"	f	class:tcmalloc::LogItem	access:public	signature:(long long v)
tcmalloc::LogItem::LogItem	src/internal_logging.h	/^  LogItem(long v)               : tag_(kSigned)   { u_.snum = v; }$/;"	f	class:tcmalloc::LogItem	access:public	signature:(long v)
tcmalloc::LogItem::LogItem	src/internal_logging.h	/^  LogItem(unsigned int v)       : tag_(kUnsigned) { u_.unum = v; }$/;"	f	class:tcmalloc::LogItem	access:public	signature:(unsigned int v)
tcmalloc::LogItem::LogItem	src/internal_logging.h	/^  LogItem(unsigned long long v) : tag_(kUnsigned) { u_.unum = v; }$/;"	f	class:tcmalloc::LogItem	access:public	signature:(unsigned long long v)
tcmalloc::LogItem::LogItem	src/internal_logging.h	/^  LogItem(unsigned long v)      : tag_(kUnsigned) { u_.unum = v; }$/;"	f	class:tcmalloc::LogItem	access:public	signature:(unsigned long v)
tcmalloc::LogItem::Tag	src/internal_logging.h	/^  enum Tag {$/;"	g	class:tcmalloc::LogItem	access:private
tcmalloc::LogItem::__anon9::ptr	src/internal_logging.h	/^    const void* ptr;$/;"	m	union:tcmalloc::LogItem::__anon9	access:public
tcmalloc::LogItem::__anon9::snum	src/internal_logging.h	/^    int64_t snum;$/;"	m	union:tcmalloc::LogItem::__anon9	access:public
tcmalloc::LogItem::__anon9::str	src/internal_logging.h	/^    const char* str;$/;"	m	union:tcmalloc::LogItem::__anon9	access:public
tcmalloc::LogItem::__anon9::unum	src/internal_logging.h	/^    uint64_t unum;$/;"	m	union:tcmalloc::LogItem::__anon9	access:public
tcmalloc::LogItem::kEnd	src/internal_logging.h	/^    kEnd$/;"	e	enum:tcmalloc::LogItem::Tag
tcmalloc::LogItem::kPtr	src/internal_logging.h	/^    kPtr,$/;"	e	enum:tcmalloc::LogItem::Tag
tcmalloc::LogItem::kSigned	src/internal_logging.h	/^    kSigned,$/;"	e	enum:tcmalloc::LogItem::Tag
tcmalloc::LogItem::kStr	src/internal_logging.h	/^    kStr,$/;"	e	enum:tcmalloc::LogItem::Tag
tcmalloc::LogItem::kUnsigned	src/internal_logging.h	/^    kUnsigned,$/;"	e	enum:tcmalloc::LogItem::Tag
tcmalloc::LogItem::tag_	src/internal_logging.h	/^  Tag tag_;$/;"	m	class:tcmalloc::LogItem	access:private
tcmalloc::LogItem::u_	src/internal_logging.h	/^  } u_;$/;"	m	class:tcmalloc::LogItem	typeref:union:tcmalloc::LogItem::__anon9	access:private
tcmalloc::LogMode	src/internal_logging.h	/^enum LogMode {$/;"	g	namespace:tcmalloc
tcmalloc::Logger	src/internal_logging.cc	/^class Logger {$/;"	c	namespace:tcmalloc	file:
tcmalloc::Logger::Add	src/internal_logging.cc	/^  bool Add(const LogItem& item);$/;"	p	class:tcmalloc::Logger	file:	access:public	signature:(const LogItem& item)
tcmalloc::Logger::Add	src/internal_logging.cc	/^bool Logger::Add(const LogItem& item) {$/;"	f	class:tcmalloc::Logger	signature:(const LogItem& item)
tcmalloc::Logger::AddNum	src/internal_logging.cc	/^  bool AddNum(uint64_t num, int base);  \/\/ base must be 10 or 16.$/;"	p	class:tcmalloc::Logger	file:	access:public	signature:(uint64_t num, int base)
tcmalloc::Logger::AddNum	src/internal_logging.cc	/^bool Logger::AddNum(uint64_t num, int base) {$/;"	f	class:tcmalloc::Logger	signature:(uint64_t num, int base)
tcmalloc::Logger::AddStr	src/internal_logging.cc	/^  bool AddStr(const char* str, int n);$/;"	p	class:tcmalloc::Logger	file:	access:public	signature:(const char* str, int n)
tcmalloc::Logger::AddStr	src/internal_logging.cc	/^bool Logger::AddStr(const char* str, int n) {$/;"	f	class:tcmalloc::Logger	signature:(const char* str, int n)
tcmalloc::Logger::buf_	src/internal_logging.cc	/^  char buf_[kBufSize];$/;"	m	class:tcmalloc::Logger	file:	access:public
tcmalloc::Logger::end_	src/internal_logging.cc	/^  char* end_;$/;"	m	class:tcmalloc::Logger	file:	access:public
tcmalloc::Logger::kBufSize	src/internal_logging.cc	/^  static const int kBufSize = 200;$/;"	m	class:tcmalloc::Logger	file:	access:public
tcmalloc::Logger::p_	src/internal_logging.cc	/^  char* p_;$/;"	m	class:tcmalloc::Logger	file:	access:public
tcmalloc::MapObjectToSpan	src/central_freelist.cc	/^Span* MapObjectToSpan(void* object) {$/;"	f	namespace:tcmalloc	signature:(void* object)
tcmalloc::MapSelector	src/page_heap.h	/^template <> class MapSelector<32> {$/;"	c	namespace:tcmalloc
tcmalloc::MapSelector	src/page_heap.h	/^template <> class MapSelector<48> {$/;"	c	namespace:tcmalloc
tcmalloc::MapSelector	src/page_heap.h	/^template <int BITS> class MapSelector {$/;"	c	namespace:tcmalloc
tcmalloc::MapSelector::Type	src/page_heap.h	/^  typedef TCMalloc_PageMap2<32-kPageShift> Type;$/;"	t	class:tcmalloc::MapSelector	access:public
tcmalloc::MapSelector::Type	src/page_heap.h	/^  typedef TCMalloc_PageMap2<48-kPageShift> Type;$/;"	t	class:tcmalloc::MapSelector	access:public
tcmalloc::MapSelector::Type	src/page_heap.h	/^  typedef TCMalloc_PageMap3<BITS-kPageShift> Type;$/;"	t	class:tcmalloc::MapSelector	access:public
tcmalloc::MetaDataAlloc	src/common.cc	/^void* MetaDataAlloc(size_t bytes) {$/;"	f	namespace:tcmalloc	signature:(size_t bytes)
tcmalloc::MetaDataAlloc	src/common.h	/^void* MetaDataAlloc(size_t bytes);$/;"	p	namespace:tcmalloc	signature:(size_t bytes)
tcmalloc::NewSpan	src/span.cc	/^Span* NewSpan(PageID p, Length len) {$/;"	f	namespace:tcmalloc	signature:(PageID p, Length len)
tcmalloc::NewSpan	src/span.h	/^Span* NewSpan(PageID p, Length len);$/;"	p	namespace:tcmalloc	signature:(PageID p, Length len)
tcmalloc::PageHeap	src/page_heap.h	/^class PERFTOOLS_DLL_DECL PageHeap {$/;"	c	namespace:tcmalloc
tcmalloc::PageHeap::AllocLarge	src/page_heap.cc	/^Span* PageHeap::AllocLarge(Length n) {$/;"	f	class:tcmalloc::PageHeap	signature:(Length n)
tcmalloc::PageHeap::AllocLarge	src/page_heap.h	/^  Span* AllocLarge(Length n);$/;"	p	class:tcmalloc::PageHeap	access:private	signature:(Length n)
tcmalloc::PageHeap::Carve	src/page_heap.cc	/^Span* PageHeap::Carve(Span* span, Length n) {$/;"	f	class:tcmalloc::PageHeap	signature:(Span* span, Length n)
tcmalloc::PageHeap::Carve	src/page_heap.h	/^  Span* Carve(Span* span, Length n);$/;"	p	class:tcmalloc::PageHeap	access:private	signature:(Span* span, Length n)
tcmalloc::PageHeap::Check	src/page_heap.cc	/^bool PageHeap::Check() {$/;"	f	class:tcmalloc::PageHeap	signature:()
tcmalloc::PageHeap::Check	src/page_heap.h	/^  bool Check();$/;"	p	class:tcmalloc::PageHeap	access:public	signature:()
tcmalloc::PageHeap::CheckAndHandlePreMerge	src/page_heap.cc	/^Span* PageHeap::CheckAndHandlePreMerge(Span* span, Span* other) {$/;"	f	class:tcmalloc::PageHeap	signature:(Span* span, Span* other)
tcmalloc::PageHeap::CheckAndHandlePreMerge	src/page_heap.h	/^  Span* CheckAndHandlePreMerge(Span *span, Span *other);$/;"	p	class:tcmalloc::PageHeap	access:private	signature:(Span *span, Span *other)
tcmalloc::PageHeap::CheckExpensive	src/page_heap.cc	/^bool PageHeap::CheckExpensive() {$/;"	f	class:tcmalloc::PageHeap	signature:()
tcmalloc::PageHeap::CheckExpensive	src/page_heap.h	/^  bool CheckExpensive();$/;"	p	class:tcmalloc::PageHeap	access:public	signature:()
tcmalloc::PageHeap::CheckList	src/page_heap.cc	/^bool PageHeap::CheckList(Span* list, Length min_pages, Length max_pages,$/;"	f	class:tcmalloc::PageHeap	signature:(Span* list, Length min_pages, Length max_pages, int freelist)
tcmalloc::PageHeap::CheckList	src/page_heap.h	/^  bool CheckList(Span* list, Length min_pages, Length max_pages,$/;"	p	class:tcmalloc::PageHeap	access:public	signature:(Span* list, Length min_pages, Length max_pages, int freelist)
tcmalloc::PageHeap::CommitSpan	src/page_heap.cc	/^void PageHeap::CommitSpan(Span* span) {$/;"	f	class:tcmalloc::PageHeap	signature:(Span* span)
tcmalloc::PageHeap::CommitSpan	src/page_heap.h	/^  void CommitSpan(Span* span);$/;"	p	class:tcmalloc::PageHeap	access:private	signature:(Span* span)
tcmalloc::PageHeap::DecommitSpan	src/page_heap.cc	/^bool PageHeap::DecommitSpan(Span* span) {$/;"	f	class:tcmalloc::PageHeap	signature:(Span* span)
tcmalloc::PageHeap::DecommitSpan	src/page_heap.h	/^  bool DecommitSpan(Span* span);$/;"	p	class:tcmalloc::PageHeap	access:private	signature:(Span* span)
tcmalloc::PageHeap::Delete	src/page_heap.cc	/^void PageHeap::Delete(Span* span) {$/;"	f	class:tcmalloc::PageHeap	signature:(Span* span)
tcmalloc::PageHeap::Delete	src/page_heap.h	/^  void Delete(Span* span);$/;"	p	class:tcmalloc::PageHeap	access:public	signature:(Span* span)
tcmalloc::PageHeap::EnsureLimit	src/page_heap.cc	/^bool PageHeap::EnsureLimit(Length n, bool withRelease)$/;"	f	class:tcmalloc::PageHeap	signature:(Length n, bool withRelease)
tcmalloc::PageHeap::EnsureLimit	src/page_heap.h	/^  bool EnsureLimit(Length n, bool allowRelease = true);$/;"	p	class:tcmalloc::PageHeap	access:private	signature:(Length n, bool allowRelease = true)
tcmalloc::PageHeap::GetAggressiveDecommit	src/page_heap.h	/^  bool GetAggressiveDecommit(void) {return aggressive_decommit_;}$/;"	f	class:tcmalloc::PageHeap	access:public	signature:(void)
tcmalloc::PageHeap::GetDescriptor	src/page_heap.h	/^  Span* GetDescriptor(PageID p) const {$/;"	f	class:tcmalloc::PageHeap	access:public	signature:(PageID p) const
tcmalloc::PageHeap::GetLargeSpanStats	src/page_heap.cc	/^void PageHeap::GetLargeSpanStats(LargeSpanStats* result) {$/;"	f	class:tcmalloc::PageHeap	signature:(LargeSpanStats* result)
tcmalloc::PageHeap::GetLargeSpanStats	src/page_heap.h	/^  void GetLargeSpanStats(LargeSpanStats* result);$/;"	p	class:tcmalloc::PageHeap	access:public	signature:(LargeSpanStats* result)
tcmalloc::PageHeap::GetNextRange	src/page_heap.cc	/^bool PageHeap::GetNextRange(PageID start, base::MallocRange* r) {$/;"	f	class:tcmalloc::PageHeap	signature:(PageID start, base::MallocRange* r)
tcmalloc::PageHeap::GetNextRange	src/page_heap.h	/^  bool GetNextRange(PageID start, base::MallocRange* r);$/;"	p	class:tcmalloc::PageHeap	access:public	signature:(PageID start, base::MallocRange* r)
tcmalloc::PageHeap::GetSizeClassOrZero	src/page_heap.h	/^  uint32 GetSizeClassOrZero(PageID p) const {$/;"	f	class:tcmalloc::PageHeap	access:public	signature:(PageID p) const
tcmalloc::PageHeap::GetSmallSpanStats	src/page_heap.cc	/^void PageHeap::GetSmallSpanStats(SmallSpanStats* result) {$/;"	f	class:tcmalloc::PageHeap	signature:(SmallSpanStats* result)
tcmalloc::PageHeap::GetSmallSpanStats	src/page_heap.h	/^  void GetSmallSpanStats(SmallSpanStats* result);$/;"	p	class:tcmalloc::PageHeap	access:public	signature:(SmallSpanStats* result)
tcmalloc::PageHeap::GrowHeap	src/page_heap.cc	/^bool PageHeap::GrowHeap(Length n) {$/;"	f	class:tcmalloc::PageHeap	signature:(Length n)
tcmalloc::PageHeap::GrowHeap	src/page_heap.h	/^  bool GrowHeap(Length n);$/;"	p	class:tcmalloc::PageHeap	access:private	signature:(Length n)
tcmalloc::PageHeap::IncrementalScavenge	src/page_heap.cc	/^void PageHeap::IncrementalScavenge(Length n) {$/;"	f	class:tcmalloc::PageHeap	signature:(Length n)
tcmalloc::PageHeap::IncrementalScavenge	src/page_heap.h	/^  void IncrementalScavenge(Length n);$/;"	p	class:tcmalloc::PageHeap	access:private	signature:(Length n)
tcmalloc::PageHeap::InvalidateCachedSizeClass	src/page_heap.h	/^  void InvalidateCachedSizeClass(PageID p) { pagemap_cache_.Invalidate(p); }$/;"	f	class:tcmalloc::PageHeap	access:public	signature:(PageID p)
tcmalloc::PageHeap::LargeSpanStats	src/page_heap.h	/^  struct LargeSpanStats {$/;"	s	class:tcmalloc::PageHeap	access:public
tcmalloc::PageHeap::LargeSpanStats::normal_pages	src/page_heap.h	/^    int64 normal_pages;    \/\/ Combined page length of normal large spans$/;"	m	struct:tcmalloc::PageHeap::LargeSpanStats	access:public
tcmalloc::PageHeap::LargeSpanStats::returned_pages	src/page_heap.h	/^    int64 returned_pages;  \/\/ Combined page length of unmapped spans$/;"	m	struct:tcmalloc::PageHeap::LargeSpanStats	access:public
tcmalloc::PageHeap::LargeSpanStats::spans	src/page_heap.h	/^    int64 spans;           \/\/ Number of such spans$/;"	m	struct:tcmalloc::PageHeap::LargeSpanStats	access:public
tcmalloc::PageHeap::MergeIntoFreeList	src/page_heap.cc	/^void PageHeap::MergeIntoFreeList(Span* span) {$/;"	f	class:tcmalloc::PageHeap	signature:(Span* span)
tcmalloc::PageHeap::MergeIntoFreeList	src/page_heap.h	/^  void MergeIntoFreeList(Span* span);$/;"	p	class:tcmalloc::PageHeap	access:private	signature:(Span* span)
tcmalloc::PageHeap::New	src/page_heap.cc	/^Span* PageHeap::New(Length n) {$/;"	f	class:tcmalloc::PageHeap	signature:(Length n)
tcmalloc::PageHeap::New	src/page_heap.h	/^  Span* New(Length n);$/;"	p	class:tcmalloc::PageHeap	access:public	signature:(Length n)
tcmalloc::PageHeap::PageHeap	src/page_heap.cc	/^PageHeap::PageHeap()$/;"	f	class:tcmalloc::PageHeap	signature:()
tcmalloc::PageHeap::PageHeap	src/page_heap.h	/^  PageHeap();$/;"	p	class:tcmalloc::PageHeap	access:public	signature:()
tcmalloc::PageHeap::PageMap	src/page_heap.h	/^  typedef MapSelector<kAddressBits>::Type PageMap;$/;"	t	class:tcmalloc::PageHeap	access:private
tcmalloc::PageHeap::PageMapCache	src/page_heap.h	/^  typedef PackedCache<kAddressBits - kPageShift> PageMapCache;$/;"	t	class:tcmalloc::PageHeap	access:private
tcmalloc::PageHeap::PrependToFreeList	src/page_heap.cc	/^void PageHeap::PrependToFreeList(Span* span) {$/;"	f	class:tcmalloc::PageHeap	signature:(Span* span)
tcmalloc::PageHeap::PrependToFreeList	src/page_heap.h	/^  void PrependToFreeList(Span* span);$/;"	p	class:tcmalloc::PageHeap	access:private	signature:(Span* span)
tcmalloc::PageHeap::RecordSpan	src/page_heap.h	/^  void RecordSpan(Span* span) {$/;"	f	class:tcmalloc::PageHeap	access:private	signature:(Span* span)
tcmalloc::PageHeap::RegisterSizeClass	src/page_heap.cc	/^void PageHeap::RegisterSizeClass(Span* span, uint32 sc) {$/;"	f	class:tcmalloc::PageHeap	signature:(Span* span, uint32 sc)
tcmalloc::PageHeap::RegisterSizeClass	src/page_heap.h	/^  void RegisterSizeClass(Span* span, uint32 sc);$/;"	p	class:tcmalloc::PageHeap	access:public	signature:(Span* span, uint32 sc)
tcmalloc::PageHeap::ReleaseAtLeastNPages	src/page_heap.cc	/^Length PageHeap::ReleaseAtLeastNPages(Length num_pages) {$/;"	f	class:tcmalloc::PageHeap	signature:(Length num_pages)
tcmalloc::PageHeap::ReleaseAtLeastNPages	src/page_heap.h	/^  Length ReleaseAtLeastNPages(Length num_pages);$/;"	p	class:tcmalloc::PageHeap	access:public	signature:(Length num_pages)
tcmalloc::PageHeap::ReleaseLastNormalSpan	src/page_heap.cc	/^Length PageHeap::ReleaseLastNormalSpan(SpanList* slist) {$/;"	f	class:tcmalloc::PageHeap	signature:(SpanList* slist)
tcmalloc::PageHeap::ReleaseLastNormalSpan	src/page_heap.h	/^  Length ReleaseLastNormalSpan(SpanList* slist);$/;"	p	class:tcmalloc::PageHeap	access:private	signature:(SpanList* slist)
tcmalloc::PageHeap::RemoveFromFreeList	src/page_heap.cc	/^void PageHeap::RemoveFromFreeList(Span* span) {$/;"	f	class:tcmalloc::PageHeap	signature:(Span* span)
tcmalloc::PageHeap::RemoveFromFreeList	src/page_heap.h	/^  void RemoveFromFreeList(Span* span);$/;"	p	class:tcmalloc::PageHeap	access:private	signature:(Span* span)
tcmalloc::PageHeap::SearchFreeAndLargeLists	src/page_heap.cc	/^Span* PageHeap::SearchFreeAndLargeLists(Length n) {$/;"	f	class:tcmalloc::PageHeap	signature:(Length n)
tcmalloc::PageHeap::SearchFreeAndLargeLists	src/page_heap.h	/^  Span* SearchFreeAndLargeLists(Length n);$/;"	p	class:tcmalloc::PageHeap	access:private	signature:(Length n)
tcmalloc::PageHeap::SetAggressiveDecommit	src/page_heap.h	/^  void SetAggressiveDecommit(bool aggressive_decommit) {$/;"	f	class:tcmalloc::PageHeap	access:public	signature:(bool aggressive_decommit)
tcmalloc::PageHeap::SetCachedSizeClass	src/page_heap.h	/^  void SetCachedSizeClass(PageID p, uint32 cl) {$/;"	f	class:tcmalloc::PageHeap	access:public	signature:(PageID p, uint32 cl)
tcmalloc::PageHeap::SmallSpanStats	src/page_heap.h	/^  struct SmallSpanStats {$/;"	s	class:tcmalloc::PageHeap	access:public
tcmalloc::PageHeap::SmallSpanStats::normal_length	src/page_heap.h	/^    int64 normal_length[kMaxPages];$/;"	m	struct:tcmalloc::PageHeap::SmallSpanStats	access:public
tcmalloc::PageHeap::SmallSpanStats::returned_length	src/page_heap.h	/^    int64 returned_length[kMaxPages];$/;"	m	struct:tcmalloc::PageHeap::SmallSpanStats	access:public
tcmalloc::PageHeap::SpanList	src/page_heap.h	/^  struct SpanList {$/;"	s	class:tcmalloc::PageHeap	access:private
tcmalloc::PageHeap::SpanList::normal	src/page_heap.h	/^    Span        normal;$/;"	m	struct:tcmalloc::PageHeap::SpanList	access:public
tcmalloc::PageHeap::SpanList::returned	src/page_heap.h	/^    Span        returned;$/;"	m	struct:tcmalloc::PageHeap::SpanList	access:public
tcmalloc::PageHeap::Split	src/page_heap.cc	/^Span* PageHeap::Split(Span* span, Length n) {$/;"	f	class:tcmalloc::PageHeap	signature:(Span* span, Length n)
tcmalloc::PageHeap::Split	src/page_heap.h	/^  Span* Split(Span* span, Length n);$/;"	p	class:tcmalloc::PageHeap	access:public	signature:(Span* span, Length n)
tcmalloc::PageHeap::Stats	src/page_heap.h	/^  struct Stats {$/;"	s	class:tcmalloc::PageHeap	access:public
tcmalloc::PageHeap::Stats::Stats	src/page_heap.h	/^    Stats() : system_bytes(0), free_bytes(0), unmapped_bytes(0), committed_bytes(0),$/;"	f	struct:tcmalloc::PageHeap::Stats	access:public	signature:()
tcmalloc::PageHeap::Stats::commit_count	src/page_heap.h	/^    uint64_t commit_count;          \/\/ Number of virtual memory commits$/;"	m	struct:tcmalloc::PageHeap::Stats	access:public
tcmalloc::PageHeap::Stats::committed_bytes	src/page_heap.h	/^    uint64_t committed_bytes;  \/\/ Bytes committed, always <= system_bytes_.$/;"	m	struct:tcmalloc::PageHeap::Stats	access:public
tcmalloc::PageHeap::Stats::decommit_count	src/page_heap.h	/^    uint64_t decommit_count;        \/\/ Number of virtual memory decommits$/;"	m	struct:tcmalloc::PageHeap::Stats	access:public
tcmalloc::PageHeap::Stats::free_bytes	src/page_heap.h	/^    uint64_t free_bytes;      \/\/ Total bytes on normal freelists$/;"	m	struct:tcmalloc::PageHeap::Stats	access:public
tcmalloc::PageHeap::Stats::reserve_count	src/page_heap.h	/^    uint64_t reserve_count;         \/\/ Number of virtual memory reserves$/;"	m	struct:tcmalloc::PageHeap::Stats	access:public
tcmalloc::PageHeap::Stats::scavenge_count	src/page_heap.h	/^    uint64_t scavenge_count;   \/\/ Number of times scavagened flush pages$/;"	m	struct:tcmalloc::PageHeap::Stats	access:public
tcmalloc::PageHeap::Stats::system_bytes	src/page_heap.h	/^    uint64_t system_bytes;    \/\/ Total bytes allocated from system$/;"	m	struct:tcmalloc::PageHeap::Stats	access:public
tcmalloc::PageHeap::Stats::total_commit_bytes	src/page_heap.h	/^    uint64_t total_commit_bytes;    \/\/ Bytes committed in lifetime of process$/;"	m	struct:tcmalloc::PageHeap::Stats	access:public
tcmalloc::PageHeap::Stats::total_decommit_bytes	src/page_heap.h	/^    uint64_t total_decommit_bytes;  \/\/ Bytes decommitted in lifetime of process$/;"	m	struct:tcmalloc::PageHeap::Stats	access:public
tcmalloc::PageHeap::Stats::total_reserve_bytes	src/page_heap.h	/^    uint64_t total_reserve_bytes;   \/\/ Bytes reserved in lifetime of process$/;"	m	struct:tcmalloc::PageHeap::Stats	access:public
tcmalloc::PageHeap::Stats::unmapped_bytes	src/page_heap.h	/^    uint64_t unmapped_bytes;  \/\/ Total bytes on returned freelists$/;"	m	struct:tcmalloc::PageHeap::Stats	access:public
tcmalloc::PageHeap::TryGetSizeClass	src/page_heap.h	/^  bool TryGetSizeClass(PageID p, uint32* out) const {$/;"	f	class:tcmalloc::PageHeap	access:public	signature:(PageID p, uint32* out) const
tcmalloc::PageHeap::aggressive_decommit_	src/page_heap.h	/^  bool aggressive_decommit_;$/;"	m	class:tcmalloc::PageHeap	access:private
tcmalloc::PageHeap::free_	src/page_heap.h	/^  SpanList free_[kMaxPages];$/;"	m	class:tcmalloc::PageHeap	access:private
tcmalloc::PageHeap::kDefaultReleaseDelay	src/page_heap.h	/^  static const int kDefaultReleaseDelay = 1 << 18;$/;"	m	class:tcmalloc::PageHeap	access:private
tcmalloc::PageHeap::kMaxReleaseDelay	src/page_heap.h	/^  static const int kMaxReleaseDelay = 1 << 20;$/;"	m	class:tcmalloc::PageHeap	access:private
tcmalloc::PageHeap::kMinSystemAlloc	src/page_heap.h	/^  static const int kMinSystemAlloc = kMaxPages;$/;"	m	class:tcmalloc::PageHeap	access:private
tcmalloc::PageHeap::kPageMapBigAllocationThreshold	src/page_heap.h	/^  static const size_t kPageMapBigAllocationThreshold = 128 << 20;$/;"	m	class:tcmalloc::PageHeap	access:private
tcmalloc::PageHeap::large_	src/page_heap.h	/^  SpanList large_;$/;"	m	class:tcmalloc::PageHeap	access:private
tcmalloc::PageHeap::pagemap_	src/page_heap.h	/^  PageMap pagemap_;$/;"	m	class:tcmalloc::PageHeap	access:private
tcmalloc::PageHeap::pagemap_cache_	src/page_heap.h	/^  mutable PageMapCache pagemap_cache_;$/;"	m	class:tcmalloc::PageHeap	access:private
tcmalloc::PageHeap::release_index_	src/page_heap.h	/^  int release_index_;$/;"	m	class:tcmalloc::PageHeap	access:private
tcmalloc::PageHeap::scavenge_counter_	src/page_heap.h	/^  int64_t scavenge_counter_;$/;"	m	class:tcmalloc::PageHeap	access:private
tcmalloc::PageHeap::stats	src/page_heap.h	/^  inline Stats stats() const { return stats_; }$/;"	f	class:tcmalloc::PageHeap	access:public	signature:() const
tcmalloc::PageHeap::stats_	src/page_heap.h	/^  Stats stats_;$/;"	m	class:tcmalloc::PageHeap	access:private
tcmalloc::PageHeapAllocator	src/page_heap_allocator.h	/^class PageHeapAllocator {$/;"	c	namespace:tcmalloc
tcmalloc::PageHeapAllocator::Delete	src/page_heap_allocator.h	/^  void Delete(T* p) {$/;"	f	class:tcmalloc::PageHeapAllocator	access:public	signature:(T* p)
tcmalloc::PageHeapAllocator::Init	src/page_heap_allocator.h	/^  void Init() {$/;"	f	class:tcmalloc::PageHeapAllocator	access:public	signature:()
tcmalloc::PageHeapAllocator::New	src/page_heap_allocator.h	/^  T* New() {$/;"	f	class:tcmalloc::PageHeapAllocator	access:public	signature:()
tcmalloc::PageHeapAllocator::free_area_	src/page_heap_allocator.h	/^  char* free_area_;$/;"	m	class:tcmalloc::PageHeapAllocator	access:private
tcmalloc::PageHeapAllocator::free_avail_	src/page_heap_allocator.h	/^  size_t free_avail_;$/;"	m	class:tcmalloc::PageHeapAllocator	access:private
tcmalloc::PageHeapAllocator::free_list_	src/page_heap_allocator.h	/^  void* free_list_;$/;"	m	class:tcmalloc::PageHeapAllocator	access:private
tcmalloc::PageHeapAllocator::inuse	src/page_heap_allocator.h	/^  int inuse() const { return inuse_; }$/;"	f	class:tcmalloc::PageHeapAllocator	access:public	signature:() const
tcmalloc::PageHeapAllocator::inuse_	src/page_heap_allocator.h	/^  int inuse_;$/;"	m	class:tcmalloc::PageHeapAllocator	access:private
tcmalloc::PageHeapAllocator::kAllocIncrement	src/page_heap_allocator.h	/^  static const int kAllocIncrement = 128 << 10;$/;"	m	class:tcmalloc::PageHeapAllocator	access:private
tcmalloc::RecordGrowth	src/page_heap.cc	/^static void RecordGrowth(size_t growth) {$/;"	f	namespace:tcmalloc	signature:(size_t growth)
tcmalloc::SLL_Next	src/linked_list.h	/^inline void *SLL_Next(void *t) {$/;"	f	namespace:tcmalloc	signature:(void *t)
tcmalloc::SLL_Pop	src/linked_list.h	/^inline void *SLL_Pop(void **list) {$/;"	f	namespace:tcmalloc	signature:(void **list)
tcmalloc::SLL_PopRange	src/linked_list.h	/^inline void SLL_PopRange(void **head, int N, void **start, void **end) {$/;"	f	namespace:tcmalloc	signature:(void **head, int N, void **start, void **end)
tcmalloc::SLL_Push	src/linked_list.h	/^inline void SLL_Push(void **list, void *element) {$/;"	f	namespace:tcmalloc	signature:(void **list, void *element)
tcmalloc::SLL_PushRange	src/linked_list.h	/^inline void SLL_PushRange(void **head, void *start, void *end) {$/;"	f	namespace:tcmalloc	signature:(void **head, void *start, void *end)
tcmalloc::SLL_SetNext	src/linked_list.h	/^inline void SLL_SetNext(void *t, void *n) {$/;"	f	namespace:tcmalloc	signature:(void *t, void *n)
tcmalloc::SLL_Size	src/linked_list.h	/^inline size_t SLL_Size(void *head) {$/;"	f	namespace:tcmalloc	signature:(void *head)
tcmalloc::SLL_TryPop	src/linked_list.h	/^inline bool SLL_TryPop(void **list, void **rv) {$/;"	f	namespace:tcmalloc	signature:(void **list, void **rv)
tcmalloc::Sampler	src/sampler.h	/^class PERFTOOLS_DLL_DECL Sampler {$/;"	c	namespace:tcmalloc
tcmalloc::Sampler::GetSamplePeriod	src/sampler.cc	/^int Sampler::GetSamplePeriod() {$/;"	f	class:tcmalloc::Sampler	signature:()
tcmalloc::Sampler::GetSamplePeriod	src/sampler.h	/^  static int GetSamplePeriod();$/;"	p	class:tcmalloc::Sampler	access:public	signature:()
tcmalloc::Sampler::Init	src/sampler.cc	/^void Sampler::Init(uint64_t seed) {$/;"	f	class:tcmalloc::Sampler	signature:(uint64_t seed)
tcmalloc::Sampler::Init	src/sampler.h	/^  void Init(uint64_t seed);$/;"	p	class:tcmalloc::Sampler	access:public	signature:(uint64_t seed)
tcmalloc::Sampler::NextRandom	src/sampler.h	/^  static uint64_t NextRandom(uint64_t rnd_);  \/\/ Returns the next prng value$/;"	p	class:tcmalloc::Sampler	access:public	signature:(uint64_t rnd_)
tcmalloc::Sampler::NextRandom	src/sampler.h	/^inline uint64_t Sampler::NextRandom(uint64_t rnd) {$/;"	f	class:tcmalloc::Sampler	signature:(uint64_t rnd)
tcmalloc::Sampler::PickNextSamplingPoint	src/sampler.cc	/^ssize_t Sampler::PickNextSamplingPoint() {$/;"	f	class:tcmalloc::Sampler	signature:()
tcmalloc::Sampler::PickNextSamplingPoint	src/sampler.h	/^  ssize_t PickNextSamplingPoint();$/;"	p	class:tcmalloc::Sampler	access:public	signature:()
tcmalloc::Sampler::RecordAllocation	src/sampler.h	/^  bool RecordAllocation(size_t k);$/;"	p	class:tcmalloc::Sampler	access:public	signature:(size_t k)
tcmalloc::Sampler::RecordAllocation	src/sampler.h	/^inline bool Sampler::RecordAllocation(size_t k) {$/;"	f	class:tcmalloc::Sampler	signature:(size_t k)
tcmalloc::Sampler::RecordAllocationSlow	src/sampler.cc	/^bool Sampler::RecordAllocationSlow(size_t k) {$/;"	f	class:tcmalloc::Sampler	signature:(size_t k)
tcmalloc::Sampler::RecordAllocationSlow	src/sampler.h	/^  bool RecordAllocationSlow(size_t k);$/;"	p	class:tcmalloc::Sampler	access:private	signature:(size_t k)
tcmalloc::Sampler::TryRecordAllocationFast	src/sampler.h	/^  bool TryRecordAllocationFast(size_t k);$/;"	p	class:tcmalloc::Sampler	access:public	signature:(size_t k)
tcmalloc::Sampler::TryRecordAllocationFast	src/sampler.h	/^inline bool Sampler::TryRecordAllocationFast(size_t k) {$/;"	f	class:tcmalloc::Sampler	signature:(size_t k)
tcmalloc::Sampler::bytes_until_sample_	src/sampler.h	/^  ssize_t bytes_until_sample_;$/;"	m	class:tcmalloc::Sampler	access:public
tcmalloc::Sampler::initialized_	src/sampler.h	/^  bool initialized_;$/;"	m	class:tcmalloc::Sampler	access:public
tcmalloc::Sampler::rnd_	src/sampler.h	/^  uint64_t rnd_;  \/\/ Cheap random number generator$/;"	m	class:tcmalloc::Sampler	access:public
tcmalloc::SizeMap	src/common.h	/^class SizeMap {$/;"	c	namespace:tcmalloc
tcmalloc::SizeMap::ByteSizeForClass	src/common.h	/^  inline int32 ATTRIBUTE_ALWAYS_INLINE ByteSizeForClass(uint32 cl) {$/;"	f	class:tcmalloc::SizeMap	access:public	signature:(uint32 cl)
tcmalloc::SizeMap::ClassIndex	src/common.h	/^  static inline size_t ClassIndex(size_t s) {$/;"	f	class:tcmalloc::SizeMap	access:private	signature:(size_t s)
tcmalloc::SizeMap::ClassIndexMaybe	src/common.h	/^  static inline bool ATTRIBUTE_ALWAYS_INLINE ClassIndexMaybe(size_t s,$/;"	f	class:tcmalloc::SizeMap	access:private	signature:(size_t s, uint32* idx)
tcmalloc::SizeMap::GetSizeClass	src/common.h	/^  inline bool ATTRIBUTE_ALWAYS_INLINE GetSizeClass(size_t size, uint32* cl) {$/;"	f	class:tcmalloc::SizeMap	access:public	signature:(size_t size, uint32* cl)
tcmalloc::SizeMap::Init	src/common.cc	/^void SizeMap::Init() {$/;"	f	class:tcmalloc::SizeMap	signature:()
tcmalloc::SizeMap::Init	src/common.h	/^  void Init();$/;"	p	class:tcmalloc::SizeMap	access:public	signature:()
tcmalloc::SizeMap::LargeSizeClass	src/common.h	/^  static inline size_t LargeSizeClass(size_t s) {$/;"	f	class:tcmalloc::SizeMap	access:private	signature:(size_t s)
tcmalloc::SizeMap::NumMoveSize	src/common.cc	/^int SizeMap::NumMoveSize(size_t size) {$/;"	f	class:tcmalloc::SizeMap	signature:(size_t size)
tcmalloc::SizeMap::NumMoveSize	src/common.h	/^  int NumMoveSize(size_t size);$/;"	p	class:tcmalloc::SizeMap	access:private	signature:(size_t size)
tcmalloc::SizeMap::SizeClass	src/common.h	/^  inline int SizeClass(size_t size) {$/;"	f	class:tcmalloc::SizeMap	access:public	signature:(size_t size)
tcmalloc::SizeMap::SizeMap	src/common.h	/^  SizeMap() { }$/;"	f	class:tcmalloc::SizeMap	access:public	signature:()
tcmalloc::SizeMap::SmallSizeClass	src/common.h	/^  static inline size_t SmallSizeClass(size_t s) {$/;"	f	class:tcmalloc::SizeMap	access:private	signature:(size_t s)
tcmalloc::SizeMap::class_array_	src/common.h	/^  unsigned char class_array_[kClassArraySize];$/;"	m	class:tcmalloc::SizeMap	access:private
tcmalloc::SizeMap::class_to_pages	src/common.h	/^  inline size_t class_to_pages(uint32 cl) {$/;"	f	class:tcmalloc::SizeMap	access:public	signature:(uint32 cl)
tcmalloc::SizeMap::class_to_pages_	src/common.h	/^  size_t class_to_pages_[kClassSizesMax];$/;"	m	class:tcmalloc::SizeMap	access:private
tcmalloc::SizeMap::class_to_size	src/common.h	/^  inline int32 class_to_size(uint32 cl) {$/;"	f	class:tcmalloc::SizeMap	access:public	signature:(uint32 cl)
tcmalloc::SizeMap::class_to_size_	src/common.h	/^  int32 class_to_size_[kClassSizesMax];$/;"	m	class:tcmalloc::SizeMap	access:private
tcmalloc::SizeMap::kClassArraySize	src/common.h	/^  static const size_t kClassArraySize =$/;"	m	class:tcmalloc::SizeMap	access:private
tcmalloc::SizeMap::kMaxSmallSize	src/common.h	/^  static const int kMaxSmallSize = 1024;$/;"	m	class:tcmalloc::SizeMap	access:private
tcmalloc::SizeMap::num_objects_to_move	src/common.h	/^  inline int num_objects_to_move(uint32 cl) {$/;"	f	class:tcmalloc::SizeMap	access:public	signature:(uint32 cl)
tcmalloc::SizeMap::num_objects_to_move_	src/common.h	/^  int num_objects_to_move_[kClassSizesMax];$/;"	m	class:tcmalloc::SizeMap	access:private
tcmalloc::SizeMap::num_size_classes	src/common.h	/^  size_t num_size_classes;$/;"	m	class:tcmalloc::SizeMap	access:public
tcmalloc::Span	src/span.h	/^struct Span {$/;"	s	namespace:tcmalloc
tcmalloc::Span::IN_USE	src/span.h	/^  enum { IN_USE, ON_NORMAL_FREELIST, ON_RETURNED_FREELIST };$/;"	e	enum:tcmalloc::Span::__anon6
tcmalloc::Span::ON_NORMAL_FREELIST	src/span.h	/^  enum { IN_USE, ON_NORMAL_FREELIST, ON_RETURNED_FREELIST };$/;"	e	enum:tcmalloc::Span::__anon6
tcmalloc::Span::ON_RETURNED_FREELIST	src/span.h	/^  enum { IN_USE, ON_NORMAL_FREELIST, ON_RETURNED_FREELIST };$/;"	e	enum:tcmalloc::Span::__anon6
tcmalloc::Span::history	src/span.h	/^  char history[64];$/;"	m	struct:tcmalloc::Span	access:public
tcmalloc::Span::length	src/span.h	/^  Length        length;         \/\/ Number of pages in span$/;"	m	struct:tcmalloc::Span	access:public
tcmalloc::Span::location	src/span.h	/^  unsigned int  location : 2;   \/\/ Is the span on a freelist, and if so, which?$/;"	m	struct:tcmalloc::Span	access:public
tcmalloc::Span::next	src/span.h	/^  Span*         next;           \/\/ Used when in link list$/;"	m	struct:tcmalloc::Span	access:public
tcmalloc::Span::nexthistory	src/span.h	/^  int nexthistory;$/;"	m	struct:tcmalloc::Span	access:public
tcmalloc::Span::objects	src/span.h	/^  void*         objects;        \/\/ Linked list of free objects$/;"	m	struct:tcmalloc::Span	access:public
tcmalloc::Span::prev	src/span.h	/^  Span*         prev;           \/\/ Used when in link list$/;"	m	struct:tcmalloc::Span	access:public
tcmalloc::Span::refcount	src/span.h	/^  unsigned int  refcount : 16;  \/\/ Number of non-free objects$/;"	m	struct:tcmalloc::Span	access:public
tcmalloc::Span::sample	src/span.h	/^  unsigned int  sample : 1;     \/\/ Sampled object?$/;"	m	struct:tcmalloc::Span	access:public
tcmalloc::Span::sizeclass	src/span.h	/^  unsigned int  sizeclass : 8;  \/\/ Size-class for small objects (or 0)$/;"	m	struct:tcmalloc::Span	access:public
tcmalloc::Span::start	src/span.h	/^  PageID        start;          \/\/ Starting page number$/;"	m	struct:tcmalloc::Span	access:public
tcmalloc::Span::value	src/span.h	/^  int value[64];$/;"	m	struct:tcmalloc::Span	access:public
tcmalloc::StackTrace	src/common.h	/^struct StackTrace {$/;"	s	namespace:tcmalloc
tcmalloc::StackTrace::depth	src/common.h	/^  uintptr_t depth;         \/\/ Number of PC values stored in array below$/;"	m	struct:tcmalloc::StackTrace	access:public
tcmalloc::StackTrace::size	src/common.h	/^  uintptr_t size;          \/\/ Size of object$/;"	m	struct:tcmalloc::StackTrace	access:public
tcmalloc::StackTrace::stack	src/common.h	/^  void*     stack[kMaxStackDepth];$/;"	m	struct:tcmalloc::StackTrace	access:public
tcmalloc::StackTraceTable	src/stack_trace_table.h	/^class PERFTOOLS_DLL_DECL StackTraceTable {$/;"	c	namespace:tcmalloc
tcmalloc::StackTraceTable::AddTrace	src/stack_trace_table.cc	/^void StackTraceTable::AddTrace(const StackTrace& t) {$/;"	f	class:tcmalloc::StackTraceTable	signature:(const StackTrace& t)
tcmalloc::StackTraceTable::AddTrace	src/stack_trace_table.h	/^  void AddTrace(const StackTrace& t);$/;"	p	class:tcmalloc::StackTraceTable	access:public	signature:(const StackTrace& t)
tcmalloc::StackTraceTable::Bucket	src/stack_trace_table.h	/^  struct Bucket {$/;"	s	class:tcmalloc::StackTraceTable	access:public
tcmalloc::StackTraceTable::Bucket::KeyEqual	src/stack_trace_table.cc	/^bool StackTraceTable::Bucket::KeyEqual(uintptr_t h,$/;"	f	class:tcmalloc::StackTraceTable::Bucket	signature:(uintptr_t h, const StackTrace& t) const
tcmalloc::StackTraceTable::Bucket::KeyEqual	src/stack_trace_table.h	/^    bool KeyEqual(uintptr_t h, const StackTrace& t) const;$/;"	p	struct:tcmalloc::StackTraceTable::Bucket	access:public	signature:(uintptr_t h, const StackTrace& t) const
tcmalloc::StackTraceTable::Bucket::count	src/stack_trace_table.h	/^    int count;$/;"	m	struct:tcmalloc::StackTraceTable::Bucket	access:public
tcmalloc::StackTraceTable::Bucket::hash	src/stack_trace_table.h	/^    uintptr_t hash;$/;"	m	struct:tcmalloc::StackTraceTable::Bucket	access:public
tcmalloc::StackTraceTable::Bucket::next	src/stack_trace_table.h	/^    Bucket* next;$/;"	m	struct:tcmalloc::StackTraceTable::Bucket	access:public
tcmalloc::StackTraceTable::Bucket::trace	src/stack_trace_table.h	/^    StackTrace trace;$/;"	m	struct:tcmalloc::StackTraceTable::Bucket	access:public
tcmalloc::StackTraceTable::ReadStackTracesAndClear	src/stack_trace_table.cc	/^void** StackTraceTable::ReadStackTracesAndClear() {$/;"	f	class:tcmalloc::StackTraceTable	signature:()
tcmalloc::StackTraceTable::ReadStackTracesAndClear	src/stack_trace_table.h	/^  void** ReadStackTracesAndClear();$/;"	p	class:tcmalloc::StackTraceTable	access:public	signature:()
tcmalloc::StackTraceTable::StackTraceTable	src/stack_trace_table.cc	/^StackTraceTable::StackTraceTable()$/;"	f	class:tcmalloc::StackTraceTable	signature:()
tcmalloc::StackTraceTable::StackTraceTable	src/stack_trace_table.h	/^  StackTraceTable();$/;"	p	class:tcmalloc::StackTraceTable	access:public	signature:()
tcmalloc::StackTraceTable::bucket_total	src/stack_trace_table.h	/^  int bucket_total() const { return bucket_total_; }$/;"	f	class:tcmalloc::StackTraceTable	access:public	signature:() const
tcmalloc::StackTraceTable::bucket_total_	src/stack_trace_table.h	/^  int bucket_total_;$/;"	m	class:tcmalloc::StackTraceTable	access:private
tcmalloc::StackTraceTable::depth_total	src/stack_trace_table.h	/^  int depth_total() const { return depth_total_; }$/;"	f	class:tcmalloc::StackTraceTable	access:public	signature:() const
tcmalloc::StackTraceTable::depth_total_	src/stack_trace_table.h	/^  int depth_total_;$/;"	m	class:tcmalloc::StackTraceTable	access:private
tcmalloc::StackTraceTable::error_	src/stack_trace_table.h	/^  bool error_;$/;"	m	class:tcmalloc::StackTraceTable	access:private
tcmalloc::StackTraceTable::kHashTableSize	src/stack_trace_table.h	/^  static const int kHashTableSize = 1 << 14; \/\/ => table_ is 128k$/;"	m	class:tcmalloc::StackTraceTable	access:private
tcmalloc::StackTraceTable::table_	src/stack_trace_table.h	/^  Bucket** table_;$/;"	m	class:tcmalloc::StackTraceTable	access:private
tcmalloc::StackTraceTable::~StackTraceTable	src/stack_trace_table.cc	/^StackTraceTable::~StackTraceTable() {$/;"	f	class:tcmalloc::StackTraceTable	signature:()
tcmalloc::StackTraceTable::~StackTraceTable	src/stack_trace_table.h	/^  ~StackTraceTable();$/;"	p	class:tcmalloc::StackTraceTable	access:public	signature:()
tcmalloc::Static	src/static_vars.h	/^class Static {$/;"	c	namespace:tcmalloc
tcmalloc::Static::InitLateMaybeRecursive	src/static_vars.cc	/^void Static::InitLateMaybeRecursive() {$/;"	f	class:tcmalloc::Static	signature:()
tcmalloc::Static::InitLateMaybeRecursive	src/static_vars.h	/^  static void InitLateMaybeRecursive();$/;"	p	class:tcmalloc::Static	access:public	signature:()
tcmalloc::Static::InitStaticVars	src/static_vars.cc	/^void Static::InitStaticVars() {$/;"	f	class:tcmalloc::Static	signature:()
tcmalloc::Static::InitStaticVars	src/static_vars.h	/^  static void InitStaticVars();$/;"	p	class:tcmalloc::Static	access:public	signature:()
tcmalloc::Static::IsInited	src/static_vars.h	/^  static bool IsInited() { return inited_; }$/;"	f	class:tcmalloc::Static	access:public	signature:()
tcmalloc::Static::PageHeapStorage	src/static_vars.h	/^  union PageHeapStorage {$/;"	u	class:tcmalloc::Static	access:private
tcmalloc::Static::PageHeapStorage::extra	src/static_vars.h	/^    uintptr_t extra;  \/\/ To force alignment$/;"	m	union:tcmalloc::Static::PageHeapStorage	access:public
tcmalloc::Static::PageHeapStorage::memory	src/static_vars.h	/^    char memory[sizeof(PageHeap)];$/;"	m	union:tcmalloc::Static::PageHeapStorage	access:public
tcmalloc::Static::bucket_allocator	src/static_vars.h	/^  static PageHeapAllocator<StackTraceTable::Bucket>* bucket_allocator() {$/;"	f	class:tcmalloc::Static	access:public	signature:()
tcmalloc::Static::bucket_allocator_	src/static_vars.cc	/^PageHeapAllocator<StackTraceTable::Bucket> Static::bucket_allocator_;$/;"	m	class:tcmalloc::Static	file:
tcmalloc::Static::bucket_allocator_	src/static_vars.h	/^  ATTRIBUTE_HIDDEN static PageHeapAllocator<StackTraceTable::Bucket> bucket_allocator_;$/;"	m	class:tcmalloc::Static	access:private
tcmalloc::Static::central_cache	src/static_vars.h	/^  static CentralFreeListPadded* central_cache() { return central_cache_; }$/;"	f	class:tcmalloc::Static	access:public	signature:()
tcmalloc::Static::central_cache_	src/static_vars.cc	/^CentralFreeListPadded Static::central_cache_[kClassSizesMax];$/;"	m	class:tcmalloc::Static	file:
tcmalloc::Static::central_cache_	src/static_vars.h	/^  ATTRIBUTE_HIDDEN static CentralFreeListPadded central_cache_[kClassSizesMax];$/;"	m	class:tcmalloc::Static	access:private
tcmalloc::Static::growth_stacks	src/static_vars.h	/^  static StackTrace* growth_stacks() { return growth_stacks_; }$/;"	f	class:tcmalloc::Static	access:public	signature:()
tcmalloc::Static::growth_stacks_	src/static_vars.cc	/^StackTrace* Static::growth_stacks_ = NULL;$/;"	m	class:tcmalloc::Static	file:
tcmalloc::Static::growth_stacks_	src/static_vars.h	/^  ATTRIBUTE_HIDDEN static StackTrace* growth_stacks_;$/;"	m	class:tcmalloc::Static	access:private
tcmalloc::Static::inited_	src/static_vars.cc	/^bool Static::inited_;$/;"	m	class:tcmalloc::Static	file:
tcmalloc::Static::inited_	src/static_vars.h	/^  \/* ATTRIBUTE_HIDDEN *\/ static bool inited_;$/;"	m	class:tcmalloc::Static	access:private
tcmalloc::Static::num_size_classes	src/static_vars.h	/^  static unsigned num_size_classes() { return sizemap_.num_size_classes; }$/;"	f	class:tcmalloc::Static	access:public	signature:()
tcmalloc::Static::pageheap	src/static_vars.h	/^  static PageHeap* pageheap() { return reinterpret_cast<PageHeap *>(&pageheap_.memory); }$/;"	f	class:tcmalloc::Static	access:public	signature:()
tcmalloc::Static::pageheap_	src/static_vars.cc	/^Static::PageHeapStorage Static::pageheap_;$/;"	m	class:tcmalloc::Static	file:
tcmalloc::Static::pageheap_	src/static_vars.h	/^  ATTRIBUTE_HIDDEN static PageHeapStorage pageheap_;$/;"	m	class:tcmalloc::Static	access:private
tcmalloc::Static::pageheap_lock	src/static_vars.h	/^  static SpinLock* pageheap_lock() { return &pageheap_lock_; }$/;"	f	class:tcmalloc::Static	access:public	signature:()
tcmalloc::Static::pageheap_lock_	src/static_vars.cc	/^SpinLock Static::pageheap_lock_(SpinLock::LINKER_INITIALIZED);$/;"	p	class:tcmalloc::Static	file:	signature:(SpinLock::LINKER_INITIALIZED)
tcmalloc::Static::pageheap_lock_	src/static_vars.h	/^  \/* ATTRIBUTE_HIDDEN *\/ static SpinLock pageheap_lock_;$/;"	m	class:tcmalloc::Static	access:private
tcmalloc::Static::sampled_objects	src/static_vars.h	/^  static Span* sampled_objects() { return &sampled_objects_; }$/;"	f	class:tcmalloc::Static	access:public	signature:()
tcmalloc::Static::sampled_objects_	src/static_vars.cc	/^Span Static::sampled_objects_;$/;"	m	class:tcmalloc::Static	file:
tcmalloc::Static::sampled_objects_	src/static_vars.h	/^  ATTRIBUTE_HIDDEN static Span sampled_objects_;$/;"	m	class:tcmalloc::Static	access:private
tcmalloc::Static::set_growth_stacks	src/static_vars.h	/^  static void set_growth_stacks(StackTrace* s) { growth_stacks_ = s; }$/;"	f	class:tcmalloc::Static	access:public	signature:(StackTrace* s)
tcmalloc::Static::sizemap	src/static_vars.h	/^  static SizeMap* sizemap() { return &sizemap_; }$/;"	f	class:tcmalloc::Static	access:public	signature:()
tcmalloc::Static::sizemap_	src/static_vars.cc	/^SizeMap Static::sizemap_;$/;"	m	class:tcmalloc::Static	file:
tcmalloc::Static::sizemap_	src/static_vars.h	/^  ATTRIBUTE_HIDDEN static SizeMap sizemap_;$/;"	m	class:tcmalloc::Static	access:private
tcmalloc::Static::span_allocator	src/static_vars.h	/^  static PageHeapAllocator<Span>* span_allocator() { return &span_allocator_; }$/;"	f	class:tcmalloc::Static	access:public	signature:()
tcmalloc::Static::span_allocator_	src/static_vars.cc	/^PageHeapAllocator<Span> Static::span_allocator_;$/;"	m	class:tcmalloc::Static	file:
tcmalloc::Static::span_allocator_	src/static_vars.h	/^  ATTRIBUTE_HIDDEN static PageHeapAllocator<Span> span_allocator_;$/;"	m	class:tcmalloc::Static	access:private
tcmalloc::Static::stacktrace_allocator	src/static_vars.h	/^  static PageHeapAllocator<StackTrace>* stacktrace_allocator() {$/;"	f	class:tcmalloc::Static	access:public	signature:()
tcmalloc::Static::stacktrace_allocator_	src/static_vars.cc	/^PageHeapAllocator<StackTrace> Static::stacktrace_allocator_;$/;"	m	class:tcmalloc::Static	file:
tcmalloc::Static::stacktrace_allocator_	src/static_vars.h	/^  ATTRIBUTE_HIDDEN static PageHeapAllocator<StackTrace> stacktrace_allocator_;$/;"	m	class:tcmalloc::Static	access:private
tcmalloc::ThreadCache	src/thread_cache.h	/^class ThreadCache {$/;"	c	namespace:tcmalloc
tcmalloc::ThreadCache::ATTR_INITIAL_EXEC	src/thread_cache.h	/^    CACHELINE_ALIGNED ATTR_INITIAL_EXEC;$/;"	m	class:tcmalloc::ThreadCache	access:private
tcmalloc::ThreadCache::Allocate	src/thread_cache.h	/^  void* Allocate(size_t size, uint32 cl, void *(*oom_handler)(size_t size));$/;"	p	class:tcmalloc::ThreadCache	access:public	signature:(size_t size, uint32 cl, void *(*oom_handler)(size_t size))
tcmalloc::ThreadCache::Allocate	src/thread_cache.h	/^inline ATTRIBUTE_ALWAYS_INLINE void* ThreadCache::Allocate($/;"	f	class:tcmalloc::ThreadCache	signature:( size_t size, uint32 cl, void *(*oom_handler)(size_t size))
tcmalloc::ThreadCache::BecomeIdle	src/thread_cache.cc	/^void ThreadCache::BecomeIdle() {$/;"	f	class:tcmalloc::ThreadCache	signature:()
tcmalloc::ThreadCache::BecomeIdle	src/thread_cache.h	/^  static void         BecomeIdle();$/;"	p	class:tcmalloc::ThreadCache	access:public	signature:()
tcmalloc::ThreadCache::BecomeTemporarilyIdle	src/thread_cache.cc	/^void ThreadCache::BecomeTemporarilyIdle() {$/;"	f	class:tcmalloc::ThreadCache	signature:()
tcmalloc::ThreadCache::BecomeTemporarilyIdle	src/thread_cache.h	/^  static void         BecomeTemporarilyIdle();$/;"	p	class:tcmalloc::ThreadCache	access:public	signature:()
tcmalloc::ThreadCache::Cleanup	src/thread_cache.cc	/^void ThreadCache::Cleanup() {$/;"	f	class:tcmalloc::ThreadCache	signature:()
tcmalloc::ThreadCache::Cleanup	src/thread_cache.h	/^  void Cleanup();$/;"	p	class:tcmalloc::ThreadCache	access:public	signature:()
tcmalloc::ThreadCache::CreateCacheIfNecessary	src/thread_cache.cc	/^ThreadCache* ThreadCache::CreateCacheIfNecessary() {$/;"	f	class:tcmalloc::ThreadCache	signature:()
tcmalloc::ThreadCache::CreateCacheIfNecessary	src/thread_cache.h	/^  static ThreadCache* CreateCacheIfNecessary();$/;"	p	class:tcmalloc::ThreadCache	access:public	signature:()
tcmalloc::ThreadCache::Deallocate	src/thread_cache.h	/^  void Deallocate(void* ptr, uint32 size_class);$/;"	p	class:tcmalloc::ThreadCache	access:public	signature:(void* ptr, uint32 size_class)
tcmalloc::ThreadCache::Deallocate	src/thread_cache.h	/^inline ATTRIBUTE_ALWAYS_INLINE void ThreadCache::Deallocate(void* ptr, uint32 cl) {$/;"	f	class:tcmalloc::ThreadCache	signature:(void* ptr, uint32 cl)
tcmalloc::ThreadCache::DeleteCache	src/thread_cache.cc	/^void ThreadCache::DeleteCache(ThreadCache* heap) {$/;"	f	class:tcmalloc::ThreadCache	signature:(ThreadCache* heap)
tcmalloc::ThreadCache::DeleteCache	src/thread_cache.h	/^  static void DeleteCache(ThreadCache* heap);$/;"	p	class:tcmalloc::ThreadCache	access:private	signature:(ThreadCache* heap)
tcmalloc::ThreadCache::DestroyThreadCache	src/thread_cache.cc	/^void ThreadCache::DestroyThreadCache(void* ptr) {$/;"	f	class:tcmalloc::ThreadCache	signature:(void* ptr)
tcmalloc::ThreadCache::DestroyThreadCache	src/thread_cache.h	/^  static void DestroyThreadCache(void* ptr);$/;"	p	class:tcmalloc::ThreadCache	access:private	signature:(void* ptr)
tcmalloc::ThreadCache::FetchFromCentralCache	src/thread_cache.cc	/^void* ThreadCache::FetchFromCentralCache(uint32 cl, int32_t byte_size,$/;"	f	class:tcmalloc::ThreadCache	signature:(uint32 cl, int32_t byte_size, void *(*oom_handler)(size_t size))
tcmalloc::ThreadCache::FetchFromCentralCache	src/thread_cache.h	/^  void* FetchFromCentralCache(uint32 cl, int32_t byte_size,$/;"	p	class:tcmalloc::ThreadCache	access:private	signature:(uint32 cl, int32_t byte_size, void *(*oom_handler)(size_t size))
tcmalloc::ThreadCache::FreeList	src/thread_cache.h	/^  class FreeList {$/;"	c	class:tcmalloc::ThreadCache	access:private
tcmalloc::ThreadCache::FreeList::Init	src/thread_cache.h	/^    void Init(size_t size) {$/;"	f	class:tcmalloc::ThreadCache::FreeList	access:public	signature:(size_t size)
tcmalloc::ThreadCache::FreeList::Next	src/thread_cache.h	/^    void* Next() {$/;"	f	class:tcmalloc::ThreadCache::FreeList	access:public	signature:()
tcmalloc::ThreadCache::FreeList::Pop	src/thread_cache.h	/^    void* Pop() {$/;"	f	class:tcmalloc::ThreadCache::FreeList	access:public	signature:()
tcmalloc::ThreadCache::FreeList::PopRange	src/thread_cache.h	/^    void PopRange(int N, void **start, void **end) {$/;"	f	class:tcmalloc::ThreadCache::FreeList	access:public	signature:(int N, void **start, void **end)
tcmalloc::ThreadCache::FreeList::Push	src/thread_cache.h	/^    uint32_t Push(void* ptr) {$/;"	f	class:tcmalloc::ThreadCache::FreeList	access:public	signature:(void* ptr)
tcmalloc::ThreadCache::FreeList::PushRange	src/thread_cache.h	/^    void PushRange(int N, void *start, void *end) {$/;"	f	class:tcmalloc::ThreadCache::FreeList	access:public	signature:(int N, void *start, void *end)
tcmalloc::ThreadCache::FreeList::TryPop	src/thread_cache.h	/^    bool TryPop(void **rv) {$/;"	f	class:tcmalloc::ThreadCache::FreeList	access:public	signature:(void **rv)
tcmalloc::ThreadCache::FreeList::clear_lowwatermark	src/thread_cache.h	/^    void clear_lowwatermark() { lowater_ = length_; }$/;"	f	class:tcmalloc::ThreadCache::FreeList	access:public	signature:()
tcmalloc::ThreadCache::FreeList::empty	src/thread_cache.h	/^    bool empty() const {$/;"	f	class:tcmalloc::ThreadCache::FreeList	access:public	signature:() const
tcmalloc::ThreadCache::FreeList::length	src/thread_cache.h	/^    size_t length() const {$/;"	f	class:tcmalloc::ThreadCache::FreeList	access:public	signature:() const
tcmalloc::ThreadCache::FreeList::length_	src/thread_cache.h	/^    uint16_t length_;$/;"	m	class:tcmalloc::ThreadCache::FreeList	access:private
tcmalloc::ThreadCache::FreeList::length_	src/thread_cache.h	/^    uint32_t length_;      \/\/ Current length.$/;"	m	class:tcmalloc::ThreadCache::FreeList	access:private
tcmalloc::ThreadCache::FreeList::length_overages	src/thread_cache.h	/^    size_t length_overages() const {$/;"	f	class:tcmalloc::ThreadCache::FreeList	access:public	signature:() const
tcmalloc::ThreadCache::FreeList::length_overages_	src/thread_cache.h	/^    uint16_t length_overages_;$/;"	m	class:tcmalloc::ThreadCache::FreeList	access:private
tcmalloc::ThreadCache::FreeList::length_overages_	src/thread_cache.h	/^    uint32_t length_overages_;$/;"	m	class:tcmalloc::ThreadCache::FreeList	access:private
tcmalloc::ThreadCache::FreeList::list_	src/thread_cache.h	/^    void*    list_;       \/\/ Linked list of nodes$/;"	m	class:tcmalloc::ThreadCache::FreeList	access:private
tcmalloc::ThreadCache::FreeList::lowater_	src/thread_cache.h	/^    uint16_t lowater_;$/;"	m	class:tcmalloc::ThreadCache::FreeList	access:private
tcmalloc::ThreadCache::FreeList::lowater_	src/thread_cache.h	/^    uint32_t lowater_;     \/\/ Low water mark for list length.$/;"	m	class:tcmalloc::ThreadCache::FreeList	access:private
tcmalloc::ThreadCache::FreeList::lowwatermark	src/thread_cache.h	/^    int lowwatermark() const { return lowater_; }$/;"	f	class:tcmalloc::ThreadCache::FreeList	access:public	signature:() const
tcmalloc::ThreadCache::FreeList::max_length	src/thread_cache.h	/^    size_t max_length() const {$/;"	f	class:tcmalloc::ThreadCache::FreeList	access:public	signature:() const
tcmalloc::ThreadCache::FreeList::max_length_	src/thread_cache.h	/^    uint16_t max_length_;$/;"	m	class:tcmalloc::ThreadCache::FreeList	access:private
tcmalloc::ThreadCache::FreeList::max_length_	src/thread_cache.h	/^    uint32_t max_length_;  \/\/ Dynamic max list length based on usage.$/;"	m	class:tcmalloc::ThreadCache::FreeList	access:private
tcmalloc::ThreadCache::FreeList::object_size	src/thread_cache.h	/^    int32_t object_size() const {$/;"	f	class:tcmalloc::ThreadCache::FreeList	access:public	signature:() const
tcmalloc::ThreadCache::FreeList::set_length_overages	src/thread_cache.h	/^    void set_length_overages(size_t new_count) {$/;"	f	class:tcmalloc::ThreadCache::FreeList	access:public	signature:(size_t new_count)
tcmalloc::ThreadCache::FreeList::set_max_length	src/thread_cache.h	/^    void set_max_length(size_t new_max) {$/;"	f	class:tcmalloc::ThreadCache::FreeList	access:public	signature:(size_t new_max)
tcmalloc::ThreadCache::FreeList::size_	src/thread_cache.h	/^    int32_t size_;$/;"	m	class:tcmalloc::ThreadCache::FreeList	access:private
tcmalloc::ThreadCache::GetCache	src/thread_cache.h	/^  static ThreadCache* GetCache();$/;"	p	class:tcmalloc::ThreadCache	access:public	signature:()
tcmalloc::ThreadCache::GetCache	src/thread_cache.h	/^inline ThreadCache* ThreadCache::GetCache() {$/;"	f	class:tcmalloc::ThreadCache	signature:()
tcmalloc::ThreadCache::GetCacheIfPresent	src/thread_cache.h	/^  static ThreadCache* GetCacheIfPresent();$/;"	p	class:tcmalloc::ThreadCache	access:public	signature:()
tcmalloc::ThreadCache::GetCacheIfPresent	src/thread_cache.h	/^inline ThreadCache* ThreadCache::GetCacheIfPresent() {$/;"	f	class:tcmalloc::ThreadCache	signature:()
tcmalloc::ThreadCache::GetCacheWhichMustBePresent	src/thread_cache.h	/^  static ThreadCache* GetCacheWhichMustBePresent();$/;"	p	class:tcmalloc::ThreadCache	access:public	signature:()
tcmalloc::ThreadCache::GetCacheWhichMustBePresent	src/thread_cache.h	/^inline ThreadCache* ThreadCache::GetCacheWhichMustBePresent() {$/;"	f	class:tcmalloc::ThreadCache	signature:()
tcmalloc::ThreadCache::GetFastPathCache	src/thread_cache.h	/^  static ThreadCache* GetFastPathCache();$/;"	p	class:tcmalloc::ThreadCache	access:public	signature:()
tcmalloc::ThreadCache::GetFastPathCache	src/thread_cache.h	/^inline ThreadCache* ThreadCache::GetFastPathCache() {$/;"	f	class:tcmalloc::ThreadCache	signature:()
tcmalloc::ThreadCache::GetSamplePeriod	src/thread_cache.cc	/^int ThreadCache::GetSamplePeriod() {$/;"	f	class:tcmalloc::ThreadCache	signature:()
tcmalloc::ThreadCache::GetSamplePeriod	src/thread_cache.h	/^  int GetSamplePeriod();$/;"	p	class:tcmalloc::ThreadCache	access:public	signature:()
tcmalloc::ThreadCache::GetThreadHeap	src/thread_cache.h	/^  static ThreadCache* GetThreadHeap();$/;"	p	class:tcmalloc::ThreadCache	access:public	signature:()
tcmalloc::ThreadCache::GetThreadHeap	src/thread_cache.h	/^inline ThreadCache* ThreadCache::GetThreadHeap() {$/;"	f	class:tcmalloc::ThreadCache	signature:()
tcmalloc::ThreadCache::GetThreadStats	src/thread_cache.cc	/^void ThreadCache::GetThreadStats(uint64_t* total_bytes, uint64_t* class_count) {$/;"	f	class:tcmalloc::ThreadCache	signature:(uint64_t* total_bytes, uint64_t* class_count)
tcmalloc::ThreadCache::GetThreadStats	src/thread_cache.h	/^  static void GetThreadStats(uint64_t* total_bytes, uint64_t* class_count);$/;"	p	class:tcmalloc::ThreadCache	access:public	signature:(uint64_t* total_bytes, uint64_t* class_count)
tcmalloc::ThreadCache::HeapsInUse	src/thread_cache.h	/^  static inline int HeapsInUse();$/;"	p	class:tcmalloc::ThreadCache	access:public	signature:()
tcmalloc::ThreadCache::HeapsInUse	src/thread_cache.h	/^inline int ThreadCache::HeapsInUse() {$/;"	f	class:tcmalloc::ThreadCache	signature:()
tcmalloc::ThreadCache::IncreaseCacheLimit	src/thread_cache.cc	/^void ThreadCache::IncreaseCacheLimit() {$/;"	f	class:tcmalloc::ThreadCache	signature:()
tcmalloc::ThreadCache::IncreaseCacheLimit	src/thread_cache.h	/^  void IncreaseCacheLimit();$/;"	p	class:tcmalloc::ThreadCache	access:private	signature:()
tcmalloc::ThreadCache::IncreaseCacheLimitLocked	src/thread_cache.cc	/^void ThreadCache::IncreaseCacheLimitLocked() {$/;"	f	class:tcmalloc::ThreadCache	signature:()
tcmalloc::ThreadCache::IncreaseCacheLimitLocked	src/thread_cache.h	/^  void IncreaseCacheLimitLocked();$/;"	p	class:tcmalloc::ThreadCache	access:private	signature:()
tcmalloc::ThreadCache::Init	src/thread_cache.cc	/^void ThreadCache::Init(pthread_t tid) {$/;"	f	class:tcmalloc::ThreadCache	signature:(pthread_t tid)
tcmalloc::ThreadCache::Init	src/thread_cache.h	/^  void Init(pthread_t tid);$/;"	p	class:tcmalloc::ThreadCache	access:public	signature:(pthread_t tid)
tcmalloc::ThreadCache::InitModule	src/thread_cache.cc	/^void ThreadCache::InitModule() {$/;"	f	class:tcmalloc::ThreadCache	signature:()
tcmalloc::ThreadCache::InitModule	src/thread_cache.h	/^  static void         InitModule();$/;"	p	class:tcmalloc::ThreadCache	access:public	signature:()
tcmalloc::ThreadCache::InitTSD	src/thread_cache.cc	/^void ThreadCache::InitTSD() {$/;"	f	class:tcmalloc::ThreadCache	signature:()
tcmalloc::ThreadCache::InitTSD	src/thread_cache.h	/^  static void         InitTSD();$/;"	p	class:tcmalloc::ThreadCache	access:public	signature:()
tcmalloc::ThreadCache::IsUseEmergencyMalloc	src/thread_cache.h	/^  static bool         IsUseEmergencyMalloc();$/;"	p	class:tcmalloc::ThreadCache	access:public	signature:()
tcmalloc::ThreadCache::IsUseEmergencyMalloc	src/thread_cache.h	/^inline bool ThreadCache::IsUseEmergencyMalloc() {$/;"	f	class:tcmalloc::ThreadCache	signature:()
tcmalloc::ThreadCache::ListTooLong	src/thread_cache.cc	/^void ThreadCache::ListTooLong(FreeList* list, uint32 cl) {$/;"	f	class:tcmalloc::ThreadCache	signature:(FreeList* list, uint32 cl)
tcmalloc::ThreadCache::ListTooLong	src/thread_cache.h	/^  void ListTooLong(FreeList* src, uint32 cl);$/;"	p	class:tcmalloc::ThreadCache	access:private	signature:(FreeList* src, uint32 cl)
tcmalloc::ThreadCache::ListTooLong	src/thread_cache.h	/^  void ListTooLong(void* ptr, uint32 cl);$/;"	p	class:tcmalloc::ThreadCache	access:private	signature:(void* ptr, uint32 cl)
tcmalloc::ThreadCache::NewHeap	src/thread_cache.cc	/^ThreadCache* ThreadCache::NewHeap(pthread_t tid) {$/;"	f	class:tcmalloc::ThreadCache	signature:(pthread_t tid)
tcmalloc::ThreadCache::NewHeap	src/thread_cache.h	/^  static ThreadCache* NewHeap(pthread_t tid);$/;"	p	class:tcmalloc::ThreadCache	access:private	signature:(pthread_t tid)
tcmalloc::ThreadCache::RecomputePerThreadCacheSize	src/thread_cache.cc	/^void ThreadCache::RecomputePerThreadCacheSize() {$/;"	f	class:tcmalloc::ThreadCache	signature:()
tcmalloc::ThreadCache::RecomputePerThreadCacheSize	src/thread_cache.h	/^  static void RecomputePerThreadCacheSize();$/;"	p	class:tcmalloc::ThreadCache	access:private	signature:()
tcmalloc::ThreadCache::ReleaseToCentralCache	src/thread_cache.cc	/^void ThreadCache::ReleaseToCentralCache(FreeList* src, uint32 cl, int N) {$/;"	f	class:tcmalloc::ThreadCache	signature:(FreeList* src, uint32 cl, int N)
tcmalloc::ThreadCache::ReleaseToCentralCache	src/thread_cache.h	/^  void ReleaseToCentralCache(FreeList* src, uint32 cl, int N);$/;"	p	class:tcmalloc::ThreadCache	access:private	signature:(FreeList* src, uint32 cl, int N)
tcmalloc::ThreadCache::ResetUseEmergencyMalloc	src/thread_cache.h	/^  static void         ResetUseEmergencyMalloc();$/;"	p	class:tcmalloc::ThreadCache	access:public	signature:()
tcmalloc::ThreadCache::ResetUseEmergencyMalloc	src/thread_cache.h	/^inline void ThreadCache::ResetUseEmergencyMalloc() {$/;"	f	class:tcmalloc::ThreadCache	signature:()
tcmalloc::ThreadCache::SampleAllocation	src/thread_cache.h	/^  bool SampleAllocation(size_t k);$/;"	p	class:tcmalloc::ThreadCache	access:public	signature:(size_t k)
tcmalloc::ThreadCache::SampleAllocation	src/thread_cache.h	/^inline bool ThreadCache::SampleAllocation(size_t k) {$/;"	f	class:tcmalloc::ThreadCache	signature:(size_t k)
tcmalloc::ThreadCache::Scavenge	src/thread_cache.cc	/^void ThreadCache::Scavenge() {$/;"	f	class:tcmalloc::ThreadCache	signature:()
tcmalloc::ThreadCache::Scavenge	src/thread_cache.h	/^  void Scavenge();$/;"	p	class:tcmalloc::ThreadCache	access:public	signature:()
tcmalloc::ThreadCache::SetMaxSize	src/thread_cache.h	/^  void SetMaxSize(int32 new_max_size);$/;"	p	class:tcmalloc::ThreadCache	access:private	signature:(int32 new_max_size)
tcmalloc::ThreadCache::SetMaxSize	src/thread_cache.h	/^inline void ThreadCache::SetMaxSize(int32 new_max_size) {$/;"	f	class:tcmalloc::ThreadCache	signature:(int32 new_max_size)
tcmalloc::ThreadCache::SetUseEmergencyMalloc	src/thread_cache.h	/^  static void         SetUseEmergencyMalloc();$/;"	p	class:tcmalloc::ThreadCache	access:public	signature:()
tcmalloc::ThreadCache::SetUseEmergencyMalloc	src/thread_cache.h	/^inline void ThreadCache::SetUseEmergencyMalloc() {$/;"	f	class:tcmalloc::ThreadCache	signature:()
tcmalloc::ThreadCache::Size	src/thread_cache.h	/^  size_t Size() const { return size_; }$/;"	f	class:tcmalloc::ThreadCache	access:public	signature:() const
tcmalloc::ThreadCache::ThreadLocalData	src/thread_cache.h	/^  struct ThreadLocalData {$/;"	s	class:tcmalloc::ThreadCache	access:private
tcmalloc::ThreadCache::ThreadLocalData::fast_path_heap	src/thread_cache.h	/^    ThreadCache* fast_path_heap;$/;"	m	struct:tcmalloc::ThreadCache::ThreadLocalData	access:public
tcmalloc::ThreadCache::ThreadLocalData::heap	src/thread_cache.h	/^    ThreadCache* heap;$/;"	m	struct:tcmalloc::ThreadCache::ThreadLocalData	access:public
tcmalloc::ThreadCache::ThreadLocalData::use_emergency_malloc	src/thread_cache.h	/^    bool use_emergency_malloc;$/;"	m	struct:tcmalloc::ThreadCache::ThreadLocalData	access:public
tcmalloc::ThreadCache::TryRecordAllocationFast	src/thread_cache.h	/^  bool TryRecordAllocationFast(size_t k);$/;"	p	class:tcmalloc::ThreadCache	access:public	signature:(size_t k)
tcmalloc::ThreadCache::TryRecordAllocationFast	src/thread_cache.h	/^inline bool ThreadCache::TryRecordAllocationFast(size_t k) {$/;"	f	class:tcmalloc::ThreadCache	signature:(size_t k)
tcmalloc::ThreadCache::freelist_length	src/thread_cache.h	/^  int freelist_length(uint32 cl) const { return list_[cl].length(); }$/;"	f	class:tcmalloc::ThreadCache	access:public	signature:(uint32 cl) const
tcmalloc::ThreadCache::have_tls	src/thread_cache.h	/^  enum { have_tls = true };$/;"	e	enum:tcmalloc::ThreadCache::__anon31
tcmalloc::ThreadCache::heap_key_	src/thread_cache.cc	/^pthread_key_t ThreadCache::heap_key_;$/;"	m	class:tcmalloc::ThreadCache	file:
tcmalloc::ThreadCache::heap_key_	src/thread_cache.h	/^  static pthread_key_t heap_key_;$/;"	m	class:tcmalloc::ThreadCache	access:private
tcmalloc::ThreadCache::in_setspecific_	src/thread_cache.h	/^  bool          in_setspecific_;        \/\/ In call to pthread_setspecific?$/;"	m	class:tcmalloc::ThreadCache	access:private
tcmalloc::ThreadCache::list_	src/thread_cache.h	/^  FreeList      list_[kClassSizesMax];     \/\/ Array indexed by size-class$/;"	m	class:tcmalloc::ThreadCache	access:private
tcmalloc::ThreadCache::max_size_	src/thread_cache.h	/^  int32         max_size_;                 \/\/ size_ > max_size_ --> Scavenge()$/;"	m	class:tcmalloc::ThreadCache	access:private
tcmalloc::ThreadCache::next_	src/thread_cache.h	/^  ThreadCache* next_;$/;"	m	class:tcmalloc::ThreadCache	access:public
tcmalloc::ThreadCache::next_memory_steal_	src/thread_cache.cc	/^ThreadCache* ThreadCache::next_memory_steal_ = NULL;$/;"	m	class:tcmalloc::ThreadCache	file:
tcmalloc::ThreadCache::next_memory_steal_	src/thread_cache.h	/^  static ThreadCache* next_memory_steal_;$/;"	m	class:tcmalloc::ThreadCache	access:private
tcmalloc::ThreadCache::overall_thread_cache_size	src/thread_cache.h	/^  static size_t overall_thread_cache_size() {$/;"	f	class:tcmalloc::ThreadCache	access:public	signature:()
tcmalloc::ThreadCache::overall_thread_cache_size_	src/thread_cache.cc	/^size_t ThreadCache::overall_thread_cache_size_ = kDefaultOverallThreadCacheSize;$/;"	m	class:tcmalloc::ThreadCache	file:
tcmalloc::ThreadCache::overall_thread_cache_size_	src/thread_cache.h	/^  static size_t overall_thread_cache_size_;$/;"	m	class:tcmalloc::ThreadCache	access:private
tcmalloc::ThreadCache::per_thread_cache_size_	src/thread_cache.cc	/^volatile size_t ThreadCache::per_thread_cache_size_ = kMaxThreadCacheSize;$/;"	m	class:tcmalloc::ThreadCache	file:
tcmalloc::ThreadCache::per_thread_cache_size_	src/thread_cache.h	/^  static volatile size_t per_thread_cache_size_;$/;"	m	class:tcmalloc::ThreadCache	access:private
tcmalloc::ThreadCache::prev_	src/thread_cache.h	/^  ThreadCache* prev_;$/;"	m	class:tcmalloc::ThreadCache	access:public
tcmalloc::ThreadCache::sampler_	src/thread_cache.h	/^  Sampler       sampler_;               \/\/ A sampler$/;"	m	class:tcmalloc::ThreadCache	access:private
tcmalloc::ThreadCache::set_overall_thread_cache_size	src/thread_cache.cc	/^void ThreadCache::set_overall_thread_cache_size(size_t new_size) {$/;"	f	class:tcmalloc::ThreadCache	signature:(size_t new_size)
tcmalloc::ThreadCache::set_overall_thread_cache_size	src/thread_cache.h	/^  static void set_overall_thread_cache_size(size_t new_size);$/;"	p	class:tcmalloc::ThreadCache	access:public	signature:(size_t new_size)
tcmalloc::ThreadCache::size_	src/thread_cache.h	/^  int32         size_;                     \/\/ Combined size of data$/;"	m	class:tcmalloc::ThreadCache	access:private
tcmalloc::ThreadCache::thread_heap_count_	src/thread_cache.cc	/^int ThreadCache::thread_heap_count_ = 0;$/;"	m	class:tcmalloc::ThreadCache	file:
tcmalloc::ThreadCache::thread_heap_count_	src/thread_cache.h	/^  static int thread_heap_count_;$/;"	m	class:tcmalloc::ThreadCache	access:private
tcmalloc::ThreadCache::thread_heaps_	src/thread_cache.cc	/^ThreadCache* ThreadCache::thread_heaps_ = NULL;$/;"	m	class:tcmalloc::ThreadCache	file:
tcmalloc::ThreadCache::thread_heaps_	src/thread_cache.h	/^  static ThreadCache* thread_heaps_;$/;"	m	class:tcmalloc::ThreadCache	access:private
tcmalloc::ThreadCache::tid_	src/thread_cache.h	/^  pthread_t     tid_;                   \/\/ Which thread owns it$/;"	m	class:tcmalloc::ThreadCache	access:private
tcmalloc::ThreadCache::tsd_inited_	src/thread_cache.cc	/^bool ThreadCache::tsd_inited_ = false;$/;"	m	class:tcmalloc::ThreadCache	file:
tcmalloc::ThreadCache::tsd_inited_	src/thread_cache.h	/^  static ATTRIBUTE_HIDDEN bool tsd_inited_;$/;"	m	class:tcmalloc::ThreadCache	access:private
tcmalloc::ThreadCache::unclaimed_cache_space_	src/thread_cache.cc	/^ssize_t ThreadCache::unclaimed_cache_space_ = kDefaultOverallThreadCacheSize;$/;"	m	class:tcmalloc::ThreadCache	file:
tcmalloc::ThreadCache::unclaimed_cache_space_	src/thread_cache.h	/^  static ssize_t unclaimed_cache_space_;$/;"	m	class:tcmalloc::ThreadCache	access:private
tcmalloc::WriteMessage	src/internal_logging.cc	/^static void WriteMessage(const char* msg, int length) {$/;"	f	namespace:tcmalloc	signature:(const char* msg, int length)
tcmalloc::__anon19::LockInverter	src/central_freelist.cc	/^class LockInverter {$/;"	c	namespace:tcmalloc::__anon19	file:
tcmalloc::__anon19::LockInverter::LockInverter	src/central_freelist.cc	/^  inline explicit LockInverter(SpinLock* held, SpinLock *temp)$/;"	f	class:tcmalloc::__anon19::LockInverter	access:public	signature:(SpinLock* held, SpinLock *temp)
tcmalloc::__anon19::LockInverter::held_	src/central_freelist.cc	/^  SpinLock *held_, *temp_;$/;"	m	class:tcmalloc::__anon19::LockInverter	file:	access:private
tcmalloc::__anon19::LockInverter::temp_	src/central_freelist.cc	/^  SpinLock *held_, *temp_;$/;"	m	class:tcmalloc::__anon19::LockInverter	file:	access:private
tcmalloc::__anon19::LockInverter::~LockInverter	src/central_freelist.cc	/^  inline ~LockInverter() { temp_->Unlock(); held_->Lock();  }$/;"	f	class:tcmalloc::__anon19::LockInverter	access:public	signature:()
tcmalloc::__anon29::bytes	src/emergency_malloc.cc	/^    char bytes[sizeof(EmergencyArenaPagesAllocator)];$/;"	m	union:tcmalloc::__anon29	file:	access:public
tcmalloc::__anon29::ptr	src/emergency_malloc.cc	/^    void *ptr;$/;"	m	union:tcmalloc::__anon29	file:	access:public
tcmalloc::commandlineflags	src/base/commandlineflags.h	/^  namespace commandlineflags {$/;"	n	namespace:tcmalloc
tcmalloc::commandlineflags::StringToBool	src/base/commandlineflags.h	/^    inline bool StringToBool(const char *value, bool def) {$/;"	f	namespace:tcmalloc::commandlineflags	signature:(const char *value, bool def)
tcmalloc::commandlineflags::StringToDouble	src/base/commandlineflags.h	/^    inline double StringToDouble(const char *value, double def) {$/;"	f	namespace:tcmalloc::commandlineflags	signature:(const char *value, double def)
tcmalloc::commandlineflags::StringToInt	src/base/commandlineflags.h	/^    inline int StringToInt(const char *value, int def) {$/;"	f	namespace:tcmalloc::commandlineflags	signature:(const char *value, int def)
tcmalloc::commandlineflags::StringToLongLong	src/base/commandlineflags.h	/^    inline long long StringToLongLong(const char *value, long long def) {$/;"	f	namespace:tcmalloc::commandlineflags	signature:(const char *value, long long def)
tcmalloc::cpp_nothrow_oom	src/tcmalloc.cc	/^void* cpp_nothrow_oom(size_t size) {$/;"	f	namespace:tcmalloc	signature:(size_t size)
tcmalloc::cpp_throw_oom	src/tcmalloc.cc	/^void* cpp_throw_oom(size_t size) {$/;"	f	namespace:tcmalloc	signature:(size_t size)
tcmalloc::dispatch_allocate_full	src/tcmalloc.cc	/^static ATTRIBUTE_ALWAYS_INLINE inline void* dispatch_allocate_full(size_t size) {$/;"	f	namespace:tcmalloc	signature:(size_t size)
tcmalloc::do_allocate_full	src/tcmalloc.cc	/^static void* do_allocate_full(size_t size) {$/;"	f	namespace:tcmalloc	signature:(size_t size)
tcmalloc::emergency_arena	src/emergency_malloc.cc	/^  static LowLevelAlloc::Arena *emergency_arena;$/;"	m	namespace:tcmalloc	file:
tcmalloc::emergency_arena_end	src/emergency_malloc.cc	/^  static char *emergency_arena_end;$/;"	m	namespace:tcmalloc	file:
tcmalloc::emergency_arena_start	src/emergency_malloc.cc	/^  __attribute__ ((visibility("internal"))) char *emergency_arena_start;$/;"	m	namespace:tcmalloc	file:
tcmalloc::emergency_arena_start_shifted	src/emergency_malloc.cc	/^  __attribute__ ((visibility("internal"))) uintptr_t emergency_arena_start_shifted;$/;"	m	namespace:tcmalloc	file:
tcmalloc::emergency_malloc_lock	src/emergency_malloc.cc	/^  static CACHELINE_ALIGNED SpinLock emergency_malloc_lock(base::LINKER_INITIALIZED);$/;"	p	namespace:tcmalloc	file:	signature:(base::LINKER_INITIALIZED)
tcmalloc::invoke_hooks_and_free	src/tcmalloc.cc	/^void invoke_hooks_and_free(void *ptr) {$/;"	f	namespace:tcmalloc	signature:(void *ptr)
tcmalloc::kCrash	src/internal_logging.h	/^  kCrash,                     \/\/ Print the message and crash$/;"	e	enum:tcmalloc::LogMode
tcmalloc::kCrashWithStats	src/internal_logging.h	/^  kCrashWithStats             \/\/ Print the message, some stats, and crash$/;"	e	enum:tcmalloc::LogMode
tcmalloc::kDefaultTransferNumObjecs	src/common.cc	/^static const int32 kDefaultTransferNumObjecs = 32;$/;"	m	namespace:tcmalloc	file:
tcmalloc::kEmergencyArenaShift	src/emergency_malloc.h	/^  static const uintptr_t kEmergencyArenaShift = 20+4; \/\/ 16 megs$/;"	m	namespace:tcmalloc
tcmalloc::kEmergencyArenaSize	src/emergency_malloc.h	/^  static const uintptr_t kEmergencyArenaSize = 1 << kEmergencyArenaShift;$/;"	m	namespace:tcmalloc
tcmalloc::kForcedCoalesceInterval	src/page_heap.cc	/^static const size_t kForcedCoalesceInterval = 128*1024*1024;$/;"	m	namespace:tcmalloc	file:
tcmalloc::kLog	src/internal_logging.h	/^  kLog,                       \/\/ Just print the message$/;"	e	enum:tcmalloc::LogMode
tcmalloc::kMaxStackDepth	src/common.h	/^static const int kMaxStackDepth = 31;$/;"	m	namespace:tcmalloc
tcmalloc::kMetadataAllignment	src/common.cc	/^static const size_t kMetadataAllignment = sizeof(MemoryAligner);$/;"	m	namespace:tcmalloc	file:
tcmalloc::kMetadataAllocChunkSize	src/common.cc	/^static const size_t kMetadataAllocChunkSize = 8*1024*1024;$/;"	m	namespace:tcmalloc	file:
tcmalloc::log_message_writer	src/internal_logging.cc	/^void (*log_message_writer)(const char* msg, int length) = WriteMessage;$/;"	m	namespace:tcmalloc	file:
tcmalloc::malloc_oom	src/tcmalloc.cc	/^void* malloc_oom(size_t size) {$/;"	f	namespace:tcmalloc	signature:(size_t size)
tcmalloc::memalign_pages	src/tcmalloc.cc	/^void* memalign_pages(size_t align, size_t size,$/;"	f	namespace:tcmalloc	signature:(size_t align, size_t size, bool from_operator, bool nothrow)
tcmalloc::metadata_alloc_lock	src/common.cc	/^static SpinLock metadata_alloc_lock(SpinLock::LINKER_INITIALIZED);$/;"	p	namespace:tcmalloc	file:	signature:(SpinLock::LINKER_INITIALIZED)
tcmalloc::metadata_chunk_alloc_	src/common.cc	/^static char *metadata_chunk_alloc_;$/;"	m	namespace:tcmalloc	file:
tcmalloc::metadata_chunk_avail_	src/common.cc	/^static size_t metadata_chunk_avail_;$/;"	m	namespace:tcmalloc	file:
tcmalloc::metadata_system_bytes	src/common.cc	/^uint64_t metadata_system_bytes() { return metadata_system_bytes_; }$/;"	f	namespace:tcmalloc	signature:()
tcmalloc::metadata_system_bytes	src/common.h	/^uint64_t metadata_system_bytes();$/;"	p	namespace:tcmalloc	signature:()
tcmalloc::metadata_system_bytes_	src/common.cc	/^static uint64_t metadata_system_bytes_ = 0;$/;"	m	namespace:tcmalloc	file:
tcmalloc::pages	src/common.h	/^inline Length pages(size_t bytes) {$/;"	f	namespace:tcmalloc	signature:(size_t bytes)
tcmalloc::pages_allocator_place	src/emergency_malloc.cc	/^  } pages_allocator_place;$/;"	m	namespace:tcmalloc	typeref:union:tcmalloc::__anon29	file:
tcmalloc::phinited	src/thread_cache.cc	/^static bool phinited = false;$/;"	m	namespace:tcmalloc	file:
tcmalloc::retry_do_memalign	src/tcmalloc.cc	/^static void *retry_do_memalign(void *arg) {$/;"	f	namespace:tcmalloc	signature:(void *arg)
tcmalloc::retry_memalign_data	src/tcmalloc.cc	/^struct retry_memalign_data {$/;"	s	namespace:tcmalloc	file:
tcmalloc::retry_memalign_data::align	src/tcmalloc.cc	/^  size_t align;$/;"	m	struct:tcmalloc::retry_memalign_data	file:	access:public
tcmalloc::retry_memalign_data::size	src/tcmalloc.cc	/^  size_t size;$/;"	m	struct:tcmalloc::retry_memalign_data	file:	access:public
tcmalloc::threadcache_allocator	src/thread_cache.cc	/^PageHeapAllocator<ThreadCache> threadcache_allocator;$/;"	m	namespace:tcmalloc	file:
tcmalloc_h	src/tests/simple_compat_test.cc	/^void* (*tcmalloc_h)(size_t) = &tc_new;$/;"	v
tcmalloc_heap_limit_mb	src/tests/page_heap_test.cc	/^DECLARE_int64(tcmalloc_heap_limit_mb);$/;"	v
tcmalloc_initializer	src/heap-profiler.cc	/^static const TCMallocGuard tcmalloc_initializer;$/;"	v	file:
tcmalloc_sample_parameter	src/tests/sampler_test.cc	/^DECLARE_int64(tcmalloc_sample_parameter);$/;"	v
tcmalloc_sample_parameter	src/tests/tcmalloc_unittest.cc	/^DECLARE_int64(tcmalloc_sample_parameter);$/;"	v
tcmalloc_sample_parameter	src/thread_cache.h	/^DECLARE_int64(tcmalloc_sample_parameter);$/;"	v
tcmalloc_sized_delete_enabled	src/libc_override_gcc_and_weak.h	/^int tcmalloc_sized_delete_enabled(void);$/;"	p	signature:(void)
tcmalloc_sys_alloc	src/system-alloc.cc	/^SysAllocator* tcmalloc_sys_alloc = NULL;$/;"	v
tcmalloc_sys_alloc	src/windows/system-alloc.cc	/^SysAllocator* tcmalloc_sys_alloc = NULL;$/;"	v
tcmallocguard_refcount	src/tcmalloc.cc	/^static int tcmallocguard_refcount = 0;  \/\/ no lock needed: runs before main()$/;"	v	file:
temp_	src/central_freelist.cc	/^  SpinLock *held_, *temp_;$/;"	m	class:tcmalloc::__anon19::LockInverter	file:	access:private
test	binary_trees_shared	/^    elif test "X`{ $ECHO '\\t'; } 2>\/dev\/null`" = 'X\\t'; then$/;"	v
test	compile	/^  test "$cofile" = "$ofile" || mv "$cofile" "$ofile"$/;"	v
test	config.status	/^   test "X`expr 00001 : '.*\\(...\\)'`" = X001; then$/;"	v
test	configure	/^   test "X`expr 00001 : '.*\\(...\\)'`" = X001; then$/;"	v
test	configure	/^elif test "X$1" = X--fallback-echo; then$/;"	v
test	configure	/^elif test "X`{ $ECHO '\\t'; } 2>\/dev\/null`" = 'X\\t' ; then$/;"	v
test	current_allocated_bytes_test	/^    elif test "X`{ $ECHO '\\t'; } 2>\/dev\/null`" = 'X\\t'; then$/;"	v
test	debugallocation_test	/^    elif test "X`{ $ECHO '\\t'; } 2>\/dev\/null`" = 'X\\t'; then$/;"	v
test	frag_unittest	/^    elif test "X`{ $ECHO '\\t'; } 2>\/dev\/null`" = 'X\\t'; then$/;"	v
test	heap-checker_debug_unittest	/^    elif test "X`{ $ECHO '\\t'; } 2>\/dev\/null`" = 'X\\t'; then$/;"	v
test	heap-checker_unittest	/^    elif test "X`{ $ECHO '\\t'; } 2>\/dev\/null`" = 'X\\t'; then$/;"	v
test	heap-profiler_debug_unittest	/^    elif test "X`{ $ECHO '\\t'; } 2>\/dev\/null`" = 'X\\t'; then$/;"	v
test	heap-profiler_unittest	/^    elif test "X`{ $ECHO '\\t'; } 2>\/dev\/null`" = 'X\\t'; then$/;"	v
test	m4/libtool.m4	/^elif test "$with_gnu_ld" = yes; then$/;"	v
test	malloc_bench_shared	/^    elif test "X`{ $ECHO '\\t'; } 2>\/dev\/null`" = 'X\\t'; then$/;"	v
test	malloc_bench_shared_full	/^    elif test "X`{ $ECHO '\\t'; } 2>\/dev\/null`" = 'X\\t'; then$/;"	v
test	malloc_extension_c_test	/^    elif test "X`{ $ECHO '\\t'; } 2>\/dev\/null`" = 'X\\t'; then$/;"	v
test	malloc_extension_debug_test	/^    elif test "X`{ $ECHO '\\t'; } 2>\/dev\/null`" = 'X\\t'; then$/;"	v
test	malloc_extension_test	/^    elif test "X`{ $ECHO '\\t'; } 2>\/dev\/null`" = 'X\\t'; then$/;"	v
test	malloc_hook_test	/^    elif test "X`{ $ECHO '\\t'; } 2>\/dev\/null`" = 'X\\t'; then$/;"	v
test	markidle_unittest	/^    elif test "X`{ $ECHO '\\t'; } 2>\/dev\/null`" = 'X\\t'; then$/;"	v
test	memalign_debug_unittest	/^    elif test "X`{ $ECHO '\\t'; } 2>\/dev\/null`" = 'X\\t'; then$/;"	v
test	memalign_unittest	/^    elif test "X`{ $ECHO '\\t'; } 2>\/dev\/null`" = 'X\\t'; then$/;"	v
test	missing	/^    elif test "x$2" = "x--version" || test "x$2" = "x--help"; then$/;"	v
test	packed_cache_test	/^    elif test "X`{ $ECHO '\\t'; } 2>\/dev\/null`" = 'X\\t'; then$/;"	v
test	page_heap_test	/^    elif test "X`{ $ECHO '\\t'; } 2>\/dev\/null`" = 'X\\t'; then$/;"	v
test	pagemap_unittest	/^    elif test "X`{ $ECHO '\\t'; } 2>\/dev\/null`" = 'X\\t'; then$/;"	v
test	profile_handler_unittest	/^    elif test "X`{ $ECHO '\\t'; } 2>\/dev\/null`" = 'X\\t'; then$/;"	v
test	profiledata_unittest	/^    elif test "X`{ $ECHO '\\t'; } 2>\/dev\/null`" = 'X\\t'; then$/;"	v
test	profiler1_unittest	/^    elif test "X`{ $ECHO '\\t'; } 2>\/dev\/null`" = 'X\\t'; then$/;"	v
test	profiler2_unittest	/^    elif test "X`{ $ECHO '\\t'; } 2>\/dev\/null`" = 'X\\t'; then$/;"	v
test	profiler3_unittest	/^    elif test "X`{ $ECHO '\\t'; } 2>\/dev\/null`" = 'X\\t'; then$/;"	v
test	profiler4_unittest	/^    elif test "X`{ $ECHO '\\t'; } 2>\/dev\/null`" = 'X\\t'; then$/;"	v
test	raw_printer_test	/^    elif test "X`{ $ECHO '\\t'; } 2>\/dev\/null`" = 'X\\t'; then$/;"	v
test	realloc_debug_unittest	/^    elif test "X`{ $ECHO '\\t'; } 2>\/dev\/null`" = 'X\\t'; then$/;"	v
test	realloc_unittest	/^    elif test "X`{ $ECHO '\\t'; } 2>\/dev\/null`" = 'X\\t'; then$/;"	v
test	sampler_debug_test	/^    elif test "X`{ $ECHO '\\t'; } 2>\/dev\/null`" = 'X\\t'; then$/;"	v
test	sampler_test	/^    elif test "X`{ $ECHO '\\t'; } 2>\/dev\/null`" = 'X\\t'; then$/;"	v
test	sampling_debug_test	/^    elif test "X`{ $ECHO '\\t'; } 2>\/dev\/null`" = 'X\\t'; then$/;"	v
test	sampling_test	/^    elif test "X`{ $ECHO '\\t'; } 2>\/dev\/null`" = 'X\\t'; then$/;"	v
test	simple_compat_test	/^    elif test "X`{ $ECHO '\\t'; } 2>\/dev\/null`" = 'X\\t'; then$/;"	v
test	stack_trace_table_test	/^    elif test "X`{ $ECHO '\\t'; } 2>\/dev\/null`" = 'X\\t'; then$/;"	v
test	system_alloc_unittest	/^    elif test "X`{ $ECHO '\\t'; } 2>\/dev\/null`" = 'X\\t'; then$/;"	v
test	tags	/^test	configure	\/^elif test "X$1" = X--fallback-echo; then$\/;"	v$/;"	v
test	tcmalloc_and_profiler_unittest	/^    elif test "X`{ $ECHO '\\t'; } 2>\/dev\/null`" = 'X\\t'; then$/;"	v
test	tcmalloc_both_unittest	/^    elif test "X`{ $ECHO '\\t'; } 2>\/dev\/null`" = 'X\\t'; then$/;"	v
test	tcmalloc_debug_unittest	/^    elif test "X`{ $ECHO '\\t'; } 2>\/dev\/null`" = 'X\\t'; then$/;"	v
test	tcmalloc_large_heap_fragmentation_unittest	/^    elif test "X`{ $ECHO '\\t'; } 2>\/dev\/null`" = 'X\\t'; then$/;"	v
test	tcmalloc_large_unittest	/^    elif test "X`{ $ECHO '\\t'; } 2>\/dev\/null`" = 'X\\t'; then$/;"	v
test	tcmalloc_minimal_debug_unittest	/^    elif test "X`{ $ECHO '\\t'; } 2>\/dev\/null`" = 'X\\t'; then$/;"	v
test	tcmalloc_minimal_large_heap_fragmentation_unittest	/^    elif test "X`{ $ECHO '\\t'; } 2>\/dev\/null`" = 'X\\t'; then$/;"	v
test	tcmalloc_minimal_large_unittest	/^    elif test "X`{ $ECHO '\\t'; } 2>\/dev\/null`" = 'X\\t'; then$/;"	v
test	tcmalloc_minimal_unittest	/^    elif test "X`{ $ECHO '\\t'; } 2>\/dev\/null`" = 'X\\t'; then$/;"	v
test	tcmalloc_unittest	/^    elif test "X`{ $ECHO '\\t'; } 2>\/dev\/null`" = 'X\\t'; then$/;"	v
test	thread_dealloc_unittest	/^    elif test "X`{ $ECHO '\\t'; } 2>\/dev\/null`" = 'X\\t'; then$/;"	v
test	unwind_bench	/^    elif test "X`{ $ECHO '\\t'; } 2>\/dev\/null`" = 'X\\t'; then$/;"	v
test_arithmetic	src/tests/sampler_test.cc	/^void test_arithmetic(uint64_t rnd) {$/;"	f	signature:(uint64_t rnd)
test_counter	src/tests/debugallocation_test.cc	/^static int test_counter = 0;    \/\/ incremented every time the macro is called$/;"	v	file:
test_main_thread	src/tests/profiler_unittest.cc	/^static void test_main_thread() {$/;"	f	file:	signature:()
test_new_handler	src/tests/tcmalloc_unittest.cc	/^static void test_new_handler() {$/;"	f	namespace:testing	signature:()
test_other_thread	src/tests/profiler_unittest.cc	/^static void test_other_thread() {$/;"	f	file:	signature:()
test_sys_alloc_space	src/tests/tcmalloc_unittest.cc	/^} test_sys_alloc_space;$/;"	v	typeref:union:__anon58	file:
test_to_run	src/tests/debugallocation_test.cc	/^static int test_to_run = 0;     \/\/ set in main() based on argv$/;"	v	file:
testing	src/tests/tcmalloc_unittest.cc	/^namespace testing {$/;"	n	file:
testing::AggressiveDecommitChanger	src/tests/tcmalloc_unittest.cc	/^class AggressiveDecommitChanger {$/;"	c	namespace:testing	file:
testing::AggressiveDecommitChanger::AggressiveDecommitChanger	src/tests/tcmalloc_unittest.cc	/^  AggressiveDecommitChanger(size_t new_value) {$/;"	f	class:testing::AggressiveDecommitChanger	access:public	signature:(size_t new_value)
testing::AggressiveDecommitChanger::old_value_	src/tests/tcmalloc_unittest.cc	/^  size_t old_value_;$/;"	m	class:testing::AggressiveDecommitChanger	file:	access:private
testing::AggressiveDecommitChanger::~AggressiveDecommitChanger	src/tests/tcmalloc_unittest.cc	/^  ~AggressiveDecommitChanger() {$/;"	f	class:testing::AggressiveDecommitChanger	access:public	signature:()
testing::AllocatorState	src/tests/tcmalloc_unittest.cc	/^class AllocatorState : public TestHarness {$/;"	c	namespace:testing	file:	inherits:TestHarness
testing::AllocatorState::AllocatorState	src/tests/tcmalloc_unittest.cc	/^  explicit AllocatorState(int seed) : TestHarness(seed), memalign_fraction_(0) {$/;"	f	class:testing::AllocatorState	access:public	signature:(int seed)
testing::AllocatorState::alloc	src/tests/tcmalloc_unittest.cc	/^  void* alloc(size_t size) {$/;"	f	class:testing::AllocatorState	access:public	signature:(size_t size)
testing::AllocatorState::memalign_fraction_	src/tests/tcmalloc_unittest.cc	/^  double memalign_fraction_;$/;"	m	class:testing::AllocatorState	file:	access:private
testing::AllocatorState::~AllocatorState	src/tests/tcmalloc_unittest.cc	/^  virtual ~AllocatorState() {}$/;"	f	class:testing::AllocatorState	access:public	signature:()
testing::FLAGS_allocweight	src/tests/tcmalloc_unittest.cc	/^static const int FLAGS_allocweight = 50;    \/\/ Weight for picking allocation$/;"	m	namespace:testing	file:
testing::FLAGS_freeweight	src/tests/tcmalloc_unittest.cc	/^static const int FLAGS_freeweight = 50;     \/\/ Weight for picking free$/;"	m	namespace:testing	file:
testing::FLAGS_lg_max_memalign	src/tests/tcmalloc_unittest.cc	/^static const int FLAGS_lg_max_memalign = 18; \/\/ lg of max alignment for memalign$/;"	m	namespace:testing	file:
testing::FLAGS_lgmaxsize	src/tests/tcmalloc_unittest.cc	/^static const int FLAGS_lgmaxsize = 16;   \/\/ lg() of the max size object to alloc$/;"	m	namespace:testing	file:
testing::FLAGS_log_every_n_tests	src/tests/tcmalloc_unittest.cc	/^static const int FLAGS_log_every_n_tests = 50000; \/\/ log exactly once$/;"	m	namespace:testing	file:
testing::FLAGS_memalign_max_alignment_ratio	src/tests/tcmalloc_unittest.cc	/^static const double FLAGS_memalign_max_alignment_ratio = 6;  \/\/ alignment\/size$/;"	m	namespace:testing	file:
testing::FLAGS_memalign_max_fraction	src/tests/tcmalloc_unittest.cc	/^static const double FLAGS_memalign_max_fraction = 0.4;  \/\/ max expected%$/;"	m	namespace:testing	file:
testing::FLAGS_memalign_min_fraction	src/tests/tcmalloc_unittest.cc	/^static const double FLAGS_memalign_min_fraction = 0;    \/\/ min expected%$/;"	m	namespace:testing	file:
testing::FLAGS_numtests	src/tests/tcmalloc_unittest.cc	/^static const int FLAGS_numtests = 50000;$/;"	m	namespace:testing	file:
testing::FLAGS_numthreads	src/tests/tcmalloc_unittest.cc	/^static const int FLAGS_numthreads = 10;  \/\/ Number of threads$/;"	m	namespace:testing	file:
testing::FLAGS_passweight	src/tests/tcmalloc_unittest.cc	/^static const int FLAGS_passweight = 1;      \/\/ Weight for passing object$/;"	m	namespace:testing	file:
testing::FLAGS_threadmb	src/tests/tcmalloc_unittest.cc	/^static const int FLAGS_threadmb = 4;     \/\/ Max memory size allocated by thread$/;"	m	namespace:testing	file:
testing::FLAGS_updateweight	src/tests/tcmalloc_unittest.cc	/^static const int FLAGS_updateweight = 10;   \/\/ Weight for picking update$/;"	m	namespace:testing	file:
testing::GetUnmappedBytes	src/tests/tcmalloc_unittest.cc	/^static size_t GetUnmappedBytes() {$/;"	f	namespace:testing	signature:()
testing::GlobalNallocx	src/tests/tcmalloc_unittest.cc	/^struct GlobalNallocx {$/;"	s	namespace:testing	file:
testing::GlobalNallocx::GlobalNallocx	src/tests/tcmalloc_unittest.cc	/^  GlobalNallocx() { CHECK_GT(nallocx(99, 0), 99); }$/;"	f	struct:testing::GlobalNallocx	access:public	signature:()
testing::HaveSystemRelease	src/tests/tcmalloc_unittest.cc	/^static bool HaveSystemRelease =$/;"	m	namespace:testing	file:
testing::MAKE_HOOK_CALLBACK	src/tests/tcmalloc_unittest.cc	/^MAKE_HOOK_CALLBACK(DeleteHook, const void*);$/;"	p	namespace:testing	file:	signature:(DeleteHook, const void*)
testing::MAKE_HOOK_CALLBACK	src/tests/tcmalloc_unittest.cc	/^MAKE_HOOK_CALLBACK(MmapHook, const void*, const void*, size_t, int, int, int,$/;"	p	namespace:testing	file:	signature:(MmapHook, const void*, const void*, size_t, int, int, int, off_t)
testing::MAKE_HOOK_CALLBACK	src/tests/tcmalloc_unittest.cc	/^MAKE_HOOK_CALLBACK(MremapHook, const void*, const void*, size_t, size_t, int,$/;"	p	namespace:testing	file:	signature:(MremapHook, const void*, const void*, size_t, size_t, int, const void*)
testing::MAKE_HOOK_CALLBACK	src/tests/tcmalloc_unittest.cc	/^MAKE_HOOK_CALLBACK(MunmapHook, const void *, size_t);$/;"	p	namespace:testing	file:	signature:(MunmapHook, const void *, size_t)
testing::MAKE_HOOK_CALLBACK	src/tests/tcmalloc_unittest.cc	/^MAKE_HOOK_CALLBACK(NewHook, const void*, size_t);$/;"	p	namespace:testing	file:	signature:(NewHook, const void*, size_t)
testing::MAKE_HOOK_CALLBACK	src/tests/tcmalloc_unittest.cc	/^MAKE_HOOK_CALLBACK(SbrkHook, const void *, ptrdiff_t);$/;"	p	namespace:testing	file:	signature:(SbrkHook, const void *, ptrdiff_t)
testing::OnNoMemory	src/tests/tcmalloc_unittest.cc	/^static void OnNoMemory() {$/;"	f	namespace:testing	signature:()
testing::RunAllTests	src/tests/tcmalloc_unittest.cc	/^static int RunAllTests(int argc, char** argv) {$/;"	f	namespace:testing	signature:(int argc, char** argv)
testing::RunThread	src/tests/tcmalloc_unittest.cc	/^static void RunThread(int thread_id) {$/;"	f	namespace:testing	signature:(int thread_id)
testing::TestAggressiveDecommit	src/tests/tcmalloc_unittest.cc	/^static void TestAggressiveDecommit() {$/;"	f	namespace:testing	signature:()
testing::TestAlignmentForSize	src/tests/tcmalloc_unittest.cc	/^static void TestAlignmentForSize(int size) {$/;"	f	namespace:testing	signature:(int size)
testing::TestCalloc	src/tests/tcmalloc_unittest.cc	/^static void TestCalloc(size_t n, size_t s, bool ok) {$/;"	f	namespace:testing	signature:(size_t n, size_t s, bool ok)
testing::TestErrno	src/tests/tcmalloc_unittest.cc	/^static void TestErrno(void) {$/;"	f	namespace:testing	signature:(void)
testing::TestHarness	src/tests/tcmalloc_unittest.cc	/^class TestHarness {$/;"	c	namespace:testing	file:
testing::TestHarness::AddType	src/tests/tcmalloc_unittest.cc	/^  void AddType(int type, int weight, const char* name);$/;"	p	class:testing::TestHarness	file:	access:public	signature:(int type, int weight, const char* name)
testing::TestHarness::AddType	src/tests/tcmalloc_unittest.cc	/^void TestHarness::AddType(int type, int weight, const char* name) {$/;"	f	class:testing::TestHarness	signature:(int type, int weight, const char* name)
testing::TestHarness::PickType	src/tests/tcmalloc_unittest.cc	/^  int PickType();$/;"	p	class:testing::TestHarness	file:	access:public	signature:()
testing::TestHarness::PickType	src/tests/tcmalloc_unittest.cc	/^int TestHarness::PickType() {$/;"	f	class:testing::TestHarness	signature:()
testing::TestHarness::Skewed	src/tests/tcmalloc_unittest.cc	/^  int Skewed(int max_log) {$/;"	f	class:testing::TestHarness	access:public	signature:(int max_log)
testing::TestHarness::TestHarness	src/tests/tcmalloc_unittest.cc	/^  TestHarness(int seed)$/;"	f	class:testing::TestHarness	access:public	signature:(int seed)
testing::TestHarness::Type	src/tests/tcmalloc_unittest.cc	/^  struct Type {$/;"	s	class:testing::TestHarness	file:	access:private
testing::TestHarness::Type::name	src/tests/tcmalloc_unittest.cc	/^    string      name;$/;"	m	struct:testing::TestHarness::Type	file:	access:public
testing::TestHarness::Type::type	src/tests/tcmalloc_unittest.cc	/^    int         type;$/;"	m	struct:testing::TestHarness::Type	file:	access:public
testing::TestHarness::Type::weight	src/tests/tcmalloc_unittest.cc	/^    int         weight;$/;"	m	struct:testing::TestHarness::Type	file:	access:public
testing::TestHarness::Uniform	src/tests/tcmalloc_unittest.cc	/^  int Uniform(int n) {$/;"	f	class:testing::TestHarness	access:public	signature:(int n)
testing::TestHarness::num_tests_	src/tests/tcmalloc_unittest.cc	/^  int                   num_tests_;     \/\/ Num tests run so far$/;"	m	class:testing::TestHarness	file:	access:private
testing::TestHarness::total_weight_	src/tests/tcmalloc_unittest.cc	/^  int                   total_weight_;  \/\/ Total weight of all types$/;"	m	class:testing::TestHarness	file:	access:private
testing::TestHarness::types_	src/tests/tcmalloc_unittest.cc	/^  vector<Type>*         types_;         \/\/ Registered types$/;"	m	class:testing::TestHarness	file:	access:private
testing::TestHarness::~TestHarness	src/tests/tcmalloc_unittest.cc	/^  ~TestHarness() {$/;"	f	class:testing::TestHarness	access:public	signature:()
testing::TestHugeAllocations	src/tests/tcmalloc_unittest.cc	/^static void TestHugeAllocations(AllocatorState* rnd) {$/;"	f	namespace:testing	signature:(AllocatorState* rnd)
testing::TestHugeThreadCache	src/tests/tcmalloc_unittest.cc	/^static void TestHugeThreadCache() {$/;"	f	namespace:testing	signature:()
testing::TestMallocAlignment	src/tests/tcmalloc_unittest.cc	/^static void TestMallocAlignment() {$/;"	f	namespace:testing	signature:()
testing::TestNAllocX	src/tests/tcmalloc_unittest.cc	/^static void TestNAllocX() {$/;"	f	namespace:testing	signature:()
testing::TestNAllocXAlignment	src/tests/tcmalloc_unittest.cc	/^static void TestNAllocXAlignment() {$/;"	f	namespace:testing	signature:()
testing::TestNew	src/tests/tcmalloc_unittest.cc	/^static void TestNew(void* (*func)(size_t)) {$/;"	f	namespace:testing	signature:(void* (*func)(size_t))
testing::TestNewHandler	src/tests/tcmalloc_unittest.cc	/^static void TestNewHandler() {$/;"	f	namespace:testing	signature:()
testing::TestNewOOMHandling	src/tests/tcmalloc_unittest.cc	/^static ATTRIBUTE_NOINLINE void TestNewOOMHandling() {$/;"	f	namespace:testing	signature:()
testing::TestNothrowNew	src/tests/tcmalloc_unittest.cc	/^static void TestNothrowNew(void* (*func)(size_t, const std::nothrow_t&)) {$/;"	f	namespace:testing	signature:(void* (*func)(size_t, const std::nothrow_t&))
testing::TestOneNew	src/tests/tcmalloc_unittest.cc	/^static void TestOneNew(void* (*func)(size_t)) {$/;"	f	namespace:testing	signature:(void* (*func)(size_t))
testing::TestOneNothrowNew	src/tests/tcmalloc_unittest.cc	/^static void TestOneNothrowNew(void* (*func)(size_t, const std::nothrow_t&)) {$/;"	f	namespace:testing	signature:(void* (*func)(size_t, const std::nothrow_t&))
testing::TestRanges	src/tests/tcmalloc_unittest.cc	/^static void TestRanges() {$/;"	f	namespace:testing	signature:()
testing::TestRealloc	src/tests/tcmalloc_unittest.cc	/^static void TestRealloc() {$/;"	f	namespace:testing	signature:()
testing::TestReleaseToSystem	src/tests/tcmalloc_unittest.cc	/^static void TestReleaseToSystem() {$/;"	f	namespace:testing	signature:()
testing::TestSetNewMode	src/tests/tcmalloc_unittest.cc	/^static void TestSetNewMode() {$/;"	f	namespace:testing	signature:()
testing::TesterThread	src/tests/tcmalloc_unittest.cc	/^class TesterThread {$/;"	c	namespace:testing	file:
testing::TesterThread::ACMRandom	src/tests/tcmalloc_unittest.cc	/^  class ACMRandom {$/;"	c	class:testing::TesterThread	file:	access:private
testing::TesterThread::ACMRandom::ACMRandom	src/tests/tcmalloc_unittest.cc	/^    explicit ACMRandom(int32 seed) { seed_ = seed; }$/;"	f	class:testing::TesterThread::ACMRandom	access:public	signature:(int32 seed)
testing::TesterThread::ACMRandom::Next	src/tests/tcmalloc_unittest.cc	/^    int32 Next() {$/;"	f	class:testing::TesterThread::ACMRandom	access:public	signature:()
testing::TesterThread::ACMRandom::seed_	src/tests/tcmalloc_unittest.cc	/^    int32 seed_;$/;"	m	class:testing::TesterThread::ACMRandom	file:	access:private
testing::TesterThread::ALLOC	src/tests/tcmalloc_unittest.cc	/^  enum Type { ALLOC, FREE, UPDATE, PASS };$/;"	e	enum:testing::TesterThread::Type	file:
testing::TesterThread::AcquirePassedObjects	src/tests/tcmalloc_unittest.cc	/^  void AcquirePassedObjects() {$/;"	f	class:testing::TesterThread	access:public	signature:()
testing::TesterThread::AllocateObject	src/tests/tcmalloc_unittest.cc	/^  void AllocateObject() {$/;"	f	class:testing::TesterThread	access:public	signature:()
testing::TesterThread::CheckContents	src/tests/tcmalloc_unittest.cc	/^  void CheckContents(const Object& object) {$/;"	f	class:testing::TesterThread	access:public	signature:(const Object& object)
testing::TesterThread::DeleteHeap	src/tests/tcmalloc_unittest.cc	/^  void DeleteHeap() {$/;"	f	class:testing::TesterThread	access:public	signature:()
testing::TesterThread::FREE	src/tests/tcmalloc_unittest.cc	/^  enum Type { ALLOC, FREE, UPDATE, PASS };$/;"	e	enum:testing::TesterThread::Type	file:
testing::TesterThread::FillContents	src/tests/tcmalloc_unittest.cc	/^  void FillContents(Object* object) {$/;"	f	class:testing::TesterThread	access:public	signature:(Object* object)
testing::TesterThread::FreeObject	src/tests/tcmalloc_unittest.cc	/^  void FreeObject() {$/;"	f	class:testing::TesterThread	access:public	signature:()
testing::TesterThread::Object	src/tests/tcmalloc_unittest.cc	/^  struct Object {$/;"	s	class:testing::TesterThread	file:	access:private
testing::TesterThread::Object::generation	src/tests/tcmalloc_unittest.cc	/^    int         generation;             \/\/ Generation counter of object contents$/;"	m	struct:testing::TesterThread::Object	file:	access:public
testing::TesterThread::Object::ptr	src/tests/tcmalloc_unittest.cc	/^    char*       ptr;                    \/\/ Allocated pointer$/;"	m	struct:testing::TesterThread::Object	file:	access:public
testing::TesterThread::Object::size	src/tests/tcmalloc_unittest.cc	/^    int         size;                   \/\/ Allocated size$/;"	m	struct:testing::TesterThread::Object	file:	access:public
testing::TesterThread::PASS	src/tests/tcmalloc_unittest.cc	/^  enum Type { ALLOC, FREE, UPDATE, PASS };$/;"	e	enum:testing::TesterThread::Type	file:
testing::TesterThread::PassObject	src/tests/tcmalloc_unittest.cc	/^  void PassObject() {$/;"	f	class:testing::TesterThread	access:public	signature:()
testing::TesterThread::Run	src/tests/tcmalloc_unittest.cc	/^  virtual void Run() {$/;"	f	class:testing::TesterThread	access:public	signature:()
testing::TesterThread::ShrinkHeap	src/tests/tcmalloc_unittest.cc	/^  void ShrinkHeap() {$/;"	f	class:testing::TesterThread	access:public	signature:()
testing::TesterThread::TesterThread	src/tests/tcmalloc_unittest.cc	/^  TesterThread(int id)$/;"	f	class:testing::TesterThread	access:public	signature:(int id)
testing::TesterThread::Type	src/tests/tcmalloc_unittest.cc	/^  enum Type { ALLOC, FREE, UPDATE, PASS };$/;"	g	class:testing::TesterThread	file:	access:private
testing::TesterThread::UPDATE	src/tests/tcmalloc_unittest.cc	/^  enum Type { ALLOC, FREE, UPDATE, PASS };$/;"	e	enum:testing::TesterThread::Type	file:
testing::TesterThread::UpdateObject	src/tests/tcmalloc_unittest.cc	/^  void UpdateObject() {$/;"	f	class:testing::TesterThread	access:public	signature:()
testing::TesterThread::heap_	src/tests/tcmalloc_unittest.cc	/^  vector<Object>        heap_;          \/\/ This thread's heap$/;"	m	class:testing::TesterThread	file:	access:private
testing::TesterThread::heap_size_	src/tests/tcmalloc_unittest.cc	/^  size_t                heap_size_;     \/\/ Current heap size$/;"	m	class:testing::TesterThread	file:	access:private
testing::TesterThread::id_	src/tests/tcmalloc_unittest.cc	/^  int                   id_;            \/\/ My thread id$/;"	m	class:testing::TesterThread	file:	access:private
testing::TesterThread::lock_	src/tests/tcmalloc_unittest.cc	/^  Mutex                 lock_;          \/\/ For passing in another thread's obj$/;"	m	class:testing::TesterThread	file:	access:private
testing::TesterThread::locks_failed_	src/tests/tcmalloc_unittest.cc	/^  int                   locks_failed_;  \/\/ Number of failed TryLock() ops$/;"	m	class:testing::TesterThread	file:	access:private
testing::TesterThread::locks_ok_	src/tests/tcmalloc_unittest.cc	/^  int                   locks_ok_;      \/\/ Number of OK TryLock() ops$/;"	m	class:testing::TesterThread	file:	access:private
testing::TesterThread::passed_	src/tests/tcmalloc_unittest.cc	/^  vector<Object>        passed_;        \/\/ Pending objects passed from others$/;"	m	class:testing::TesterThread	file:	access:private
testing::TesterThread::rnd_	src/tests/tcmalloc_unittest.cc	/^  AllocatorState        rnd_;           \/\/ For generating random numbers$/;"	m	class:testing::TesterThread	file:	access:private
testing::TesterThread::~TesterThread	src/tests/tcmalloc_unittest.cc	/^  virtual ~TesterThread() {$/;"	f	class:testing::TesterThread	access:public	signature:()
testing::TryHugeAllocation	src/tests/tcmalloc_unittest.cc	/^static void TryHugeAllocation(size_t s, AllocatorState* rnd) {$/;"	f	namespace:testing	signature:(size_t s, AllocatorState* rnd)
testing::__anon59::CheckRangeCallback	src/tests/tcmalloc_unittest.cc	/^static void CheckRangeCallback(void* ptr, base::MallocRange::Type type,$/;"	f	namespace:testing::__anon59	signature:(void* ptr, base::MallocRange::Type type, size_t min_size)
testing::__anon59::RangeCallback	src/tests/tcmalloc_unittest.cc	/^static void RangeCallback(void* arg, const base::MallocRange* r) {$/;"	f	namespace:testing::__anon59	signature:(void* arg, const base::MallocRange* r)
testing::__anon59::RangeCallbackState	src/tests/tcmalloc_unittest.cc	/^struct RangeCallbackState {$/;"	s	namespace:testing::__anon59	file:
testing::__anon59::RangeCallbackState::expected_type	src/tests/tcmalloc_unittest.cc	/^  base::MallocRange::Type expected_type;$/;"	m	struct:testing::__anon59::RangeCallbackState	file:	access:public
testing::__anon59::RangeCallbackState::matched	src/tests/tcmalloc_unittest.cc	/^  bool matched;$/;"	m	struct:testing::__anon59::RangeCallbackState	file:	access:public
testing::__anon59::RangeCallbackState::min_size	src/tests/tcmalloc_unittest.cc	/^  size_t min_size;$/;"	m	struct:testing::__anon59::RangeCallbackState	file:	access:public
testing::__anon59::RangeCallbackState::ptr	src/tests/tcmalloc_unittest.cc	/^  uintptr_t ptr;$/;"	m	struct:testing::__anon59::RangeCallbackState	file:	access:public
testing::check_global_nallocx	src/tests/tcmalloc_unittest.cc	/^static void check_global_nallocx() __attribute__((constructor));$/;"	p	namespace:testing	file:	signature:()
testing::check_global_nallocx	src/tests/tcmalloc_unittest.cc	/^static void check_global_nallocx() { CHECK_GT(nallocx(99, 0), 99); }$/;"	f	namespace:testing	signature:()
testing::g_no_memory	src/tests/tcmalloc_unittest.cc	/^volatile bool g_no_memory = false;$/;"	m	namespace:testing	file:
testing::g_old_handler	src/tests/tcmalloc_unittest.cc	/^std::new_handler g_old_handler = NULL;$/;"	m	namespace:testing	file:
testing::global_nallocx	src/tests/tcmalloc_unittest.cc	/^} global_nallocx;$/;"	m	namespace:testing	typeref:struct:testing::GlobalNallocx	file:
testing::kMaxSignedSize	src/tests/tcmalloc_unittest.cc	/^static const size_t kMaxSignedSize = ((size_t(1) << (kSizeBits-1)) - 1);$/;"	m	namespace:testing	file:
testing::kMaxSize	src/tests/tcmalloc_unittest.cc	/^static const size_t kMaxSize = ~static_cast<size_t>(0);$/;"	m	namespace:testing	file:
testing::kNotTooBig	src/tests/tcmalloc_unittest.cc	/^static const size_t kNotTooBig = 100000;$/;"	m	namespace:testing	file:
testing::kSizeBits	src/tests/tcmalloc_unittest.cc	/^static const int kSizeBits = 8 * sizeof(size_t);$/;"	m	namespace:testing	file:
testing::kTooBig	src/tests/tcmalloc_unittest.cc	/^static const size_t kTooBig = kMaxSize - 100000;$/;"	m	namespace:testing	file:
testing::news_handled	src/tests/tcmalloc_unittest.cc	/^static int news_handled = 0;$/;"	m	namespace:testing	file:
testing::oom_test_last_ptr	src/tests/tcmalloc_unittest.cc	/^static void* volatile oom_test_last_ptr;$/;"	m	namespace:testing	file:
testing::saw_new_handler_runs	src/tests/tcmalloc_unittest.cc	/^static int saw_new_handler_runs;$/;"	m	namespace:testing	file:
testing::test_new_handler	src/tests/tcmalloc_unittest.cc	/^static void test_new_handler() {$/;"	f	namespace:testing	signature:()
testing::threads	src/tests/tcmalloc_unittest.cc	/^static TesterThread** threads;$/;"	m	namespace:testing	file:
the	src/windows/shortproc.asm	/^; in the documentation and\/or other materials provided with the$/;"	v
them	docs/heap_checker.html	/^is no good way to fix them, then you can use$/;"	v
then	docs/pprof_remote_servers.html	/^(from <code>heap-profiler.h<\/code>), continue to do work, and then,$/;"	v
then	docs/pprof_remote_servers.html	/^then, XX seconds later, calling <code>ProfilerStop()<\/code>.  (These$/;"	v
there	configure.ac	/^AC_CHECK_HEADERS(malloc.h)      # some systems define stuff there, others not$/;"	v
thisdir	binary_trees_shared	/^      thisdir=`pwd`$/;"	v
thisdir	binary_trees_shared	/^  thisdir=`$ECHO "X$file" | $Xsed -e 's%\/[^\/]*$%%'`$/;"	v
thisdir	current_allocated_bytes_test	/^      thisdir=`pwd`$/;"	v
thisdir	current_allocated_bytes_test	/^  thisdir=`$ECHO "X$file" | $Xsed -e 's%\/[^\/]*$%%'`$/;"	v
thisdir	debugallocation_test	/^      thisdir=`pwd`$/;"	v
thisdir	debugallocation_test	/^  thisdir=`$ECHO "X$file" | $Xsed -e 's%\/[^\/]*$%%'`$/;"	v
thisdir	frag_unittest	/^      thisdir=`pwd`$/;"	v
thisdir	frag_unittest	/^  thisdir=`$ECHO "X$file" | $Xsed -e 's%\/[^\/]*$%%'`$/;"	v
thisdir	heap-checker_debug_unittest	/^      thisdir=`pwd`$/;"	v
thisdir	heap-checker_debug_unittest	/^  thisdir=`$ECHO "X$file" | $Xsed -e 's%\/[^\/]*$%%'`$/;"	v
thisdir	heap-checker_unittest	/^      thisdir=`pwd`$/;"	v
thisdir	heap-checker_unittest	/^  thisdir=`$ECHO "X$file" | $Xsed -e 's%\/[^\/]*$%%'`$/;"	v
thisdir	heap-profiler_debug_unittest	/^      thisdir=`pwd`$/;"	v
thisdir	heap-profiler_debug_unittest	/^  thisdir=`$ECHO "X$file" | $Xsed -e 's%\/[^\/]*$%%'`$/;"	v
thisdir	heap-profiler_unittest	/^      thisdir=`pwd`$/;"	v
thisdir	heap-profiler_unittest	/^  thisdir=`$ECHO "X$file" | $Xsed -e 's%\/[^\/]*$%%'`$/;"	v
thisdir	malloc_bench_shared	/^      thisdir=`pwd`$/;"	v
thisdir	malloc_bench_shared	/^  thisdir=`$ECHO "X$file" | $Xsed -e 's%\/[^\/]*$%%'`$/;"	v
thisdir	malloc_bench_shared_full	/^      thisdir=`pwd`$/;"	v
thisdir	malloc_bench_shared_full	/^  thisdir=`$ECHO "X$file" | $Xsed -e 's%\/[^\/]*$%%'`$/;"	v
thisdir	malloc_extension_c_test	/^      thisdir=`pwd`$/;"	v
thisdir	malloc_extension_c_test	/^  thisdir=`$ECHO "X$file" | $Xsed -e 's%\/[^\/]*$%%'`$/;"	v
thisdir	malloc_extension_debug_test	/^      thisdir=`pwd`$/;"	v
thisdir	malloc_extension_debug_test	/^  thisdir=`$ECHO "X$file" | $Xsed -e 's%\/[^\/]*$%%'`$/;"	v
thisdir	malloc_extension_test	/^      thisdir=`pwd`$/;"	v
thisdir	malloc_extension_test	/^  thisdir=`$ECHO "X$file" | $Xsed -e 's%\/[^\/]*$%%'`$/;"	v
thisdir	malloc_hook_test	/^      thisdir=`pwd`$/;"	v
thisdir	malloc_hook_test	/^  thisdir=`$ECHO "X$file" | $Xsed -e 's%\/[^\/]*$%%'`$/;"	v
thisdir	markidle_unittest	/^      thisdir=`pwd`$/;"	v
thisdir	markidle_unittest	/^  thisdir=`$ECHO "X$file" | $Xsed -e 's%\/[^\/]*$%%'`$/;"	v
thisdir	memalign_debug_unittest	/^      thisdir=`pwd`$/;"	v
thisdir	memalign_debug_unittest	/^  thisdir=`$ECHO "X$file" | $Xsed -e 's%\/[^\/]*$%%'`$/;"	v
thisdir	memalign_unittest	/^      thisdir=`pwd`$/;"	v
thisdir	memalign_unittest	/^  thisdir=`$ECHO "X$file" | $Xsed -e 's%\/[^\/]*$%%'`$/;"	v
thisdir	packed_cache_test	/^      thisdir=`pwd`$/;"	v
thisdir	packed_cache_test	/^  thisdir=`$ECHO "X$file" | $Xsed -e 's%\/[^\/]*$%%'`$/;"	v
thisdir	page_heap_test	/^      thisdir=`pwd`$/;"	v
thisdir	page_heap_test	/^  thisdir=`$ECHO "X$file" | $Xsed -e 's%\/[^\/]*$%%'`$/;"	v
thisdir	pagemap_unittest	/^      thisdir=`pwd`$/;"	v
thisdir	pagemap_unittest	/^  thisdir=`$ECHO "X$file" | $Xsed -e 's%\/[^\/]*$%%'`$/;"	v
thisdir	profile_handler_unittest	/^      thisdir=`pwd`$/;"	v
thisdir	profile_handler_unittest	/^  thisdir=`$ECHO "X$file" | $Xsed -e 's%\/[^\/]*$%%'`$/;"	v
thisdir	profiledata_unittest	/^      thisdir=`pwd`$/;"	v
thisdir	profiledata_unittest	/^  thisdir=`$ECHO "X$file" | $Xsed -e 's%\/[^\/]*$%%'`$/;"	v
thisdir	profiler1_unittest	/^      thisdir=`pwd`$/;"	v
thisdir	profiler1_unittest	/^  thisdir=`$ECHO "X$file" | $Xsed -e 's%\/[^\/]*$%%'`$/;"	v
thisdir	profiler2_unittest	/^      thisdir=`pwd`$/;"	v
thisdir	profiler2_unittest	/^  thisdir=`$ECHO "X$file" | $Xsed -e 's%\/[^\/]*$%%'`$/;"	v
thisdir	profiler3_unittest	/^      thisdir=`pwd`$/;"	v
thisdir	profiler3_unittest	/^  thisdir=`$ECHO "X$file" | $Xsed -e 's%\/[^\/]*$%%'`$/;"	v
thisdir	profiler4_unittest	/^      thisdir=`pwd`$/;"	v
thisdir	profiler4_unittest	/^  thisdir=`$ECHO "X$file" | $Xsed -e 's%\/[^\/]*$%%'`$/;"	v
thisdir	raw_printer_test	/^      thisdir=`pwd`$/;"	v
thisdir	raw_printer_test	/^  thisdir=`$ECHO "X$file" | $Xsed -e 's%\/[^\/]*$%%'`$/;"	v
thisdir	realloc_debug_unittest	/^      thisdir=`pwd`$/;"	v
thisdir	realloc_debug_unittest	/^  thisdir=`$ECHO "X$file" | $Xsed -e 's%\/[^\/]*$%%'`$/;"	v
thisdir	realloc_unittest	/^      thisdir=`pwd`$/;"	v
thisdir	realloc_unittest	/^  thisdir=`$ECHO "X$file" | $Xsed -e 's%\/[^\/]*$%%'`$/;"	v
thisdir	sampler_debug_test	/^      thisdir=`pwd`$/;"	v
thisdir	sampler_debug_test	/^  thisdir=`$ECHO "X$file" | $Xsed -e 's%\/[^\/]*$%%'`$/;"	v
thisdir	sampler_test	/^      thisdir=`pwd`$/;"	v
thisdir	sampler_test	/^  thisdir=`$ECHO "X$file" | $Xsed -e 's%\/[^\/]*$%%'`$/;"	v
thisdir	sampling_debug_test	/^      thisdir=`pwd`$/;"	v
thisdir	sampling_debug_test	/^  thisdir=`$ECHO "X$file" | $Xsed -e 's%\/[^\/]*$%%'`$/;"	v
thisdir	sampling_test	/^      thisdir=`pwd`$/;"	v
thisdir	sampling_test	/^  thisdir=`$ECHO "X$file" | $Xsed -e 's%\/[^\/]*$%%'`$/;"	v
thisdir	simple_compat_test	/^      thisdir=`pwd`$/;"	v
thisdir	simple_compat_test	/^  thisdir=`$ECHO "X$file" | $Xsed -e 's%\/[^\/]*$%%'`$/;"	v
thisdir	stack_trace_table_test	/^      thisdir=`pwd`$/;"	v
thisdir	stack_trace_table_test	/^  thisdir=`$ECHO "X$file" | $Xsed -e 's%\/[^\/]*$%%'`$/;"	v
thisdir	system_alloc_unittest	/^      thisdir=`pwd`$/;"	v
thisdir	system_alloc_unittest	/^  thisdir=`$ECHO "X$file" | $Xsed -e 's%\/[^\/]*$%%'`$/;"	v
thisdir	tcmalloc_and_profiler_unittest	/^      thisdir=`pwd`$/;"	v
thisdir	tcmalloc_and_profiler_unittest	/^  thisdir=`$ECHO "X$file" | $Xsed -e 's%\/[^\/]*$%%'`$/;"	v
thisdir	tcmalloc_both_unittest	/^      thisdir=`pwd`$/;"	v
thisdir	tcmalloc_both_unittest	/^  thisdir=`$ECHO "X$file" | $Xsed -e 's%\/[^\/]*$%%'`$/;"	v
thisdir	tcmalloc_debug_unittest	/^      thisdir=`pwd`$/;"	v
thisdir	tcmalloc_debug_unittest	/^  thisdir=`$ECHO "X$file" | $Xsed -e 's%\/[^\/]*$%%'`$/;"	v
thisdir	tcmalloc_large_heap_fragmentation_unittest	/^      thisdir=`pwd`$/;"	v
thisdir	tcmalloc_large_heap_fragmentation_unittest	/^  thisdir=`$ECHO "X$file" | $Xsed -e 's%\/[^\/]*$%%'`$/;"	v
thisdir	tcmalloc_large_unittest	/^      thisdir=`pwd`$/;"	v
thisdir	tcmalloc_large_unittest	/^  thisdir=`$ECHO "X$file" | $Xsed -e 's%\/[^\/]*$%%'`$/;"	v
thisdir	tcmalloc_minimal_debug_unittest	/^      thisdir=`pwd`$/;"	v
thisdir	tcmalloc_minimal_debug_unittest	/^  thisdir=`$ECHO "X$file" | $Xsed -e 's%\/[^\/]*$%%'`$/;"	v
thisdir	tcmalloc_minimal_large_heap_fragmentation_unittest	/^      thisdir=`pwd`$/;"	v
thisdir	tcmalloc_minimal_large_heap_fragmentation_unittest	/^  thisdir=`$ECHO "X$file" | $Xsed -e 's%\/[^\/]*$%%'`$/;"	v
thisdir	tcmalloc_minimal_large_unittest	/^      thisdir=`pwd`$/;"	v
thisdir	tcmalloc_minimal_large_unittest	/^  thisdir=`$ECHO "X$file" | $Xsed -e 's%\/[^\/]*$%%'`$/;"	v
thisdir	tcmalloc_minimal_unittest	/^      thisdir=`pwd`$/;"	v
thisdir	tcmalloc_minimal_unittest	/^  thisdir=`$ECHO "X$file" | $Xsed -e 's%\/[^\/]*$%%'`$/;"	v
thisdir	tcmalloc_unittest	/^      thisdir=`pwd`$/;"	v
thisdir	tcmalloc_unittest	/^  thisdir=`$ECHO "X$file" | $Xsed -e 's%\/[^\/]*$%%'`$/;"	v
thisdir	thread_dealloc_unittest	/^      thisdir=`pwd`$/;"	v
thisdir	thread_dealloc_unittest	/^  thisdir=`$ECHO "X$file" | $Xsed -e 's%\/[^\/]*$%%'`$/;"	v
thisdir	unwind_bench	/^      thisdir=`pwd`$/;"	v
thisdir	unwind_bench	/^  thisdir=`$ECHO "X$file" | $Xsed -e 's%\/[^\/]*$%%'`$/;"	v
thread_	src/tests/profile-handler_unittest.cc	/^  pthread_t thread_;$/;"	m	class:__anon56::Thread	file:	access:private
thread_back_trace	src/stacktrace_instrument-inl.h	/^static BACK_TRACE thread_back_trace[MAX_THREAD];$/;"	v
thread_bytes	src/tcmalloc.cc	/^  uint64_t thread_bytes;      \/\/ Bytes in thread caches$/;"	m	struct:TCMallocStats	file:	access:public
thread_disable_counter	src/heap-checker.cc	/^static __thread int thread_disable_counter$/;"	v	file:
thread_disable_counter_key	src/heap-checker.cc	/^static pthread_key_t thread_disable_counter_key;$/;"	v	file:
thread_heap_count_	src/thread_cache.cc	/^int ThreadCache::thread_heap_count_ = 0;$/;"	m	class:tcmalloc::ThreadCache	file:
thread_heap_count_	src/thread_cache.h	/^  static int thread_heap_count_;$/;"	m	class:tcmalloc::ThreadCache	access:private
thread_heaps_	src/thread_cache.cc	/^ThreadCache* ThreadCache::thread_heaps_ = NULL;$/;"	m	class:tcmalloc::ThreadCache	file:
thread_heaps_	src/thread_cache.h	/^  static ThreadCache* thread_heaps_;$/;"	m	class:tcmalloc::ThreadCache	access:private
thread_listing_status	src/heap-checker.cc	/^} thread_listing_status = CALLBACK_NOT_STARTED;$/;"	v	typeref:enum:__anon4	file:
thread_timer_key	src/profile-handler.cc	/^  pthread_key_t thread_timer_key;$/;"	m	class:ProfileHandler	file:	access:private
threadcache_allocator	src/thread_cache.cc	/^PageHeapAllocator<ThreadCache> threadcache_allocator;$/;"	m	namespace:tcmalloc	file:
threadcount_lock	src/tests/malloc_hook_test.cc	/^static Mutex threadcount_lock;$/;"	m	namespace:__anon57	file:
threads	README	/^new threads, or is otherwise likely to cause a call to$/;"	v
threads	docs/cpuprofile.html	/^<p>In Linux 2.6 and above, profiling works correctly with threads,$/;"	v
threads	docs/tcmalloc.html	/^threads, for max allocation size 64 bytes - 128 Kbytes.<\/p>$/;"	m	class:object::structure	file:	access:private
threads	src/tests/tcmalloc_unittest.cc	/^static TesterThread** threads;$/;"	m	namespace:testing	file:
tid	src/base/elfcore.h	/^    pid_t            tid;$/;"	m	struct:Frame	access:public
tid	src/base/elfcore.h	/^    pid_t           tid;$/;"	m	struct:Frame	access:public
tid	src/base/elfcore.h	/^    pid_t tid;$/;"	m	struct:Frame	access:public
tid_	src/thread_cache.h	/^  pthread_t     tid_;                   \/\/ Which thread owns it$/;"	m	class:tcmalloc::ThreadCache	access:private
timer_id_holder	src/profile-handler.cc	/^  timer_id_holder(timer_t _timerid) : timerid(_timerid) {}$/;"	f	struct:timer_id_holder	access:public	signature:(timer_t _timerid)
timer_id_holder	src/profile-handler.cc	/^struct timer_id_holder {$/;"	s	file:
timer_id_holder::timer_id_holder	src/profile-handler.cc	/^  timer_id_holder(timer_t _timerid) : timerid(_timerid) {}$/;"	f	struct:timer_id_holder	access:public	signature:(timer_t _timerid)
timer_id_holder::timerid	src/profile-handler.cc	/^  timer_t timerid;$/;"	m	struct:timer_id_holder	file:	access:public
timer_running_	src/profile-handler.cc	/^  bool timer_running_;$/;"	m	class:ProfileHandler	file:	access:private
timer_type_	src/profile-handler.cc	/^  int timer_type_;$/;"	m	class:ProfileHandler	file:	access:private
timer_type_	src/tests/profile-handler_unittest.cc	/^static int timer_type_ = ITIMER_PROF;$/;"	m	namespace:__anon56	file:
timerid	src/profile-handler.cc	/^  timer_t timerid;$/;"	m	struct:timer_id_holder	file:	access:public
timespec	src/windows/port.h	/^struct timespec {$/;"	s
timespec::tv_nsec	src/windows/port.h	/^  int tv_nsec;$/;"	m	struct:timespec	access:public
timespec::tv_sec	src/windows/port.h	/^  int tv_sec;$/;"	m	struct:timespec	access:public
tmpdepfile1	depcomp	/^    tmpdepfile1=$dir$base.d$/;"	v
tmpdepfile1	depcomp	/^    tmpdepfile1=$dir$base.u$/;"	v
topdir	packages/deb.sh	/^topdir="${PWD%\/*}"$/;"	v
total	src/heap-profile-table.h	/^  const Stats& total() const { return total_; }$/;"	f	class:HeapProfileTable	access:public	signature:() const
total	src/heap-profile-table.h	/^  const Stats& total() const { return total_; }$/;"	f	class:HeapProfileTable::Snapshot	access:public	signature:() const
total_	src/heap-profile-table.h	/^  Bucket total_;$/;"	m	class:HeapProfileTable	access:private
total_	src/heap-profile-table.h	/^  Bucket total_;$/;"	m	class:HeapProfileTable::Snapshot	access:private
total_bytes_	src/profiledata.h	/^  size_t        total_bytes_;   \/\/ How much output$/;"	m	class:ProfileData	access:private
total_bytes_free	src/gperftools/malloc_extension.h	/^    size_t total_bytes_free;$/;"	m	struct:MallocExtension::FreeListInfo	access:public
total_commit_bytes	src/page_heap.h	/^    uint64_t total_commit_bytes;    \/\/ Bytes committed in lifetime of process$/;"	m	struct:tcmalloc::PageHeap::Stats	access:public
total_decommit_bytes	src/page_heap.h	/^    uint64_t total_decommit_bytes;  \/\/ Bytes decommitted in lifetime of process$/;"	m	struct:tcmalloc::PageHeap::Stats	access:public
total_reserve_bytes	src/page_heap.h	/^    uint64_t total_reserve_bytes;   \/\/ Bytes reserved in lifetime of process$/;"	m	struct:tcmalloc::PageHeap::Stats	access:public
total_weight_	src/tests/tcmalloc_unittest.cc	/^  int                   total_weight_;  \/\/ Total weight of all types$/;"	m	class:testing::TestHarness	file:	access:private
touch_files	missing	/^      *:*) touch_files="$touch_files "`echo "$f" |$/;"	v
trace	src/stack_trace_table.h	/^    StackTrace trace;$/;"	m	struct:tcmalloc::StackTraceTable::Bucket	access:public
transfer_bytes	src/tcmalloc.cc	/^  uint64_t transfer_bytes;    \/\/ Bytes in central transfer cache$/;"	m	struct:TCMallocStats	file:	access:public
true	docs/heap_checker.html	/^    If true, ignore objects reachable from global variables and data$/;"	v
tsd_inited_	src/thread_cache.cc	/^bool ThreadCache::tsd_inited_ = false;$/;"	m	class:tcmalloc::ThreadCache	file:
tsd_inited_	src/thread_cache.h	/^  static ATTRIBUTE_HIDDEN bool tsd_inited_;$/;"	m	class:tcmalloc::ThreadCache	access:private
tvH	src/.libs/libtcmalloc_internal_la-heap-profiler.o	/^»/;"	v
tv_nsec	src/base/linux_syscall_support.h	/^  long               tv_nsec;$/;"	m	struct:kernel_timespec	access:public
tv_nsec	src/windows/port.h	/^  int tv_nsec;$/;"	m	struct:timespec	access:public
tv_sec	src/base/linux_syscall_support.h	/^  long               tv_sec;$/;"	m	struct:kernel_timespec	access:public
tv_sec	src/base/linux_syscall_support.h	/^  long               tv_sec;$/;"	m	struct:kernel_timeval	access:public
tv_sec	src/windows/port.h	/^  int tv_sec;$/;"	m	struct:timespec	access:public
tv_usec	src/base/linux_syscall_support.h	/^  long               tv_usec;$/;"	m	struct:kernel_timeval	access:public
type	INSTALL	/^a message saying it cannot guess the machine type, give it the$/;"	v
type	src/debugallocation.cc	/^  int type;$/;"	m	struct:memalign_retry_data	file:	access:public
type	src/gperftools/malloc_extension.h	/^    const char* type;$/;"	m	struct:MallocExtension::FreeListInfo	access:public
type	src/gperftools/malloc_extension.h	/^  Type type;            \/\/ Type of this range$/;"	m	struct:base::MallocRange	access:public
type	src/tests/tcmalloc_unittest.cc	/^    int         type;$/;"	m	struct:testing::TestHarness::Type	file:	access:public
type_	src/windows/mini_disassembler_types.h	/^  InstructionType type_;$/;"	m	struct:sidestep::Opcode	access:public
type_	src/windows/mini_disassembler_types.h	/^  InstructionType type_;$/;"	m	struct:sidestep::SpecificOpcode	access:public
types_	src/tests/tcmalloc_unittest.cc	/^  vector<Type>*         types_;         \/\/ Registered types$/;"	m	class:testing::TestHarness	file:	access:private
u	src/.libs/libtcmalloc_internal_la-sampler.o	/^:/;"	v
u	src/libtcmalloc_and_profiler_la-profile-handler.o	/^/;"	v
u	src/libtcmalloc_internal_la-sampler.o	/^:/;"	v
u_	src/internal_logging.h	/^  } u_;$/;"	m	class:tcmalloc::LogItem	typeref:union:tcmalloc::LogItem::__anon9	access:private
ucontext_t	src/getpc.h	/^typedef int ucontext_t;$/;"	t
ucontext_t	src/getpc.h	/^typedef ucontext ucontext_t;$/;"	t
ucontext_t	src/profiler.cc	/^typedef int ucontext_t;   \/\/ just to quiet the compiler, mostly$/;"	t	file:
ucontext_t	src/profiler.cc	/^typedef ucontext ucontext_t;$/;"	t	file:
ucontext_t	src/stacktrace_x86-inl.h	/^typedef ucontext ucontext_t;$/;"	t
uint16	src/base/basictypes.h	/^typedef uint16_t           uint16;$/;"	t
uint16_t	src/windows/port.h	/^typedef unsigned __int16 uint16_t;$/;"	t
uint32	src/base/basictypes.h	/^typedef uint32_t           uint32;$/;"	t
uint32_t	src/windows/port.h	/^typedef unsigned __int32 uint32_t;$/;"	t
uint64	src/base/basictypes.h	/^typedef uint64_t           uint64;$/;"	t
uint64_t	src/windows/port.h	/^typedef unsigned __int64 uint64_t;$/;"	t
uint8	src/base/basictypes.h	/^typedef uint8_t            uint8;$/;"	t
uint8_t	src/windows/port.h	/^typedef unsigned __int8 uint8_t;$/;"	t
unclaimed_cache_space_	src/thread_cache.cc	/^ssize_t ThreadCache::unclaimed_cache_space_ = kDefaultOverallThreadCacheSize;$/;"	m	class:tcmalloc::ThreadCache	file:
unclaimed_cache_space_	src/thread_cache.h	/^  static ssize_t unclaimed_cache_space_;$/;"	m	class:tcmalloc::ThreadCache	access:private
unhooked_arena	src/base/low_level_alloc.cc	/^static struct LowLevelAlloc::Arena unhooked_arena;$/;"	v	typeref:struct:Arena	file:
unhooked_async_sig_safe_arena	src/base/low_level_alloc.cc	/^static struct LowLevelAlloc::Arena unhooked_async_sig_safe_arena;$/;"	v	typeref:struct:Arena	file:
unittests	README_windows.txt	/^When you build the solution, it will create a number of unittests,$/;"	v
unmap_size_	src/memory_region_map.cc	/^int64 MemoryRegionMap::unmap_size_ = 0;$/;"	m	class:MemoryRegionMap	file:
unmap_size_	src/memory_region_map.h	/^  static int64 unmap_size_;$/;"	m	class:MemoryRegionMap	access:private
unmapped_bytes	src/page_heap.h	/^    uint64_t unmapped_bytes;  \/\/ Total bytes on returned freelists$/;"	m	struct:tcmalloc::PageHeap::Stats	access:public
unum	src/internal_logging.h	/^    uint64_t unum;$/;"	m	union:tcmalloc::LogItem::__anon9	access:public
unused	src/base/elfcore.h	/^    unsigned long unused;$/;"	m	struct:mips_regs	access:public
uregs	src/base/elfcore.h	/^    long uregs[18];$/;"	m	struct:arm_regs	access:public
uregs	src/base/elfcore.h	/^    struct i386_regs uregs;$/;"	m	struct:Frame	typeref:struct:Frame::i386_regs	access:public
uregs	src/base/elfcore.h	/^    unsigned long uregs[32];	\/* General Purpose Registers - r0-r31.       *\/$/;"	m	struct:ppc_regs	access:public
uregs	src/base/elfcore.h	/^    unsigned long uregs[32];    \/* General purpose registers.                *\/$/;"	m	struct:mips_regs	access:public
usage	src/windows/addr2line-pdb.c	/^void usage() {$/;"	f	signature:()
usage	src/windows/nm-pdb.c	/^void usage() {$/;"	f	signature:()
use_emergency_malloc	src/thread_cache.h	/^    bool use_emergency_malloc;$/;"	m	struct:tcmalloc::ThreadCache::ThreadLocalData	access:public
use_main_thread_counter	src/heap-checker.cc	/^static bool use_main_thread_counter = true;$/;"	v	file:
use_sib_byte_	src/windows/mini_disassembler_types.h	/^  bool use_sib_byte_;$/;"	m	struct:sidestep::ModrmEntry	access:public
used_slots_	src/central_freelist.h	/^  int32_t used_slots_;$/;"	m	class:tcmalloc::CentralFreeList	access:private
using_low_level_alloc	src/tests/low_level_alloc_unittest.cc	/^static bool using_low_level_alloc = false;$/;"	v	file:
using_maps_backing_	src/base/sysinfo.h	/^  bool using_maps_backing_; \/\/ true if we are looking at maps_backing instead of maps.$/;"	m	class:ProcMapsIterator	access:private
ut	src/tests/page_heap_test-page_heap_test.o	/^/;"	v
v	src/.libs/libtcmalloc_internal_la-internal_logging.o	/^/;"	v
v	src/.libs/libtcmalloc_internal_la-raw_printer.o	/^/;"	v
v	src/tcm_min_asserts_unittest-symbolize.o	/^/;"	v
v2	config.log	/^ int32_t v1 = 0; intptr_t v2 = 0; return (&v1 - &v2)$/;"	v
v2	tags	/^v2	config.log	\/^ int32_t v1 = 0; intptr_t v2 = 0; return (&v1 - &v2)$\/;"	v$/;"	v
vZ	src/libtcmalloc_minimal_debug_la-debugallocation.o	/^ÒPh>?´QÖwN½N6ô	è^A:ñvZ;ß._;Þå;éÉlÞ-Ñ2 ÎÍÞK"ulÃ^K$j nËôoÔûoÒqÔ÷7iIêWåZOÒÛ&)=Ù´Ã$õ#cê=À[Æô±w&ÅÞ7zîoE2'QRµ4ðÏðg¨; 0öÎÀØA±±wÆ;:0v\\`lv#U{(0vÆÙë<äk71é)oS*¶÷ x@CÔþÀÛCxwÌÂ{þ/;"	v
val	src/tests/heap-checker_unittest.cc	/^  mutable C val;$/;"	m	class:TClass	file:	access:public
valloc	src/libc_override_redefine.h	/^  void* valloc(size_t s)                         { return tc_valloc(s);       }$/;"	f	signature:(size_t s)
valloc	src/tests/tcmalloc_unittest.cc	104;"	d	file:
value	docs/pprof_remote_servers.html	/^positive value, such as 524288, before running.<\/p>$/;"	v
value	src/addressmap-inl.h	/^    Value  value;$/;"	m	struct:AddressMap::Entry	access:public
value	src/span.h	/^  int value[64];$/;"	m	struct:tcmalloc::Span	access:public
value_type	src/base/stl_allocator.h	/^  typedef T          value_type;$/;"	t	class:STL_Allocator	access:public
values	src/pagemap.h	/^    void* values[LEAF_LENGTH];$/;"	m	struct:TCMalloc_PageMap2::Leaf	access:public
values	src/pagemap.h	/^    void* values[LEAF_LENGTH];$/;"	m	struct:TCMalloc_PageMap3::Leaf	access:public
variables_saved_for_relink	m4/libtool.m4	/^  variables_saved_for_relink="$variables_saved_for_relink GCC_EXEC_PREFIX COMPILER_PATH LIBRARY_PATH"$/;"	v
vdso_base_	src/base/vdso_support.cc	/^const void *VDSOSupport::vdso_base_ = ElfMemImage::kInvalidBase;$/;"	m	class:base::VDSOSupport	file:
vdso_base_	src/base/vdso_support.h	/^  static const void *vdso_base_;$/;"	m	class:base::VDSOSupport	access:private
vdso_init_helper	src/base/vdso_support.cc	/^} vdso_init_helper;$/;"	m	namespace:base	typeref:class:base::VDSOInitHelper	file:
vendor	config.sub	/^vendor=unknown$/;"	v
verbose	src/base/logging.h	/^DECLARE_int32(verbose);$/;"	v
verdef_	src/base/elf_mem_image.h	/^  const ElfW(Verdef) *verdef_;$/;"	m	class:base::ElfMemImage	access:private
verdefnum_	src/base/elf_mem_image.h	/^  size_t verdefnum_;$/;"	m	class:base::ElfMemImage	access:private
version	src/base/elf_mem_image.h	/^    const char      *version;   \/\/ E.g. "LINUX_2.6", could be ""$/;"	m	struct:base::ElfMemImage::SymbolInfo	access:public
version_type	m4/libtool.m4	/^		version_type=linux$/;"	v
version_type	m4/libtool.m4	/^    nonstopux*) version_type=nonstopux ;;$/;"	v
version_type	m4/libtool.m4	/^    version_type=linux$/;"	v
version_type	m4/libtool.m4	/^  version_type=freebsd-$objformat$/;"	v
version_type	m4/libtool.m4	/^  version_type=linux$/;"	v
version_type	m4/libtool.m4	/^  version_type=osf$/;"	v
version_type	m4/libtool.m4	/^  version_type=qnx$/;"	v
version_type	m4/libtool.m4	/^  version_type=sunos$/;"	v
version_type	m4/libtool.m4	/^  version_type=windows$/;"	v
versioning	ChangeLog.old	/^	* Added proper libtool versioning, so this lib will be 0.1.0 (csilvers)$/;"	v
versym_	src/base/elf_mem_image.h	/^  const ElfW(Versym) *versym_;$/;"	m	class:base::ElfMemImage	access:private
virtual_space	src/windows/system-alloc.cc	/^static char virtual_space[sizeof(VirtualSysAllocator)];$/;"	v	file:
void_function	src/gperftools/heap-checker.h	/^  typedef void (*void_function)(void);$/;"	t	class:HeapCleaner	access:public
w	src/.libs/libtcmalloc_minimal_internal_la-internal_logging.o	/^/;"	v
w	src/tests/profiler1_unittest-profiler_unittest.o	/^/;"	v
w	src/tests/profiler2_unittest-profiler_unittest.o	/^/;"	v
waitpid	src/base/linux_syscall_support.h	/^    LSS_INLINE pid_t LSS_NAME(waitpid)(pid_t pid, int *status, int options){$/;"	f	signature:(pid_t pid, int *status, int options)
warnings	src/pprof	/^use warnings;$/;"	v
weight	src/tests/tcmalloc_unittest.cc	/^    int         weight;$/;"	m	struct:testing::TestHarness::Type	file:	access:public
windows_fn	src/windows/patch_functions.cc	/^    GenericFnPtr windows_fn;         \/\/ the fn whose name we call (&malloc)$/;"	m	struct:__anon13::WindowsInfo::FunctionInfo	file:	access:public
windows_fn	src/windows/patch_functions.cc	/^  GenericFnPtr windows_fn(int ifunction) const {$/;"	f	class:__anon13::LibcInfo	access:public	signature:(int ifunction) const
windows_fn_	src/windows/patch_functions.cc	/^  GenericFnPtr windows_fn_[kNumFunctions];$/;"	m	class:__anon13::LibcInfo	file:	access:protected
wipe_stack_ptr	src/tests/heap-checker_unittest.cc	/^void (*volatile wipe_stack_ptr)(int n);$/;"	v
with_gnu_ld	m4/libtool.m4	/^with_gnu_ld=$lt_cv_prog_gnu_ld$/;"	v
without	src/windows/shortproc.asm	/^; Redistribution and use in source and binary forms, with or without$/;"	v
wlarc	m4/libtool.m4	/^	wlarc='${wl}'$/;"	v
words	docs/heap_checker.html	/^<p>In other words, imprecisions in the liveness flood mean that for$/;"	v
work	docs/pprof_remote_servers.html	/^(from <code>heap-profiler.h<\/code>), continue to do work, and then,$/;"	v
work	docs/pprof_remote_servers.html	/^<code>ProfilerStart(filename)<\/code>, continuing to do its work, and$/;"	v
write	docs/cpuprofile-fileformat.html	/^    document.write(lm.toDateString());$/;"	p	file:	signature:(lm.toDateString())
write	docs/cpuprofile.html	/^    document.write(lm.toDateString());$/;"	p	file:	signature:(lm.toDateString())
write	docs/heap_checker.html	/^    document.write(lm.toDateString());$/;"	p	file:	signature:(lm.toDateString())
write	docs/heapprofile.html	/^    document.write(lm.toDateString());$/;"	p	file:	signature:(lm.toDateString())
write	src/windows/port.h	/^inline ssize_t write(int fd, const void *buf, size_t count) {$/;"	f	signature:(int fd, const void *buf, size_t count)
www	docs/overview.gif	/^GIF89ay±/;"	v
x	config.guess	/^	if test x"$CC_FOR_BUILD" = x ; then$/;"	v
x	m4/acx_pthread.m4	/^		if test x"$acx_pthread_config" = xno; then continue; fi$/;"	v
x	m4/acx_pthread.m4	/^	if test x"$done" = xno; then$/;"	v
x	m4/acx_pthread.m4	/^if test x"$acx_pthread_ok" = xno; then$/;"	v
x	m4/libtool.m4	/^  chmod +x "$ofile"$/;"	v
x	src/.libs/maybe_threads.o	/^T/;"	v
x	src/libtcmalloc_internal_la-fake_stacktrace_scope.o	/^/;"	v
x	src/tests/profiler1_unittest-profiler_unittest.o	/^/;"	v
x	src/tests/profiler2_unittest-profiler_unittest.o	/^/;"	v
x$host_vendor	m4/libtool.m4	/^    if test x$host_vendor = xsni; then$/;"	v
xa0000	docs/cpuprofile-fileformat.html	/^<p>In this example, 5 ticks were received at PC 0xa0000, whose$/;"	v
xc0000	docs/cpuprofile-fileformat.html	/^function had been called by the function containing 0xc0000, which had$/;"	v
xeq	src/base/elfcore.h	/^    unsigned long xeq;$/;"	m	struct:ppc_regs	access:public
xno	m4/acx_pthread.m4	/^        if test "x$flag" != xno; then$/;"	v
xno	m4/libtool.m4	/^  if test "x$lt_cv_dlopen" != xno; then$/;"	v
xw	src/.libs/libtcmalloc_internal_la-internal_logging.o	/^c/;"	v
y	src/.libs/libtcmalloc_minimal_internal_la-internal_logging.o	/^/;"	v
y	src/tcm_min_asserts_unittest-thread_cache.o	/^/;"	v
yes	depcomp	/^  if test -f "$tmpdepfile"; then  # yes, the sourcefile depend on other files$/;"	v
yes	m4/libtool.m4	/^  yes,cygwin* | yes,mingw* | yes,pw32* | yes,cegcc*)$/;"	v
yes	tags	/^yes	m4\/libtool.m4	\/^  yes,cygwin* | yes,mingw* | yes,pw32* | yes,cegcc*)$\/;"	v$/;"	v
z	src/libtcmalloc_internal_la-internal_logging.o	/^/;"	v
z8k	config.sub	/^	m88110 | m680[12346]0 | m683?2 | m68360 | m5200 | v70 | w65 | z8k)$/;"	v
zero	docs/heap_checker.html	/^    emitted to file output for pprof to visualize). If negative or zero,$/;"	v
~	src/.libs/libtcmalloc_internal_la-raw_printer.o	/^ELF/;"	v
~	src/libtcmalloc_internal_la-raw_printer.o	/^ELF/;"	v
~%	src/libtcmalloc_and_profiler_la-profile-handler.o	/^/;"	v
~AddressMap	src/addressmap-inl.h	/^  ~AddressMap();$/;"	p	class:AddressMap	access:public	signature:()
~AddressMap	src/addressmap-inl.h	/^AddressMap<Value>::~AddressMap() {$/;"	f	class:AddressMap	signature:()
~AggressiveDecommitChanger	src/tests/tcmalloc_unittest.cc	/^  ~AggressiveDecommitChanger() {$/;"	f	class:testing::AggressiveDecommitChanger	access:public	signature:()
~AllocatorState	src/tests/tcmalloc_unittest.cc	/^  virtual ~AllocatorState() {}$/;"	f	class:testing::AllocatorState	access:public	signature:()
~ArenaLock	src/base/low_level_alloc.cc	/^    ~ArenaLock() { RAW_CHECK(this->left_, "haven't left Arena region"); }$/;"	f	class:__anon39::ArenaLock	access:public	signature:()
~Array	src/tests/heap-checker_unittest.cc	/^  ~Array() { delete [] ptr; }$/;"	f	struct:Array	access:public	signature:()
~AutoTestingHookBase	src/windows/auto_testing_hook.h	/^  virtual ~AutoTestingHookBase() {}$/;"	f	class:sidestep::AutoTestingHookBase	access:public	signature:()
~AutoTestingHookHolder	src/windows/auto_testing_hook.h	/^  ~AutoTestingHookHolder() { delete hook_; }$/;"	f	class:sidestep::AutoTestingHookHolder	access:public	signature:()
~AutoTestingHookImpl	src/windows/auto_testing_hook.h	/^  ~AutoTestingHookImpl() {$/;"	f	class:sidestep::AutoTestingHookImpl	access:public	signature:()
~ClassB	src/tests/heap-checker_unittest.cc	/^  virtual ~ClassB() { }$/;"	f	class:ClassB	access:public	signature:()
~ClassB2	src/tests/heap-checker_unittest.cc	/^  virtual ~ClassB2() { }$/;"	f	class:ClassB2	access:public	signature:()
~Closure	src/tests/heap-checker_unittest.cc	/^  virtual ~Closure() { }$/;"	f	class:Closure	access:public	signature:()
~CpuProfiler	src/profiler.cc	/^  ~CpuProfiler();$/;"	p	class:CpuProfiler	file:	access:public	signature:()
~CpuProfiler	src/profiler.cc	/^CpuProfiler::~CpuProfiler() {$/;"	f	class:CpuProfiler	signature:()
~DefaultPagesAllocator	src/base/low_level_alloc.cc	/^    virtual ~DefaultPagesAllocator() {};$/;"	f	class:__anon38::DefaultPagesAllocator	access:public	signature:()
~DeleteUnsignedCharArray	src/windows/preamble_patcher.cc	/^  ~DeleteUnsignedCharArray() {$/;"	f	class:sidestep::DeleteUnsignedCharArray	access:public	signature:()
~Disabler	src/gperftools/heap-checker.h	/^    ~Disabler();$/;"	p	class:HeapLeakChecker::Disabler	access:public	signature:()
~Disabler	src/heap-checker.cc	/^HeapLeakChecker::Disabler::~Disabler() {$/;"	f	class:HeapLeakChecker::Disabler	signature:()
~EmergencyArenaPagesAllocator	src/emergency_malloc.cc	/^    ~EmergencyArenaPagesAllocator() {}$/;"	f	class:tcmalloc::EmergencyArenaPagesAllocator	file:	access:private	signature:()
~FileDescriptor	src/tests/profiledata_unittest.cc	/^  ~FileDescriptor() {$/;"	f	struct:__anon53::FileDescriptor	access:public	signature:()
~GoogleInitializer	src/base/googleinit.h	/^  ~GoogleInitializer() {$/;"	f	class:GoogleInitializer	access:public	signature:()
~HeapLeakChecker	src/gperftools/heap-checker.h	/^  ~HeapLeakChecker();$/;"	p	class:HeapLeakChecker	access:public	signature:()
~HeapLeakChecker	src/heap-checker.cc	/^HeapLeakChecker::~HeapLeakChecker() {$/;"	f	class:HeapLeakChecker	signature:()
~HeapLeakCheckerGlobalPrePost	src/heap-checker-bcad.cc	/^  ~HeapLeakCheckerGlobalPrePost() {$/;"	f	class:HeapLeakCheckerGlobalPrePost	access:public	signature:()
~HeapProfileEndWriter	src/heap-profiler.cc	/^  ~HeapProfileEndWriter() {$/;"	f	struct:HeapProfileEndWriter	access:public	signature:()
~HeapProfileTable	src/heap-profile-table.cc	/^HeapProfileTable::~HeapProfileTable() {$/;"	f	class:HeapProfileTable	signature:()
~HeapProfileTable	src/heap-profile-table.h	/^  ~HeapProfileTable();$/;"	p	class:HeapProfileTable	access:public	signature:()
~InterfaceA	src/tests/heap-checker_unittest.cc	/^  virtual ~InterfaceA() { }$/;"	f	class:InterfaceA	access:public	signature:()
~InterfaceB	src/tests/heap-checker_unittest.cc	/^  virtual ~InterfaceB() { }$/;"	f	class:InterfaceB	access:public	signature:()
~InterfaceC	src/tests/heap-checker_unittest.cc	/^  virtual ~InterfaceC() { }$/;"	f	class:InterfaceC	access:public	signature:()
~LockHolder	src/memory_region_map.h	/^    ~LockHolder() { Unlock(); }$/;"	f	class:MemoryRegionMap::LockHolder	access:public	signature:()
~LockInverter	src/central_freelist.cc	/^  inline ~LockInverter() { temp_->Unlock(); held_->Lock();  }$/;"	f	class:tcmalloc::__anon19::LockInverter	access:public	signature:()
~MallocExtension	src/gperftools/malloc_extension.h	/^  virtual ~MallocExtension();$/;"	p	class:MallocExtension	access:public	signature:()
~MallocExtension	src/malloc_extension.cc	/^MallocExtension::~MallocExtension() { }$/;"	f	class:MallocExtension	signature:()
~Mutex	src/base/simple_mutex.h	/^  inline ~Mutex();$/;"	p	class:MUTEX_NAMESPACE::Mutex	access:public	signature:()
~Mutex	src/base/simple_mutex.h	/^Mutex::~Mutex()            { assert(mutex_ == 0); }$/;"	f	class:MUTEX_NAMESPACE::Mutex	signature:()
~Mutex	src/base/simple_mutex.h	/^Mutex::~Mutex()            { if (destroy_) DeleteCriticalSection(&mutex_); }$/;"	f	class:MUTEX_NAMESPACE::Mutex	signature:()
~Mutex	src/base/simple_mutex.h	/^Mutex::~Mutex()       { if (destroy_) SAFE_PTHREAD(pthread_mutex_destroy); }$/;"	f	class:MUTEX_NAMESPACE::Mutex	signature:()
~Mutex	src/base/simple_mutex.h	/^Mutex::~Mutex()       { if (destroy_) SAFE_PTHREAD(pthread_rwlock_destroy); }$/;"	f	class:MUTEX_NAMESPACE::Mutex	signature:()
~MutexLock	src/base/simple_mutex.h	/^  ~MutexLock() { mu_->Unlock(); }$/;"	f	class:MUTEX_NAMESPACE::MutexLock	access:public	signature:()
~Node	benchmark/binary_trees.cc	/^  ~Node() { delete l; delete r; }$/;"	f	struct:Node	access:public	signature:()
~PagesAllocator	src/base/low_level_alloc.cc	/^LowLevelAlloc::PagesAllocator::~PagesAllocator() {$/;"	f	class:LowLevelAlloc::PagesAllocator	signature:()
~PagesAllocator	src/base/low_level_alloc.h	/^    virtual ~PagesAllocator();$/;"	p	class:LowLevelAlloc::PagesAllocator	access:public	signature:()
~ProcMapsIterator	src/base/sysinfo.cc	/^ProcMapsIterator::~ProcMapsIterator() {$/;"	f	class:ProcMapsIterator	signature:()
~ProcMapsIterator	src/base/sysinfo.h	/^  ~ProcMapsIterator();$/;"	p	class:ProcMapsIterator	access:public	signature:()
~ProfileData	src/profiledata.cc	/^ProfileData::~ProfileData() {$/;"	f	class:ProfileData	signature:()
~ProfileData	src/profiledata.h	/^  ~ProfileData();$/;"	p	class:ProfileData	access:public	signature:()
~ProfileHandler	src/profile-handler.cc	/^  ~ProfileHandler();$/;"	p	class:ProfileHandler	file:	access:private	signature:()
~ProfileHandler	src/profile-handler.cc	/^ProfileHandler::~ProfileHandler() {$/;"	f	class:ProfileHandler	signature:()
~ReaderMutexLock	src/base/simple_mutex.h	/^  ~ReaderMutexLock() { mu_->ReaderUnlock(); }$/;"	f	class:MUTEX_NAMESPACE::ReaderMutexLock	access:public	signature:()
~STL_Allocator	src/base/stl_allocator.h	/^  ~STL_Allocator() { }$/;"	f	class:STL_Allocator	access:public	signature:()
~ScopedSignalBlocker	src/profile-handler.cc	/^  ~ScopedSignalBlocker() {$/;"	f	class:ScopedSignalBlocker	access:public	signature:()
~SpinLockHolder	src/base/spinlock.h	/^  inline ~SpinLockHolder() \/*UNLOCK_FUNCTION()*\/ { lock_->Unlock(); }$/;"	f	class:SpinLockHolder	access:public	signature:()
~StackTraceTable	src/stack_trace_table.cc	/^StackTraceTable::~StackTraceTable() {$/;"	f	class:tcmalloc::StackTraceTable	signature:()
~StackTraceTable	src/stack_trace_table.h	/^  ~StackTraceTable();$/;"	p	class:tcmalloc::StackTraceTable	access:public	signature:()
~StacktraceScope	src/stacktrace.cc	/^    ~StacktraceScope() {$/;"	f	class:__anon20::StacktraceScope	access:public	signature:()
~SymbolTable	src/symbolize.h	/^  ~SymbolTable() {$/;"	f	class:SymbolTable	access:public	signature:()
~SysAllocator	src/gperftools/malloc_extension.h	/^  virtual ~SysAllocator();$/;"	p	class:SysAllocator	access:public	signature:()
~SysAllocator	src/malloc_extension.cc	/^SysAllocator::~SysAllocator() {}$/;"	f	class:SysAllocator	signature:()
~TCMallocGuard	src/tcmalloc.cc	/^TCMallocGuard::~TCMallocGuard() {$/;"	f	class:TCMallocGuard	signature:()
~TCMallocGuard	src/tcmalloc_guard.h	/^  ~TCMallocGuard();$/;"	p	class:TCMallocGuard	access:public	signature:()
~TestHarness	src/tests/tcmalloc_unittest.cc	/^  ~TestHarness() {$/;"	f	class:testing::TestHarness	access:public	signature:()
~TesterThread	src/tests/tcmalloc_unittest.cc	/^  virtual ~TesterThread() {$/;"	f	class:testing::TesterThread	access:public	signature:()
~Thread	src/tests/profile-handler_unittest.cc	/^  virtual ~Thread() { }$/;"	f	class:__anon56::Thread	access:public	signature:()
~WriterMutexLock	src/base/simple_mutex.h	/^  ~WriterMutexLock() { mu_->WriterUnlock(); }$/;"	f	class:MUTEX_NAMESPACE::WriterMutexLock	access:public	signature:()
~dldir	m4/libtool.m4	/^      dlpath=`$SHELL 2>&1 -c '\\''. $dir\/'\\''\\${base_file}'\\''i; echo \\$dlname'\\''`~$/;"	v
~dlpath	m4/libtool.m4	/^    postuninstall_cmds='dldll=`$SHELL 2>&1 -c '\\''. $file; echo \\$dlname'\\''`~$/;"	v
~scoped_array	src/tests/profiledata_unittest.cc	/^  ~scoped_array() { delete[] data_; }$/;"	f	class:__anon53::scoped_array	access:public	signature:()
~scoped_array	src/tests/sampler_test.cc	/^  ~scoped_array() { delete[] p_; }$/;"	f	class:__anon54::scoped_array	access:public	signature:()
~±	src/base/logging.o	/^/;"	v
~Õ	src/.libs/libtcmalloc_internal_la-internal_logging.o	/^/;"	v
